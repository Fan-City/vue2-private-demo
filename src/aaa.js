// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
if ("undefined" != typeof window && "undefined" != typeof navigator && window.document && (window.dojoConfig || (window.dojoConfig = {}), !window.dojoConfig.hasOwnProperty("baseUrl"))) {
	const o = window.document.currentScript.src;
	let d;
	d = o.endsWith("/init.js") ? o.slice(0, o.lastIndexOf("/")) + "/dojo" : o.endsWith("/dojo/dojo.js") ? o.slice(0, o.lastIndexOf("/")) : o + (o.endsWith("/") ? "dojo" : "/dojo"), window.dojoConfig.baseUrl = d
}
//>>built
(function(a, b) {
	var c, e, d, k = function() {
			return "undefined" !== typeof x && "function" !== typeof x ? x : "undefined" !== typeof window ? window : "undefined" !== typeof self ? self : this
		}(),
		v = function() {},
		m = function(X) {
			for (var Ea in X) return 0;
			return 1
		},
		f = {}.toString,
		g = function(X) {
			return "[object Function]" == f.call(X)
		},
		l = function(X) {
			return "[object String]" == f.call(X)
		},
		r = function(X) {
			return "[object Array]" == f.call(X)
		},
		p = function(X, Ea) {
			if (X)
				for (var Ha = 0; Ha < X.length;) Ea(X[Ha++])
		},
		n = function(X, Ea) {
			for (var Ha in Ea) X[Ha] = Ea[Ha];
			return X
		},
		t = function(X, Ea) {
			return n(Error(X), {
				src: "dojoLoader",
				info: Ea
			})
		},
		h = 1,
		q = function() {
			return "_" + h++
		},
		u = function(X, Ea, Ha) {
			return ca(X, Ea, Ha, 0, u)
		},
		x = k,
		y = x.document,
		w = y && y.createElement("DiV"),
		A = u.has = function(X) {
			return g(B[X]) ? B[X] = B[X](x, y, w) : B[X]
		},
		B = A.cache = b.hasCache;
	g(a) && (a = a(k));
	A.add = function(X, Ea, Ha, La) {
		(void 0 === B[X] || La) && (B[X] = Ea);
		return Ha && A(X)
	};
	A.add("host-webworker", "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope);
	A("host-webworker") && (n(b.hasCache, {
		"host-browser": 0,
		dom: 0,
		"dojo-dom-ready-api": 0,
		"dojo-sniff": 0,
		"dojo-inject-api": 1,
		"host-webworker": 1,
		"dojo-guarantee-console": 0
	}), b.loaderPatch = {
		injectUrl: function(X, Ea) {
			try {
				importScripts(X), Ea()
			} catch (Ha) {
				console.info("failed to load resource (" + X + ")"), console.error(Ha)
			}
		}
	});
	for (var E in a.has) A.add(E, a.has[E], 0, 1);
	var z = 0,
		C = [],
		D = 0,
		J = v,
		K = v;
	u.isXdUrl = v;
	u.initSyncLoader = function(X, Ea, Ha) {
		D || (D = X, J = Ea, K = Ha);
		return {
			sync: "sync",
			requested: 1,
			arrived: 2,
			nonmodule: 3,
			executing: 4,
			executed: 5,
			syncExecStack: C,
			modules: Ka,
			execQ: va,
			getModule: Xa,
			injectModule: jb,
			setArrived: aa,
			signal: U,
			finishExec: Pa,
			execModule: Ua,
			dojoRequirePlugin: D,
			getLegacyMode: function() {
				return z
			},
			guardCheckComplete: db
		}
	};
	if (A("dom") || A("host-webworker")) {
		var H = location.protocol,
			G = location.host;
		u.isXdUrl = function(X) {
			return /^\./.test(X) ? !1 : /^\/\//.test(X) ? !0 : (X = X.match(/^([^\/:]+:)\/+([^\/]+)/)) && (X[1] != H || G && X[2] != G)
		};
		A.add("dojo-force-activex-xhr", A("host-browser") && !y.addEventListener && "file:" == window.location.protocol);
		if (A("dojo-force-activex-xhr")) {
			var F = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"];
			for (d = 0; 3 > d;) try {
				var L = F[d++];
				new ActiveXObject(L);
				break
			} catch (X) {}
			var R = function() {
				return new ActiveXObject(L)
			}
		} else R = function() {
			return new XMLHttpRequest
		};
		u.getXhr = R;
		A.add("dojo-gettext-api", 1);
		u.getText = function(X, Ea, Ha) {
			var La = R();
			La.open("GET", ib(X), !1);
			La.send(null);
			if (200 == La.status || !location.host && !La.status) Ha && Ha(La.responseText, Ea);
			else throw t("xhrFailed", La.status);
			return La.responseText
		}
	}
	u.eval = function(X, Ea) {};
	var V = {},
		U =
		u.signal = function(X, Ea) {
			X = V[X];
			p(X && X.slice(0), function(Ha) {
				Ha.apply(null, r(Ea) ? Ea : [Ea])
			})
		},
		W = u.on = function(X, Ea) {
			var Ha = V[X] || (V[X] = []);
			Ha.push(Ea);
			return {
				remove: function() {
					for (var La = 0; La < Ha.length; La++)
						if (Ha[La] === Ea) {
							Ha.splice(La, 1);
							break
						}
				}
			}
		},
		M = [],
		T = {},
		Z = [],
		oa = {},
		qa = u.map = {},
		Aa = [],
		Ka = {},
		da = "",
		ja = {},
		sa = {},
		I = {},
		N = 0;
	if (!A("foreign-loader")) var ea = function(X, Ea) {
		Ea = !1 !== Ea;
		var Ha, La;
		for (Ha in sa) {
			var Oa = sa[Ha];
			if (La = Ha.match(/^url:(.+)/)) ja["url:" + $a(La[1], X)] = Oa;
			else if ("*now" == Ha) var Va = Oa;
			else "*noref" !=
				Ha && (La = Ta(Ha, X, !0), ja[La.mid] = ja["url:" + La.url] = Oa)
		}
		Va && Va(ka(X));
		Ea && (sa = {})
	};
	var pa = function(X) {
			return X.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(Ea) {
				return "\\" + Ea
			})
		},
		xa = function(X, Ea) {
			Ea.splice(0, Ea.length);
			for (var Ha in X) Ea.push([Ha, X[Ha], new RegExp("^" + pa(Ha) + "(/|$)"), Ha.length]);
			Ea.sort(function(La, Oa) {
				return Oa[3] - La[3]
			});
			return Ea
		},
		S = function(X, Ea) {
			p(X, function(Ha) {
				Ea.push([l(Ha[0]) ? new RegExp("^" + pa(Ha[0]) + "$") : Ha[0], Ha[1]])
			})
		},
		ba = function(X) {
			var Ea = X.name;
			Ea || (Ea = X, X = {
				name: Ea
			});
			X = n({
				main: "main"
			}, X);
			X.location = X.location ? X.location : Ea;
			X.packageMap && (qa[Ea] = X.packageMap);
			X.main.indexOf("./") || (X.main = X.main.substring(2));
			oa[Ea] = X
		},
		la = [],
		ha = function(X, Ea, Ha) {
			for (var La in X) {
				"waitSeconds" == La && (u.waitms = 1E3 * (X[La] || 0));
				"cacheBust" == La && (da = X[La] ? l(X[La]) ? X[La] : (new Date)
					.getTime() + "" : "");
				if ("baseUrl" == La || "combo" == La) u[La] = X[La];
				if ("async" == La) {
					var Oa = X[La];
					u.legacyMode = z = l(Oa) && /sync|legacyAsync/.test(Oa) ? Oa : Oa ? !1 : "sync";
					u.async = !z
				}
				X[La] !== B && (u.rawConfig[La] = X[La], "has" !=
					La && A.add("config-" + La, X[La], 0, Ea))
			}
			u.baseUrl || (u.baseUrl = "./");
			/\/$/.test(u.baseUrl) || (u.baseUrl += "/");
			for (La in X.has) A.add(La, X.has[La], 0, Ea);
			p(X.packages, ba);
			for (var Va in X.packagePaths) p(X.packagePaths[Va], function(eb) {
				var nb = Va + "/" + eb;
				l(eb) && (eb = {
					name: eb
				});
				eb.location = nb;
				ba(eb)
			});
			xa(n(qa, X.map), Aa);
			p(Aa, function(eb) {
				eb[1] = xa(eb[1], []);
				"*" == eb[0] && (Aa.star = eb)
			});
			xa(n(T, X.paths), Z);
			S(X.aliases, M);
			if (!A("foreign-loader")) {
				if (Ea) la.push({
					config: X.config
				});
				else
					for (La in X.config) Ea = Xa(La, Ha), Ea.config =
						n(Ea.config || {}, X.config[La]);
				X.cache && (ea(), sa = X.cache, ea(0, !!X.cache["*noref"]))
			}
			U("config", [X, u.rawConfig])
		};
	u.rawConfig = {};
	ha(b, 1);
	ha(a, 1);
	ha(I, 1);
	if (!A("foreign-loader")) var P = function(X) {
			db(function() {
				p(X.deps, jb)
			})
		},
		ca = function(X, Ea, Ha, La, Oa) {
			var Va;
			if (l(X)) {
				if ((Va = Xa(X, La, !0)) && Va.executed) return Va.result;
				throw t("undefinedModule", X);
			}
			r(X) || (ha(X, 0, La), X = Ea, Ea = Ha);
			if (r(X))
				if (X.length) {
					Ha = "require*" + q();
					for (var eb, nb = [], pb = 0; pb < X.length;) eb = X[pb++], nb.push(Xa(eb, La));
					Va = n(Na("", Ha, 0, ""), {
						injected: 2,
						deps: nb,
						def: Ea || v,
						require: La ? La.require : u,
						gc: 1
					});
					Ka[Va.mid] = Va;
					P(Va);
					var rb = Za && "sync" != z;
					db(function() {
						Ua(Va, rb)
					});
					Va.executed || va.push(Va);
					fb()
				} else Ea && Ea();
			return Oa
		},
		ka = function(X) {
			if (!X) return u;
			var Ea = X.require;
			Ea || (Ea = function(Ha, La, Oa) {
				return ca(Ha, La, Oa, X, Ea)
			}, X.require = n(Ea, u), Ea.module = X, Ea.toUrl = function(Ha) {
				return $a(Ha, X)
			}, Ea.toAbsMid = function(Ha) {
				return bb(Ha, X)
			}, Ea.syncLoadNls = function(Ha) {
				Ha = Ta(Ha, X);
				var La = Ka[Ha.mid];
				if (!La || !La.executed)
					if (kb = ja[Ha.mid] || ja["url:" + Ha.url]) cb(kb),
						La = Ka[Ha.mid];
				return La && La.executed && La.result
			});
			return Ea
		},
		va = [],
		Ca = [],
		ma = {},
		Q = function(X) {
			X.injected = 1;
			ma[X.mid] = 1;
			X.url && (ma[X.url] = X.pack || 1);
			ia()
		},
		aa = function(X) {
			X.injected = 2;
			delete ma[X.mid];
			X.url && delete ma[X.url];
			m(ma) && (hb(), "xd" == z && (z = "sync"))
		},
		ta = u.idle = function() {
			return !Ca.length && m(ma) && !va.length && !Za
		};
	var Da = function(X, Ea) {
			if (Ea)
				for (var Ha = 0; Ha < Ea.length; Ha++)
					if (Ea[Ha][2].test(X)) return Ea[Ha];
			return 0
		},
		Ga = function(X) {
			var Ea = [];
			for (X = X.replace(/\\/g, "/")
				.split("/"); X.length;) {
				var Ha =
					X.shift();
				if (".." == Ha && Ea.length && ".." != La) {
					Ea.pop();
					var La = Ea[Ea.length - 1]
				} else "." != Ha && Ea.push(La = Ha)
			}
			return Ea.join("/")
		},
		Na = function(X, Ea, Ha, La) {
			var Oa = u.isXdUrl(La);
			return {
				pid: X,
				mid: Ea,
				pack: Ha,
				url: La,
				executed: 0,
				def: 0,
				isXd: Oa,
				isAmd: !!(Oa || oa[X] && oa[X].isAmd)
			}
		},
		Ma = function(X, Ea, Ha, La, Oa, Va, eb, nb, pb, rb) {
			var ob, ub, mb;
			var sb = /^\./.test(X);
			if (/(^\/)|(:)|(\.js$)/.test(X) || sb && !Ea) return Na(0, X, 0, X);
			X = Ga(sb ? Ea.mid + "/../" + X : X);
			if (/^\./.test(X)) throw t("irrationalPath", X);
			rb || sb || !Va.star || (mb = Da(X, Va.star[1]));
			!mb && Ea && (mb = (mb = Da(Ea.mid, Va)) && Da(X, mb[1]));
			mb && (X = mb[1] + X.substring(mb[3]));
			Ea = (c = X.match(/^([^\/]+)(\/(.+))?$/)) ? c[1] : "";
			(ob = Ha[Ea]) ? X = Ea + "/" + (ub = c[3] || ob.main): Ea = "";
			var tb = 0;
			p(nb, function(qb) {
				var vb = X.match(qb[0]);
				vb && 0 < vb.length && (tb = g(qb[1]) ? X.replace(qb[0], qb[1]) : qb[1])
			});
			if (tb) return Ma(tb, 0, Ha, La, Oa, Va, eb, nb, pb);
			if (Ha = La[X]) return pb ? Na(Ha.pid, Ha.mid, Ha.pack, Ha.url) : La[X];
			La = (mb = Da(X, eb)) ? mb[1] + X.substring(mb[3]) : Ea ? ("/" === ob.location.slice(-1) ? ob.location.slice(0, -1) : ob.location) + "/" +
				ub : X;
			/(^\/)|(:)/.test(La) || (La = Oa + La);
			return Na(Ea, X, ob, Ga(La + ".js"))
		},
		Ta = function(X, Ea, Ha) {
			return Ma(X, Ea, oa, Ka, u.baseUrl, Aa, Z, M, void 0, Ha)
		};
	if (!A("foreign-loader")) var Ra = function(X, Ea, Ha) {
			return X.normalize ? X.normalize(Ea, function(La) {
				return bb(La, Ha)
			}) : bb(Ea, Ha)
		},
		Wa = 0,
		Xa = function(X, Ea, Ha) {
			var La;
			if (La = X.match(/^(.+?)!(.*)$/)) {
				var Oa = Xa(La[1], Ea, Ha);
				"sync" != z || Oa.executed || (jb(Oa), 2 !== Oa.injected || Oa.executed || db(function() {
					Ua(Oa)
				}), Oa.executed ? za(Oa) : va.unshift(Oa));
				5 !== Oa.executed || Oa.load ||
					za(Oa);
				Oa.load ? (La = Ra(Oa, La[2], Ea), X = Oa.mid + "!" + (Oa.dynamic ? ++Wa + "!" : "") + La) : (La = La[2], X = Oa.mid + "!" + ++Wa + "!waitingForPlugin");
				X = {
					plugin: Oa,
					mid: X,
					req: ka(Ea),
					prid: La
				}
			} else X = Ta(X, Ea);
			return Ka[X.mid] || !Ha && (Ka[X.mid] = X)
		};
	var bb = u.toAbsMid = function(X, Ea) {
			return Ta(X, Ea)
				.mid
		},
		$a = u.toUrl = function(X, Ea) {
			Ea = Ta(X + "/x", Ea);
			var Ha = Ea.url;
			return ib(0 === Ea.pid ? X : Ha.substring(0, Ha.length - 5))
		};
	if (!A("foreign-loader")) var Ya = {
			injected: 2,
			executed: 5,
			def: 3,
			result: 3
		},
		ab = function(X) {
			return Ka[X] = n({
				mid: X
			}, Ya)
		},
		Qa = ab("require"),
		Ba = ab("exports"),
		O = ab("module"),
		Y = {},
		ya = 0,
		za = function(X) {
			var Ea = X.result;
			X.dynamic = Ea.dynamic;
			X.normalize = Ea.normalize;
			X.load = Ea.load;
			return X
		},
		fa = function(X) {
			var Ea = {};
			p(X.loadQ, function(Oa) {
				var Va = Ra(X, Oa.prid, Oa.req.module),
					eb = X.dynamic ? Oa.mid.replace(/waitingForPlugin$/, Va) : X.mid + "!" + Va;
				Va = n(n({}, Oa), {
					mid: eb,
					prid: Va,
					injected: 0
				});
				Ka[eb] && Ka[eb].injected || gb(Ka[eb] = Va);
				Ea[Oa.mid] = Ka[eb];
				aa(Oa);
				delete Ka[Oa.mid]
			});
			X.loadQ = 0;
			var Ha = function(Oa) {
					for (var Va = Oa.deps || [], eb = 0; eb < Va.length; eb++)(Oa = Ea[Va[eb].mid]) &&
						(Va[eb] = Oa)
				},
				La;
			for (La in Ka) Ha(Ka[La]);
			p(va, Ha)
		},
		Pa = function(X) {
			u.trace("loader-finish-exec", [X.mid]);
			X.executed = 5;
			X.defOrder = ya++;
			p(X.provides, function(Ea) {
				Ea()
			});
			X.loadQ && (za(X), fa(X));
			for (d = 0; d < va.length;) va[d] === X ? va.splice(d, 1) : d++;
			/^require\*/.test(X.mid) && delete Ka[X.mid]
		},
		Sa = [],
		Ua = function(X, Ea) {
			if (4 === X.executed) return u.trace("loader-circular-dependency", [Sa.concat(X.mid)
				.join("-\x3e")
			]), !X.def || Ea ? Y : X.cjs && X.cjs.exports;
			if (!X.executed) {
				if (!X.def) return Y;
				var Ha = X.mid,
					La = X.deps || [],
					Oa,
					Va = [],
					eb = 0;
				for (X.executed = 4; Oa = La[eb++];) {
					Oa = Oa === Qa ? ka(X) : Oa === Ba ? X.cjs.exports : Oa === O ? X.cjs : Ua(Oa, Ea);
					if (Oa === Y) return X.executed = 0, u.trace("loader-exec-module", ["abort", Ha]), Y;
					Va.push(Oa)
				}
				u.trace("loader-run-factory", [X.mid]);
				Ea = X.def;
				C.unshift(X);
				Va = g(Ea) ? Ea.apply(null, Va) : Ea;
				X.result = void 0 === Va && X.cjs ? X.cjs.exports : Va;
				C.shift(X);
				Pa(X)
			}
			return X.result
		},
		Za = 0,
		db = function(X) {
			try {
				Za++, X()
			} catch (Ea) {
				throw Ea;
			} finally {
				Za--
			}
			ta() && U("idle", [])
		},
		fb = function() {
			Za || db(function() {
				J();
				for (var X, Ea, Ha = 0; Ha <
					va.length;) X = ya, Ea = va[Ha], Ua(Ea), X != ya ? (J(), Ha = 0) : Ha++
			})
		};
	var ib = "function" == typeof a.fixupUrl ? a.fixupUrl : function(X) {
		X += "";
		return X + (da ? (/\?/.test(X) ? "\x26" : "?") + da : "")
	};
	void 0 === A("dojo-loader-eval-hint-url") && A.add("dojo-loader-eval-hint-url", 1);
	var gb = function(X) {
			var Ea = X.plugin;
			5 !== Ea.executed || Ea.load || za(Ea);
			var Ha = function(La) {
				X.result = La;
				aa(X);
				Pa(X);
				fb()
			};
			Ea.load ? Ea.load(X.prid, X.req, Ha) : Ea.loadQ ? Ea.loadQ.push(X) : (Ea.loadQ = [X], va.unshift(Ea), jb(Ea))
		},
		kb = 0,
		cb = function(X, Ea) {
			A("config-stripStrict") &&
				(X = X.replace(/(["'])use strict\1/g, ""));
			X === kb ? kb.call(null) : u.eval(X, A("dojo-loader-eval-hint-url") ? Ea.url : Ea.mid)
		},
		jb = function(X) {
			var Ea = X.mid,
				Ha = X.url;
			if (!(X.executed || X.injected || ma[Ea] || X.url && (X.pack && ma[X.url] === X.pack || 1 == ma[X.url])))
				if (Q(X), X.plugin) gb(X);
				else {
					var La = function() {
						Fa(X);
						if (2 !== X.injected) {
							if (A("dojo-enforceDefine")) {
								U("error", t("noDefine", X));
								return
							}
							aa(X);
							n(X, Ya);
							u.trace("loader-define-nonmodule", [X.url])
						}
						z ? !C.length && fb() : fb()
					};
					if (kb = ja[Ea] || ja["url:" + X.url]) u.trace("loader-inject",
						["cache", X.mid, Ha]), cb(kb, X), La();
					else {
						if (z)
							if (X.isXd) "sync" == z && (z = "xd");
							else if (!X.isAmd || "sync" == z) {
							u.trace("loader-inject", ["xhr", X.mid, Ha, "sync" != z]);
							u.getText(Ha, "sync" != z, function(Oa) {
								if ("sync" == z) {
									C.unshift(X);
									cb(Oa, X);
									C.shift();
									Fa(X);
									X.cjs || (aa(X), Pa(X));
									if (X.finish) {
										Oa = Ea + "*finish";
										var Va = X.finish;
										delete X.finish;
										Ja(Oa, ["dojo", ("dojo/require!" + Va.join(","))
											.replace(/\./g, "/")
										], function(eb) {
											p(Va, function(nb) {
												eb.require(nb)
											})
										});
										va.unshift(Xa(Oa))
									}
									La()
								} else(Oa = K(X, Oa)) ? (cb(Oa, X), La()) : u.injectUrl(ib(Ha),
									La, X)
							});
							return
						}
						u.trace("loader-inject", ["script", X.mid, Ha]);
						u.injectUrl(ib(Ha), La, X)
					}
				}
		},
		lb = function(X, Ea, Ha) {
			u.trace("loader-define-module", [X.mid, Ea]);
			var La = X.mid;
			if (2 === X.injected) return U("error", t("multipleDefine", X)), X;
			n(X, {
				deps: Ea,
				def: Ha,
				cjs: {
					id: X.mid,
					uri: X.url,
					exports: X.result = {},
					setExports: function(Va) {
						X.cjs.exports = Va
					},
					config: function() {
						return X.config
					}
				}
			});
			for (var Oa = 0; Ea[Oa]; Oa++) Ea[Oa] = Xa(Ea[Oa], X);
			z && !ma[La] && (P(X), va.push(X), fb());
			aa(X);
			g(Ha) || Ea.length || (X.result = Ha, Pa(X));
			return X
		},
		Fa = function(X, Ea) {
			for (var Ha = [], La, Oa; Ca.length;) Oa = Ca.shift(), Ea && (Oa[0] = Ea.shift()), La = Oa[0] && Xa(Oa[0]) || X, Ha.push([La, Oa[1], Oa[2]]);
			ea(X);
			p(Ha, function(Va) {
				P(lb.apply(null, Va))
			})
		},
		hb = v,
		ia = v;
	A("dom");
	if (A("dom")) {
		var ra = function(X, Ea, Ha, La) {
				X.addEventListener(Ea, La, !1);
				return function() {
					X.removeEventListener(Ea, La, !1)
				}
			},
			na = ra(window, "load", "onload", function() {
				u.pageLoaded = 1;
				try {
					"complete" != y.readyState && (y.readyState = "complete")
				} catch (X) {}
				na()
			});
		var wa = y.getElementsByTagName("script");
		for (d = 0; !N;) /^dojo/.test((e =
			wa[d++]) && e.type) || (N = e);
		u.injectUrl = function(X, Ea, Ha) {
			Ha = Ha.node = y.createElement("script");
			var La = ra(Ha, "load", "onreadystatechange", function(Va) {
					Va = Va || window.event;
					var eb = Va.target || Va.srcElement;
					if ("load" === Va.type || /complete|loaded/.test(eb.readyState)) La(), Oa(), Ea && Ea()
				}),
				Oa = ra(Ha, "error", "onerror", function(Va) {
					La();
					Oa();
					U("error", t("scriptError: " + X, [X, Va]))
				});
			Ha.type = "text/javascript";
			Ha.charset = "utf-8";
			Ha.src = X;
			N.parentNode.insertBefore(Ha, N);
			return Ha
		}
	}
	u.log = v;
	u.trace = v;
	if (A("foreign-loader")) Ja =
		v;
	else {
		var Ja = function(X, Ea, Ha) {
			var La = arguments.length,
				Oa = ["require", "exports", "module"],
				Va = [0, X, Ea];
			1 == La ? Va = [0, g(X) ? Oa : [], X] : 2 == La && l(X) ? Va = [X, g(Ea) ? Oa : [], Ea] : 3 == La && (Va = [X, Ea, Ha]);
			u.trace("loader-define", Va.slice(0, 2));
			(La = Va[0] && Xa(Va[0])) && !ma[La.mid] ? P(lb(La, Va[1], Va[2])) : Ca.push(Va)
		};
		Ja.amd = {
			vendor: "dojotoolkit.org"
		}
	}
	n(n(u, b.loaderPatch), a.loaderPatch);
	W("error", function(X) {
		try {
			if (console.error(X), X instanceof Error) {
				for (var Ea in X) console.log(Ea + ":", X[Ea]);
				console.log(".")
			}
		} catch (Ha) {}
	});
	n(u, {
		uid: q,
		cache: ja,
		packs: oa
	});
	if (!x.define && (x.define = Ja, x.require = u, !A("foreign-loader"))) {
		p(la, function(X) {
			ha(X)
		});
		var ua = I.deps || a.deps || b.deps,
			Ia = I.callback || a.callback || b.callback;
		u.boot = ua || Ia ? [ua || [], Ia] : 0
	}
})(function(a) {
	return a.dojoConfig || a.djConfig || a.require || {}
}, {
	async: 1,
	hasCache: {
		"config-selectorEngine": "lite",
		"config-tlmSiblingOfDojo": 1,
		"dojo-built": 1,
		"dojo-loader": 1,
		dom: 1,
		"host-browser": 1
	},
	packages: [{
		location: ".",
		name: "dojo"
	}, {
		location: "../esri",
		name: "esri"
	}]
});
require({
	cache: {
		"esri/Map": function() {
			define("./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./Basemap ./Ground ./core/Accessor ./core/CollectionFlattener ./core/Evented ./core/maybe ./core/accessorSupport/decorators/property ./core/arrayUtils ./core/accessorSupport/decorators/cast ./core/accessorSupport/decorators/subclass ./layers/support/editableLayers ./support/basemapUtils ./support/collectionUtils ./support/groundUtils ./support/LayersMixin ./support/TablesMixin".split(" "), function(a,
				b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u) {
				d = function(x) {
					function y(A) {
						var B = x.call(this, A) || this;
						B.allLayers = new k({
							getCollections: () => [B.basemap ? .baseLayers, B.ground ? .layers, B.layers, B.basemap ? .referenceLayers],
							getChildrenFunction: E => "layers" in E ? E.layers : null
						});
						B.allTables = t.createFlattenedTablesCollection(a._assertThisInitialized(B));
						B.basemap = null;
						B.editableLayers = new k({
							getCollections: () => [B.allLayers],
							itemFilterFunction: p.isEditableLayer
						});
						B.ground = new e;
						B._basemapCache = n.createCache();
						return B
					}
					a._inheritsLoose(y,
						x);
					var w = y.prototype;
					w.destroy = function() {
						this.allLayers.destroy();
						this.allTables.destroy();
						this.editableLayers.destroy();
						this.ground ? .destroy();
						this.basemap ? .destroy();
						n.destroyCache(this._basemapCache);
						this._basemapCache = null
					};
					w.castBasemap = function(A) {
						return n.ensureType(A, this._basemapCache)
					};
					w.castGround = function(A) {
						A = h.ensureType(A);
						return m.isNone(A) ? this._get("ground") : A
					};
					w.findLayerById = function(A) {
						return this.allLayers.find(B => B.id === A)
					};
					w.findTableById = function(A) {
						return this.allTables.find(B =>
							B.id === A)
					};
					return y
				}(u.TablesMixin(q.LayersMixin(v.EventedMixin(d))));
				b.__decorate([f.property({
					readOnly: !0,
					dependsOn: []
				})], d.prototype, "allLayers", void 0);
				b.__decorate([f.property({
					readOnly: !0
				})], d.prototype, "allTables", void 0);
				b.__decorate([f.property({
					type: c
				})], d.prototype, "basemap", void 0);
				b.__decorate([l.cast("basemap")], d.prototype, "castBasemap", null);
				b.__decorate([f.property({
					readOnly: !0
				})], d.prototype, "editableLayers", void 0);
				b.__decorate([f.property({
						type: e,
						nonNullable: !0
					})], d.prototype,
					"ground", void 0);
				b.__decorate([l.cast("ground")], d.prototype, "castGround", null);
				return d = b.__decorate([r.subclass("esri.Map")], d)
			})
		},
		"esri/chunks/_rollupPluginBabelHelpers": function() {
			define(["exports"], function(a) {
				function b(r) {
					function p(q, u) {
						try {
							var x = r[q](u),
								y = x.value,
								w = y instanceof c;
							Promise.resolve(w ? y.v : y)
								.then(function(A) {
									if (w) {
										var B = "return" === q ? "return" : "next";
										if (!y.k || A.done) return p(B, A);
										A = r[B](A)
											.value
									}
									n(x.done ? "return" : "normal", A)
								}, function(A) {
									p("throw", A)
								})
						} catch (A) {
							n("throw", A)
						}
					}

					function n(q,
						u) {
						switch (q) {
							case "return":
								t.resolve({
									value: u,
									done: !0
								});
								break;
							case "throw":
								t.reject(u);
								break;
							default:
								t.resolve({
									value: u,
									done: !1
								})
						}(t = t.next) ? p(t.key, t.arg): h = null
					}
					var t, h;
					this._invoke = function(q, u) {
						return new Promise(function(x, y) {
							x = {
								key: q,
								arg: u,
								resolve: x,
								reject: y,
								next: null
							};
							h ? h = h.next = x : (t = h = x, p(q, u))
						})
					};
					"function" != typeof r.return && (this.return = void 0)
				}

				function c(r, p) {
					this.v = r;
					this.k = p
				}

				function e(r) {
					function p(n) {
						if (Object(n) !== n) return Promise.reject(new TypeError(n + " is not an object."));
						var t =
							n.done;
						return Promise.resolve(n.value)
							.then(function(h) {
								return {
									value: h,
									done: t
								}
							})
					}
					return e = function(n) {
						this.s = n;
						this.n = n.next
					}, e.prototype = {
						s: null,
						n: null,
						next: function() {
							return p(this.n.apply(this.s, arguments))
						},
						return: function(n) {
							var t = this.s.return;
							return void 0 === t ? Promise.resolve({
								value: n,
								done: !0
							}) : p(t.apply(this.s, arguments))
						},
						throw: function(n) {
							var t = this.s.return;
							return void 0 === t ? Promise.reject(n) : p(t.apply(this.s, arguments))
						}
					}, new e(r)
				}

				function d(r, p, n, t, h, q, u) {
					try {
						var x = r[q](u),
							y = x.value
					} catch (w) {
						n(w);
						return
					}
					x.done ? p(y) : Promise.resolve(y)
						.then(t, h)
				}

				function k(r, p) {
					for (var n = 0; n < p.length; n++) {
						var t = p[n];
						t.enumerable = t.enumerable || !1;
						t.configurable = !0;
						"value" in t && (t.writable = !0);
						Object.defineProperty(r, t.key, t)
					}
				}

				function v(r) {
					v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(p) {
						return p.__proto__ || Object.getPrototypeOf(p)
					};
					return v(r)
				}

				function m(r, p) {
					m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, t) {
						n.__proto__ = t;
						return n
					};
					return m(r, p)
				}

				function f() {
					if ("undefined" ===
						typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
					if ("function" === typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
					} catch (r) {
						return !1
					}
				}

				function g(r, p, n) {
					g = f() ? Reflect.construct.bind() : function(t, h, q) {
						var u = [null];
						u.push.apply(u, h);
						t = new(Function.bind.apply(t, u));
						q && m(t, q.prototype);
						return t
					};
					return g.apply(null, arguments)
				}

				function l(r) {
					var p = "function" === typeof Map ? new Map : void 0;
					l = function(n) {
						function t() {
							return g(n,
								arguments, v(this)
								.constructor)
						}
						if (null === n || -1 === Function.toString.call(n)
							.indexOf("[native code]")) return n;
						if ("function" !== typeof n) throw new TypeError("Super expression must either be null or a function");
						if ("undefined" !== typeof p) {
							if (p.has(n)) return p.get(n);
							p.set(n, t)
						}
						t.prototype = Object.create(n.prototype, {
							constructor: {
								value: t,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						});
						return m(t, n)
					};
					return l(r)
				}
				b.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
					return this
				};
				b.prototype.next = function(r) {
					return this._invoke("next", r)
				};
				b.prototype.throw = function(r) {
					return this._invoke("throw", r)
				};
				b.prototype.return = function(r) {
					return this._invoke("return", r)
				};
				a._assertThisInitialized = function(r) {
					if (void 0 === r) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
					return r
				};
				a._asyncIterator = function(r) {
					var p, n, t, h = 2;
					for ("undefined" != typeof Symbol && (n = Symbol.asyncIterator, t = Symbol.iterator); h--;) {
						if (n && null != (p = r[n])) return p.call(r);
						if (t &&
							null != (p = r[t])) return new e(p.call(r));
						n = "@@asyncIterator";
						t = "@@iterator"
					}
					throw new TypeError("Object is not async iterable");
				};
				a._asyncToGenerator = function(r) {
					return function() {
						var p = this,
							n = arguments;
						return new Promise(function(t, h) {
							function q(y) {
								d(x, t, h, q, u, "next", y)
							}

							function u(y) {
								d(x, t, h, q, u, "throw", y)
							}
							var x = r.apply(p, n);
							q(void 0)
						})
					}
				};
				a._awaitAsyncGenerator = function(r) {
					return new c(r, 0)
				};
				a._createClass = function(r, p, n) {
					p && k(r.prototype, p);
					n && k(r, n);
					Object.defineProperty(r, "prototype", {
						writable: !1
					});
					return r
				};
				a._inheritsLoose = function(r, p) {
					r.prototype = Object.create(p.prototype);
					r.prototype.constructor = r;
					m(r, p)
				};
				a._wrapAsyncGenerator = function(r) {
					return function() {
						return new b(r.apply(this, arguments))
					}
				};
				a._wrapNativeSuper = l
			})
		},
		"esri/chunks/tslib.es6": function() {
			define(["exports"], function(a) {
				a.__decorate = function(b, c, e, d) {
					var k = arguments.length,
						v = 3 > k ? c : null === d ? d = Object.getOwnPropertyDescriptor(c, e) : d,
						m;
					if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) v = Reflect.decorate(b, c, e,
						d);
					else
						for (var f = b.length - 1; 0 <= f; f--)
							if (m = b[f]) v = (3 > k ? m(v) : 3 < k ? m(c, e, v) : m(c, e)) || v;
					return 3 < k && v && Object.defineProperty(c, e, v), v
				}
			})
		},
		"esri/Basemap": function() {
			define("require ./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./core/Collection ./core/collectionUtils ./core/deprecate ./core/JSONSupport ./core/lang ./core/Loadable ./core/loadAll ./core/Logger ./core/maybe ./core/promiseUtils ./core/urlUtils ./core/accessorSupport/decorators/property ./core/accessorSupport/ensureType ./core/accessorSupport/decorators/subclass ./core/accessorSupport/decorators/writer ./geometry/SpatialReference ./portal/Portal ./portal/PortalItem ./support/basemapDefinitions ./webdoc/support/writeUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B) {
					var E;
					let z = 0;
					v = E = function(C) {
						function D(K) {
							var H = C.call(this, K) || this;
							H.id = null;
							H.portalItem = null;
							H.spatialReference = null;
							H.thumbnailUrl = null;
							H.title = "Basemap";
							H.id = Date.now()
								.toString(16) + "-basemap-" + z++;
							H.baseLayers = new e;
							H.referenceLayers = new e;
							const G = F => {
								F.parent && F.parent !== b._assertThisInitialized(H) && "remove" in F.parent && F.parent.remove(F);
								F.parent = b._assertThisInitialized(H);
								"elevation" === F.type && l.getLogger(H.declaredClass)
									.error(`Layer '${F.title}, id:${F.id}' of type '${F.type}' is not supported as a basemap layer and will therefore be ignored.`)
							};
							H.baseLayers.on("after-add", F => G(F.item));
							H.referenceLayers.on("after-add", F => G(F.item));
							H.baseLayers.on("after-remove", F => {
								F.item.parent = null
							});
							H.referenceLayers.on("after-remove", F => {
								F.item.parent = null
							});
							return H
						}
						b._inheritsLoose(D, C);
						var J = D.prototype;
						J.initialize = function() {
							this.when()
								.catch(K => {
									l.getLogger(this.declaredClass)
										.error("#load()", `Failed to load basemap (title: '${this.title}', id: '${this.id}')`, K)
								});
							this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context)
						};
						J.destroy = function() {
							var K = this.baseLayers.removeAll();
							for (const H of K) H.destroy();
							K = this.referenceLayers.removeAll();
							for (const H of K) H.destroy();
							this.baseLayers.destroy();
							this.referenceLayers.destroy();
							this.portalItem ? .destroy();
							this.portalItem = null
						};
						J.normalizeCtorArgs = function(K) {
							K && "resourceInfo" in K && (this._set("resourceInfo", K.resourceInfo), K = {
								...K
							}, delete K.resourceInfo);
							return K
						};
						J._writeBaseLayers = function(K, H, G) {
							const F = [];
							K && (G = {
								...G,
								layerContainerType: "basemap"
							}, this.baseLayers.forEach(L => {
								L = B.getLayerJSON(L, G.webmap ? G.webmap.getLayerJSONFromResourceInfo(L) : null, G);
								r.isSome(L) && F.push(L)
							}), this.referenceLayers.forEach(L => {
								L = B.getLayerJSON(L, G.webmap ? G.webmap.getLayerJSONFromResourceInfo(L) : null, G);
								r.isSome(L) && (L.isReference = !0, F.push(L))
							}));
							H.baseMapLayers = F
						};
						J.writeTitle = function(K, H) {
							H.title = K || "Basemap"
						};
						J.load = function(K) {
							this.addResolvingPromise(this._loadFromSource(K));
							return Promise.resolve(this)
						};
						J.loadAll = function() {
							return g.loadAll(this, K => {
								K(this.baseLayers, this.referenceLayers)
							})
						};
						J.clone = function() {
							const K = {
								id: this.id,
								title: this.title,
								portalItem: this.portalItem,
								baseLayers: this.baseLayers.slice(),
								referenceLayers: this.referenceLayers.slice()
							};
							this.loaded && (K.loadStatus = "loaded");
							return (new E({
									resourceInfo: this.resourceInfo
								}))
								.set(K)
						};
						J.read = function(K, H) {
							this.resourceInfo || this._set("resourceInfo", {
								data: K,
								context: H
							});
							C.prototype.read.call(this, K, H)
						};
						J.write = function(K, H) {
							K = K || {};
							H && H.origin || (H = {
								origin: "web-map",
								...H
							});
							C.prototype.write.call(this, K, H);
							!this.loaded && this.resourceInfo &&
								this.resourceInfo.data.baseMapLayers && (K.baseMapLayers = this.resourceInfo.data.baseMapLayers.map(G => {
									G = m.clone(G);
									G.url && n.isProtocolRelative(G.url) && (G.url = `https:${G.url}`);
									G.templateUrl && n.isProtocolRelative(G.templateUrl) && (G.templateUrl = `https:${G.templateUrl}`);
									return G
								}));
							return K
						};
						J._loadFromSource = function() {
							var K = b._asyncToGenerator(function*(H) {
								const {
									resourceInfo: G,
									portalItem: F
								} = this;
								p.throwIfAborted(H);
								const L = [];
								G ? (L.push(this._loadLayersFromJSON(G.data, G.context ? G.context.url : null, H)),
									G.data.id && !G.data.title && L.push(A.getBasemapTitle(G.data.id)
										.then(R => {
											R && this.read({
												title: R
											}, G.context)
										}))) : F && L.push(this._loadFromItem(F, H));
								yield Promise.all(L)
							});
							return function(H) {
								return K.apply(this, arguments)
							}
						}();
						J._loadLayersFromJSON = function() {
							var K = b._asyncToGenerator(function*(H, G, F) {
								var L = this.resourceInfo && this.resourceInfo.context;
								const R = this.portalItem && this.portalItem.portal || L && L.portal || null,
									V = L && "web-scene" === L.origin ? "web-scene" : "web-map",
									{
										populateOperationalLayers: U
									} = yield new Promise((W,
										M) => a(["./layers/support/layersCreator"], W, M));
								L = [];
								p.throwIfAborted(F);
								H.baseMapLayers && Array.isArray(H.baseMapLayers) && (G = {
									context: {
										origin: V,
										url: G,
										portal: R,
										layerContainerType: "basemap"
									},
									defaultLayerType: "DefaultTileLayer"
								}, F = U(this.baseLayers, H.baseMapLayers.filter(W => !W.isReference), G), L.push(F), H = U(this.referenceLayers, H.baseMapLayers.filter(W => W.isReference), G), L.push(H));
								yield p.eachAlways(L)
							});
							return function(H, G, F) {
								return K.apply(this, arguments)
							}
						}();
						J._loadFromItem = function() {
							var K = b._asyncToGenerator(function*(H,
								G) {
								const F = yield(yield H.load(G))
									.fetchData("json", G), L = n.urlToObject(H.itemUrl ? ? "");
								this._set("resourceInfo", {
									data: F.baseMap ? ? {},
									context: {
										origin: "web-map",
										portal: H.portal || y.getDefault(),
										url: L
									}
								});
								this.read(this.resourceInfo.data, this.resourceInfo.context);
								this.read({
									spatialReference: F.spatialReference
								}, this.resourceInfo.context);
								this.read({
									title: H.title,
									thumbnailUrl: H.thumbnailUrl
								}, {
									origin: "portal-item",
									portal: H.portal || y.getDefault(),
									url: L
								});
								return this._loadLayersFromJSON(this.resourceInfo.data,
									L, G)
							});
							return function(H, G) {
								return K.apply(this, arguments)
							}
						}();
						D.fromId = function(K) {
							const H = A.esriBasemapDefinitions[K];
							if (H) {
								if (H.deprecated) {
									let G = null;
									"dark-gray" === K ? G = "dark-gray-vector" : "gray" === K ? G = "gray-vector" : "streets" === K ? G = "streets-vector" : "topo" === K && (G = "topo-vector");
									k.deprecated(l.getLogger("esri.Basemap"), `The ${K} basemap has entered mature support and is no longer being updated.`, {
										replacement: G,
										see: "https://arcg.is/1iq8aD",
										warnOnce: !0
									})
								}
								return E.fromJSON(H)
							}
							return null
						};
						b._createClass(D,
							[{
								key: "baseLayers",
								set: function(K) {
									this._set("baseLayers", d.referenceSetter(K, this._get("baseLayers")))
								}
							}, {
								key: "referenceLayers",
								set: function(K) {
									this._set("referenceLayers", d.referenceSetter(K, this._get("referenceLayers")))
								}
							}]);
						return D
					}(v.JSONSupportMixin(f));
					c.__decorate([t.property({
						json: {
							write: {
								ignoreOrigin: !0,
								target: "baseMapLayers",
								writer(C, D, J, K) {
									this._writeBaseLayers(C, D, K)
								}
							},
							origins: {
								"web-scene": {
									write: {
										ignoreOrigin: !0,
										target: {
											baseMapLayers: {
												type: e
											}
										},
										writer(C, D, J, K) {
											this._writeBaseLayers(C,
												D, K)
										}
									}
								}
							}
						}
					})], v.prototype, "baseLayers", null);
					c.__decorate([t.property({
						type: String,
						json: {
							origins: {
								"web-scene": {
									write: !0
								}
							}
						}
					})], v.prototype, "id", void 0);
					c.__decorate([t.property({
						type: w
					})], v.prototype, "portalItem", void 0);
					c.__decorate([t.property()], v.prototype, "referenceLayers", null);
					c.__decorate([t.property({
						readOnly: !0
					})], v.prototype, "resourceInfo", void 0);
					c.__decorate([t.property({
						type: x
					})], v.prototype, "spatialReference", void 0);
					c.__decorate([t.property()], v.prototype, "thumbnailUrl", void 0);
					c.__decorate([t.property({
						type: String,
						json: {
							origins: {
								"web-scene": {
									write: {
										isRequired: !0
									}
								}
							}
						}
					})], v.prototype, "title", void 0);
					c.__decorate([u.writer("title")], v.prototype, "writeTitle", null);
					return v = E = c.__decorate([q.subclass("esri.Basemap")], v)
				})
		},
		"esri/core/Collection": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./ArrayPool ./Evented ./lang ./maybe ./ObjectPool ./ObservableChangesType ./scheduling ./accessorSupport/decorators/property ./accessorSupport/ensureType ./accessorSupport/decorators/shared ./accessorSupport/decorators/subclass ./accessorSupport/tracking ./accessorSupport/tracking/SimpleObservable".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					function h(K) {
						return K ? K instanceof J ? K.toArray() : K.length ? Array.prototype.slice.apply(K) : [] : []
					}

					function q(K) {
						if (K && K.length) return K[0]
					}

					function u(K, H, G, F) {
						H && H.forEach((L, R, V) => {
							K.push(L);
							u(K, G.call(F, L, R, V), G, F)
						})
					}
					var x;
					let y = function() {
						function K() {
							this.target = null;
							this.defaultPrevented = this.cancellable = !1;
							this.type = this.item = void 0
						}
						var H = K.prototype;
						H.preventDefault = function() {
							this.cancellable && (this.defaultPrevented = !0)
						};
						H.reset = function(G) {
							this.defaultPrevented = !1;
							this.item = G
						};
						return K
					}();
					const w = new v(y, void 0, K => {
							K.item = null;
							K.target = null;
							K.defaultPrevented = !1;
							K.cancellable = !1
						}),
						A = () => {},
						B = new Set,
						E = new Set,
						z = new Set,
						C = new Map;
					let D = 0,
						J = x = function(K, H) {
							function G(L) {
								L = K.call(this, L) || this;
								L._chgListeners = [];
								L._notifications = null;
								L._timer = null;
								L._observable = new t.SimpleObservable;
								L.length = 0;
								L._items = [];
								Object.defineProperty(a._assertThisInitialized(L), "uid", {
									value: D++
								});
								return L
							}
							a._inheritsLoose(G, K);
							G.isCollection = function(L) {
								return null != L && L instanceof
								x
							};
							var F = G.prototype;
							F.normalizeCtorArgs = function(L) {
								return L ? Array.isArray(L) || L instanceof x ? {
									items: L
								} : L : {}
							};
							F.destroy = function() {
								this.removeAll()
							};
							F[H] = function*() {
								yield* this.items
							};
							F.hasEventListener = function(L) {
								return "change" === L ? 0 < this._chgListeners.length : this._emitter.hasEventListener(L)
							};
							F.on = function(L, R) {
								if ("change" === L) {
									const V = this._chgListeners,
										U = {
											removed: !1,
											callback: R
										};
									V.push(U);
									this._notifications && this._notifications.push({
										listeners: V.slice(),
										items: this._items.slice(),
										changes: []
									});
									return {
										remove() {
											this.remove = A;
											U.removed = !0;
											V.splice(V.indexOf(U), 1)
										}
									}
								}
								return this._emitter.on(L, R)
							};
							F.once = function(L, R) {
								const V = this.on(L, R);
								return {
									remove() {
										V.remove()
									}
								}
							};
							F.add = function(L, R) {
								n.trackAccess(this._observable);
								if (this._emitBeforeChanges(m.ObservableChangesType.ADD)) return this;
								R = this.getNextIndex(R ? ? null);
								this._splice(R, 0, [L]);
								this._emitAfterChanges(m.ObservableChangesType.ADD);
								return this
							};
							F.addMany = function(L, R = this._items.length) {
								n.trackAccess(this._observable);
								if (!L || !L.length ||
									this._emitBeforeChanges(m.ObservableChangesType.ADD)) return this;
								R = this.getNextIndex(R);
								this._splice(R, 0, h(L));
								this._emitAfterChanges(m.ObservableChangesType.ADD);
								return this
							};
							F.at = function(L) {
								n.trackAccess(this._observable);
								L = Math.trunc(L) || 0;
								0 > L && (L += this.length);
								if (!(0 > L || L >= this.length)) return this._items[L]
							};
							F.removeAll = function() {
								n.trackAccess(this._observable);
								if (!this.length || this._emitBeforeChanges(m.ObservableChangesType.REMOVE)) return [];
								const L = this._splice(0, this.length) || [];
								this._emitAfterChanges(m.ObservableChangesType.REMOVE);
								return L
							};
							F.clone = function() {
								n.trackAccess(this._observable);
								return this._createNewInstance({
									items: this._items.map(d.clone)
								})
							};
							F.concat = function(...L) {
								n.trackAccess(this._observable);
								L = L.map(h);
								return this._createNewInstance({
									items: this._items.concat(...L)
								})
							};
							F.drain = function(L, R) {
								n.trackAccess(this._observable);
								if (this.length && !this._emitBeforeChanges(m.ObservableChangesType.REMOVE)) {
									var V = k.assumeNonNull(this._splice(0, this.length)),
										U = V.length;
									for (let W = 0; W < U; W++) L.call(R, V[W], W, V);
									this._emitAfterChanges(m.ObservableChangesType.REMOVE)
								}
							};
							F.every = function(L, R) {
								n.trackAccess(this._observable);
								return this._items.every(L, R)
							};
							F.filter = function(L, R) {
								n.trackAccess(this._observable);
								let V;
								V = 2 === arguments.length ? this._items.filter(L, R) : this._items.filter(L);
								return this._createNewInstance({
									items: V
								})
							};
							F.find = function(L, R) {
								n.trackAccess(this._observable);
								return this._items.find(L, R)
							};
							F.findIndex = function(L, R) {
								n.trackAccess(this._observable);
								return this._items.findIndex(L, R)
							};
							F.flatten = function(L, R) {
								n.trackAccess(this._observable);
								const V = [];
								u(V, this, L, R);
								return new x(V)
							};
							F.forEach = function(L, R) {
								n.trackAccess(this._observable);
								return this._items.forEach(L, R)
							};
							F.getItemAt = function(L) {
								n.trackAccess(this._observable);
								return this._items[L]
							};
							F.getNextIndex = function(L) {
								n.trackAccess(this._observable);
								const R = this.length;
								L = null == L ? R : L;
								0 > L ? L = 0 : L > R && (L = R);
								return L
							};
							F.includes = function(L, R = 0) {
								n.trackAccess(this._observable);
								return this._items.includes(L, R)
							};
							F.indexOf = function(L, R = 0) {
								n.trackAccess(this._observable);
								return this._items.indexOf(L,
									R)
							};
							F.join = function(L = ",") {
								n.trackAccess(this._observable);
								return this._items.join(L)
							};
							F.lastIndexOf = function(L, R = this.length - 1) {
								n.trackAccess(this._observable);
								return this._items.lastIndexOf(L, R)
							};
							F.map = function(L, R) {
								n.trackAccess(this._observable);
								L = this._items.map(L, R);
								return new x({
									items: L
								})
							};
							F.reorder = function(L, R = this.length - 1) {
								n.trackAccess(this._observable);
								const V = this.indexOf(L);
								if (-1 !== V) {
									0 > R ? R = 0 : R >= this.length && (R = this.length - 1);
									if (V !== R) {
										if (this._emitBeforeChanges(m.ObservableChangesType.MOVE)) return L;
										this._splice(V, 1);
										this._splice(R, 0, [L]);
										this._emitAfterChanges(m.ObservableChangesType.MOVE)
									}
									return L
								}
							};
							F.pop = function() {
								n.trackAccess(this._observable);
								if (this.length && !this._emitBeforeChanges(m.ObservableChangesType.REMOVE)) {
									var L = q(this._splice(this.length - 1, 1));
									this._emitAfterChanges(m.ObservableChangesType.REMOVE);
									return L
								}
							};
							F.push = function(...L) {
								n.trackAccess(this._observable);
								if (this._emitBeforeChanges(m.ObservableChangesType.ADD)) return this.length;
								this._splice(this.length, 0, L);
								this._emitAfterChanges(m.ObservableChangesType.ADD);
								return this.length
							};
							F.reduce = function(L, R) {
								n.trackAccess(this._observable);
								const V = this._items;
								return 2 === arguments.length ? V.reduce(L, R) : V.reduce(L)
							};
							F.reduceRight = function(L, R) {
								n.trackAccess(this._observable);
								const V = this._items;
								return 2 === arguments.length ? V.reduceRight(L, R) : V.reduceRight(L)
							};
							F.remove = function(L) {
								n.trackAccess(this._observable);
								return this.removeAt(this.indexOf(L))
							};
							F.removeAt = function(L) {
								n.trackAccess(this._observable);
								if (!(0 > L || L >= this.length || this._emitBeforeChanges(m.ObservableChangesType.REMOVE))) return L =
									q(this._splice(L, 1)), this._emitAfterChanges(m.ObservableChangesType.REMOVE), L
							};
							F.removeMany = function(L) {
								n.trackAccess(this._observable);
								if (!L || !L.length || this._emitBeforeChanges(m.ObservableChangesType.REMOVE)) return [];
								L = L instanceof x ? L.toArray() : L;
								const R = this._items,
									V = [],
									U = L.length;
								for (let Z = 0; Z < U; Z++) {
									var W = R.indexOf(L[Z]);
									if (-1 < W) {
										var M = Z + 1,
											T = W + 1;
										const oa = Math.min(L.length - M, R.length - T);
										let qa = 0;
										for (; qa < oa && L[M + qa] === R[T + qa];) qa++;
										M = 1 + qa;
										(W = this._splice(W, M)) && 0 < W.length && V.push.apply(V, W);
										Z +=
											M - 1
									}
								}
								this._emitAfterChanges(m.ObservableChangesType.REMOVE);
								return V
							};
							F.reverse = function() {
								n.trackAccess(this._observable);
								if (this._emitBeforeChanges(m.ObservableChangesType.MOVE)) return this;
								const L = this._splice(0, this.length);
								L && (L.reverse(), this._splice(0, 0, L));
								this._emitAfterChanges(m.ObservableChangesType.MOVE);
								return this
							};
							F.shift = function() {
								n.trackAccess(this._observable);
								if (this.length && !this._emitBeforeChanges(m.ObservableChangesType.REMOVE)) {
									var L = q(this._splice(0, 1));
									this._emitAfterChanges(m.ObservableChangesType.REMOVE);
									return L
								}
							};
							F.slice = function(L = 0, R = this.length) {
								n.trackAccess(this._observable);
								return this._createNewInstance({
									items: this._items.slice(L, R)
								})
							};
							F.some = function(L, R) {
								n.trackAccess(this._observable);
								return this._items.some(L, R)
							};
							F.sort = function(L) {
								n.trackAccess(this._observable);
								if (!this.length || this._emitBeforeChanges(m.ObservableChangesType.MOVE)) return this;
								const R = k.assumeNonNull(this._splice(0, this.length));
								arguments.length ? R.sort(L) : R.sort();
								this._splice(0, 0, R);
								this._emitAfterChanges(m.ObservableChangesType.MOVE);
								return this
							};
							F.splice = function(L, R, ...V) {
								n.trackAccess(this._observable);
								const U = (R ? m.ObservableChangesType.REMOVE : 0) | (V.length ? m.ObservableChangesType.ADD : 0);
								if (this._emitBeforeChanges(U)) return [];
								L = this._splice(L, R, V) || [];
								this._emitAfterChanges(U);
								return L
							};
							F.toArray = function() {
								n.trackAccess(this._observable);
								return this._items.slice()
							};
							F.toJSON = function() {
								n.trackAccess(this._observable);
								return this.toArray()
							};
							F.toLocaleString = function() {
								n.trackAccess(this._observable);
								return this._items.toLocaleString()
							};
							F.toString = function() {
								n.trackAccess(this._observable);
								return this._items.toString()
							};
							F.unshift = function(...L) {
								n.trackAccess(this._observable);
								if (!L.length || this._emitBeforeChanges(m.ObservableChangesType.ADD)) return this.length;
								this._splice(0, 0, L);
								this._emitAfterChanges(m.ObservableChangesType.ADD);
								return this.length
							};
							F._createNewInstance = function(L) {
								return new this.constructor(L)
							};
							F._splice = function(L, R, V) {
								const U = this._items;
								var W = this.itemType;
								let M = void 0;
								!this._notifications && this.hasEventListener("change") &&
									(this._notifications = [{
										listeners: this._chgListeners.slice(),
										items: this._items.slice(),
										changes: []
									}], this._timer && this._timer.remove(), this._timer = f.schedule(() => this._dispatchChange()));
								if (R) {
									M = U.splice(L, R);
									if (this.hasEventListener("before-remove")) {
										var T = w.acquire();
										T.target = this;
										T.cancellable = !0;
										for (let qa = 0, Aa = M.length; qa < Aa; qa++) R = M[qa], T.reset(R), this.emit("before-remove", T), T.defaultPrevented && (M.splice(qa, 1), U.splice(L, 0, R), L += 1, --qa, --Aa);
										w.release(T)
									}
									this.length = this._items.length;
									if (this.hasEventListener("after-remove")) {
										R =
											w.acquire();
										R.target = this;
										R.cancellable = !1;
										T = M.length;
										for (let qa = 0; qa < T; qa++) R.reset(M[qa]), this.emit("after-remove", R);
										w.release(R)
									}
								}
								if (V && V.length) {
									if (W) {
										R = [];
										for (var Z of V) V = W.ensureType(Z), null == V && null != Z || R.push(V);
										V = R
									}
									W = this.hasEventListener("before-add");
									Z = this.hasEventListener("after-add");
									R = L === this.length;
									if (W || Z) {
										var oa = w.acquire();
										oa.target = this;
										oa.cancellable = !0;
										T = w.acquire();
										T.target = this;
										T.cancellable = !1;
										for (const qa of V) W ? (oa.reset(qa), this.emit("before-add", oa), oa.defaultPrevented ||
											(R ? U.push(qa) : U.splice(L++, 0, qa), this._set("length", U.length), Z && (T.reset(qa), this.emit("after-add", T)))) : (R ? U.push(qa) : U.splice(L++, 0, qa), this._set("length", U.length), T.reset(qa), this.emit("after-add", T));
										w.release(T);
										w.release(oa)
									} else {
										if (R)
											for (oa of V) U.push(oa);
										else U.splice(L, 0, ...V);
										this._set("length", U.length)
									}
								}(V && V.length || M && M.length) && this._notifyChangeEvent(V, M);
								return M
							};
							F._emitBeforeChanges = function(L) {
								let R = !1;
								if (this.hasEventListener("before-changes")) {
									const V = w.acquire();
									V.target =
										this;
									V.cancellable = !0;
									V.type = L;
									this.emit("before-changes", V);
									R = V.defaultPrevented;
									w.release(V)
								}
								return R
							};
							F._emitAfterChanges = function(L) {
								if (this.hasEventListener("after-changes")) {
									const R = w.acquire();
									R.target = this;
									R.cancellable = !1;
									R.type = L;
									this.emit("after-changes", R);
									w.release(R)
								}
								this._observable.notify()
							};
							F._notifyChangeEvent = function(L, R) {
								this.hasEventListener("change") && this._notifications && this._notifications[this._notifications.length - 1].changes.push({
									added: L,
									removed: R
								})
							};
							F._dispatchChange =
								function() {
									this._timer && (this._timer.remove(), this._timer = null);
									if (this._notifications) {
										var L = this._notifications;
										this._notifications = null;
										for (const R of L) {
											L = R.changes;
											B.clear();
											E.clear();
											z.clear();
											for (const {
												added: Z,
												removed: oa
											} of L) {
												if (Z)
													if (0 === z.size && 0 === E.size)
														for (const qa of Z) B.add(qa);
													else
														for (const qa of Z) E.has(qa) ? (z.add(qa), E.delete(qa)) : z.has(qa) || B.add(qa);
												if (oa)
													if (0 === z.size && 0 === B.size)
														for (const qa of oa) E.add(qa);
													else
														for (const qa of oa) B.has(qa) ? B.delete(qa) : (z.delete(qa), E.add(qa))
											}
											const V =
												c.acquire();
											B.forEach(Z => {
												V.push(Z)
											});
											const U = c.acquire();
											E.forEach(Z => {
												U.push(Z)
											});
											const W = this._items,
												M = R.items,
												T = c.acquire();
											z.forEach(Z => {
												M.indexOf(Z) !== W.indexOf(Z) && T.push(Z)
											});
											if (R.listeners && (V.length || U.length || T.length)) {
												L = {
													target: this,
													added: V,
													removed: U,
													moved: T
												};
												const Z = R.listeners.length;
												for (let oa = 0; oa < Z; oa++) {
													const qa = R.listeners[oa];
													qa.removed || qa.callback.call(this, L)
												}
											}
											c.release(V);
											c.release(U);
											c.release(T)
										}
										B.clear();
										E.clear();
										z.clear()
									}
								};
							a._createClass(G, [{
								key: "items",
								get: function() {
									n.trackAccess(this._observable);
									return this._items
								},
								set: function(L) {
									this._emitBeforeChanges(m.ObservableChangesType.ADD) || (this._splice(0, this.length, h(L)), this._emitAfterChanges(m.ObservableChangesType.ADD))
								}
							}]);
							return G
						}(e.EventedAccessor, Symbol.iterator);
					J.ofType = K => {
						if (!K) return x;
						if (C.has(K)) return C.get(K);
						let H = null;
						if ("function" === typeof K) H = K.prototype.declaredClass;
						else if (K.base) H = K.base.prototype.declaredClass;
						else
							for (var G in K.typeMap) {
								const F = K.typeMap[G].prototype.declaredClass;
								H = H ? H + ` | ${F}` : F
							}
						G = function(F) {
							function L() {
								return F.apply(this,
									arguments) || this
							}
							a._inheritsLoose(L, F);
							return L
						}(x);
						b.__decorate([r.shared({
							Type: K,
							ensureType: "function" === typeof K ? l.ensureType(K) : l.ensureOneOfType(K)
						})], G.prototype, "itemType", void 0);
						G = b.__decorate([p.subclass(`esri.core.Collection<${H}>`)], G);
						C.set(K, G);
						return G
					};
					b.__decorate([g.property()], J.prototype, "length", void 0);
					b.__decorate([g.property()], J.prototype, "items", null);
					return J = x = b.__decorate([p.subclass("esri.core.Collection")], J)
				})
		},
		"esri/core/ArrayPool": function() {
			define(["./ObjectPool"],
				function(a) {
					function b(d) {
						d.length = 0
					}
					let c = function() {
						function d(v = 50, m = 50) {
							this._pool = new a(Array, void 0, b, m, v)
						}
						var k = d.prototype;
						k.acquire = function() {
							return this._pool.acquire()
						};
						k.release = function(v) {
							this._pool.release(v)
						};
						k.prune = function() {
							this._pool.prune(0)
						};
						d.acquire = function() {
							return e.acquire()
						};
						d.release = function(v) {
							return e.release(v)
						};
						d.prune = function() {
							e.prune()
						};
						return d
					}();
					const e = new c(100);
					return c
				})
		},
		"esri/core/ObjectPool": function() {
			define(function() {
				let a = function() {
					function b(e,
						d, k, v = 1, m = 0) {
						this._ctor = e;
						this._acquireFunction = d;
						this._releaseFunction = k;
						this.allocationSize = v;
						this._pool = Array(m);
						this._initialSize = m;
						if (this._ctor)
							for (e = 0; e < m; e++) this._pool[e] = new this._ctor;
						this.allocationSize = Math.max(v, 1)
					}
					var c = b.prototype;
					c.destroy = function() {
						this.prune(0)
					};
					c.acquire = function(...e) {
						if (b.test.disabled) var d = new this._ctor;
						else {
							if (0 === this._pool.length) {
								d = this.allocationSize;
								for (let k = 0; k < d; k++) this._pool[k] = new this._ctor
							}
							d = this._pool.pop()
						}
						this._acquireFunction ? this._acquireFunction(d,
							...e) : d && d.acquire && "function" === typeof d.acquire && d.acquire(...e);
						return d
					};
					c.release = function(e) {
						e && !b.test.disabled && (this._releaseFunction ? this._releaseFunction(e) : e && e.release && "function" === typeof e.release && e.release(), this._pool.push(e))
					};
					c.prune = function(e = this._initialSize) {
						if (!(e >= this._pool.length)) {
							for (let d = e; d < this._pool.length; ++d) this._dispose(this._pool[d]);
							this._pool.length = e
						}
					};
					c._dispose = function(e) {
						e.dispose && "function" === typeof e.dispose && e.dispose()
					};
					return b
				}();
				a.test = {
					disabled: !1
				};
				return a
			})
		},
		"esri/core/Evented": function() {
			define(["../chunks/_rollupPluginBabelHelpers", "../chunks/tslib.es6", "./Accessor", "./handleUtils", "./accessorSupport/decorators/subclass"], function(a, b, c, e, d) {
				let k = function() {
					function v() {
						this._emitter = new v.EventEmitter(this)
					}
					var m = v.prototype;
					m.emit = function(f, g) {
						return this._emitter.emit(f, g)
					};
					m.on = function(f, g) {
						return this._emitter.on(f, g)
					};
					m.once = function(f, g) {
						return this._emitter.once(f, g)
					};
					m.hasEventListener = function(f) {
						return this._emitter.hasEventListener(f)
					};
					return v
				}();
				(function(v) {
					let m = function() {
						function g(r = null) {
							this._target = r;
							this._listenersMap = null
						}
						var l = g.prototype;
						l.clear = function() {
							this._listenersMap && this._listenersMap.clear();
							this._listenersMap = null
						};
						l.emit = function(r, p) {
							r = this._listenersMap && this._listenersMap.get(r);
							if (!r) return !1;
							const n = this._target || this;
							[...r].forEach(t => {
								t.call(n, p)
							});
							return 0 < r.length
						};
						l.on = function(r, p) {
							if (Array.isArray(r)) {
								var n = r.map(t => this.on(t, p));
								return e.handlesGroup(n)
							}
							if (r.includes(",")) throw new TypeError("Evented.on() with a comma delimited string of event types is not supported");
							this._listenersMap || (this._listenersMap = new Map);
							n = this._listenersMap.get(r) || [];
							n.push(p);
							this._listenersMap.set(r, n);
							return {
								remove: () => {
									const t = this._listenersMap && this._listenersMap.get(r) || [],
										h = t.indexOf(p);
									0 <= h && t.splice(h, 1)
								}
							}
						};
						l.once = function(r, p) {
							const n = this.on(r, t => {
								n.remove();
								p.call(null, t)
							});
							return n
						};
						l.hasEventListener = function(r) {
							r = this._listenersMap && this._listenersMap.get(r);
							return null != r && 0 < r.length
						};
						return g
					}();
					v.EventEmitter = m;
					v.EventedMixin = g => {
						g = function(l) {
							function r() {
								var n =
									l.apply(this, arguments) || this;
								n._emitter = new m;
								return n
							}
							a._inheritsLoose(r, l);
							var p = r.prototype;
							p.destroy = function() {
								this._emitter.clear()
							};
							p.emit = function(n, t) {
								return this._emitter.emit(n, t)
							};
							p.on = function(n, t) {
								return this._emitter.on(n, t)
							};
							p.once = function(n, t) {
								return this._emitter.once(n, t)
							};
							p.hasEventListener = function(n) {
								return this._emitter.hasEventListener(n)
							};
							return r
						}(g);
						return g = b.__decorate([d.subclass("esri.core.Evented")], g)
					};
					let f = function(g) {
						function l() {
							var p = g.apply(this, arguments) ||
								this;
							p._emitter = new k.EventEmitter(a._assertThisInitialized(p));
							return p
						}
						a._inheritsLoose(l, g);
						var r = l.prototype;
						r.destroy = function() {
							this._emitter.clear()
						};
						r.emit = function(p, n) {
							return this._emitter.emit(p, n)
						};
						r.on = function(p, n) {
							return this._emitter.on(p, n)
						};
						r.once = function(p, n) {
							return this._emitter.once(p, n)
						};
						r.hasEventListener = function(p) {
							return this._emitter.hasEventListener(p)
						};
						return l
					}(c);
					f = b.__decorate([d.subclass("esri.core.Evented")], f);
					v.EventedAccessor = f
				})(k || (k = {}));
				return k
			})
		},
		"esri/core/Accessor": function() {
			define("../chunks/_rollupPluginBabelHelpers ./Handles ./maybe ./accessorSupport/get ./accessorSupport/metadata ./accessorSupport/Properties ./accessorSupport/set ./accessorSupport/watch ./accessorSupport/decorators/property ./accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					function l(q) {
						if (null == q) return {
							value: q
						};
						if (Array.isArray(q)) return {
							type: [q[0]],
							value: null
						};
						switch (typeof q) {
							case "object":
								return q.constructor ? .__accessorMetadata__ || q instanceof Date ? {
									type: q.constructor,
									value: q
								} : q;
							case "boolean":
								return {
									type: Boolean,
									value: q
								};
							case "string":
								return {
									type: String,
									value: q
								};
							case "number":
								return {
									type: Number,
									value: q
								};
							case "function":
								return {
									type: q,
									value: null
								}
						}
					}
					const r = Symbol("Accessor-Handles"),
						p = Symbol("Accessor-Initialized");
					let n = function() {
						function q(...x) {
							this[t] =
								null;
							this[h] = !1;
							if (this.constructor === q) throw Error("[accessor] cannot instantiate Accessor. This can be fixed by creating a subclass of Accessor");
							Object.defineProperty(this, "__accessor__", {
								enumerable: !1,
								value: new k(this)
							});
							0 < x.length && this.normalizeCtorArgs && (this.__accessor__.ctorArgs = this.normalizeCtorArgs.apply(this, x))
						}
						q.createSubclass = function(x = {}) {
							if (Array.isArray(x)) throw Error("Multi-inheritance unsupported since 4.16");
							const {
								properties: y,
								declaredClass: w,
								constructor: A
							} = x;
							delete x.declaredClass;
							delete x.properties;
							delete x.constructor;
							const B = this;
							let E = function(z) {
								function C(...D) {
									var J = z.call(this, ...D) || this;
									J.inherited = null;
									A && A.apply(a._assertThisInitialized(J), D);
									return J
								}
								a._inheritsLoose(C, z);
								return C
							}(B);
							d.getOwnClassMetadata(E.prototype);
							for (const z in x) {
								const C = x[z];
								E.prototype[z] = "function" === typeof C ? function(...D) {
									const J = this.inherited;
									this.inherited = function(...H) {
										if (B.prototype[z]) return B.prototype[z].apply(this, H)
									};
									let K = void 0;
									try {
										K = C.apply(this, D)
									} catch (H) {
										throw this.inherited =
											J, H;
									}
									this.inherited = J;
									return K
								} : x[z]
							}
							for (const z in y) x = l(y[z]), f.property(x)(E.prototype, z);
							return g.subclass(w)(E)
						};
						var u = q.prototype;
						u.postscript = function(x) {
							const y = this.__accessor__;
							x = y.ctorArgs || x;
							y.initialize();
							x && (this.set(x), y.ctorArgs = null);
							y.constructed();
							this.initialize();
							this[p] = !0
						};
						u.initialize = function() {};
						u.destroy = function() {
							this.destroyed || (this[r] = c.destroyMaybe(this[r]), m.removeTarget(this), this.__accessor__.destroy())
						};
						u.commitProperty = function(x) {
							this.get(x)
						};
						u.get = function(x) {
							return e.get(this,
								x)
						};
						u.hasOwnProperty = function(x) {
							return this.__accessor__ ? this.__accessor__.has(x) : Object.prototype.hasOwnProperty.call(this, x)
						};
						u.keys = function() {
							return this.__accessor__ ? this.__accessor__.keys() : []
						};
						u.set = function(x, y) {
							v.set(this, x, y);
							return this
						};
						u.watch = function(x, y, w) {
							return m.watch(this, x, y, w)
						};
						u.own = function(x) {
							this.addHandles(x)
						};
						u.addHandles = function(x, y) {
							let w = this[r];
							c.isNone(w) && (w = this[r] = new b);
							w.add(x, y)
						};
						u.removeHandles = function(x) {
							const y = this[r];
							c.isNone(y) || y.remove(x)
						};
						u.hasHandles =
							function(x) {
								const y = this[r];
								return c.isSome(y) ? y.has(x) : !1
							};
						u._override = function(x, y) {
							void 0 === y ? this.__accessor__.clearOverride(x) : this.__accessor__.override(x, y)
						};
						u._clearOverride = function(x) {
							return this.__accessor__.clearOverride(x)
						};
						u._overrideIfSome = function(x, y) {
							null == y ? this.__accessor__.clearOverride(x) : this.__accessor__.override(x, y)
						};
						u._isOverridden = function(x) {
							return this.__accessor__.isOverridden(x)
						};
						u.notifyChange = function(x) {
							this.__accessor__.notifyChange(x)
						};
						u._get = function(x) {
							return this.__accessor__.internalGet(x)
						};
						u._set = function(x, y) {
							this.__accessor__.internalSet(x, y);
							return this
						};
						a._createClass(q, [{
							key: "constructed",
							get: function() {
								return this.__accessor__ && this.__accessor__.initialized || !1
							}
						}, {
							key: "initialized",
							get: function() {
								return this[p]
							}
						}, {
							key: "destroyed",
							get: function() {
								return this.__accessor__ && this.__accessor__.destroyed || !1
							}
						}]);
						return q
					}();
					var t = r;
					var h = p;
					return n
				})
		},
		"esri/core/Handles": function() {
			define(["../chunks/_rollupPluginBabelHelpers", "./iteratorUtils", "./maybe"], function(a, b, c) {
				return function() {
					function e() {
						this._groups =
							new Map
					}
					var d = e.prototype;
					d.destroy = function() {
						this.removeAll()
					};
					d.add = function(k, v) {
						if (b.isIterable(k)) {
							v = this._getOrCreateGroup(v);
							for (const m of k) this._isHandle(m) && v.push(m)
						} else this._isHandle(k) && this._getOrCreateGroup(v)
							.push(k);
						return this
					};
					d.forEach = function(k, v) {
						if ("function" === typeof k) this._groups.forEach(m => m.forEach(k));
						else {
							const m = this._getGroup(k);
							m && v && m.forEach(v)
						}
					};
					d.has = function(k) {
						return this._groups.has(this._ensureGroupKey(k))
					};
					d.remove = function(k) {
						if ("string" !== typeof k &&
							b.isIterable(k)) {
							for (const v of k) this.remove(v);
							return this
						}
						if (!this.has(k)) return this;
						this._removeAllFromGroup(this._getGroup(k));
						this._groups.delete(this._ensureGroupKey(k));
						return this
					};
					d.removeAll = function() {
						this._groups.forEach(k => this._removeAllFromGroup(k));
						this._groups.clear();
						return this
					};
					d._isHandle = function(k) {
						return k && !!k.remove
					};
					d._getOrCreateGroup = function(k) {
						if (this.has(k)) return this._getGroup(k);
						const v = [];
						this._groups.set(this._ensureGroupKey(k), v);
						return v
					};
					d._getGroup = function(k) {
						return c.assumeNonNull(this._groups.get(this._ensureGroupKey(k)))
					};
					d._ensureGroupKey = function(k) {
						return k || "_default_"
					};
					d._removeAllFromGroup = function(k) {
						k.forEach(v => v.remove())
					};
					a._createClass(e, [{
						key: "size",
						get: function() {
							let k = 0;
							this._groups.forEach(v => {
								k += v.length
							});
							return k
						}
					}]);
					return e
				}()
			})
		},
		"esri/core/iteratorUtils": function() {
			define(["exports"], function(a) {
				a.cache = function(b) {
					const c = [];
					return function*() {
						yield* c;
						for (const e of b) c.push(e), yield e
					}
				};
				a.find = function(b, c) {
					for (const e of b)
						if (null != e && c(e)) return e
				};
				a.isIterable = function(b) {
					return null != b &&
						"function" === typeof b[Symbol.iterator]
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/maybe": function() {
			define(["exports"], function(a) {
				function b(d, k) {
					return null != d ? k(d) : null
				}

				function c(d, k) {
					if (null == d) throw Error(k ? ? "value is None");
				}

				function e(d, k, v) {
					return null != d ? v(d) : k
				}
				a.abortMaybe = function(d) {
					null != d && d.abort();
					return null
				};
				a.applySome = b;
				a.assertIsSome = c;
				a.assumeNonNull = function(d) {
					return d
				};
				a.destroyMaybe = function(d) {
					null != d && d.destroy();
					return null
				};
				a.disposeMaybe = function(d) {
					null != d && d.dispose();
					return null
				};
				a.equalsMaybe = function(d, k, v) {
					return null != d && null != k ? null != v ? v(d, k) : d.equals(k) : d === k
				};
				a.filterNones = function(d) {
					return d.filter(k => null != k)
				};
				a.forEachSome = function(d, k) {
					for (const v of d) b(v, k)
				};
				a.get = function(d, ...k) {
					for (let v = 0; v < k.length && d; ++v) d = d[k[v]];
					return d
				};
				a.isNone = function(d) {
					return null == d
				};
				a.isSome = function(d) {
					return null != d
				};
				a.isUndefined = function(d) {
					return void 0 === d
				};
				a.mapMany = function(d, k) {
					const v = [];
					for (const m of d) v.push(e(m,
						null, k));
					return v
				};
				a.mapOr = e;
				a.mapSome = function(d, k) {
					const v = [];
					d.forEach(m => {
						m = k(m);
						null != m && v.push(m)
					});
					return v
				};
				a.mapSomeFirst = function(d, k) {
					for (const v of d)
						if (d = k(v), null != d) return d;
					return null
				};
				a.none = null;
				a.nullifyNonNullableForDispose = function(d) {
					return null
				};
				a.releaseMaybe = function(d) {
					null != d && d.release();
					return null
				};
				a.removeMaybe = function(d) {
					null != d && d.remove();
					return null
				};
				a.unwrap = function(d) {
					return d
				};
				a.unwrapOr = function(d, k) {
					return null != d ? d : "function" === typeof k ? k() : k
				};
				a.unwrapOrThrow =
					function(d, k) {
						c(d, k);
						return d
					};
				a.unwrapOrValue = function(d, k) {
					return null != d ? d : k
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/get": function() {
			define(["exports", "./utils"], function(a, b) {
				function c(k, v) {
					k = "?" === k[k.length - 1] ? k.slice(0, -1) : k;
					if (null != v.getItemAt || Array.isArray(v)) {
						var m = parseInt(k, 10);
						if (!isNaN(m)) return Array.isArray(v) ? v[m] : v.getItemAt(m)
					}
					m = b.getProperties(v);
					return b.isPropertyDeclared(m, k) ? m.get(k) : v[k]
				}

				function e(k,
					v, m) {
					if (null == k) return k;
					if ((k = c(v[m], k)) || !(m < v.length - 1)) return m === v.length - 1 ? k : e(k, v, m + 1)
				}

				function d(k, v, m = 0) {
					return "string" !== typeof v || v.includes(".") ? e(k, b.pathToArray(v), m) : c(v, k)
				}
				a.exists = function(k, v) {
					return void 0 !== d(v, k)
				};
				a.get = function(k, v) {
					return d(k, v)
				};
				a.valueOf = d;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/utils": function() {
			define(["exports", "../handleUtils", "../lang", "../maybe"], function(a, b, c, e) {
				function d(g) {
					return g ?
						g.__accessor__ ? g.__accessor__ : g.propertyInvalidated ? g : null : null
				}

				function k(g, l, r) {
					return l ? Object.keys(l)
						.reduce((p, n) => {
							let t = null;
							var h = "merge";
							r && (t = r.path ? `${r.path}.${n}` : n, h = r.policy(t));
							if ("replace" === h) return p[n] = l[n], p;
							if (void 0 === p[n]) return p[n] = c.clone(l[n]), p;
							let q = p[n];
							h = l[n];
							if (q === h) return p;
							if (Array.isArray(h) || Array.isArray(p)) q = q ? Array.isArray(q) ? p[n] = q.concat() : p[n] = [q] : p[n] = [], h && (Array.isArray(h) || (h = [h]), h.forEach(u => {
								q.includes(u) || q.push(u)
							}));
							else if (h && "object" === typeof h)
								if (r) {
									const u =
										r.path;
									r.path = e.assumeNonNull(t);
									p[n] = k(q, h, r);
									r.path = u
								} else p[n] = k(q, h, null);
							else if (!p.hasOwnProperty(n) || l.hasOwnProperty(n)) p[n] = h;
							return p
						}, g || {}) : g
				}

				function v(g) {
					return Array.isArray(g) ? g : g.split(".")
				}

				function m(g) {
					return g.includes(",") ? g.split(",")
						.map(l => l.trim()) : [g.trim()]
				}

				function f(g) {
					if (Array.isArray(g)) {
						const l = [];
						for (const r of g) l.push(...m(r));
						return l
					}
					return m(g)
				}
				a.getDependsInfo = function(g, l) {
					const r = d(g);
					return r ? r.getDependsInfo(g, l, "") : ""
				};
				a.getProperties = d;
				a.isPropertyDeclared =
					function(g, l) {
						return null != g && g.metadatas && null != g.metadatas[l]
					};
				a.merge = function(g, l, r) {
					return r ? k(g, l, {
						policy: r,
						path: ""
					}) : k(g, l, null)
				};
				a.once = function(g) {
					let l = !1;
					return () => {
						l || (l = !0, g())
					}
				};
				a.parse = function(g, l, r, p) {
					l = f(l);
					return 1 !== l.length ? (l = l.map(n => p(g, n, r)), b.handlesGroup(l)) : p(g, l[0], r)
				};
				a.parseConditionalPath = function(g) {
					if (!g.includes("?")) return null;
					g = v(g);
					const l = Array(g.length);
					for (let r = 0; r < g.length; r++) {
						const p = g[r];
						l[r] = "?" === p[p.length - 1];
						l[r] && (g[r] = p.slice(0, -1))
					}
					return {
						fullPath: g.join("."),
						conditional: l
					}
				};
				a.pathToArray = v;
				a.pathToStringOrArray = function(g) {
					return !g || "string" === typeof g && !g.includes(".") ? g : v(g)
				};
				a.splitPath = f;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/handleUtils": function() {
			define(["exports", "./maybe"], function(a, b) {
				function c(e) {
					return {
						remove: () => {
							e && (e(), e = void 0)
						}
					}
				}
				a.asyncHandle = function(e, d) {
					let k = !1,
						v = null;
					e.then(m => {
						k ? m.remove() : v = m
					});
					return c(() => {
						k = !0;
						b.isSome(v) ? v.remove() : b.isSome(d) && (d.abort(), d =
							null)
					})
				};
				a.destroyHandle = function(e) {
					return c(b.isSome(e) ? () => e.destroy() : void 0)
				};
				a.handlesGroup = function(e) {
					return c(() => e.forEach(d => b.isSome(d) && d.remove()))
				};
				a.makeHandle = c;
				a.refHandle = function(e) {
					return c(() => {
						const d = e();
						b.isSome(d) && d.remove()
					})
				};
				a.timeoutHandle = function(e, d) {
					const k = setTimeout(e, d);
					return c(() => clearTimeout(k))
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/lang": function() {
			define(["exports", "./arrayUtils", "./maybe",
				"./typedArrayUtil"
			], function(a, b, c, e) {
				function d(p, n) {
					let t;
					if (n)
						for (t in p) p.hasOwnProperty(t) && (void 0 === p[t] ? delete p[t] : p[t] instanceof Object && d(p[t], !0));
					else
						for (t in p) p.hasOwnProperty(t) && void 0 === p[t] && delete p[t];
					return p
				}

				function k(p) {
					if (!p || "object" !== typeof p || "function" === typeof p) return p;
					var n = l(p);
					if (c.isSome(n)) return n;
					if ("function" === typeof p.clone) return p.clone();
					if (m(p)) return p.map(k);
					if (f(p)) return p.clone();
					n = {};
					for (const t of Object.getOwnPropertyNames(p)) n[t] = k(p[t]);
					return n
				}

				function v(p) {
					if (!p || "object" !== typeof p || "function" === typeof p || "HTMLElement" in globalThis && p instanceof HTMLElement) return p;
					var n = l(p);
					if (c.isSome(n)) return n;
					if (m(p)) {
						let t = !0;
						p = p.map(h => {
							const q = v(h);
							null != h && null == q && (t = !1);
							return q
						});
						return t ? p : null
					}
					if ("function" === typeof p.clone) return p.clone();
					if (!f(p)) {
						n = new(Object.getPrototypeOf(p)
							.constructor);
						for (const t of Object.getOwnPropertyNames(p)) {
							const h = p[t],
								q = v(h);
							if (null != h && null == q) return null;
							n[t] = q
						}
						return n
					}
					return null
				}

				function m(p) {
					return "function" ===
						typeof p.map && "function" === typeof p.forEach
				}

				function f(p) {
					return "function" === typeof p.notifyChange && "function" === typeof p.watch
				}

				function g(p) {
					if ("[object Object]" !== Object.prototype.toString.call(p)) return !1;
					p = Object.getPrototypeOf(p);
					return null === p || p === Object.prototype
				}

				function l(p) {
					if (e.isInt8Array(p) || e.isUint8Array(p) || e.isUint8ClampedArray(p) || e.isInt16Array(p) || e.isUint16Array(p) || e.isInt32Array(p) || e.isUint32Array(p) || e.isFloat32Array(p) || e.isFloat64Array(p)) return e.slice(p);
					if (p instanceof Date) return new Date(p.getTime());
					if (p instanceof ArrayBuffer) return p.slice(0, p.byteLength);
					if (p instanceof Map) {
						var n = new Map;
						for (const [t, h] of p) n.set(t, k(h));
						return n
					}
					if (p instanceof Set) {
						n = new Set;
						for (const t of p) n.add(k(t));
						return n
					}
					return null
				}

				function r(p, n) {
					if (null === p || null === n) return !1;
					const t = Object.keys(p);
					if (null === n || Object.keys(n)
						.length !== t.length) return !1;
					for (const h of t)
						if (p[h] !== n[h] || !Object.prototype.hasOwnProperty.call(n, h)) return !1;
					return !0
				}
				a.clone = k;
				a.equals = function(p,
					n) {
					return p === n || "number" === typeof p && isNaN(p) && "number" === typeof n && isNaN(n) || "function" === typeof(p || {})
						.getTime && "function" === typeof(n || {})
						.getTime && p.getTime() === n.getTime() || !1
				};
				a.equalsShallow = function(p, n) {
					if (p === n) return !0;
					if (null === p || void 0 === p || "string" === typeof p) return p === n;
					if ("number" === typeof p) return p === n || "number" === typeof n && isNaN(p) && isNaN(n);
					if (p instanceof Date) return n instanceof Date && p.getTime() === n.getTime();
					if (Array.isArray(p)) return Array.isArray(n) && b.equals(p, n);
					if (p instanceof Set) {
						var t;
						if (t = n instanceof Set) a: if (p.size !== n.size) t = !1;
							else {
								for (const h of p)
									if (!n.has(h)) {
										t = !1;
										break a
									} t = !0
							} return t
					}
					if (p instanceof Map) {
						if (t = n instanceof Map) a: if (p.size !== n.size) t = !1;
							else {
								for (const [h, q] of p)
									if (p = n.get(h), p !== q || void 0 === p && !n.has(h)) {
										t = !1;
										break a
									} t = !0
							} return t
					}
					return g(p) ? g(n) && r(p, n) : !1
				};
				a.fixJson = d;
				a.isAccessorLike = f;
				a.isPlainObject = g;
				a.tryClone = v;
				a.tryCloneBuiltInObject = l;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/arrayUtils": function() {
			define(["exports",
				"./maybe", "./RandomLCG"
			], function(a, b, c) {
				function e(p) {
					return p
				}

				function d(p, n = e) {
					if (p && 0 !== p.length) {
						var t = p[0],
							h = n(t);
						for (let q = 1; q < p.length; ++q) {
							const u = p[q],
								x = Number(n(u));
							x > h && (h = x, t = u)
						}
						return t
					}
				}

				function k(p, n, t, h) {
					h = h || g;
					var q = Math.max(0, h.last - 10);
					for (let u = q; u < t; ++u)
						if (p[u] === n) return h.last = u;
					t = Math.min(q, t);
					for (q = 0; q < t; ++q)
						if (p[q] === n) return h.last = q;
					return -1
				}

				function v(p) {
					return p ? (r.seed = p, () => r.getFloat()) : Math.random
				}
				const m = !!Array.prototype.fill;
				let f = function() {
					this.last = 0
				};
				const g =
					new f,
					l = new Set,
					r = new c;
				a.PositionHint = f;
				a.binaryFindClosest = function(p, n, t) {
					if (p && 0 !== p.length) {
						var h = p.length - 1,
							q = p[0];
						if (n <= t(q)) return q;
						q = p[h];
						if (n >= t(q)) return q;
						var u = 0;
						q = 0;
						for (var x = h; u < x;) {
							q = u + Math.floor((x - u) / 2);
							const w = p[q],
								A = t(w);
							if (A === n) return w;
							if (n < A) {
								if (0 < q) {
									x = p[q - 1];
									var y = t(x);
									if (n > y) return n - y >= A - n ? w : x
								}
								x = q
							} else {
								if (q < h && (u = p[q + 1], y = t(u), n < y)) return n - A >= y - n ? u : w;
								u = q + 1
							}
						}
						return p[q]
					}
				};
				a.binaryIndexOf = function(p, n, t) {
					const h = p.length;
					let q = 0;
					for (var u = h - 1; q < u;) {
						const x = q + Math.floor((u -
							q) / 2);
						n > p[x] ? q = x + 1 : u = x
					}
					u = p[q];
					return t ? n >= p[h - 1] ? -1 : u === n ? q : q - 1 : u === n ? q : -1
				};
				a.constant = function(p, n) {
					if (m) return Array(p)
						.fill(n);
					const t = Array(p);
					for (let h = 0; h < p; h++) t[h] = n;
					return t
				};
				a.difference = function(p, n, t) {
					let h, q;
					t ? (h = n.filter(u => !p.some(x => t(x, u))), q = p.filter(u => !n.some(x => t(x, u)))) : (h = n.filter(u => !p.includes(u)), q = p.filter(u => !n.includes(u)));
					return {
						added: h,
						removed: q
					}
				};
				a.equals = function(p, n, t) {
					if (b.isNone(p) && b.isNone(n)) return !0;
					if (b.isNone(p) || b.isNone(n) || p.length !== n.length) return !1;
					if (t)
						for (let h = 0; h < p.length; h++) {
							if (!t(p[h], n[h])) return !1
						} else
							for (t = 0; t < p.length; t++)
								if (p[t] !== n[t]) return !1;
					return !0
				};
				a.first = function(p) {
					if (p) return 0 < p.length ? p[0] : void 0
				};
				a.groupToMap = function(p, n) {
					const t = new Map,
						h = p.length;
					for (let q = 0; q < h; q++) {
						const u = p[q],
							x = n(u, q, p),
							y = t.get(x);
						y ? y.push(u) : t.set(x, [u])
					}
					return t
				};
				a.indexOf = k;
				a.intersect = function(p, n, t) {
					return p && n ? t ? p.filter(h => -1 < n.findIndex(q => t(h, q))) : p.filter(h => n.includes(h)) : []
				};
				a.isArrayLike = function(p) {
					return p && "number" === typeof p.length
				};
				a.last = function(p) {
					if (p) {
						var n = p.length;
						return 0 < n ? p[n - 1] : void 0
					}
				};
				a.max = d;
				a.min = function(p, n = e) {
					return d(p, t => -n(t))
				};
				a.pickRandom = function(p, n, t) {
					const h = p.length;
					if (n >= h) return p.slice(0);
					t = v(t);
					const q = new Set,
						u = [];
					for (; u.length < n;) {
						const x = Math.floor(t() * h);
						q.has(x) || (q.add(x), u.push(p[x]))
					}
					return u
				};
				a.range = function(p, n) {
					void 0 === n && (n = p, p = 0);
					const t = Array(n - p);
					for (let h = p; h < n; h++) t[h - p] = h;
					return t
				};
				a.remove = function(p, n) {
					const t = p.indexOf(n);
					return -1 !== t ? (p.splice(t, 1), n) : null
				};
				a.removeUnordered =
					function(p, n, t, h) {
						const q = null == t ? p.length : t;
						h = k(p, n, q, h);
						if (-1 !== h) return p[h] = p[q - 1], null == t && p.pop(), n
					};
				a.removeUnorderedMany = function(p, n, t = p.length, h = n.length, q, u) {
					if (0 === h || 0 === t) return t;
					l.clear();
					for (let x = 0; x < h; ++x) l.add(n[x]);
					q = q || g;
					n = Math.max(0, q.last - 10);
					for (h = n; h < t; ++h)
						if (l.has(p[h]) && (u && u.push(p[h]), l.delete(p[h]), p[h] = p[t - 1], --t, --h, 0 === l.size || 0 === t)) return l.clear(), t;
					for (h = 0; h < n; ++h)
						if (l.has(p[h]) && (u && u.push(p[h]), l.delete(p[h]), p[h] = p[t - 1], --t, --h, 0 === l.size || 0 === t)) return l.clear(),
							t;
					l.clear();
					return t
				};
				a.shuffle = function(p, n) {
					n = v(n);
					for (let t = p.length - 1; 0 < t; t--) {
						const h = Math.floor(n() * (t + 1)),
							q = p[t];
						p[t] = p[h];
						p[h] = q
					}
					return p
				};
				a.splitIntoChunks = function(p, n) {
					const t = p.length;
					if (0 === t) return [];
					const h = [];
					for (let q = 0; q < t; q += n) h.push(p.slice(q, q + n));
					return h
				};
				a.unique = function(p, n) {
					return n ? p.filter((t, h, q) => q.findIndex(n.bind(null, t)) === h) : p.filter((t, h, q) => q.indexOf(t) === h)
				};
				a.update = function(p, n) {
					let t = p.length !== n.length;
					t && (p.length = n.length);
					for (let h = 0; h < n.length; ++h) p[h] !==
						n[h] && (p[h] = n[h], t = !0);
					return t
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/RandomLCG": function() {
			define(["../chunks/_rollupPluginBabelHelpers"], function(a) {
				let b = function() {
					function c(d = 1) {
						this._seed = d
					}
					var e = c.prototype;
					e.getInt = function() {
						return this._seed = (c._a * this._seed + c._c) % c._m
					};
					e.getFloat = function() {
						return this.getInt() / (c._m - 1)
					};
					e.getIntRange = function(d, k) {
						return Math.round(this.getFloatRange(d, k))
					};
					e.getFloatRange = function(d, k) {
						k -=
							d;
						const v = this.getInt() / c._m;
						return d + v * k
					};
					a._createClass(c, [{
						key: "seed",
						set: function(d) {
							this._seed = null == d ? Math.random() * c._m : d
						}
					}]);
					return c
				}();
				b._m = 2147483647;
				b._a = 48271;
				b._c = 0;
				return b
			})
		},
		"esri/core/typedArrayUtil": function() {
			define(["exports", "./maybe"], function(a, b) {
				a.estimateSize = function(c) {
					return b.isNone(c) ? 0 : 128 + c.buffer.byteLength + 64
				};
				a.forEach = function(c, e) {
					if (c.forEach) c.forEach(e);
					else
						for (let d = 0; d < c.length; d++) e(c[d], d, c)
				};
				a.isArrayBuffer = function(c) {
					return c instanceof ArrayBuffer ||
						c && c.constructor && "ArrayBuffer" === c.constructor.name
				};
				a.isFloat32Array = function(c) {
					return c instanceof Float32Array || c && c.constructor && "Float32Array" === c.constructor.name
				};
				a.isFloat64Array = function(c) {
					return c instanceof Float64Array || c && c.constructor && "Float64Array" === c.constructor.name
				};
				a.isInt16Array = function(c) {
					return c instanceof Int16Array || c && c.constructor && "Int16Array" === c.constructor.name
				};
				a.isInt32Array = function(c) {
					return c instanceof Int32Array || c && c.constructor && "Int32Array" === c.constructor.name
				};
				a.isInt8Array = function(c) {
					return c instanceof Int8Array || c && c.constructor && "Int8Array" === c.constructor.name
				};
				a.isUint16Array = function(c) {
					return c instanceof Uint16Array || c && c.constructor && "Uint16Array" === c.constructor.name
				};
				a.isUint32Array = function(c) {
					return c instanceof Uint32Array || c && c.constructor && "Uint32Array" === c.constructor.name
				};
				a.isUint8Array = function(c) {
					return c instanceof Uint8Array || c && c.constructor && "Uint8Array" === c.constructor.name
				};
				a.isUint8ClampedArray = function(c) {
					return c instanceof
					Uint8ClampedArray || c && c.constructor && "Uint8ClampedArray" === c.constructor.name
				};
				a.slice = function(c, e, d) {
					if (c.slice) return c.slice(e, d);
					void 0 === e ? e = 0 : (0 > e && (e += c.length), e = Math.min(c.length, Math.max(0, e)));
					void 0 === d ? d = c.length : (0 > d && (d += c.length), d = Math.min(c.length, Math.max(0, d)));
					d = Math.max(0, d - e);
					const k = new c.constructor(d);
					for (let v = 0; v < d; v++) k[v] = c[e + v];
					return k
				};
				a.toArray = function(c) {
					const e = Array(c.length);
					for (let d = 0; d < c.length; d++) e[d] = c[d];
					return e
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/metadata": function() {
			define(["exports", "../lang", "../maybe", "./utils"], function(a, b, c, e) {
				function d(r) {
					let p = r.constructor.__accessorMetadata__;
					var n = Object.prototype.hasOwnProperty.call(r.constructor, "__accessorMetadata__");
					if (!p) p = new f({}), Object.defineProperty(r.constructor, "__accessorMetadata__", {
						value: p,
						enumerable: !1,
						configurable: !0,
						writable: !0
					});
					else if (!n) {
						n = Object.create(p.properties);
						const t = p.autoDestroy;
						for (const h in n) n[h] =
							b.clone(n[h]);
						p = new f(n);
						p.autoDestroy = t;
						Object.defineProperty(r.constructor, "__accessorMetadata__", {
							value: p,
							enumerable: !1,
							configurable: !0,
							writable: !0
						})
					}
					return c.assumeNonNull(r.constructor.__accessorMetadata__)
				}

				function k(r) {
					return d(r)
						.properties
				}

				function v(r) {
					return g.test(r) ? "replace" : "merge"
				}

				function m(r) {
					return l.test(r) ? v(r.slice(11)) : "merge"
				}
				let f = function(r) {
					this.autoDestroy = !1;
					this.properties = r
				};
				const g = /^(?:[^.]+\.)?(?:value|type|(?:json\.type|json\.origins\.[^.]\.type))$/,
					l = /^properties\./;
				a.ClassMetadata = f;
				a.getOwnClassMetadata = d;
				a.getOwnPropertiesMetadata = k;
				a.getOwnPropertyMetadata = function(r, p) {
					r = k(r);
					let n = r[p];
					n || (n = r[p] = {});
					return n
				};
				a.merge = function(r, p) {
					return e.merge(r, p, m)
				};
				a.mergeProperty = function(r, p) {
					return e.merge(r, p, v)
				};
				a.setPropertyMetadata = function(r, p, n) {
					k(r)[p] = n
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/Properties": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../has ../lang ../Logger ../ObjectPool ./interfaces ./Property ./PropertyOrigin ./Store ./tracking ./utils ./tracking/Flags".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					e.getLogger("esri.core.accessorSupport.Properties");
					b = function() {
						function n(h) {
							this.host = h;
							this.properties = new Map;
							this.ctorArgs = null;
							this.destroyed = !1;
							this.lifecycle = k.Lifecycle.INITIALIZING;
							this.store = new f.Store;
							this._origin = m.OriginId.USER;
							h = this.host.constructor.__accessorMetadata__;
							const q = h.properties;
							for (const u in q) {
								const x = new v.Property(this, u, q[u]);
								this.properties.set(u, x)
							}
							this.metadatas = q;
							this._autoDestroy = h.autoDestroy
						}
						var t = n.prototype;
						t.initialize =
							function() {
								this.lifecycle = k.Lifecycle.CONSTRUCTING
							};
						t.constructed = function() {
							this.lifecycle = k.Lifecycle.CONSTRUCTED
						};
						t.destroy = function() {
							this.destroyed = !0;
							if (this._autoDestroy)
								for (const [q, u] of this.properties) {
									var h = this.internalGet(q);
									h && h && "function" === typeof h.destroy && (h.destroy(), ~u.flags & r.Flags.NonNullable && this._internalSet(u, null));
									u.destroy()
								} else
									for ([, h] of this.properties) h.destroy()
						};
						t.get = function(h) {
							const q = this.properties.get(h);
							if (q.metadata.get) return q.getComputed();
							g.trackAccess(q);
							const u = this.store;
							return u.has(h) ? u.get(h) : q.metadata.value
						};
						t.originOf = function(h) {
							const q = this.store.originOf(h);
							return void 0 === q && (h = this.properties.get(h), void 0 !== h && h.flags & r.Flags.HasDefaultValue) ? "defaults" : m.idToName(q)
						};
						t.has = function(h) {
							return this.properties.has(h) ? this.store.has(h) : !1
						};
						t.keys = function() {
							return [...this.properties.keys()]
						};
						t.internalGet = function(h) {
							const q = this.properties.get(h);
							if (void 0 !== q) return this.store.has(h) ? this.store.get(h) : q.metadata.value
						};
						t.internalSet =
							function(h, q) {
								h = this.properties.get(h);
								void 0 !== h && this._internalSet(h, q)
							};
						t.getDependsInfo = function(h, q, u) {
							const x = this.properties.get(q);
							if (void 0 === x) return "";
							const y = new Set;
							var w = g.runTracked({
									onObservableAccessed: B => y.add(B),
									onTrackingEnd: () => {}
								}, () => x.metadata.get ? .call(h)),
								A = h.declaredClass.split(".")
								.pop();
							q = `${u}${A}.${q}: ${w}\n`;
							if (0 === y.size) return q;
							u += "  ";
							for (const B of y) {
								if (!(B instanceof v.Property)) continue;
								w = B.properties.host;
								A = B.propertyName;
								const E = l.getProperties(w);
								q = E ? q +
									E.getDependsInfo(w, A, u) : q + `${u}${A}: undefined\n`
							}
							return q
						};
						t.setAtOrigin = function(h, q, u) {
							h = this.properties.get(h);
							if (void 0 !== h) return this._setAtOrigin(h, q, u)
						};
						t.isOverridden = function(h) {
							h = this.properties.get(h);
							return void 0 !== h && !!(h.flags & r.Flags.Overriden)
						};
						t.clearOverride = function(h) {
							h = this.properties.get(h);
							void 0 !== h && h.flags & r.Flags.Overriden && (h.flags &= ~r.Flags.Overriden, h.notifyChange())
						};
						t.override = function(h, q) {
							h = this.properties.get(h);
							if (!(void 0 === h || null == q && h.flags & r.Flags.NonNullable)) {
								var u =
									h.metadata.cast;
								if (u) {
									q = this._cast(u, q);
									const {
										valid: x,
										value: y
									} = q;
									p.release(q);
									if (!x) return;
									q = y
								}
								h.flags |= r.Flags.Overriden;
								this._internalSet(h, q)
							}
						};
						t.set = function(h, q) {
							h = this.properties.get(h);
							if (!(void 0 === h || null == q && h.flags & r.Flags.NonNullable)) {
								var u = h.metadata.cast;
								if (u) {
									q = this._cast(u, q);
									const {
										valid: x,
										value: y
									} = q;
									p.release(q);
									if (!x) return;
									q = y
								}(u = h.metadata.set) ? u.call(this.host, q): this._internalSet(h, q)
							}
						};
						t.setDefaultOrigin = function(h) {
							this._origin = m.nameToId(h)
						};
						t.getDefaultOrigin = function() {
							return m.idToName(this._origin)
						};
						t.notifyChange = function(h) {
							h = this.properties.get(h);
							void 0 !== h && h.notifyChange()
						};
						t.invalidate = function(h) {
							h = this.properties.get(h);
							void 0 !== h && h.invalidate()
						};
						t.commit = function(h) {
							h = this.properties.get(h);
							void 0 !== h && h.commit()
						};
						t._internalSet = function(h, q) {
							this._setAtOrigin(h, q, this.lifecycle !== k.Lifecycle.INITIALIZING ? this._origin : m.OriginId.DEFAULTS)
						};
						t._setAtOrigin = function(h, q, u) {
							const x = this.store,
								y = h.propertyName;
							x.has(y, u) && c.equals(q, x.get(y)) && ~h.flags & r.Flags.Overriden && u === x.originOf(y) ||
								(h.invalidate(), x.set(y, q, u), h.commit(), g.initializeDependencyTracking(this.host, h))
						};
						t._cast = function(h, q) {
							const u = p.acquire();
							u.valid = !0;
							u.value = q;
							h && (u.value = h.call(this.host, q, u));
							return u
						};
						a._createClass(n, [{
							key: "initialized",
							get: function() {
								return this.lifecycle !== k.Lifecycle.INITIALIZING
							}
						}]);
						return n
					}();
					e = function() {
						function n() {
							this.value = null;
							this.valid = !0
						}
						var t = n.prototype;
						t.acquire = function() {
							this.valid = !0
						};
						t.release = function() {
							this.value = null
						};
						return n
					}();
					const p = new d(e);
					return b
				})
		},
		"esri/core/has": function() {
			define(function() {
				function a(c) {
					return "function" ===
						typeof b[c] ? b[c] = b[c](globalThis) : b[c]
				}
				let b;
				b = globalThis.dojoConfig ? .has || globalThis.esriConfig ? .has ? {
					...globalThis.dojoConfig ? .has,
					...globalThis.esriConfig ? .has
				} : {};
				a.add = (c, e, d, k) => {
					if (k || "undefined" === typeof b[c]) b[c] = e;
					return d && a(c)
				};
				a.cache = b;
				a.add("esri-deprecation-warnings", !0);
				(() => {
					a.add("host-webworker", "undefined" !== typeof globalThis.WorkerGlobalScope && self instanceof globalThis.WorkerGlobalScope);
					var c = "undefined" !== typeof window && "undefined" !== typeof location && "undefined" !== typeof document &&
						window.location === location && window.document === document;
					a.add("host-browser", c);
					a.add("dom", c);
					if (a("host-browser")) {
						var e = navigator;
						c = e.userAgent;
						e = e.appVersion;
						const k = parseFloat(e);
						a.add("edge", parseFloat(c.split("Edge/")[1]) || void 0);
						a.add("webkit", !a("edge") && parseFloat(c.split("WebKit/")[1]) || void 0);
						a.add("chrome", !a("edge") && parseFloat(c.split("Chrome/")[1]) || void 0);
						a.add("safari", !e.includes("Safari") || a("chrome") || a("edge") ? void 0 : parseFloat(e.split("Version/")[1]));
						a.add("mac", e.includes("Macintosh"));
						if (c.match(/(iPhone|iPod|iPad)/)) {
							const v = RegExp.$1.replace(/P/, "p");
							var d = c.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
							d = parseFloat(d.replace(/_/, ".")
								.replace(/_/g, ""));
							a.add(v, d);
							a.add("ios", d)
						}
						a.add("trident", parseFloat(e.split("Trident/")[1]) || void 0);
						a("webkit") || (!c.includes("Gecko") || a("trident") || a("edge") || a.add("mozilla", k), a("mozilla") && a.add("ff", parseFloat(c.split("Firefox/")[1] || c.split("Minefield/")[1]) || void 0))
					}
				})();
				(() => {
					if (globalThis.navigator) {
						var c = navigator.userAgent;
						const e = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini|IEMobile/i.test(c);
						c = /iPhone/i.test(c);
						e && a.add("esri-mobile", e);
						c && a.add("esri-iPhone", c);
						a.add("esri-geolocation", !!navigator.geolocation)
					}
					a.add("esri-canvas-svg-support", !a("trident"));
					a.add("esri-wasm", "WebAssembly" in globalThis);
					a.add("esri-shared-array-buffer", () => {
						const e = !1 === globalThis.crossOriginIsolated;
						return "SharedArrayBuffer" in globalThis && !e
					});
					a.add("wasm-simd", () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11])));
					a.add("esri-atomics",
						"Atomics" in globalThis);
					a.add("esri-workers", "Worker" in globalThis);
					a.add("web-feat:cache", "caches" in globalThis);
					a.add("esri-workers-arraybuffer-transfer", !a("safari") || 12 <= Number(a("safari")));
					a.add("featurelayer-simplify-thresholds", [.5, .5, .5, .5]);
					a.add("featurelayer-simplify-payload-size-factors", [1, 1, 4]);
					a.add("featurelayer-snapshot-enabled", !0);
					a.add("featurelayer-snapshot-point-min-threshold", 8E4);
					a.add("featurelayer-snapshot-point-max-threshold", 4E5);
					a.add("featurelayer-snapshot-point-coverage",
						.1);
					a.add("featurelayer-advanced-symbols", !1);
					a.add("featurelayer-pbf", !0);
					a.add("featurelayer-pbf-statistics", !1);
					a.add("feature-layers-workers", !0);
					a.add("feature-polyline-generalization-factor", 1);
					a.add("mapview-transitions-duration", 200);
					a.add("mapview-srswitch-adjust-rotation-scale-threshold", 24E6);
					a.add("mapserver-pbf-enabled", !1);
					a.add("mapimagelayer-popup-identify-max-tolerance", 20);
					a.add("heatmap-allow-raster-fallback", !0);
					a.add("heatmap-force-raster", !1);
					!a("host-webworker") && a("host-browser") &&
						(a.add("esri-csp-restrictions", () => {
							try {
								new Function
							} catch {
								return !0
							}
							return !1
						}), a.add("esri-image-decode", () => {
							if ("decode" in new Image) {
								const e = new Image;
								e.src = 'data:image/svg+xml;charset\x3dUTF-8,\x3csvg version\x3d"1.1" xmlns\x3d"http://www.w3.org/2000/svg"\x3e\x3c/svg\x3e';
								e.decode()
									.then(() => {
										a.add("esri-image-decode", !0, !0, !0)
									})
									.catch(() => {
										a.add("esri-image-decode", !1, !0, !0)
									})
							} else return !1
						}), a.add("esri-url-encodes-apostrophe", () => {
							const e = window.document.createElement("a");
							e.href = "?'";
							return e.href.includes("?%27")
						}))
				})();
				return a
			})
		},
		"esri/core/Logger": function() {
			define(["../chunks/_rollupPluginBabelHelpers", "../config", "./has", "./maybe", "./string"], function(a, b, c, e, d) {
				const k = {
					info: 0,
					warn: 1,
					error: 2,
					none: 3
				};
				c = function() {
					function v(f) {
						this.level = null;
						this._module = "";
						this.writer = this._parent = null;
						this._loggedMessages = {
							error: new Map,
							warn: new Map,
							info: new Map
						};
						null != f.level && (this.level = f.level);
						null != f.writer && (this.writer = f.writer);
						this._module = f.module;
						v._loggers[this.module] = this;
						f = this.module.lastIndexOf("."); - 1 !==
							f && (this._parent = v.getLogger(this.module.slice(0, f)))
					}
					var m = v.prototype;
					m.error = function(...f) {
						this._log("error", "always", ...f)
					};
					m.warn = function(...f) {
						this._log("warn", "always", ...f)
					};
					m.info = function(...f) {
						this._log("info", "always", ...f)
					};
					m.errorOnce = function(...f) {
						this._log("error", "once", ...f)
					};
					m.warnOnce = function(...f) {
						this._log("warn", "once", ...f)
					};
					m.infoOnce = function(...f) {
						this._log("info", "once", ...f)
					};
					m.errorOncePerTick = function(...f) {
						this._log("error", "oncePerTick", ...f)
					};
					m.warnOncePerTick =
						function(...f) {
							this._log("warn", "oncePerTick", ...f)
						};
					m.infoOncePerTick = function(...f) {
						this._log("info", "oncePerTick", ...f)
					};
					v.getLogger = function(f) {
						let g = v._loggers[f];
						g || (g = new v({
							module: f
						}));
						return g
					};
					m._log = function(f, g, ...l) {
						if (this._matchLevel(f)) {
							if ("always" !== g && !v._throttlingDisabled) {
								const r = this._argsToKey(l),
									p = this._loggedMessages[f].get(r);
								if ("once" === g && null != p || "oncePerTick" === g && p && p >= v._tickCounter) return;
								this._loggedMessages[f].set(r, v._tickCounter);
								v._scheduleTickCounterIncrement()
							}
							for (const r of b.log.interceptors)
								if (r(f,
									this.module, ...l)) return;
							this._inheritedWriter()(f, this.module, ...l)
						}
					};
					m._parentWithMember = function(f, g) {
						let l = this;
						for (; e.isSome(l);) {
							const r = l[f];
							if (e.isSome(r)) return r;
							l = l.parent
						}
						return g
					};
					m._inheritedWriter = function() {
						return this._parentWithMember("writer", this._consoleWriter)
					};
					m._consoleWriter = function(f, g, ...l) {
						console[f](`[${g}]`, ...l)
					};
					m._matchLevel = function(f) {
						return k[this._parentWithMember("level", b.log.level ? b.log.level : "warn")] <= k[f]
					};
					m._argsToKey = function(...f) {
						return d.numericHash(JSON.stringify(f,
							(g, l) => "object" !== typeof l || Array.isArray(l) ? l : "[Object]"))
					};
					v._scheduleTickCounterIncrement = function() {
						v._tickCounterScheduled || (v._tickCounterScheduled = !0, Promise.resolve()
							.then(() => {
								v._tickCounter++;
								v._tickCounterScheduled = !1
							}))
					};
					a._createClass(v, [{
						key: "module",
						get: function() {
							return this._module
						}
					}, {
						key: "parent",
						get: function() {
							return this._parent
						}
					}, {
						key: "test",
						get: function() {
							const f = this;
							return {
								loggedMessages: f._loggedMessages,
								clearLoggedWarnings() {
									return f._loggedMessages.warn.clear()
								}
							}
						}
					}], [{
						key: "testSingleton",
						get: function() {
							return {
								resetLoggers(f = {}) {
									const g = v._loggers;
									v._loggers = f;
									return g
								},
								set throttlingDisabled(f) {
									v._throttlingDisabled = f
								}
							}
						}
					}]);
					return v
				}();
				c._loggers = {};
				c._tickCounter = 0;
				c._tickCounterScheduled = !1;
				c._throttlingDisabled = !1;
				return c
			})
		},
		"esri/config": function() {
			define(["module", "./core/has", "./core/object"], function(a, b, c) {
				b = {
					analysisTheme: {
						accentColor: [255, 128, 0],
						textColor: "white"
					},
					apiKey: void 0,
					applicationUrl: globalThis.location ? .href,
					assetsPath: "",
					fontsUrl: "https://static.arcgis.com/fonts",
					geometryServiceUrl: "https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer",
					geoRSSServiceUrl: "https://utility.arcgis.com/sharing/rss",
					kmlServiceUrl: "https://utility.arcgis.com/sharing/kml",
					portalUrl: "https://www.arcgis.com",
					routeServiceUrl: "https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World",
					workers: {
						loaderConfig: {
							has: {},
							paths: {},
							map: {},
							packages: []
						}
					},
					request: {
						crossOriginNoCorsDomains: null,
						httpsDomains: "arcgis.com arcgisonline.com esrikr.com premiumservices.blackbridge.com esripremium.accuweather.com gbm.digitalglobe.com firstlook.digitalglobe.com msi.digitalglobe.com".split(" "),
						interceptors: [],
						maxUrlLength: 2E3,
						priority: "high",
						proxyRules: [],
						proxyUrl: null,
						timeout: 6E4,
						trustedServers: [],
						useIdentity: !0
					},
					log: {
						interceptors: [],
						level: null
					}
				};
				globalThis.esriConfig && (c.deepMerge(b, globalThis.esriConfig, !0), delete b.has);
				b.assetsPath || (a = (new URL(a.uri, document.baseURI))
					.href, b.assetsPath = a.slice(0, a.lastIndexOf("esri/")), b.defaultAssetsPath = b.assetsPath);
				return b
			})
		},
		"esri/core/object": function() {
			define(["exports", "./lang"], function(a, b) {
				function c(d, k, v) {
					for (const m of d) {
						if (null ==
							v) return;
						if (!(m in v))
							if (k) v[m] = {};
							else return;
						v = v[m]
					}
					return v
				}

				function e(d, k, v) {
					return k ? Object.keys(k)
						.reduce((m, f) => {
							let g = m[f],
								l = k[f];
							if (g === l) return m;
							if (void 0 === g) return m[f] = b.clone(l), m;
							if (Array.isArray(l) || Array.isArray(m)) g = g ? Array.isArray(g) ? m[f] = g.concat() : m[f] = [g] : m[f] = [], l && (Array.isArray(l) || (l = [l]), v ? l.forEach(r => {
								g.includes(r) || g.push(r)
							}) : m[f] = l.concat());
							else if (l && "object" === typeof l) m[f] = e(g, l, v);
							else if (!m.hasOwnProperty(f) || k.hasOwnProperty(f)) m[f] = l;
							return m
						}, d || {}) : d
				}
				a.deepMerge =
					function(d, k, v = !1) {
						return e(d, k, v)
					};
				a.getDeepValue = function(d, k) {
					if (null != k) return k[d] || c(d.split("."), !1, k)
				};
				a.setDeepValue = function(d, k, v) {
					const m = d.split(".");
					d = m.pop();
					(v = c(m, !0, v)) && d && (v[d] = k)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/string": function() {
			define(["exports", "./object"], function(a, b) {
				function c(d) {
					return null == d ? "" : d
				}
				const e = /\{([^\}]+)\}/g;
				a.escapeRegExpString = function(d, k) {
					return d.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g,
						v => k && k.includes(v) ? v : `\\${v}`)
				};
				a.numericHash = function(d) {
					let k = 0;
					for (let v = 0; v < d.length; v++) k = (k << 5) - k + d.charCodeAt(v), k |= 0;
					return k
				};
				a.replace = function(d, k) {
					return d.replace(e, "object" === typeof k ? (v, m) => c(b.getDeepValue(m, k)) : (v, m) => c(k(m)))
				};
				a.stripHTML = function(d) {
					return (new DOMParser)
						.parseFromString(d || "", "text/html")
						.body.innerText || ""
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/interfaces": function() {
			define(["exports"],
				function(a) {
					a.Lifecycle = void 0;
					var b = a.Lifecycle || (a.Lifecycle = {});
					b[b.INITIALIZING = 0] = "INITIALIZING";
					b[b.CONSTRUCTING = 1] = "CONSTRUCTING";
					b[b.CONSTRUCTED = 2] = "CONSTRUCTED";
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/accessorSupport/Property": function() {
			define(["exports", "./PropertyOrigin", "./tracking", "./tracking/Flags", "./tracking/ObservationHandle"], function(a, b, c, e, d) {
				let k = function() {
					function v(f, g, l) {
						this.properties = f;
						this.propertyName =
							g;
						this.metadata = l;
						this._handles = this._accessed = this._observers = null;
						this.flags = e.Flags.Dirty | (l.nonNullable ? e.Flags.NonNullable : 0) | (l.hasOwnProperty("value") ? e.Flags.HasDefaultValue : 0) | (void 0 === l.get ? e.Flags.DepTrackingInitialized : 0) | (void 0 === l.dependsOn ? e.Flags.AutoTracked : 0)
					}
					var m = v.prototype;
					m.destroy = function() {
						if (this.flags & e.Flags.Dirty && this._observers) {
							const f = this._observers.slice();
							for (const g of f) g.onCommitted()
						}
						this._observers = this._accessed = null;
						this._clearObservationHandles()
					};
					m.getComputed =
						function() {
							c.trackAccess(this);
							var f = this.properties.store;
							const g = this.propertyName;
							var l = this.flags;
							const r = f.get(g);
							if (l & e.Flags.Computing || ~l & e.Flags.Dirty && f.has(g)) return r;
							this.flags |= e.Flags.Computing;
							const p = this.properties.host;
							l & e.Flags.AutoTracked ? l = c.runTracked(this, this.metadata.get, p) : (c.trackExplicitDependencies(p, this), l = this.metadata.get.call(p));
							f.set(g, l, b.OriginId.COMPUTED);
							f = f.get(g);
							f === r ? this.flags &= ~e.Flags.Dirty : c.runUntracked(this.commit, this);
							this.flags &= ~e.Flags.Computing;
							return f
						};
					m.onObservableAccessed = function(f) {
						f !== this && (null === this._accessed && (this._accessed = []), this._accessed.includes(f) || this._accessed.push(f))
					};
					m.onTrackingEnd = function() {
						this._clearObservationHandles();
						this.flags |= e.Flags.DepTrackingInitialized;
						const f = this._accessed;
						if (null !== f) {
							var g = this._handles;
							null === g && (g = this._handles = []);
							for (let l = 0; l < f.length; ++l) g.push(f[l].observe(this));
							f.length = 0
						}
					};
					m.observe = function(f) {
						null === this._observers && (this._observers = []);
						this._observers.includes(f) ||
							this._observers.push(f);
						return new d.ObservationHandle(this._observers, f)
					};
					m.notifyChange = function() {
						this.onInvalidated();
						this.onCommitted()
					};
					m.invalidate = function() {
						this.onInvalidated()
					};
					m.onInvalidated = function() {
						~this.flags & e.Flags.Overriden && (this.flags |= e.Flags.Dirty);
						const f = this._observers;
						if (null !== f)
							for (let g = 0; g < f.length; ++g) f[g].onInvalidated()
					};
					m.commit = function() {
						this.flags &= ~e.Flags.Dirty;
						this.onCommitted()
					};
					m.onCommitted = function() {
						if (null !== this._observers) {
							var f = this._observers.slice();
							for (let g = 0; g < f.length; ++g) f[g].onCommitted()
						}
					};
					m._clearObservationHandles = function() {
						const f = this._handles;
						if (null !== f) {
							for (let g = 0; g < f.length; ++g) f[g].remove();
							f.length = 0
						}
					};
					return v
				}();
				a.Property = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/PropertyOrigin": function() {
			define(["exports", "../maybe"], function(a, b) {
				function c(d) {
					switch (d) {
						case "defaults":
							return a.OriginId.DEFAULTS;
						case "service":
							return a.OriginId.SERVICE;
						case "portal-item":
							return a.OriginId.PORTAL_ITEM;
						case "web-scene":
							return a.OriginId.WEB_SCENE;
						case "web-map":
							return a.OriginId.WEB_MAP;
						case "user":
							return a.OriginId.USER;
						default:
							return null
					}
				}

				function e(d) {
					switch (d) {
						case a.OriginId.DEFAULTS:
							return "defaults";
						case a.OriginId.SERVICE:
							return "service";
						case a.OriginId.PORTAL_ITEM:
							return "portal-item";
						case a.OriginId.WEB_SCENE:
							return "web-scene";
						case a.OriginId.WEB_MAP:
							return "web-map";
						case a.OriginId.USER:
							return "user"
					}
					return b.assumeNonNull(void 0)
				}
				a.OriginId = void 0;
				(function(d) {
					d[d.DEFAULTS = 0] = "DEFAULTS";
					d[d.COMPUTED = 1] = "COMPUTED";
					d[d.SERVICE = 2] = "SERVICE";
					d[d.PORTAL_ITEM = 3] = "PORTAL_ITEM";
					d[d.WEB_SCENE = 4] = "WEB_SCENE";
					d[d.WEB_MAP = 5] = "WEB_MAP";
					d[d.USER = 6] = "USER"
				})(a.OriginId || (a.OriginId = {}));
				a.OriginIdNum = a.OriginId.USER + 1;
				a.idToName = e;
				a.idToReadableName = function(d) {
					return e(d)
				};
				a.idToWritableName = function(d) {
					return e(d)
				};
				a.nameToId = c;
				a.readableNameToId = function(d) {
					return c(d)
				};
				a.writableNameToId = function(d) {
					return c(d)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/tracking": function() {
			define(["exports", "../has", "../Logger", "./utils", "./tracking/Flags"], function(a, b, c, e, d) {
				function k(x) {
					t.onObservableAccessed(x)
				}

				function v(x, y, w) {
					if (h) return m(x, y, w);
					t = x;
					n.push(x);
					x = y.call(w);
					f();
					return x
				}

				function m(x, y, w) {
					const A = h;
					h = !0;
					t = x;
					n.push(x);
					x = null;
					try {
						x = y.call(w)
					} catch (B) {
						q && c.getLogger("esri.core.accessorSupport.tracking")
							.error(B)
					}
					f();
					h = A;
					return x
				}

				function f() {
					var x = n.length;
					if (1 < x) {
						const y = n.pop();
						t = n[x - 2];
						y.onTrackingEnd()
					} else 1 ===
						x ? (x = n.pop(), t = p, x.onTrackingEnd()) : t = p
				}

				function g(x, y) {
					if (!(y.flags & d.Flags.DepTrackingInitialized)) {
						var w = q;
						q = !1;
						y.flags & d.Flags.AutoTracked ? m(y, y.metadata.get, x) : l(x, y);
						q = w
					}
				}

				function l(x, y) {
					y.flags & d.Flags.ExplicitlyTracking || (y.flags |= d.Flags.ExplicitlyTracking, m(y, () => {
						var w = y.metadata.dependsOn || u;
						for (const A of w)
							if ("string" !== typeof A || A.includes(".")) {
								w = e.pathToArray(A);
								for (let B = 0, E = x; B < w.length && null != E && "object" === typeof E; ++B) E = r(E, w[B], B !== w.length - 1)
							} else r(x, A, !1)
					}), y.flags &= ~d.Flags.ExplicitlyTracking)
				}

				function r(x, y, w) {
					y = "?" === y[y.length - 1] ? y.slice(0, -1) : y;
					if (null != x.getItemAt || Array.isArray(x)) {
						var A = parseInt(y, 10);
						if (!isNaN(A)) return Array.isArray(x) ? x[A] : x.getItemAt(A)
					}
					if (A = e.getProperties(x) ? .properties.get(y)) k(A), g(x, A);
					return w ? x[y] : void 0
				}
				const p = {
						onObservableAccessed: () => {},
						onTrackingEnd: () => {}
					},
					n = [];
				let t = p,
					h = !1,
					q = !1;
				const u = [];
				a.initializeDependencyTracking = g;
				a.runTracked = v;
				a.runTrackedNoThrow = m;
				a.runUntracked = function(x, y) {
					return v(p, x, y)
				};
				a.trackAccess = k;
				a.trackExplicitDependencies =
					l;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/tracking/Flags": function() {
			define(["exports"], function(a) {
				a.Flags = void 0;
				var b = a.Flags || (a.Flags = {});
				b[b.Dirty = 1] = "Dirty";
				b[b.Overriden = 2] = "Overriden";
				b[b.Computing = 4] = "Computing";
				b[b.NonNullable = 8] = "NonNullable";
				b[b.HasDefaultValue = 16] = "HasDefaultValue";
				b[b.DepTrackingInitialized = 32] = "DepTrackingInitialized";
				b[b.AutoTracked = 64] = "AutoTracked";
				b[b.ExplicitlyTracking = 128] = "ExplicitlyTracking";
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/tracking/ObservationHandle": function() {
			define(["exports", "../../arrayUtils"], function(a, b) {
				let c = function() {
					function e(d, k) {
						this._observers = d;
						this._observer = k
					}
					e.prototype.remove = function() {
						b.remove(this._observers, this._observer)
					};
					return e
				}();
				a.ObservationHandle = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/Store": function() {
			define(["exports",
				"../lang", "./PropertyOrigin"
			], function(a, b, c) {
				let e = function() {
					function d() {
						this._values = new Map;
						this.multipleOriginsSupported = !1
					}
					var k = d.prototype;
					k.clone = function(v) {
						const m = new d;
						this._values.forEach((f, g) => {
							v && v.has(g) || m.set(g, b.clone(f))
						});
						return m
					};
					k.get = function(v) {
						return this._values.get(v)
					};
					k.originOf = function() {
						return c.OriginId.USER
					};
					k.keys = function() {
						return [...this._values.keys()]
					};
					k.set = function(v, m) {
						this._values.set(v, m)
					};
					k.delete = function(v) {
						this._values.delete(v)
					};
					k.has = function(v) {
						return this._values.has(v)
					};
					k.forEach = function(v) {
						this._values.forEach(v)
					};
					return d
				}();
				a.Store = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/set": function() {
			define(["exports", "../Error", "../has", "../Logger", "./get"], function(a, b, c, e, d) {
				function k(v, m, f) {
					if (v && m)
						if ("object" === typeof m)
							for (var g of Object.getOwnPropertyNames(m)) k(v, g, m[g]);
						else if (m.includes(".")) m = m.split("."), g = m.splice(m.length - 1, 1)[0], k(d.get(v, m), g, f);
					else {
						g = v.__accessor__;
						if (null !=
							g && c("esri-unknown-property-errors") && null == g.metadatas[m]) throw new b("set:unknown-property", "setting unknown property '" + m + "' on instance of " + g.host.declaredClass);
						v[m] = f
					}
				}
				a.set = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/Error": function() {
			define(["../chunks/_rollupPluginBabelHelpers", "./lang", "./Logger", "./Message"], function(a, b, c, e) {
				e = function(d) {
					function k(v, m, f) {
						var g = d.call(this, v, m, f) || this;
						return a._assertThisInitialized(g) instanceof
						k ? g : new k(v, m, f)
					}
					a._inheritsLoose(k, d);
					k.prototype.toJSON = function() {
						if (null != this.details) try {
							return {
								name: this.name,
								message: this.message,
								details: JSON.parse(JSON.stringify(this.details, (v, m) => {
									if (m && "object" === typeof m && "function" === typeof m.toJSON) return m;
									try {
										return b.clone(m)
									} catch (f) {
										return "[object]"
									}
								}))
							}
						} catch (v) {
							throw c.getLogger("esri.core.Error")
								.error(v), v;
						}
						return {
							name: this.name,
							message: this.message,
							details: this.details
						}
					};
					k.fromJSON = function(v) {
						return new k(v.name, v.message, v.details)
					};
					return k
				}(e);
				e.prototype.type = "error";
				return e
			})
		},
		"esri/core/Message": function() {
			define(["./object"], function(a) {
				function b(c, e) {
					return c.replace(/\$\{([^\s:\}]*)(?::([^\s:\}]+))?\}/g, (d, k) => {
						if ("" === k) return "$";
						d = a.getDeepValue(k, e);
						d = null == d ? "" : d;
						if ("undefined" === typeof d) throw Error(`could not find key "${k}" in template`);
						return d.toString()
					})
				}
				return function() {
					function c(e, d, k) {
						this.name = e;
						this.details = k;
						this instanceof c && (this.message = (d && b(d, k)) ? ? "")
					}
					c.prototype.toString = function() {
						return "[" + this.name +
							"]: " + this.message
					};
					return c
				}()
			})
		},
		"esri/core/accessorSupport/watch": function() {
			define("exports ../ArrayPool ../lang ../ReentrantObjectPool ../scheduling ../SetUtils ../uid ./get ./trackingUtils ./utils".split(" "), function(a, b, c, e, d, k, v, m, f, g) {
				function l(z) {
					A.delete(z);
					A.add(z);
					B || (B = d.schedule(p))
				}

				function r(z) {
					if (!z.removed) {
						var C = z.oldValue,
							D = z.getValue();
						z.equals(C, D) || (z.oldValue = D, z.notify(D, C))
					}
				}

				function p() {
					let z = 10;
					for (; B && z--;) {
						B = null;
						const C = n(),
							D = w.acquire();
						for (const J of C) {
							const K =
								J.uid;
							r(J);
							K === J.uid && J.removed && D.push(J)
						}
						for (const J of A) J.removed && (D.push(J), A.delete(J));
						for (const J of D) y.pool.release(J);
						w.release(D);
						w.release(C);
						E.forEach(J => J())
					}
				}

				function n() {
					const z = w.acquire();
					z.length = A.size;
					let C = 0;
					for (const D of A) z[C] = D, ++C;
					A.clear();
					return z
				}

				function t(z, C, D) {
					let J = g.parse(z, C, D, (K, H, G) => {
						let F, L, R = f.reactionDeferred(() => m.valueOf(K, H), (V, U) => {
							K.__accessor__.destroyed || F && F.uid !== L ? J.remove() : (F || (F = y.acquireUntracked(V, G, U, K, H), L = F.uid), l(F))
						});
						return {
							remove: g.once(() => {
								R.remove();
								F && (F.uid !== L || F.removed || (F.removed = !0, l(F)), F = null);
								J = R = null
							})
						}
					});
					return J
				}

				function h(z, C, D) {
					const J = g.parse(z, C, D, (K, H, G) => {
						let F = !1;
						return f.reaction(() => m.valueOf(K, H), (L, R) => {
							K.__accessor__.destroyed ? J.remove() : F || (F = !0, c.equals(R, L) || G.call(K, L, R, H, K), F = !1)
						})
					});
					return J
				}

				function q(z, C, D) {
					let J, K, H = f.reactionDeferred(z, (G, F) => {
						J && J.uid !== K ? H.remove() : (J || (J = y.acquireTracked(G, C, F, D), K = J.uid), l(J))
					});
					return {
						remove: g.once(() => {
							H.remove();
							J && (J.uid !== K || J.removed || (J.removed = !0, l(J)),
								J = null);
							H = null
						})
					}
				}

				function u(z, C, D) {
					let J = !1;
					return f.reaction(z, (K, H) => {
						J || (J = !0, D(H, K) || C(K, H), J = !1)
					})
				}
				var x;
				(function(z) {
					z[z.Untracked = 0] = "Untracked";
					z[z.Tracked = 1] = "Tracked"
				})(x || (x = {}));
				let y = function() {
					function z() {
						this.uid = v.generateUID();
						this.removed = !1;
						this.equals = this.path = this.target = this.getValue = this.callback = this.oldValue = this.type = null
					}
					z.acquireUntracked = function(D, J, K, H, G) {
						return this.pool.acquire(x.Untracked, D, J, K, H, G, c.equals)
					};
					z.acquireTracked = function(D, J, K, H) {
						return this.pool.acquire(x.Tracked,
							D, J, K, null, null, H)
					};
					var C = z.prototype;
					C.notify = function(D, J) {
						this.type === x.Untracked ? this.callback.call(this.target, D, J, this.path, this.target) : this.callback.call(null, D, J)
					};
					C.acquire = function(D, J, K, H, G, F, L) {
						this.uid = v.generateUID();
						this.removed = !1;
						this.type = D;
						this.oldValue = J;
						this.callback = K;
						this.getValue = H;
						this.target = G;
						this.path = F;
						this.equals = L
					};
					C.release = function() {
						this.target = this.path = this.oldValue = this.callback = this.getValue = null;
						this.uid = v.generateUID();
						this.removed = !0
					};
					return z
				}();
				y.pool = new e.ReentrantObjectPool(y);
				const w = new b,
					A = new Set;
				let B;
				const E = new Set;
				a.afterDispatch = function(z) {
					E.add(z);
					return {
						remove() {
							E.delete(z)
						}
					}
				};
				a.dispatch = p;
				a.isValueInUse = function(z) {
					return k.someSet(A, C => C.oldValue === z)
				};
				a.removeTarget = function(z) {
					for (const C of A.values()) C.target === z && (C.removed = !0)
				};
				a.watch = function(z, C, D, J = !1) {
					return !z.__accessor__ || z.__accessor__.destroyed ? {
						remove() {}
					} : J ? h(z, C, D) : t(z, C, D)
				};
				a.watchTracked = function(z, C, D = !1, J = c.equalsShallow) {
					return D ? u(z, C, J) : q(z, C, J)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/ReentrantObjectPool": function() {
			define(["exports", "../chunks/_rollupPluginBabelHelpers", "./maybe", "./ObjectPool"], function(a, b, c, e) {
				e = function(d) {
					function k() {
						var m = d.apply(this, arguments) || this;
						m._set = new Set;
						return m
					}
					b._inheritsLoose(k, d);
					var v = k.prototype;
					v.destroy = function() {
						d.prototype.destroy.call(this);
						this._set = c.nullifyNonNullableForDispose(this._set)
					};
					v.acquire = function(...m) {
						m = d.prototype.acquire.call(this, ...m);
						this._set.delete(m);
						return m
					};
					v.release = function(m) {
						m && !this._set.has(m) && (d.prototype.release.call(this, m), this._set.add(m))
					};
					v._dispose = function(m) {
						this._set.delete(m);
						d.prototype._dispose.call(this, m)
					};
					return k
				}(e);
				a.ReentrantObjectPool = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/scheduling": function() {
			define("exports ./maybe ./nextTick ./PerformanceSampler ./PooledArray ./promiseUtils ./time".split(" "), function(a, b, c, e, d, k, v) {
				function m(D) {
					D = new n(D);
					x.push(D);
					A.willDispatch || (A.willDispatch = !0, c.nextTick(r));
					return D
				}

				function f(D) {
					D = new p(D);
					y.push(D);
					null == B && (t = performance.now(), B = requestAnimationFrame(g));
					return new w(D)
				}

				function g() {
					const D = performance.now();
					B = null;
					B = 0 < y.length ? requestAnimationFrame(g) : null;
					A.executeFrameTasks(D)
				}

				function l() {
					y.forAll(D => {
						D.removed && E.push(D)
					});
					y.removeUnorderedMany(E.data, E.length);
					E.clear()
				}

				function r() {
					for (; x.length;) {
						const D = b.assumeNonNull(x.shift());
						D.isActive && D.callback()
					}
					A.willDispatch = !1
				}
				let p =
					function(D) {
						this.phases = D;
						this.paused = !1;
						this.ticks = -1;
						this.removed = !1
					},
					n = function() {
						function D(J) {
							this.callback = J;
							this.isActive = !0
						}
						D.prototype.remove = function() {
							this.isActive = !1
						};
						return D
					}(),
					t = 0,
					h = 0;
				const q = {
						time: v.Milliseconds(0),
						deltaTime: v.Milliseconds(0),
						elapsedFrameTime: v.Milliseconds(0),
						frameDuration: v.Milliseconds(0)
					},
					u = "prepare preRender render postRender update finish".split(" "),
					x = [],
					y = new d;
				let w = function() {
					function D(K) {
						this._task = K
					}
					var J = D.prototype;
					J.remove = function() {
						this._task.removed = !0
					};
					J.pause = function() {
						this._task.paused = !0
					};
					J.resume = function() {
						this._task.paused = !1
					};
					return D
				}();
				const A = {
					frameTasks: y,
					willDispatch: !1,
					clearFrameTasks: function(D = !1) {
						y.forAll(J => {
							J.removed = !0
						});
						D && l()
					},
					dispatch: r,
					executeFrameTasks: function(D) {
						const J = v.Milliseconds(D - t);
						t = D;
						const K = 0 < h ? h : 1E3 / 60,
							H = Math.max(0, J - K);
						for (let G = 0; G < u.length; G++) {
							const F = performance.now(),
								L = u[G];
							y.forAll(R => {
								R.paused || R.removed || (0 === G && R.ticks++, R.phases[L] && (q.time = D, q.deltaTime = 0 === R.ticks ? v.Milliseconds(0) : J, q.elapsedFrameTime =
									v.Milliseconds(performance.now() - D), q.frameDuration = v.Milliseconds(K - H), R.phases[L] ? .call(R, q)))
							});
							z[G].record(performance.now() - F)
						}
						l();
						C.record(performance.now() - D)
					}
				};
				let B = null;
				const E = new d,
					z = u.map(D => new e(D)),
					C = new e("total");
				a.FrameTaskHandle = w;
				a.addFrameTask = f;
				a.debug = A;
				a.performanceInfo = z;
				a.performanceTotal = C;
				a.schedule = m;
				a.setFrameDuration = function(D) {
					h = Math.max(0, D)
				};
				a.waitAnimationFrame = function() {
					const D = k.createResolver(),
						J = f({
							postRender: () => {
								J.remove();
								m(D)
							}
						});
					return D.promise
				};
				a.waitTicks =
					function(D = 1, J) {
						const K = k.createResolver(),
							H = () => {
								k.isAborted(J) ? K.reject(k.createAbortError()) : 0 === D ? K() : (--D, c.nextTick(() => H()))
							};
						H();
						return K.promise
					};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/nextTick": function() {
			define(["exports"], function(a) {
				const b = [];
				a.nextTick = function(c) {
					b.push(c);
					1 === b.length && queueMicrotask(() => {
						const e = b.slice();
						b.length = 0;
						for (const d of e) d()
					})
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/PerformanceSampler": function() {
			define(["../chunks/_rollupPluginBabelHelpers", "./maybe"], function(a, b) {
				return function() {
					function c(e, d = 30) {
						this.name = e;
						this._counter = 0;
						this._samples = Array(d)
					}
					c.prototype.record = function(e) {
						b.isSome(e) && (this._samples[++this._counter % this._samples.length] = e)
					};
					a._createClass(c, [{
						key: "median",
						get: function() {
							return this._samples.slice()
								.sort((e, d) => e - d)[Math.floor(this._samples.length / 2)]
						}
					}, {
						key: "average",
						get: function() {
							return this._samples.reduce((e, d) => e + d,
								0) / this._samples.length
						}
					}, {
						key: "last",
						get: function() {
							return this._samples[this._counter % this._samples.length]
						}
					}]);
					return c
				}()
			})
		},
		"esri/core/PooledArray": function() {
			define(["../chunks/_rollupPluginBabelHelpers", "./arrayUtils", "./HeapSort"], function(a, b, c) {
				function e(d) {
					d.data.length > 1.5 * d.length && (d.data.length = Math.floor(1.1 * d.length))
				}
				return function() {
					function d(v) {
						this.data = [];
						this._length = 0;
						this._allocator = void 0;
						this._deallocator = () => null;
						this._shrink = () => {};
						this._hint = new b.PositionHint;
						v &&
							(v.initialSize && (this.data = Array(v.initialSize)), v.allocator && (this._allocator = v.allocator), void 0 !== v.deallocator && (this._deallocator = v.deallocator), v.shrink && (this._shrink = () => e(this)))
					}
					var k = d.prototype;
					k.toArray = function() {
						return this.data.slice(0, this.length)
					};
					k.filter = function(v) {
						const m = [];
						for (let f = 0; f < this._length; f++) {
							const g = this.data[f];
							v(g) && m.push(g)
						}
						return m
					};
					k.getItemAt = function(v) {
						if (!(0 > v || v >= this._length)) return this.data[v]
					};
					k.includes = function(v, m) {
						v = this.data.indexOf(v, m);
						return -1 !==
							v && v < this.length
					};
					k.clear = function() {
						this.length = 0
					};
					k.prune = function() {
						this.clear();
						this.data = []
					};
					k.push = function(v) {
						this.data[this._length++] = v
					};
					k.pushArray = function(v, m = v.length) {
						for (let f = 0; f < m; f++) this.data[this._length++] = v[f]
					};
					k.fill = function(v, m) {
						for (let f = 0; f < m; f++) this.data[this._length++] = v
					};
					k.pushNew = function() {
						this._allocator && (this.data[this.length] = this._allocator(this.data[this.length]));
						const v = this.data[this._length];
						++this._length;
						return v
					};
					k.unshift = function(v) {
						this.data.unshift(v);
						this._length++;
						e(this)
					};
					k.pop = function() {
						if (0 !== this.length) {
							var v = this.data[this.length - 1];
							--this.length;
							this._shrink();
							return v
						}
					};
					k.remove = function(v) {
						const m = b.indexOf(this.data, v, this.length, this._hint);
						if (-1 !== m) return this.data.splice(m, 1), --this.length, v
					};
					k.removeUnordered = function(v) {
						return this.removeUnorderedIndex(b.indexOf(this.data, v, this.length, this._hint))
					};
					k.removeUnorderedIndex = function(v) {
						if (!(v >= this.length || 0 > v)) return this.swapElements(v, this.length - 1), this.pop()
					};
					k.removeUnorderedMany =
						function(v, m = v.length, f) {
							this.length = b.removeUnorderedMany(this.data, v, this.length, m, this._hint, f);
							this._shrink()
						};
					k.front = function() {
						if (0 !== this.length) return this.data[0]
					};
					k.back = function() {
						if (0 !== this.length) return this.data[this.length - 1]
					};
					k.swapElements = function(v, m) {
						if (!(v >= this.length || m >= this.length || v === m)) {
							var f = this.data[v];
							this.data[v] = this.data[m];
							this.data[m] = f
						}
					};
					k.sort = function(v) {
						c.sort(this.data, 0, this.length, v)
					};
					k.iterableSort = function(v) {
						return c.iterableSort(this.data, 0, this.length,
							v)
					};
					k.some = function(v, m) {
						for (let f = 0; f < this.length; ++f)
							if (v.call(m, this.data[f], f, this.data)) return !0;
						return !1
					};
					k.filterInPlace = function(v, m) {
						let f = 0;
						for (let g = 0; g < this._length; ++g) {
							const l = this.data[g];
							v.call(m, l, g, this.data) && (this.data[g] = this.data[f], this.data[f] = l, f++)
						}
						if (this._deallocator)
							for (v = f; v < this._length; v++) this.data[v] = this._deallocator(this.data[v]);
						this._length = f;
						this._shrink();
						return this
					};
					k.forAll = function(v, m) {
						const f = this.length,
							g = this.data;
						for (let l = 0; l < f; ++l) v.call(m, g[l], l,
							g)
					};
					k.forEach = function(v, m) {
						for (let f = 0; f < this.length; ++f) v.call(m, this.data[f], f, this.data)
					};
					k.map = function(v, m) {
						const f = Array(this.length);
						for (let g = 0; g < this.length; ++g) f[g] = v.call(m, this.data[g], g, this.data);
						return f
					};
					k.reduce = function(v, m) {
						for (let f = 0; f < this.length; ++f) m = v(m, this.data[f], f, this.data);
						return m
					};
					k.has = function(v) {
						const m = this.length,
							f = this.data;
						for (let g = 0; g < m; ++g)
							if (f[g] === v) return !0;
						return !1
					};
					a._createClass(d, [{
						key: "length",
						get: function() {
							return this._length
						},
						set: function(v) {
							if (v >
								this._length)
								if (this._allocator)
									for (; this._length < v;) this.data[this._length++] = this._allocator(this.data[this._length]);
								else this._length = v;
							else {
								if (this._deallocator)
									for (let m = v; m < this._length; ++m) this.data[m] = this._deallocator(this.data[m]);
								this._length = v;
								this._shrink()
							}
						}
					}]);
					return d
				}()
			})
		},
		"esri/core/HeapSort": function() {
			define(function() {
				var a;
				(function(b) {
					const c = (d, k, v, m) => {
							let f = k;
							const g = v >>> 1,
								l = d[f - 1];
							for (; k <= g;) {
								k = f << 1;
								k < v && 0 > m(d[k - 1], d[k]) && ++k;
								const r = d[k - 1];
								if (0 >= m(r, l)) break;
								d[f - 1] = r;
								f = k
							}
							d[f - 1] = l
						},
						e = (d, k) => d < k ? -1 : d > k ? 1 : 0;
					b.sort = function(d, k, v, m) {
						void 0 === k && (k = 0);
						void 0 === v && (v = d.length);
						void 0 === m && (m = e);
						for (var f = v >>> 1; f > k; f--) c(d, f, v, m);
						f = k + 1;
						for (--v; v > k; v--) {
							const g = d[k];
							d[k] = d[v];
							d[v] = g;
							c(d, f, v, m)
						}
					};
					b.iterableSort = function*(d, k, v, m) {
						void 0 === k && (k = 0);
						void 0 === v && (v = d.length);
						void 0 === m && (m = e);
						for (var f = v >>> 1; f > k; f--) c(d, f, v, m), yield;
						f = k + 1;
						for (--v; v > k; v--) {
							const g = d[k];
							d[k] = d[v];
							d[v] = g;
							c(d, f, v, m);
							yield
						}
					}
				})(a || (a = {}));
				return a
			})
		},
		"esri/core/promiseUtils": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ./clock ./deprecate ./Error ./events ./Logger ./maybe".split(" "),
				function(a, b, c, e, d, k, v, m) {
					function f() {
						f = b._asyncToGenerator(function*(C, D) {
							const J = C.slice(),
								K = yield Promise.all(C.map((H, G) => D(H, G)));
							return J.filter((H, G) => K[G])
						});
						return f.apply(this, arguments)
					}

					function g(C = "Aborted") {
						return new d("AbortError", C)
					}

					function l(C, D = "Aborted") {
						if (p(C)) throw g(D);
					}

					function r(C) {
						return m.isSome(C) ? "aborted" in C ? C : C.signal : C
					}

					function p(C) {
						C = r(C);
						return m.isSome(C) && C.aborted
					}

					function n(C, D) {
						C = r(C);
						if (!m.isNone(C))
							if (C.aborted) D();
							else return k.once(C, "abort", () => D())
					}

					function t(C) {
						return "AbortError" === C ? .name
					}

					function h() {
						h = b._asyncToGenerator(function*(C) {
							try {
								return yield C
							} catch (D) {
								if (!t(D)) throw D;
							}
						});
						return h.apply(this, arguments)
					}

					function q() {
						q = b._asyncToGenerator(function*(C, D = v.getLogger("esri")) {
							try {
								return yield C
							} catch (J) {
								t(J) || D.error(J)
							}
						});
						return q.apply(this, arguments)
					}

					function u() {
						let C = null;
						const D = new Promise((J, K) => {
							C = {
								promise: void 0,
								resolve: J,
								reject: K
							}
						});
						C.promise = D;
						return C
					}

					function x(C) {
						return y.apply(this, arguments)
					}

					function y() {
						y = b._asyncToGenerator(function*(C) {
							if (C) {
								if ("function" !==
									typeof C.forEach) {
									const D = Object.keys(C),
										J = D.map(G => C[G]),
										K = yield x(J), H = {};
									D.map((G, F) => H[G] = K[F]);
									return H
								}
								return new Promise(D => {
									const J = [];
									let K = C.length;
									0 === K && D(J);
									C.forEach(H => {
										const G = {
											promise: H || Promise.resolve(H)
										};
										J.push(G);
										G.promise.then(F => {
												G.value = F
											})
											.catch(F => {
												G.error = F
											})
											.then(() => {
												--K;
												0 === K && D(J)
											})
									})
								})
							}
						});
						return y.apply(this, arguments)
					}

					function w() {
						w = b._asyncToGenerator(function*(C) {
							return (yield x(C))
								.filter(D => !!D.value)
								.map(D => D.value)
						});
						return w.apply(this, arguments)
					}

					function A(C,
						D, J) {
						const K = new AbortController;
						n(J, () => K.abort());
						return new Promise((H, G) => {
							let F = setTimeout(() => {
								F = 0;
								H(D)
							}, C);
							n(K, () => {
								F && (clearTimeout(F), G(g()))
							})
						})
					}

					function B(C) {
						return C && "function" === typeof C.then
					}

					function E(C) {
						return B(C) ? C : Promise.resolve(C)
					}

					function z() {
						z = b._asyncToGenerator(function*(C) {
							yield Promise.resolve();
							l(C)
						});
						return z.apply(this, arguments)
					}
					a.after = A;
					a.always = function(C, D) {
						return C.then(D, D)
					};
					a.create = function(C) {
						e.deprecatedFunction(v.getLogger("esri.core.promiseUtils"), "create", {
							moduleName: "esri.core.promiseUtils",
							replacement: "new Promise()",
							version: "4.24"
						});
						return new Promise((D, J) => {
							try {
								C(D, J)
							} catch (K) {
								Promise.resolve()
									.then(() => J(K))
							}
						})
					};
					a.createAbortError = g;
					a.createDeferred = u;
					a.createResolver = function() {
						let C, D;
						const J = new Promise((H, G) => {
								C = H;
								D = G
							}),
							K = H => {
								C(H)
							};
						K.resolve = H => C(H);
						K.reject = H => D(H);
						K.timeout = (H, G) => c.clock.setTimeout(() => K.reject(G), H);
						K.promise = J;
						return K
					};
					a.debounce = function(C, D = -1) {
						let J, K, H, G, F = null;
						const L = (...R) => {
							if (J) {
								K = R;
								G && G.reject(g());
								G = u();
								R = m.assumeNonNull(G.promise);
								if (F) {
									var V = F;
									F = null;
									V.abort()
								}
								return R
							}
							H = G || u();
							G = null;
							if (0 < D) {
								const W = new AbortController,
									M = J = E(C(...R, W.signal));
								A(D)
									.then(() => {
										J === M && (G ? W.abort() : F = W)
									})
							} else J = 1, J = E(C(...R));
							R = () => {
								const W = K;
								K = H = J = F = null;
								null != W && L(...W)
							};
							V = J;
							const U = H;
							V.then(R, R);
							V.then(U.resolve, U.reject);
							return m.assumeNonNull(U.promise)
						};
						return L
					};
					a.eachAlways = x;
					a.eachAlwaysValues = function(C) {
						return w.apply(this, arguments)
					};
					a.filter = function(C, D) {
						return f.apply(this, arguments)
					};
					a.ignoreAbortErrors =
						function(C) {
							return h.apply(this, arguments)
						};
					a.isAbortError = t;
					a.isAborted = p;
					a.isPromiseLike = B;
					a.logOnError = function(C) {
						return q.apply(this, arguments)
					};
					a.onAbort = n;
					a.onAbortOrThrow = function(C, D) {
						C = r(C);
						if (!m.isNone(C)) return l(C), k.once(C, "abort", () => D(g()))
					};
					a.throwIfAbortError = function(C) {
						if (t(C)) throw C;
					};
					a.throwIfAborted = l;
					a.throwIfNotAbortError = function(C) {
						if (!t(C)) throw C;
					};
					a.timeout = function(C, D, J, K) {
						const H = J && "abort" in J ? J : null;
						null != K || H || (K = J);
						let G = setTimeout(() => {
							G = 0;
							H && H.abort()
						}, D);
						const F =
							() => K || new d("promiseUtils:timeout", "The wrapped promise did not resolve within " + D + " ms");
						return C.then(L => {
							if (0 === G) throw F();
							clearTimeout(G);
							return L
						}, L => {
							clearTimeout(G);
							throw 0 === G ? F() : L;
						})
					};
					a.waitTick = function(C) {
						return z.apply(this, arguments)
					};
					a.when = E;
					a.whenOrAbort = function(C, D) {
						const J = r(D);
						return m.isNone(J) ? C : new Promise((K, H) => {
							let G = n(D, () => H(g()));
							const F = () => G = m.removeMaybe(G);
							C.then(F, F);
							C.then(K, H)
						})
					};
					a.whenOrTimeout = function(C, D, J) {
						return Promise.race([C, A(D)
							.then(() => {
								throw new d("timeout",
									`Did not resolve within ${D} milliseconds (${J??"timeout"})`);
							})
						])
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/clock": function() {
			define(["exports"], function(a) {
				function b(e) {
					return {
						setTimeout: (d, k) => {
							const v = e.setTimeout(d, k);
							return {
								remove: () => e.clearTimeout(v)
							}
						}
					}
				}
				const c = b(globalThis);
				a.clock = c;
				a.wrap = b;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/deprecate": function() {
			define(["exports",
				"./has"
			], function(a, b) {
				function c(k, v, m = !1) {
					m && d.has(v) || (m && d.add(v), k.warn(`\ud83d\uded1 DEPRECATED - ${v}`))
				}

				function e(k, v, m = {}) {
					if (b("esri-deprecation-warnings")) {
						const {
							replacement: f,
							version: g,
							see: l,
							warnOnce: r
						} = m;
						f && (v += `\n\t\ud83d\udee0\ufe0f Replacement: ${f}`);
						g && (v += `\n\t\u2699\ufe0f Version: ${g}`);
						l && (v += `\n\t\ud83d\udd17 See ${l} for more details.`);
						c(k, v, r)
					}
				}
				const d = new Set;
				a.deprecated = e;
				a.deprecatedFunction = function(k, v, m = {}) {
					if (b("esri-deprecation-warnings")) {
						const {
							moduleName: f
						} =
						m;
						e(k, `Function: ${(f?f+"::":"")+v+"()"}`, m)
					}
				};
				a.deprecatedModule = function(k, v, m = {}) {
					b("esri-deprecation-warnings") && e(k, `Module: ${v}`, m)
				};
				a.deprecatedProperty = function(k, v, m = {}) {
					if (b("esri-deprecation-warnings")) {
						const {
							moduleName: f
						} = m;
						e(k, `Property: ${(f?f+"::":"")+v}`, m)
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/events": function() {
			define(["exports"], function(a) {
				function b(d) {
					return d && ("function" === typeof d.on || "function" === typeof d.addEventListener)
				}

				function c(d, k, v) {
					if (!b(d)) throw new TypeError("target is not a Evented or EventTarget object");
					if ("on" in d) return d.on(k, v);
					if (Array.isArray(k)) {
						const m = k.slice();
						for (const f of m) d.addEventListener(f, v);
						return {
							remove() {
								for (const f of m) d.removeEventListener(f, v)
							}
						}
					}
					d.addEventListener(k, v);
					return {
						remove() {
							d.removeEventListener(k, v)
						}
					}
				}
				const e = {
					Win: "Meta",
					Scroll: "ScrollLock",
					Spacebar: " ",
					Down: "ArrowDown",
					Left: "ArrowLeft",
					Right: "ArrowRight",
					Up: "ArrowUp",
					Del: "Delete",
					Apps: "ContextMenu",
					Esc: "Escape",
					Multiply: "*",
					Add: "+",
					Subtract: "-",
					Decimal: ".",
					Divide: "/"
				};
				a.eventKey = function({
					key: d
				}) {
					return e[d] || d
				};
				a.ieKeyNormalizationMap = e;
				a.isEventTarget = b;
				a.on = c;
				a.once = function(d, k, v) {
					if (!b(d)) throw new TypeError("target is not a Evented or EventTarget object");
					if ("once" in d) return d.once(k, v);
					const m = c(d, k, f => {
						m.remove();
						v.call(d, f)
					});
					return {
						remove() {
							m.remove()
						}
					}
				};
				a.pausable = function(d, k, v) {
					let m = !1;
					const f = c(d, k, g => {
						m || v.call(d, g)
					});
					return {
						resume() {
							m = !1
						},
						pause() {
							m = !0
						},
						remove() {
							f.remove()
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/time": function() {
			define(["exports"], function(a) {
				a.Milliseconds = function(b) {
					return b
				};
				a.Seconds = function(b) {
					return b
				};
				a.millisecondsFromSeconds = function(b) {
					return 1E3 * b
				};
				a.secondsFromMilliseconds = function(b) {
					return .001 * b
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/SetUtils": function() {
			define(["exports", "./maybe"], function(a, b) {
				a.someSet = function(c, e) {
					for (const d of c.entries())
						if (e(d[0])) return !0;
					return !1
				};
				a.union = function(c, e) {
					const d = new Set;
					b.isSome(c) && c.forEach(k => d.add(k));
					b.isSome(e) && e.forEach(k => d.add(k));
					return d
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/uid": function() {
			define(["exports"], function(a) {
				let b = 0;
				a.NullUID = 0;
				a.generateUID = function() {
					return ++b
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/trackingUtils": function() {
			define(["exports", "./tracking",
				"./tracking/SimpleTrackingTarget"
			], function(a, b, c) {
				let e = !1;
				const d = [];
				a.autorun = function(k) {
					function v() {
						if (m && !f)
							if (e) d.includes(v) || d.unshift(v);
							else
								for (m.clear(), f = e = !0, b.runTracked(m, k), e = f = !1; d.length;) d.pop()()
					}
					let m = new c.SimpleTrackingTarget(v),
						f = !1;
					f = !0;
					b.runTracked(m, k);
					f = !1;
					return {
						remove: function() {
							m && (m.destroy(), m = null)
						}
					}
				};
				a.reaction = function(k, v) {
					function m() {
						if (f && !l)
							if (e) d.includes(m) || d.unshift(m);
							else {
								var r = g;
								f.clear();
								l = e = !0;
								g = b.runTracked(f, k);
								e = l = !1;
								for (v(g, r); d.length;) d.pop()()
							}
					}
					let f = new c.SimpleTrackingTarget(m),
						g = null,
						l = !1;
					l = !0;
					g = b.runTracked(f, k);
					l = !1;
					return {
						remove: function() {
							f && (f.destroy(), g = f = null)
						}
					}
				};
				a.reactionDeferred = function(k, v) {
					function m() {
						if (!f) return null;
						f.clear();
						return g = b.runTracked(f, k)
					}
					let f = new c.SimpleTrackingTarget(function() {
							v(g, m)
						}),
						g = null;
					m();
					return {
						remove: function() {
							f && (f.destroy(), f = null);
							g = null
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/tracking/SimpleTrackingTarget": function() {
			define(["exports"],
				function(a) {
					let b = function() {
						function c(d) {
							this._notify = d;
							this._accessed = [];
							this._handles = [];
							this._invalidCount = 0
						}
						var e = c.prototype;
						e.destroy = function() {
							this._accessed.length = 0;
							this.clear()
						};
						e.onInvalidated = function() {
							this._invalidCount++
						};
						e.onCommitted = function() {
							const d = this._invalidCount;
							1 === d ? (this._invalidCount = 0, this._notify()) : this._invalidCount = 0 < d ? d - 1 : 0
						};
						e.onObservableAccessed = function(d) {
							this._accessed.includes(d) || this._accessed.push(d)
						};
						e.onTrackingEnd = function() {
							const d = this._handles,
								k = this._accessed;
							for (let v = 0; v < k.length; ++v) d.push(k[v].observe(this));
							k.length = 0
						};
						e.clear = function() {
							const d = this._handles;
							for (let k = 0; k < d.length; ++k) d[k].remove();
							d.length = 0
						};
						return c
					}();
					a.SimpleTrackingTarget = b;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/accessorSupport/decorators/property": function() {
			define("exports ../../Logger ../ensureType ../get ../metadata ../set".split(" "), function(a, b, c, e, d, k) {
				function v(f) {
					let g = 0;
					var l = f;
					if (c.isLongFormType(f)) return c.ensureLongFormType(f);
					for (; Array.isArray(l) && 1 === l.length && "string" !== typeof l[0] && "number" !== typeof l[0];) l = l[0], g++;
					return c.isOneOf(l) ? 0 === g ? c.ensureOneOf(l) : c.ensureNArrayTyped(c.ensureOneOf(l), g) : 1 === g ? c.ensureArray(l) : 1 < g ? c.ensureNArray(l, g) : f.from ? f.from : c.ensureType(f)
				}

				function m(f, g) {
					return l => {
						l = +f(l);
						null != g.step && (l = Math.round(l / g.step) * g.step);
						null != g.min && (l = Math.max(g.min, l));
						null != g.max && (l = Math.min(g.max, l));
						return l
					}
				}
				a.ensureRange = m;
				a.property = function(f = {}) {
					return (g, l) => {
						if (g === Function.prototype) throw Error(`Inappropriate use of @property() on a static field: ${g.name}.${l}. Accessor does not support static properties.`);
						var r = Object.getOwnPropertyDescriptor(g, l);
						const p = d.getOwnPropertyMetadata(g, l);
						r && (r.get || r.set ? (p.get = r.get || p.get, p.set = r.set || p.set) : "value" in r && ("value" in f && b.getLogger("esri.core.accessorSupport.decorators.property")
							.warn(`@property() will redefine the value of "${l}" on "${g.constructor.name}" already defined in the metadata`, f), p.value = f.value = r.value));
						null != f.readOnly && (p.readOnly = f.readOnly);
						if (g = f.aliasOf) {
							const n = "string" === typeof g ? g : g.source;
							g = "string" === typeof g ? null : !0 === g.overridable;
							let t;
							p.dependsOn = [n];
							p.get = function() {
								let h = e.get(this, n);
								if ("function" === typeof h) {
									t || (t = n.split(".")
										.slice(0, -1)
										.join("."));
									const q = e.get(this, t);
									q && (h = h.bind(q))
								}
								return h
							};
							p.readOnly || (p.set = g ? function(h) {
								this._override(l, h)
							} : function(h) {
								k.set(this, n, h)
							})
						}
						g = f.type;
						r = f.types;
						p.cast || (g ? p.cast = v(g) : r && (Array.isArray(r) ? p.cast = c.ensureArrayTyped(c.ensureOneOfType(r[0])) : p.cast = c.ensureOneOfType(r)));
						d.mergeProperty(p, f);
						f.range && (p.cast = m(p.cast, f.range))
					}
				};
				a.propertyJSONMeta = function(f, g, l) {
					f = d.getOwnPropertyMetadata(f,
						l);
					f.json || (f.json = {});
					f = f.json;
					void 0 !== g && (f.origins || (f.origins = {}), f.origins[g] || (f.origins[g] = {}), f = f.origins[g]);
					return f
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/ensureType": function() {
			define(["exports", "../has", "../Logger", "../MapUtils"], function(a, b, c, e) {
				function d(G) {
					return null == G ? G : new Date(G)
				}

				function k(G) {
					return null == G ? G : !!G
				}

				function v(G) {
					return null == G ? G : G.toString()
				}

				function m(G) {
					if (null == G) return G;
					G =
						parseFloat(G);
					return isNaN(G) ? 0 : G
				}

				function f(G) {
					return null == G ? G : Math.round(parseFloat(G))
				}

				function g(G) {
					return G && G.constructor && void 0 !== G.constructor.__accessorMetadata__
				}

				function l(G, F) {
					return null != F && G && !(F instanceof G)
				}

				function r(G) {
					return G && G.Type ? "function" === typeof G.Type ? G.Type : G.Type.base : null
				}

				function p(G, F) {
					var L;
					(L = !F || !F.constructor) || (L = F.constructor, L = !(L && "isCollection" in L));
					if (L) return n(G, F) ? F : new G(F);
					L = r(G.prototype.itemType);
					const R = r(F.constructor.prototype.itemType);
					if (!L) return F;
					if (!R) return new G(F);
					if (L === R) return F;
					if (L.prototype.isPrototypeOf(R.prototype)) return new G(F);
					n(G, F);
					return F
				}

				function n(G, F) {
					return g(F) ? (J.error("Accessor#set", "Assigning an instance of '" + (F.declaredClass || "unknown") + "' which is not a subclass of '" + h(G) + "'"), !0) : !1
				}

				function t(G, F) {
					return null == F ? F : G && "isCollection" in G ? p(G, F) : l(G, F) ? n(G, F) ? F : new G(F) : F
				}

				function h(G) {
					return G && G.prototype && G.prototype.declaredClass || "unknown"
				}

				function q(G) {
					switch (G) {
						case Number:
							return m;
						case H:
							return f;
						case Boolean:
							return k;
						case String:
							return v;
						case Date:
							return d;
						default:
							return e.getOrCreateMapValue(K, G, () => t.bind(null, G))
					}
				}

				function u(G, F) {
					const L = q(G);
					return 1 === arguments.length ? L : L(F)
				}

				function x(G, F, L) {
					return 1 === arguments.length ? x.bind(null, G) : F ? Array.isArray(F) ? F.map(R => G(R, L)) : [G(F, L)] : F
				}

				function y(G, F, L) {
					return 0 !== F && Array.isArray(L) ? L.map(R => y(G, F - 1, R)) : G(L)
				}

				function w(G, F, L) {
					if (2 === arguments.length) return w.bind(null, G, F);
					if (!L) return L;
					L = y(G, F, L);
					let R = F;
					for (var V = L; 0 < R && Array.isArray(V);) R--, V = V[0];
					if (void 0 !==
						V)
						for (V = 0; V < R; V++) L = [L];
					return L
				}

				function A(G, F) {
					if (2 === arguments.length) return A(G)
						.call(null, F);
					const L = new Set,
						R = G.filter(M => "function" !== typeof M),
						V = G.filter(M => "function" === typeof M);
					for (const M of G) "string" !== typeof M && "number" !== typeof M || L.add(M);
					let U = null,
						W = null;
					return (M, T) => {
						if (null == M) return M;
						const Z = typeof M,
							oa = "string" === Z || "number" === Z;
						if (oa && (L.has(M) || V.some(qa => "string" === Z && qa === String || "number" === Z && qa === Number)) || "object" === Z && V.some(qa => !l(M, qa))) return M;
						oa && R.length ? (U ||
							(U = R.map(qa => "string" === typeof qa ? `'${qa}'` : `${qa}`)
								.join(", ")), J.error("Accessor#set", `'${M}' is not a valid value for this property, only the following values are valid: ${U}`)) : "object" === typeof M && V.length ? (W || (W = V.map(qa => h(qa))
							.join(", ")), J.error("Accessor#set", `'${M}' is not a valid value for this property, value must be one of ${W}`)) : J.error("Accessor#set", `'${M}' is not a valid value for this property`);
						T && (T.valid = !1);
						return null
					}
				}

				function B(G, F) {
					if (2 === arguments.length) return B(G)
						.call(null,
							F);
					const L = {},
						R = [],
						V = [];
					for (const W in G.typeMap) {
						const M = G.typeMap[W];
						L[W] = u(M);
						R.push(h(M));
						V.push(W)
					}
					const U = "string" === typeof G.key ? W => W[G.key] : G.key;
					return W => {
						if (G.base && !l(G.base, W) || null == W) return W;
						var M = U(W) || G.defaultKeyValue;
						const T = L[M];
						if (!T) return J.error("Accessor#set", `Invalid property value, value needs to be one of ${`'${R.join("', '")}'`}, or a plain object that can autocast (having .type = ${`'${V.join("', '")}'`})`), null;
						if (!l(G.typeMap[M], W)) return W;
						if ("string" === typeof G.key &&
							!g(W)) {
							M = {};
							for (const Z in W) Z !== G.key && (M[Z] = W[Z]);
							return T(M)
						}
						return T(W)
					}
				}

				function E(G) {
					switch (G.type) {
						case "native":
							return u(G.value);
						case "array":
							return x(E(G.value));
						case "one-of":
							return z(G);
						default:
							return null
					}
				}

				function z(G) {
					let F = null;
					return (L, R) => {
						if (D(L, G)) return L;
						null == F && (F = C(G));
						J.error("Accessor#set", `Invalid property value, value needs to be of type ${F}`);
						R && (R.valid = !1);
						return null
					}
				}

				function C(G) {
					switch (G.type) {
						case "native":
							switch (G.value) {
								case Number:
									return "number";
								case String:
									return "string";
								case Boolean:
									return "boolean";
								case H:
									return "integer";
								case Date:
									return "date";
								default:
									return h(G.value)
							}
						case "array":
							return `array of ${C(G.value)}`;
						case "one-of":
							return G = G.values.map(F => C(F)), `one of ${G.slice(0,G.length-1)} or ${G[G.length-1]}`
					}
					return "unknown"
				}

				function D(G, F) {
					if (null == G) return !0;
					switch (F.type) {
						case "native":
							switch (F.value) {
								case Number:
								case H:
									return "number" === typeof G;
								case Boolean:
									return "boolean" === typeof G;
								case String:
									return "string" === typeof G
							}
							return G instanceof F.value;
						case "array":
							return Array.isArray(G) ?
								!G.some(L => !D(L, F.value)) : !1;
						case "one-of":
							return F.values.some(L => D(G, L))
					}
				}
				const J = c.getLogger("esri.core.accessorSupport.ensureTypes"),
					K = new WeakMap;
				let H = function() {};
				a.Integer = H;
				a.ensureArray = function(G, F) {
					return 1 === arguments.length ? x(u.bind(null, G)) : x(u.bind(null, G), F)
				};
				a.ensureArrayTyped = x;
				a.ensureBoolean = k;
				a.ensureClass = t;
				a.ensureDate = d;
				a.ensureInteger = f;
				a.ensureLongFormType = E;
				a.ensureNArray = function(G, F, L) {
					return 2 === arguments.length ? w(u.bind(null, G), F) : w(u.bind(null, G), F, L)
				};
				a.ensureNArrayTyped =
					w;
				a.ensureNumber = m;
				a.ensureOneOf = A;
				a.ensureOneOfType = B;
				a.ensureString = v;
				a.ensureType = u;
				a.isClassedType = g;
				a.isLongFormType = function(G) {
					if (!(G && "type" in G)) return !1;
					switch (G.type) {
						case "native":
						case "array":
						case "one-of":
							return !0
					}
					return !1
				};
				a.isOneOf = function(G) {
					return Array.isArray(G) ? !G.some(F => {
						F = typeof F;
						return !("string" === F || "number" === F || "function" === F && 1 < G.length)
					}) : !1
				};
				a.requiresType = l;
				a.types = {
					native(G) {
						return {
							type: "native",
							value: G
						}
					},
					array(G) {
						return {
							type: "array",
							value: G
						}
					},
					oneOf(G) {
						return {
							type: "one-of",
							values: G
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/MapUtils": function() {
			define(["exports"], function(a) {
				a.findInMap = function(b, c) {
					for (const [e, d] of b)
						if (c(d, e)) return d;
					return null
				};
				a.first = function(b) {
					b = b.values()
						.next();
					return !0 !== b.done ? b.value : null
				};
				a.getOrCreateMapValue = function(b, c, e) {
					const d = b.get(c);
					if (void 0 !== d) return d;
					e = e();
					b.set(c, e);
					return e
				};
				a.someMap = function(b, c) {
					for (const [e, d] of b)
						if (c(d, e)) return !0;
					return !1
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/decorators/subclass": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../has ../interfaces ../metadata ../tracking ../extensions/serializableProperty".split(" "), function(a, b, c, e, d, k, v) {
				function m(r, p) {
					return null == p.get ? function() {
						const n = this.__accessor__.properties.get(r);
						if (void 0 !== n) {
							k.trackAccess(n);
							var t = this.__accessor__.store;
							return t.has(r) ? t.get(r) : n.metadata.value
						}
					} : function() {
						const n =
							this.__accessor__.properties.get(r);
						if (void 0 !== n) return n.getComputed()
					}
				}

				function f(r) {
					const p = d.getOwnClassMetadata(r.prototype)
						.properties,
						n = {};
					for (const t of Object.getOwnPropertyNames(p)) {
						const h = p[t];
						v.processPrototypePropertyMetadata(h);
						n[t] = {
							enumerable: !0,
							configurable: !0,
							get: m(t, h),
							set(q) {
								const u = this.__accessor__;
								if (void 0 === u) Object.defineProperty(this, t, {
									enumerable: !0,
									configurable: !0,
									writable: !0,
									value: q
								});
								else if (!Object.isFrozen(this)) {
									if (u.initialized && h.readOnly) throw new TypeError(`[accessor] cannot assign to read-only property '${t}' of ${this.declaredClass}`);
									if (u.lifecycle === e.Lifecycle.CONSTRUCTED && h.constructOnly) throw new TypeError(`[accessor] cannot assign to construct-only property '${t}' of ${this.declaredClass}`);
									u.set(t, q)
								}
							}
						}
					}
					Object.defineProperties(r.prototype, n)
				}
				const g = new Set,
					l = new Set;
				a.finalizeClass = f;
				a.subclass = function(r) {
					return p => {
						p.prototype.declaredClass = r;
						f(p);
						const n = [],
							t = [];
						for (var h = p.prototype; h;) h.hasOwnProperty("initialize") && !g.has(h.initialize) && (g.add(h.initialize), n.push(h.initialize)), h.hasOwnProperty("destroy") && !l.has(h.destroy) &&
							(l.add(h.destroy), t.push(h.destroy)), h = Object.getPrototypeOf(h);
						g.clear();
						l.clear();
						h = function(q) {
							function u(...x) {
								var y = q.call(this, ...x) || this;
								if (y.constructor === u && "function" === typeof y.postscript) {
									n.length && Object.defineProperty(b._assertThisInitialized(y), "initialize", {
										enumerable: !1,
										configurable: !0,
										value() {
											for (let w = n.length - 1; 0 <= w; w--) n[w].call(this)
										}
									});
									if (t.length) {
										let w = !1;
										Object.defineProperty(b._assertThisInitialized(y), "destroy", {
											enumerable: !1,
											configurable: !0,
											value() {
												if (!w) {
													w = !0;
													for (let A =
														0; A < t.length; A++) t[A].call(this)
												}
											}
										})
									}
									y.postscript(...x)
								}
								return y
							}
							b._inheritsLoose(u, q);
							return u
						}(p);
						h.__accessorMetadata__ = d.getOwnClassMetadata(p.prototype);
						h.prototype.declaredClass = r;
						return h
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/extensions/serializableProperty": function() {
			define("exports ../ensureType ./serializableProperty/originAliases ./serializableProperty/reader ./serializableProperty/shorthands ./serializableProperty/writer".split(" "),
				function(a, b, c, e, d, k) {
					function v(g, l, r) {
						let p = g && g.json;
						g && g.json && g.json.origins && r && (g = r.origin && g.json.origins[r.origin]) && ("any" === l || l in g) && (p = g);
						return p
					}

					function m(g) {
						if (g.type) {
							var l = 0;
							for (g = g.type; Array.isArray(g) && !b.isOneOf(g);) g = g[0], l++;
							return {
								type: g,
								ndimArray: l
							}
						}
					}

					function f(g) {
						if (g.types) {
							var l = 0;
							for (g = g.types; Array.isArray(g);) g = g[0], l++;
							return {
								types: g,
								ndimArray: l
							}
						}
					}
					a.originSpecificPropertyDefinition = v;
					a.originSpecificReadPropertyDefinition = function(g, l) {
						return v(g, "read", l)
					};
					a.originSpecificWritePropertyDefinition =
						function(g, l) {
							return v(g, "write", l)
						};
					a.processPrototypePropertyMetadata = function(g) {
						if (d.process(g)) {
							c.process(g);
							var l = g.json.types ? f(g.json) : g.type ? m(g) : f(g);
							if (g.json.origins)
								for (const p in g.json.origins) {
									const n = g.json.origins[p];
									if (n.types) {
										var r = n;
										r = r.type ? m(r) : f(r)
									} else r = l;
									e.create(r, n, !1);
									n.types && !n.write && g.json.write && g.json.write.enabled && (n.write = {
										...g.json.write
									});
									k.create(r, n)
								}
							e.create(l, g.json, !0);
							k.create(l, g.json)
						}
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/accessorSupport/extensions/serializableProperty/originAliases": function() {
			define(["exports"], function(a) {
				a.process = function(b) {
					if (b.json && b.json.origins) {
						const c = b.json.origins;
						b = {
							"web-document": ["web-scene", "web-map"]
						};
						for (const e in b)
							if (c[e]) {
								const d = c[e];
								b[e].forEach(k => {
									c[k] = d
								});
								delete c[e]
							}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/extensions/serializableProperty/reader": function() {
			define("exports ../../../Logger ../../../object ../../../Warning ../../metadata ./type".split(" "),
				function(a, b, c, e, d, k) {
					function v(u) {
						var x = u.ndimArray ? ? 0;
						if (1 < x) return l(u);
						if (1 === x) return r(u);
						if ("type" in u && p(u.type)) {
							x = u.type.prototype ? .itemType ? .Type;
							const y = r("function" === typeof x ? {
								type: x
							} : {
								types: x
							});
							return (w, A, B) => (w = y(w, A, B)) ? new u.type(w) : w
						}
						return m(u)
					}

					function m(u) {
						return "type" in u ? f(u.type) : h(u.types)
					}

					function f(u) {
						return u.prototype.read ? (x, y, w) => {
							if (null == x) return x;
							y = typeof x;
							if ("object" !== y) q.error(`Expected JSON value of type 'object' to deserialize type '${u.prototype.declaredClass}', but got '${y}'`);
							else return y = new u, y.read(x, w), y
						} : u.fromJSON
					}

					function g(u, x, y, w) {
						return 0 !== w && Array.isArray(x) ? x.map(A => g(u, A, y, w - 1)) : u(x, void 0, y)
					}

					function l(u) {
						const x = m(u),
							y = g.bind(null, x),
							w = u.ndimArray ? ? 0;
						return (A, B, E) => {
							if (null == A) return A;
							A = y(A, E, w);
							B = w;
							for (E = A; 0 < B && Array.isArray(E);) B--, E = E[0];
							if (void 0 !== E)
								for (E = 0; E < B; E++) A = [A];
							return A
						}
					}

					function r(u) {
						const x = m(u);
						return (y, w, A) => {
							if (null == y) return y;
							if (Array.isArray(y)) {
								w = [];
								for (const B of y) y = x(B, void 0, A), void 0 !== y && w.push(y);
								return w
							}
							A = x(y, void 0, A);
							return void 0 !== A ? [A] : void 0
						}
					}

					function p(u) {
						return k.isCollection(u) ? (u = u.prototype.itemType) && u.Type ? "function" === typeof u.Type ? n(u.Type) : t(u.Type) : !1 : !1
					}

					function n(u) {
						return Array.isArray(u) ? !1 : !!u && u.prototype && ("read" in u.prototype || "fromJSON" in u || p(u))
					}

					function t(u) {
						for (const x in u.typeMap)
							if (!n(u.typeMap[x])) return !1;
						return !0
					}

					function h(u) {
						let x = null;
						const y = u.errorContext ? ? "type";
						return (w, A, B) => {
							if (null == w) return w;
							A = typeof w;
							if ("object" !== A) q.error(`Expected JSON value of type 'object' to deserialize, but got '${A}'`);
							else {
								if (!x) {
									A = {};
									for (var E in u.typeMap) {
										const D = u.typeMap[E];
										var z = d.getOwnClassMetadata(D.prototype);
										if ("function" === typeof u.key) continue;
										z = z.properties[u.key];
										if (!z) continue;
										z.json ? .type && Array.isArray(z.json.type) && 1 === z.json.type.length && "string" === typeof z.json.type[0] && (A[z.json.type[0]] = D);
										z = z.json ? .write;
										if (!z || !z.writer) {
											A[E] = D;
											continue
										}
										var C = z.target;
										C = "string" === typeof C ? C : u.key;
										const J = {};
										z.writer(E, J, C);
										J[C] && (A[J[C]] = D)
									}
									x = A
								}
								E = u.key;
								if ("string" === typeof E) {
									if (A = (E = w[E]) ? x[E] : u.defaultKeyValue ?
										u.typeMap[u.defaultKeyValue] : void 0) return E = new A, E.read(w, B), E;
									E = `Type '${E||"unknown"}' is not supported`;
									B && B.messages && w && B.messages.push(new e(`${y}:unsupported`, E, {
										definition: w,
										context: B
									}));
									q.error(E)
								}
							}
						}
					}
					const q = b.getLogger("esri.core.accessorSupport.extensions.serializableProperty.reader");
					a.create = function(u, x, y) {
						u && (y || x.read) && !x.read ? .reader && !1 !== x.read ? .enabled && (y = "types" in u ? t(u.types) : n(u.type), y && c.setDeepValue("read.reader", v(u), x))
					};
					a.createTypeReader = v;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/Warning": function() {
			define(["../chunks/_rollupPluginBabelHelpers", "./Message"], function(a, b) {
				b = function(c) {
					function e(d, k, v) {
						var m = c.call(this, d, k, v) || this;
						return a._assertThisInitialized(m) instanceof e ? m : new e(d, k, v)
					}
					a._inheritsLoose(e, c);
					return e
				}(b);
				b.prototype.type = "warning";
				return b
			})
		},
		"esri/core/accessorSupport/extensions/serializableProperty/type": function() {
			define(["exports"], function(a) {
				a.isCollection = function(b) {
					return !!b &&
						b.prototype && b.prototype.declaredClass && 0 === b.prototype.declaredClass.indexOf("esri.core.Collection")
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/extensions/serializableProperty/shorthands": function() {
			define(["exports"], function(a) {
				function b(d) {
					d.name && (d.read ? "object" === typeof d.read ? void 0 === d.read.source && (d.read.source = d.name) : d.read = {
							source: d.name
						} : d.read = {
							source: d.name
						}, d.write ? "object" === typeof d.write ? void 0 === d.write.target &&
						(d.write.target = d.name) : d.write = {
							target: d.name
						} : d.write = {
							target: d.name
						})
				}

				function c(d) {
					"boolean" === typeof d.read ? d.read = {
						enabled: d.read
					} : "function" === typeof d.read ? d.read = {
						enabled: !0,
						reader: d.read
					} : d.read && "object" === typeof d.read && void 0 === d.read.enabled && (d.read.enabled = !0)
				}

				function e(d) {
					"boolean" === typeof d.write ? d.write = {
						enabled: d.write
					} : "function" === typeof d.write ? d.write = {
						enabled: !0,
						writer: d.write
					} : d.write && "object" === typeof d.write && void 0 === d.write.enabled && (d.write.enabled = !0)
				}
				a.process =
					function(d) {
						d.json || (d.json = {});
						c(d.json);
						e(d.json);
						b(d.json);
						if (d.json.origins)
							for (const k in d.json.origins) c(d.json.origins[k]), e(d.json.origins[k]), b(d.json.origins[k]);
						return !0
					};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/extensions/serializableProperty/writer": function() {
			define(["exports", "../../../Error", "../../../Logger", "../../../object", "./type"], function(a, b, c, e, d) {
				function k(t) {
					return (h, q, u, x) => {
						if (!h || v(h, t, x)) return f(h,
							q, u, x)
					}
				}

				function v(t, h, q) {
					for (var u in h.typeMap)
						if (t instanceof h.typeMap[u]) return !0;
					q ? .messages && (u = h.errorContext ? ? "type", h = `Values of type '${("function"!==typeof h.key?t[h.key]:t.declaredClass)??"Unknown"}' cannot be written`, q && q.messages && t && q.messages.push(new b(`${u}:unsupported`, h, {
							definition: t,
							context: q
						})), c.getLogger("esri.core.accessorSupport.extensions.serializableProperty.writer")
						.error(h));
					return !1
				}

				function m(t) {
					return (h, q, u, x) => {
						if (!h || !Array.isArray(h)) return f(h, q, u, x);
						h = h.filter(y =>
							v(y, t, x));
						return f(h, q, u, x)
					}
				}

				function f(t, h, q, u) {
					e.setDeepValue(q, g(t, u), h)
				}

				function g(t, h) {
					return t && "function" === typeof t.write ? t.write({}, h) : t && "function" === typeof t.toJSON ? t.toJSON() : "number" === typeof t ? l(t) : t
				}

				function l(t) {
					return -Infinity === t ? -Number.MAX_VALUE : Infinity === t ? Number.MAX_VALUE : isNaN(t) ? null : t
				}

				function r(t, h, q, u) {
					null === t ? t = null : t && "function" === typeof t.map ? (t = t.map(x => g(x, u)), "function" === typeof t.toArray && (t = t.toArray())) : t = [g(t, u)];
					e.setDeepValue(q, t, h)
				}

				function p(t, h, q) {
					return 0 !==
						q && Array.isArray(t) ? t.map(u => p(u, h, q - 1)) : g(t, h)
				}

				function n(t) {
					return (h, q, u, x) => {
						if (null === h) h = null;
						else {
							h = p(h, x, t);
							x = t;
							for (var y = h; 0 < x && Array.isArray(y);) x--, y = y[0];
							if (void 0 !== y)
								for (y = 0; y < x; y++) h = [h]
						}
						e.setDeepValue(u, h, q)
					}
				}
				a.create = function(t, h) {
					if (h.write && !h.write.writer && (!1 !== h.write.enabled || h.write.overridePolicy)) {
						var q = t ? .ndimArray ? ? 0;
						t && (1 === q || "type" in t && d.isCollection(t.type)) ? h.write.writer = r : 1 < q ? h.write.writer = n(q) : h.types ? Array.isArray(h.types) ? h.write.writer = m(h.types[0]) : h.write.writer =
							k(h.types) : h.write.writer = f
					}
				};
				a.numberToJSON = l;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/ObservableChangesType": function() {
			define(["exports"], function(a) {
				a.ObservableChangesType = void 0;
				var b = a.ObservableChangesType || (a.ObservableChangesType = {});
				b[b.ADD = 1] = "ADD";
				b[b.REMOVE = 2] = "REMOVE";
				b[b.MOVE = 4] = "MOVE";
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/decorators/shared": function() {
			define(["exports"],
				function(a) {
					a.shared = function(b) {
						return (c, e) => {
							c[e] = b
						}
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/accessorSupport/tracking/SimpleObservable": function() {
			define(["exports", "./ObservationHandle"], function(a, b) {
				let c = function() {
					function e() {
						this._observers = []
					}
					var d = e.prototype;
					d.observe = function(k) {
						this._observers.includes(k) || this._observers.push(k);
						return new b.ObservationHandle(this._observers, k)
					};
					d.notify = function() {
						const k = this._observers.slice();
						for (let v = 0; v < k.length; ++v) {
							const m = k[v];
							m.onInvalidated();
							m.onCommitted()
						}
					};
					return e
				}();
				a.SimpleObservable = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/collectionUtils": function() {
			define(["exports", "./Collection"], function(a, b) {
				a.castForReferenceSetter = function(c) {
					return c
				};
				a.referenceSetter = function(c, e, d = b) {
					e || (e = new d);
					if (e === c) return e;
					e.removeAll();
					c && (Array.isArray(c) || "items" in c && Array.isArray(c.items)) ? e.addMany(c) : c && e.add(c);
					return e
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/JSONSupport": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Accessor ./maybe ./accessorSupport/DefaultsStore ./accessorSupport/defaultsStoreUtils ./accessorSupport/read ./accessorSupport/utils ./accessorSupport/write ./accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m, f, g, l) {
				const r = p => {
					p = function(n) {
						function t(...q) {
							q = n.call(this,
								...q) || this;
							const u = d.assumeNonNull(f.getProperties(b._assertThisInitialized(q))),
								x = u.store,
								y = new k.DefaultsStore;
							u.store = y;
							v.setupConstructedDefaults(u, x, y);
							return q
						}
						b._inheritsLoose(t, n);
						var h = t.prototype;
						h.read = function(q, u) {
							m.read(this, q, u)
						};
						h.write = function(q = {}, u) {
							return g.write(this, q, u)
						};
						h.toJSON = function(q) {
							return this.write({}, q)
						};
						t.fromJSON = function(q, u) {
							if (q) {
								if (q.declaredClass) throw Error("JSON object is already hydrated");
								var x = new this;
								x.read(q, u);
								q = x
							} else q = null;
							return q
						};
						return t
					}(p);
					p = c.__decorate([l.subclass("esri.core.JSONSupport")], p);
					p.prototype.toJSON.isDefaultToJSON = !0;
					return p
				};
				a.JSONSupport = function(p) {
					function n() {
						return p.apply(this, arguments) || this
					}
					b._inheritsLoose(n, p);
					return n
				}(r(e));
				a.JSONSupport = c.__decorate([l.subclass("esri.core.JSONSupport")], a.JSONSupport);
				a.JSONSupportMixin = r;
				a.isJSONSupport = function(p) {
					return p && "read" in p && "write" in p && "toJSON" in p
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/DefaultsStore": function() {
			define(["exports",
				"../lang", "./PropertyOrigin"
			], function(a, b, c) {
				let e = function() {
						function k() {
							this._values = new Map;
							this.multipleOriginsSupported = !1
						}
						var v = k.prototype;
						v.clone = function(m) {
							const f = new k;
							this._values.forEach((g, l) => {
								m && m.has(l) || f.set(l, b.clone(g.value), g.origin)
							});
							return f
						};
						v.get = function(m, f) {
							f = this._normalizeOrigin(f);
							m = this._values.get(m);
							return null == f || m ? .origin === f ? m ? .value : void 0
						};
						v.originOf = function(m) {
							return this._values.get(m) ? .origin ? ? c.OriginId.USER
						};
						v.keys = function(m) {
							m = this._normalizeOrigin(m);
							const f = [...this._values.keys()];
							return null == m ? f : f.filter(g => this._values.get(g) ? .origin === m)
						};
						v.set = function(m, f, g) {
							g = this._normalizeOrigin(g);
							if (g === c.OriginId.DEFAULTS) {
								const l = this._values.get(m);
								if (l && null != l.origin && l.origin > g) return
							}
							this._values.set(m, new d(f, g))
						};
						v.delete = function(m, f) {
							f = this._normalizeOrigin(f);
							null != f && this._values.get(m) ? .origin !== f || this._values.delete(m)
						};
						v.has = function(m, f) {
							f = this._normalizeOrigin(f);
							return null != f ? this._values.get(m) ? .origin === f : this._values.has(m)
						};
						v.forEach = function(m) {
							this._values.forEach(({
								value: f
							}, g) => m(f, g))
						};
						v._normalizeOrigin = function(m) {
							if (null != m) return m === c.OriginId.DEFAULTS ? m : c.OriginId.USER
						};
						return k
					}(),
					d = function(k, v) {
						this.value = k;
						this.origin = v
					};
				a.DefaultsStore = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/defaultsStoreUtils": function() {
			define(["exports", "./PropertyOrigin"], function(a, b) {
				a.setupConstructedDefaults = function(c, e, d) {
					e.keys()
						.forEach(k => {
							d.set(k,
								e.get(k), b.OriginId.DEFAULTS)
						});
					Object.keys(c.metadatas)
						.forEach(k => {
							c.internalGet(k) && d.set(k, c.internalGet(k), b.OriginId.DEFAULTS)
						})
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/read": function() {
			define(["exports", "./get", "./utils", "./extensions/serializableProperty"], function(a, b, c, e) {
				const d = {
					origin: "service"
				};
				a.read = function(k, v, m = d) {
					if (v && "object" === typeof v) {
						var f = c.getProperties(k),
							g = f.metadatas,
							l = {};
						for (const w of Object.getOwnPropertyNames(v)) {
							var r =
								l,
								p = g,
								n = w,
								t = v,
								h = m,
								q = e.originSpecificReadPropertyDefinition(p[n], h);
							q && (!q.read || !1 !== q.read.enabled && !q.read.source) && (r[n] = !0);
							for (const A of Object.getOwnPropertyNames(p)) {
								q = e.originSpecificReadPropertyDefinition(p[A], h);
								a: {
									var u = n;
									var x = t;
									if (q && q.read && !1 !== q.read.enabled && q.read.source) {
										q = q.read.source;
										if ("string" === typeof q) {
											if (q === u || q.includes(".") && 0 === q.indexOf(u) && b.exists(q, x)) {
												u = !0;
												break a
											}
										} else
											for (const B of q)
												if (B === u || B.includes(".") && 0 === B.indexOf(u) && b.exists(B, x)) {
													u = !0;
													break a
												} u = !1
									} else u = !1
								}
								u && (r[A] = !0)
							}
						}
						f.setDefaultOrigin(m.origin);
						for (var y of Object.getOwnPropertyNames(l)) p = (p = (r = e.originSpecificReadPropertyDefinition(g[y], m)
							.read) && r.source) && "string" === typeof p ? b.valueOf(v, p) : v[y], r && r.reader && (p = r.reader.call(k, p, v, m)), void 0 !== p && f.set(y, p);
						if (!m || !m.ignoreDefaults) {
							f.setDefaultOrigin("defaults");
							for (const w of Object.getOwnPropertyNames(g)) l[w] || (y = k, v = w, g = f, r = m, p = (p = e.originSpecificPropertyDefinition(g.metadatas[v], "any", r)) && p.default, void 0 !== p && (y = "function" ===
								typeof p ? p.call(y, v, r) : p, void 0 !== y && g.set(v, y)))
						}
						f.setDefaultOrigin("user")
					}
				};
				a.readLoadable = function(k, v, m, f = d) {
					v = {
						...f,
						messages: []
					};
					m(v);
					v.messages ? .forEach(g => {
						"warning" !== g.type || k.loaded ? f && f.messages && f.messages.push(g) : k.loadWarnings.push(g)
					})
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/write": function() {
			define("exports ../arrayUtils ../Error ../Logger ./PropertyOrigin ./utils ./extensions/serializableProperty".split(" "),
				function(a, b, c, e, d, k, v) {
					function m(g, l, r, p, n) {
						const t = {};
						l.write ? .writer ? .call(g, p, t, r, n);
						return t
					}

					function f(g, l, r, p, n, t) {
						if (!p || !p.write) return !1;
						const h = g.get(r);
						if (!n && p.write.overridePolicy) {
							var q = p.write.overridePolicy.call(g, h, r, t);
							void 0 !== q && (n = q)
						}
						n || (n = p.write);
						if (!n || !1 === n.enabled) return !1;
						if ((null === h && !n.allowNull && !n.writerEnsuresNonNull || void 0 === h) && n.isRequired) return (l = new c("web-document-write:property-required", `Missing value for required property '${r}' on '${g.declaredClass}'`, {
								propertyName: r,
								target: g
							}), t) && t.messages ? t.messages.push(l) : l && !t && e.getLogger("esri.core.accessorSupport.write")
							.error(l.name, l.message), !1;
						if (void 0 === h || null === h && !n.allowNull && !n.writerEnsuresNonNull) return !1;
						if (q = !l.store.multipleOriginsSupported || l.store.originOf(r) === d.OriginId.DEFAULTS) q = p.default, void 0 === q ? q = !1 : null != p.defaultEquals ? q = p.defaultEquals(h) : "function" === typeof q ? Array.isArray(h) ? (g = q.call(g, r, t), q = b.equals(g, h)) : q = !1 : q = q === h;
						return q || !n.ignoreOrigin && t && t.origin && l.store.multipleOriginsSupported &&
							l.store.originOf(r) < d.nameToId(t.origin) ? !1 : !0
					}
					a.willPropertyWrite = function(g, l, r, p) {
						const n = k.getProperties(g),
							t = v.originSpecificWritePropertyDefinition(n.metadatas[l], p);
						return t ? f(g, n, l, t, r, p) : !1
					};
					a.write = function(g, l, r) {
						if (g && "function" === typeof g.toJSON && (!g.toJSON.isDefaultToJSON || !g.write)) return k.merge(l, g.toJSON(r));
						const p = k.getProperties(g),
							n = p.metadatas;
						for (const t in n) {
							const h = v.originSpecificWritePropertyDefinition(n[t], r);
							if (!f(g, p, t, h, void 0, r)) continue;
							const q = g.get(t),
								u = m(g, h,
									h.write && "string" === typeof h.write.target ? h.write.target : t, q, r);
							0 < Object.keys(u)
								.length && (l = k.merge(l, u), r ? .resources ? .pendingOperations ? .length && Promise.all(r.resources.pendingOperations)
									.then(() => k.merge(l, u)), r && r.writtenProperties && r.writtenProperties.push({
										target: g,
										propName: t,
										oldOrigin: d.idToReadableName(p.store.originOf(t)),
										newOrigin: r.origin
									}))
						}
						return l
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/Loadable": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Error ./Promise ./promiseUtils ./Warning ./accessorSupport/decorators/property ./accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					const f = g => {
						g = function(l) {
							function r(...n) {
								var t = l.call(this, ...n) || this;
								t._loadController = null;
								t.loadError = null;
								t.loadStatus = "not-loaded";
								t._set("loadWarnings", []);
								t.addResolvingPromise(new Promise(h => {
									const q = t.load.bind(a._assertThisInitialized(t));
									t.load = u => {
										const x = new Promise((y, w) => {
											const A = d.onAbortOrThrow(u, w);
											t.destroyed && w(new c("load:instance-destroyed", `Instance of '${t.declaredClass||t.constructor.name}' is already destroyed`, {
												instance: a._assertThisInitialized(t)
											}));
											t._promiseProps.when(y, w)
												.finally(() => {
													A && A.remove()
												})
										});
										if ("not-loaded" === t.loadStatus) {
											t._set("loadStatus", "loading");
											const y = t._loadController = new AbortController;
											q({
												signal: y.signal
											});
											d.onAbort(y.signal, () => {
												t._promiseProps.abort()
											})
										}
										h();
										return x
									}
								}));
								t.when(() => {
									t._set("loadStatus", "loaded");
									t._loadController = null
								}, h => {
									t._set("loadStatus", "failed");
									t._set("loadError", h);
									t._loadController = null
								});
								return t
							}
							a._inheritsLoose(r, l);
							var p = r.prototype;
							p.load = function() {
								return null
							};
							p.cancelLoad = function() {
								if (this.isFulfilled()) return this;
								this._set("loadError", new c("load:cancelled", "Cancelled"));
								this._loadController ? .abort();
								return this
							};
							a._createClass(r, [{
								key: "loaded",
								get: function() {
									return "loaded" === this.loadStatus
								}
							}, {
								key: "loadWarnings",
								get: function() {
									return this._get("loadWarnings")
								}
							}]);
							return r
						}(g);
						b.__decorate([v.property({
							readOnly: !0
						})], g.prototype, "loaded", null);
						b.__decorate([v.property({
							readOnly: !0
						})], g.prototype, "loadError", void 0);
						b.__decorate([v.property({
							clonable: !1
						})], g.prototype, "loadStatus", void 0);
						b.__decorate([v.property({
							type: [k],
							readOnly: !0
						})], g.prototype, "loadWarnings", null);
						return g = b.__decorate([m.subclass("esri.core.Loadable")], g)
					};
					e = function(g) {
						function l() {
							return g.apply(this, arguments) || this
						}
						a._inheritsLoose(l, g);
						return l
					}(f(e.EsriPromise));
					e = b.__decorate([m.subclass("esri.core.Loadable")], e);
					(function(g) {
						g.LoadableMixin = f;
						g.isLoadable = function(l) {
							return !(!l || !l.load)
						}
					})(e || (e = {}));
					return e
				})
		},
		"esri/core/Promise": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Accessor ./maybe ./promiseUtils ./accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					(function(l) {
						l[l.PENDING = 0] = "PENDING";
						l[l.RESOLVED = 1] = "RESOLVED";
						l[l.REJECTED = 2] = "REJECTED"
					})(m || (m = {}));
					let f = function() {
						function l(p) {
							this.instance = p;
							this._resolver = k.createDeferred();
							this._status = m.PENDING;
							this._resolvingPromises = [];
							this._resolver.promise.then(() => {
								this._status = m.RESOLVED;
								this._cleanUp()
							}, () => {
								this._status = m.REJECTED;
								this._cleanUp()
							})
						}
						var r = l.prototype;
						r.addResolvingPromise = function(p) {
							this._resolvingPromises.push(p);
							this._tryResolve()
						};
						r.isResolved =
							function() {
								return this._status === m.RESOLVED
							};
						r.isRejected = function() {
							return this._status === m.REJECTED
						};
						r.isFulfilled = function() {
							return this._status !== m.PENDING
						};
						r.abort = function() {
							this._resolver.reject(k.createAbortError())
						};
						r.when = function(p, n) {
							return this._resolver.promise.then(p, n)
						};
						r._cleanUp = function() {
							this._allPromise = this._resolvingPromises = this._allPromise = null
						};
						r._tryResolve = function() {
							if (!this.isFulfilled()) {
								var p = k.createDeferred(),
									n = [...this._resolvingPromises, d.assumeNonNull(p.promise)],
									t = this._allPromise = Promise.all(n);
								t.then(() => {
									this.isFulfilled() || this._allPromise !== t || this._resolver.resolve(this.instance)
								}, h => {
									this.isFulfilled() || this._allPromise !== t || k.isAbortError(h) || this._resolver.reject(h)
								});
								p.resolve()
							}
						};
						return l
					}();
					const g = l => {
						l = function(r) {
							function p(...t) {
								t = r.call(this, ...t) || this;
								t._promiseProps = new f(b._assertThisInitialized(t));
								t.addResolvingPromise(Promise.resolve());
								return t
							}
							b._inheritsLoose(p, r);
							var n = p.prototype;
							n.isResolved = function() {
								return this._promiseProps.isResolved()
							};
							n.isRejected = function() {
								return this._promiseProps.isRejected()
							};
							n.isFulfilled = function() {
								return this._promiseProps.isFulfilled()
							};
							n.when = function(t, h) {
								return (new Promise((q, u) => {
										this._promiseProps.when(q, u)
									}))
									.then(t, h)
							};
							n.catch = function(t) {
								return this.when(null, t)
							};
							n.addResolvingPromise = function(t) {
								t && !this._promiseProps.isFulfilled() && this._promiseProps.addResolvingPromise("_promiseProps" in t ? t.when() : t)
							};
							return p
						}(l);
						return l = c.__decorate([v.subclass("esri.core.Promise")], l)
					};
					a.EsriPromise = function(l) {
						function r() {
							return l.apply(this,
								arguments) || this
						}
						b._inheritsLoose(r, l);
						return r
					}(g(e));
					a.EsriPromise = c.__decorate([v.subclass("esri.core.Promise")], a.EsriPromise);
					a.EsriPromiseMixin = g;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/loadAll": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ./asyncUtils ./Collection ./Loadable ./maybe".split(" "), function(a, b, c, e, d, k) {
				function v() {
					v = b._asyncToGenerator(function*(g, l) {
						yield g.load();
						return m(g, l)
					});
					return v.apply(this,
						arguments)
				}

				function m(g, l) {
					return f.apply(this, arguments)
				}

				function f() {
					f = b._asyncToGenerator(function*(g, l) {
						const r = [],
							p = (...t) => {
								for (const h of t) k.isNone(h) || (Array.isArray(h) ? p(...h) : e.isCollection(h) ? h.forEach(q => p(q)) : d.isLoadable(h) && r.push(h))
							};
						l(p);
						let n = null;
						yield c.map(r, function() {
							var t = b._asyncToGenerator(function*(h) {
								!1 !== (yield c.result("loadAll" in h && "function" === typeof h.loadAll ? h.loadAll() : h.load()))
									.ok || n || (n = h)
							});
							return function(h) {
								return t.apply(this, arguments)
							}
						}());
						if (n) throw n.loadError;
						return g
					});
					return f.apply(this, arguments)
				}
				a.loadAll = function(g, l) {
					return v.apply(this, arguments)
				};
				a.loadAllChildren = m;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/asyncUtils": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Accessor ./maybe ./promiseUtils ./accessorSupport/decorators/property ./arrayUtils ./accessorSupport/ensureType ./accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k,
				v, m, f, g) {
				function l() {
					l = b._asyncToGenerator(function*(x, y, w) {
						return (yield k.eachAlways(x.map((A, B) => y.apply(w, [A, B]))))
							.map(A => A.value)
					});
					return l.apply(this, arguments)
				}

				function r(x) {
					return {
						ok: !0,
						value: x
					}
				}

				function p(x) {
					return {
						ok: !1,
						error: x
					}
				}

				function n(x) {
					return d.isSome(x) && !0 === x.ok ? x.value : null
				}

				function t(x) {
					return d.isSome(x) && !1 === x.ok ? x.error : null
				}

				function h() {
					h = b._asyncToGenerator(function*(x) {
						if (d.isNone(x)) return {
							ok: !1,
							error: Error("no promise provided")
						};
						try {
							return r(yield x)
						} catch (y) {
							return p(y)
						}
					});
					return h.apply(this, arguments)
				}

				function q() {
					q = b._asyncToGenerator(function*(x) {
						try {
							return r(yield x)
						} catch (y) {
							return k.throwIfAbortError(y), p(y)
						}
					});
					return q.apply(this, arguments)
				}
				let u = function(x) {
					function y(A, B) {
						var E = x.call(this, {}) || this;
						E._result = null;
						E._abortHandle = null;
						E.abort = () => {
							E._abortController = d.abortMaybe(E._abortController)
						};
						E.remove = E.abort;
						E._abortController = new AbortController;
						const {
							signal: z
						} = E._abortController;
						E.promise = A(z);
						E.promise.then(C => {
							E._result = r(C);
							E._cleanup()
						}, C => {
							E._result =
								p(C);
							E._cleanup()
						});
						E._abortHandle = k.onAbort(B, E.abort);
						return E
					}
					b._inheritsLoose(y, x);
					var w = y.prototype;
					w.normalizeCtorArgs = function() {
						return {}
					};
					w.destroy = function() {
						this.abort()
					};
					w._cleanup = function() {
						this._abortHandle = d.removeMaybe(this._abortHandle);
						this._abortController = null
					};
					b._createClass(y, [{
						key: "value",
						get: function() {
							return n(this._result)
						}
					}, {
						key: "error",
						get: function() {
							return t(this._result)
						}
					}, {
						key: "finished",
						get: function() {
							return d.isSome(this._result)
						}
					}]);
					return y
				}(e);
				c.__decorate([v.property()],
					u.prototype, "value", null);
				c.__decorate([v.property()], u.prototype, "error", null);
				c.__decorate([v.property()], u.prototype, "finished", null);
				c.__decorate([v.property()], u.prototype, "promise", void 0);
				c.__decorate([v.property()], u.prototype, "_result", void 0);
				u = c.__decorate([g.subclass("esri.core.asyncUtils.ReactiveTask")], u);
				a.assertResult = function(x) {
					if (!0 === x.ok) return x.value;
					throw x.error;
				};
				a.createTask = function(x, y) {
					return new u(x, y)
				};
				a.forEach = function(x, y, w) {
					return k.eachAlways(x.map((A, B) => y.apply(w,
						[A, B])))
				};
				a.makeResultError = p;
				a.makeResultOk = r;
				a.map = function(x, y, w) {
					return l.apply(this, arguments)
				};
				a.result = function(x) {
					return h.apply(this, arguments)
				};
				a.resultError = t;
				a.resultOrAbort = function(x) {
					return q.apply(this, arguments)
				};
				a.resultValue = n;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/urlUtils": function() {
			define(["exports", "../config", "./Error", "./Logger", "./maybe"], function(a, b, c, e, d) {
				function k(P) {
					if (!P) return null;
					const ca = {
							path: null,
							query: null
						},
						ka = new sa(P),
						va = P.indexOf("?");
					null === ka.query ? ca.path = P : (ca.path = P.substring(0, va), ca.query = v(ka.query));
					ka.fragment && (ca.hash = ka.fragment, null === ka.query && (ca.path = ca.path.substring(0, ca.path.length - (ka.fragment.length + 1))));
					return ca
				}

				function v(P) {
					var ca = P.split("\x26");
					P = {};
					for (const va of ca) {
						if (!va) continue;
						var ka = va.indexOf("\x3d");
						0 > ka ? (ca = decodeURIComponent(va), ka = "") : (ca = decodeURIComponent(va.slice(0, ka)), ka = decodeURIComponent(va.slice(ka + 1)));
						let Ca = P[ca];
						"string" === typeof Ca &&
							(Ca = P[ca] = [Ca]);
						Array.isArray(Ca) ? Ca.push(ka) : P[ca] = ka
					}
					return P
				}

				function m(P) {
					return P && "object" === typeof P && "toJSON" in P && "function" === typeof P.toJSON
				}

				function f(P, ca) {
					return P ? ca && "function" === typeof ca ? Object.keys(P)
						.map(ka => encodeURIComponent(ka) + "\x3d" + encodeURIComponent(ca(ka, P[ka])))
						.join("\x26") : Object.keys(P)
						.map(ka => {
							const va = P[ka];
							if (null == va) return "";
							const Ca = encodeURIComponent(ka) + "\x3d";
							return (ka = ca && ca[ka]) ? Ca + encodeURIComponent(ka(va)) : Array.isArray(va) ? va.map(ma => m(ma) ? Ca + encodeURIComponent(JSON.stringify(ma)) :
									Ca + encodeURIComponent(ma))
								.join("\x26") : m(va) ? Ca + encodeURIComponent(JSON.stringify(va)) : Ca + encodeURIComponent(va)
						})
						.filter(ka => ka)
						.join("\x26") : ""
				}

				function g(P) {
					const ca = P.indexOf("?"); - 1 !== ca ? (S.path = P.slice(0, ca), S.query = P.slice(ca + 1)) : (S.path = P, S.query = null);
					return S
				}

				function l(P) {
					P = g(P)
						.path;
					P && "/" === P[P.length - 1] || (P = `${P}/`);
					P = R(P, !0);
					return P = P.toLowerCase()
				}

				function r(P) {
					const ca = M.proxyRules;
					P = l(P);
					for (let ka = 0; ka < ca.length; ka++)
						if (0 === P.indexOf(ca[ka].urlPrefix)) return ca[ka]
				}

				function p(P) {
					P =
						h(P);
					const ca = P.indexOf("/sharing");
					return 0 < ca ? P.substring(0, ca) : P.replace(/\/+$/, "")
				}

				function n(P, ca, ka = !1) {
					if (!P || !ca) return !1;
					P = U(P);
					ca = U(ca);
					return !ka && P.scheme !== ca.scheme || null == P.host || null == ca.host ? !1 : P.host.toLowerCase() === ca.host.toLowerCase() && P.port === ca.port
				}

				function t(P, ca = xa, ka) {
					if (D(P)) return ka && ka.preserveProtocolRelative ? P : "http" === ea.scheme && ea.authority === u(P)
						.slice(2) ? `http:${P}` : `https:${P}`;
					if (!J(P)) {
						ka = d.assumeNonNull;
						var va = q;
						if ("/" === P[0]) {
							var Ca = ca.indexOf("//");
							Ca = ca.indexOf("/",
								Ca + 2);
							ca = -1 === Ca ? ca : ca.slice(0, Ca)
						}
						return ka.call(d, va(ca, P))
					}
					return P
				}

				function h(P) {
					P = P.trim();
					P = t(P);
					if (/^https?:\/\//i.test(P)) {
						const ca = g(P);
						P = ca.path.replace(/\/{2,}/g, "/");
						P = P.replace("/", "//");
						ca.query && (P += `?${ca.query}`)
					}
					P = P.replace(/^(https?:\/\/)(arcgis\.com)/i, "$1www.$2");
					return P = V(P)
				}

				function q(...P) {
					var ca = P.filter(d.isSome);
					if (ca && ca.length) {
						P = [];
						if (x(ca[0])) {
							var ka = ca[0],
								va = ka.indexOf("//"); - 1 !== va && (P.push(ka.slice(0, va + 1)), G(ca[0]) && (P[0] += "/"), ca[0] = ka.slice(va + 2))
						} else "/" === ca[0][0] &&
							P.push("");
						ca = ca.reduce((Ca, ma) => ma ? Ca.concat(ma.split("/")) : Ca, []);
						for (ka = 0; ka < ca.length; ka++) va = ca[ka], ".." === va && 0 < P.length && ".." !== P[P.length - 1] ? P.pop() : (!va && ka === ca.length - 1 || va && ("." !== va || 0 === P.length)) && P.push(va);
						return P.join("/")
					}
				}

				function u(P, ca = !1) {
					if (null == P || y(P) || w(P)) return null;
					var ka = P.indexOf("://");
					if (-1 === ka && D(P)) ka = 2;
					else if (-1 !== ka) ka += 3;
					else return null;
					ka = P.indexOf("/", ka); - 1 !== ka && (P = P.slice(0, ka));
					ca && (P = R(P, !0));
					return P
				}

				function x(P) {
					return D(P) || J(P)
				}

				function y(P) {
					return null !=
						P && "blob:" === P.slice(0, 5)
				}

				function w(P) {
					return null != P && "data:" === P.slice(0, 5)
				}

				function A(P) {
					P = B(P);
					if (!P || !P.isBase64) return null;
					P = atob(P.data);
					const ca = new Uint8Array(P.length);
					for (let ka = 0; ka < P.length; ka++) ca[ka] = P.charCodeAt(ka);
					return ca.buffer
				}

				function B(P) {
					P = P.match(ba);
					if (!P) return null;
					const [, ca, ka, va] = P;
					return {
						mediaType: ca,
						isBase64: !!ka,
						data: va
					}
				}

				function E(P) {
					const ca = A(P);
					if (!ca) return null;
					P = B(P);
					return new Blob([ca], {
						type: P.mediaType
					})
				}

				function z(P, ca) {
					if (!P) return !1;
					const ka = document.createElement("a");
					if (!("download" in ka)) return !1;
					P = URL.createObjectURL(P);
					ka.download = ca;
					ka.href = P;
					ka.style.display = "none";
					document.body.appendChild(ka);
					ka.click();
					document.body.removeChild(ka);
					URL.revokeObjectURL(P);
					return !0
				}

				function C(P, ca) {
					return window.navigator.msSaveOrOpenBlob ? window.navigator.msSaveOrOpenBlob(P, ca) : !1
				}

				function D(P) {
					return null != P && "/" === P[0] && "/" === P[1]
				}

				function J(P) {
					return null != P && T.test(P)
				}

				function K(P) {
					return null != P && oa.test(P) || "https" === ea.scheme && D(P)
				}

				function H(P) {
					return null != P && Z.test(P) ||
						"http" === ea.scheme && D(P)
				}

				function G(P) {
					return null != P && qa.test(P)
				}

				function F(P) {
					return D(P) ? `https:${P}` : P.replace(Z, "https:")
				}

				function L() {
					return "https" === ea.scheme
				}

				function R(P, ca = !1) {
					if (D(P)) return P.slice(2);
					P = P.replace(T, "");
					ca && 1 < P.length && "/" === P[0] && "/" === P[1] && (P = P.slice(2));
					return P
				}

				function V(P) {
					const ca = M.httpsDomains;
					if (!H(P)) return P;
					const ka = P.indexOf("/", 7);
					let va;
					va = -1 === ka ? P : P.slice(0, ka);
					va = va.toLowerCase()
						.slice(7);
					if (Aa.test(va))
						if (va.endsWith(":80")) va = va.slice(0, -3), P = P.replace(":80",
							"");
						else return P;
					if ("http" === ea.scheme && va === ea.authority && !Ka.test(P)) return P;
					if (L() && va === ea.authority || ca && ca.some(Ca => va === Ca || va.endsWith(`.${Ca}`)) || L() && !r(P)) P = F(P);
					return P
				}

				function U(P) {
					if ("string" === typeof P) return new sa(t(P));
					P.scheme || (P.scheme = ea.scheme);
					return P
				}
				const W = e.getLogger("esri.core.urlUtils"),
					M = b.request,
					T = /^\s*[a-z][a-z0-9-+.]*:(?![0-9])/i,
					Z = /^\s*http:/i,
					oa = /^\s*https:/i,
					qa = /^\s*file:/i,
					Aa = /:\d+$/,
					Ka = /^https?:\/\/[^/]+\.arcgis.com\/sharing(\/|$)/i,
					da = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
					ja = RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$");
				let sa = function() {
					function P(ca = "") {
						this.uri = ca;
						this.port = this.host = this.password = this.user = this.fragment = this.query = this.path = this.authority = this.scheme = null;
						ca = d.assumeNonNull(this.uri.match(da));
						this.scheme = ca[2] || (ca[1] ? "" : null);
						this.authority = ca[4] || (ca[3] ? "" : null);
						this.path = ca[5];
						this.query = ca[7] || (ca[6] ? "" : null);
						this.fragment = ca[9] || (ca[8] ? "" : null);
						null != this.authority && (ca = d.assumeNonNull(this.authority.match(ja)),
							this.user = ca[3] || null, this.password = ca[4] || null, this.host = ca[6] || ca[7], this.port = ca[9] || null)
					}
					P.prototype.toString = function() {
						return this.uri
					};
					return P
				}();
				const I = {},
					N = new sa(b.applicationUrl);
				let ea = N;
				const pa = function() {
					var P = d.assumeNonNull(ea.path);
					P = P.substring(0, P.lastIndexOf(P.split("/")[P.split("/")
						.length - 1]));
					return `${`${ea.scheme}://${ea.host}${null!=ea.port?`:${ea.port}`:""}`}${P}`
				}();
				let xa = pa;
				const S = {
						path: "",
						query: ""
					},
					ba = /^data:(.*?)(;base64)?,(.*)$/,
					la = /([^.]*)\.([^\/]*)$/,
					ha = /(^data:image\/svg|\.svg$)/i;
				a.Url = sa;
				a.addProxy = function(P) {
					var ca = r(P),
						ka = void 0;
					if (ca) {
						var va = g(ca.proxyUrl);
						ka = va.path;
						va = va.query ? v(va.query) : null
					}
					ka && (ca = k(P), P = ka + "?" + ca.path, (ka = f({
						...va,
						...ca.query
					})) && (P = `${P}?${ka}`));
					return P
				};
				a.addProxyRule = function(P) {
					P = {
						proxyUrl: P.proxyUrl,
						urlPrefix: l(P.urlPrefix)
					};
					const ca = M.proxyRules,
						ka = P.urlPrefix;
					let va = ca.length;
					for (let Ca = 0; Ca < ca.length; Ca++) {
						const ma = ca[Ca].urlPrefix;
						if (0 === ka.indexOf(ma)) {
							if (ka.length === ma.length) return -1;
							va = Ca;
							break
						}
						0 === ma.indexOf(ka) && (va = Ca + 1)
					}
					ca.splice(va,
						0, P);
					return va
				};
				a.addQueryParameter = function(P, ca, ka) {
					P = k(P);
					const va = P.query || {};
					va[ca] = String(ka);
					return `${P.path}?${f(va)}`
				};
				a.addQueryParameters = function(P, ca) {
					P = k(P);
					const ka = P.query || {};
					for (const va in ca) ka[va] = ca[va];
					return (ca = f(ka)) ? `${P.path}?${ca}` : P.path
				};
				a.base64UrlEncode = function(P) {
					return btoa(String.fromCharCode.apply(null, P))
						.replace(/\+/g, "-")
						.replace(/\//g, "_")
						.replace(/=+$/, "")
				};
				a.changeDomain = function(P, ca, ka) {
					if (!(ca && ka && P && x(P))) return P;
					const va = P.indexOf("//");
					var Ca = P.indexOf("/",
						va + 2);
					const ma = P.indexOf(":", va + 2);
					Ca = Math.min(0 > Ca ? P.length : Ca, 0 > ma ? P.length : ma);
					if (P.slice(va + 2, Ca)
						.toLowerCase() !== ca.toLowerCase()) return P;
					ca = P.slice(0, va + 2);
					P = P.slice(Ca);
					return `${ca}${ka}${P}`
				};
				a.dataComponents = B;
				a.dataToArrayBuffer = A;
				a.dataToBlob = E;
				a.downloadBlobAsFile = function(P, ca) {
					z(P, ca) || C(P, ca)
				};
				a.downloadDataAsFile = function(P, ca) {
					var ka = (ka = E(P)) ? z(ka, ca) : !1;
					ka || (P = E(P)) && C(P, ca)
				};
				a.getAppBaseUrl = () => xa;
				a.getAppUrl = () => ea;
				a.getFilename = function(P, ca) {
					if (!P) return "";
					P = k(P)
						.path.replace(/\/+$/,
							"");
					P = P.substring(P.lastIndexOf("/") + 1);
					if (!ca ? .length) return P;
					ca = new RegExp(`.(${ca.join("|")})$`, "ig");
					return P.replace(ca, "")
				};
				a.getInterceptor = function(P) {
					const ca = va => null == va || va instanceof RegExp && va.test(P) || "string" === typeof va && P.startsWith(va),
						ka = M.interceptors;
					if (ka)
						for (const va of ka)
							if (Array.isArray(va.urls)) {
								if (va.urls.some(ca)) return va
							} else if (ca(va.urls)) return va;
					return null
				};
				a.getOrigin = u;
				a.getPathExtension = function(P) {
					return d.isNone(P) ? null : (P = P.match(la)) ? P[2] : null
				};
				a.getProxyRule =
					r;
				a.getProxyUrl = function(P = !1) {
					let ca, ka = M.proxyUrl;
					if ("string" === typeof P) {
						if (ca = K(P), P = r(P)) ka = P.proxyUrl
					} else ca = !!P;
					if (!ka) throw W.warn("esri/config: esriConfig.request.proxyUrl is not set."), new c("urlutils:proxy-not-set", "esri/config: esriConfig.request.proxyUrl is not set.");
					ca && L() && (ka = F(ka));
					return k(ka)
				};
				a.hasProtocol = J;
				a.hasSameOrigin = n;
				a.hasSamePortal = function(P, ca) {
					P = p(P);
					ca = p(ca);
					return R(P) === R(ca)
				};
				a.isAbsolute = x;
				a.isAppHTTPS = L;
				a.isBlobProtocol = y;
				a.isDataProtocol = w;
				a.isHTTPSProtocol =
					K;
				a.isProtocolRelative = D;
				a.isSVG = function(P) {
					return ha.test(P)
				};
				a.isTrustedServer = function(P) {
					if ("string" === typeof P)
						if (x(P)) P = U(P);
						else return !0;
					if (n(P, ea)) return !0;
					const ca = M.trustedServers || [];
					for (let va = 0; va < ca.length; va++) {
						var ka = ca[va];
						I[ka] || (J(ka) || D(ka) ? I[ka] = [new sa(t(ka))] : I[ka] = [new sa(`http://${ka}`), new sa(`https://${ka}`)]);
						ka = I[ka];
						for (let Ca = 0; Ca < ka.length; Ca++)
							if (n(P, ka[Ca])) return !0
					}
					return !1
				};
				a.join = q;
				a.makeAbsolute = t;
				a.makeData = function(P) {
					return P.isBase64 ? `data:${P.mediaType};base64,${P.data}` :
						`data:${P.mediaType},${P.data}`
				};
				a.makeRelative = function(P, ca = xa, ka) {
					if (null == P || !x(P)) return P;
					var va = h(P),
						Ca = va.toLowerCase();
					ca = h(ca)
						.toLowerCase()
						.replace(/\/+$/, "");
					if ((ka = ka ? h(ka)
						.toLowerCase()
						.replace(/\/+$/, "") : null) && 0 !== ca.indexOf(ka)) return P;
					const ma = (ta, Da, Ga) => {
						Ga = ta.indexOf(Da, Ga);
						return -1 === Ga ? ta.length : Ga
					};
					let Q = ma(Ca, "/", Ca.indexOf("//") + 2),
						aa = -1;
					for (; Ca.slice(0, Q + 1) === ca.slice(0, Q) + "/";) {
						aa = Q + 1;
						if (Q === Ca.length) break;
						Q = ma(Ca, "/", Q + 1)
					}
					if (-1 === aa || ka && aa < ka.length) return P;
					P = va.slice(aa);
					va = ca.slice(aa - 1)
						.replace(/[^/]+/g, "")
						.length;
					if (0 < va)
						for (Ca = 0; Ca < va; Ca++) P = `../${P}`;
					else P = `./${P}`;
					return P
				};
				a.normalize = h;
				a.objectToQuery = f;
				a.queryToObject = v;
				a.removeFile = function(P) {
					let ca = 0;
					if (x(P)) {
						var ka = P.indexOf("//"); - 1 !== ka && (ca = ka + 2)
					}
					ka = P.lastIndexOf("/");
					return ka < ca ? P : P.slice(0, ka + 1)
				};
				a.removeQueryParameter = function(P, ca) {
					const {
						path: ka,
						query: va
					} = k(P);
					if (!va) return P;
					delete va[ca];
					return (P = f(va)) ? `${ka}?${P}` : ka
				};
				a.removeQueryParameters = function(P, ca) {
					P = k(P);
					const ka = Object.keys(P.query || {});
					0 < ka.length && ca && ca.warn("removeQueryParameters()", `Url query parameters are not supported, the following parameters have been removed: ${ka.join(", ")}.`);
					return P.path
				};
				a.removeTrailingSlash = function(P) {
					return P.replace(/\/+$/, "")
				};
				a.splitPathExtension = function(P) {
					if (d.isNone(P)) return null;
					const ca = P.match(la);
					return ca ? {
						path: ca[1],
						extension: ca[2]
					} : {
						path: P,
						extension: null
					}
				};
				a.test = {
					setAppUrl: P => ea = P,
					setAppBaseUrl: P => xa = P,
					restoreUrls: () => {
						ea = N;
						xa = pa
					}
				};
				a.toHTTP = function(P) {
					return D(P) ? `http:${P}` :
						P.replace(oa, "http:")
				};
				a.toHTTPS = F;
				a.trustedServersUrlCache = I;
				a.urlToObject = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/decorators/writer": function() {
			define(["exports", "./property"], function(a, b) {
				a.writer = function(c, e, d) {
					let k, v;
					void 0 === e ? (v = c, k = [void 0]) : "string" !== typeof e ? (v = c, k = [void 0], d = e) : (v = e, k = Array.isArray(c) ? c : [c]);
					return (m, f) => {
						const g = m.constructor.prototype;
						for (const l of k) {
							const r = b.propertyJSONMeta(m, l,
								v);
							r.write && "object" === typeof r.write || (r.write = {});
							d && (r.write.target = d);
							r.write.writer = g[f]
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/SpatialReference": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/lang ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./support/spatialReferenceUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					c = g = function(l) {
						function r(n) {
							n = l.call(this, n) || this;
							n.latestWkid = null;
							n.wkid = null;
							n.wkt = null;
							n.vcsWkid = null;
							n.latestVcsWkid = null;
							n.imageCoordinateSystem = null;
							return n
						}
						a._inheritsLoose(r, l);
						r.fromJSON = function(n) {
							if (!n) return null;
							if (n.wkid) {
								if (102100 === n.wkid) return g.WebMercator;
								if (4326 === n.wkid) return g.WGS84
							}
							const t = new g;
							t.read(n);
							return t
						};
						var p = r.prototype;
						p.normalizeCtorArgs = function(n) {
							return n && "object" === typeof n ? n : {
								["string" === typeof n ? "wkt" : "wkid"]: n
							}
						};
						p.writeWkt = function(n, t) {
							this.wkid || (t.wkt = n)
						};
						p.clone = function() {
							if (this === g.WGS84) return g.WGS84;
							if (this === g.WebMercator) return g.WebMercator;
							const n = new g;
							null != this.wkid ? (n.wkid = this.wkid, null != this.latestWkid && (n.latestWkid = this.latestWkid), null != this.vcsWkid && (n.vcsWkid = this.vcsWkid), null != this.latestVcsWkid && (n.latestVcsWkid = this.latestVcsWkid)) : null != this.wkt && (n.wkt = this.wkt);
							this.imageCoordinateSystem && (n.imageCoordinateSystem = e.clone(this.imageCoordinateSystem));
							return n
						};
						p.equals = function(n) {
							if (null ==
								n) return !1;
							if (this.imageCoordinateSystem || n.imageCoordinateSystem) {
								if (null == this.imageCoordinateSystem || null == n.imageCoordinateSystem) return !1;
								const {
									id: t,
									referenceServiceName: h
								} = n.imageCoordinateSystem, {
									geodataXform: q
								} = n.imageCoordinateSystem, u = this.imageCoordinateSystem;
								return null == t || q ? JSON.stringify(u) === JSON.stringify(n.imageCoordinateSystem) : h ? u.id === t && u.referenceServiceName === h : u.id === t
							}
							return f.equals(this, n)
						};
						p.toJSON = function(n) {
							return this.write(void 0, n)
						};
						a._createClass(r, [{
							key: "isWGS84",
							get: function() {
								return f.isWGS84(this)
							}
						}, {
							key: "isWebMercator",
							get: function() {
								return f.isWebMercator(this)
							}
						}, {
							key: "isGeographic",
							get: function() {
								return f.isGeographic(this)
							}
						}, {
							key: "isWrappable",
							get: function() {
								return f.isWrappable(this)
							}
						}]);
						return r
					}(c.JSONSupport);
					c.GCS_NAD_1927 = null;
					c.WGS84 = null;
					c.WebMercator = null;
					c.PlateCarree = null;
					b.__decorate([k.property({
						readOnly: !0
					})], c.prototype, "isWGS84", null);
					b.__decorate([k.property({
						readOnly: !0
					})], c.prototype, "isWebMercator", null);
					b.__decorate([k.property({
							readOnly: !0
						})],
						c.prototype, "isGeographic", null);
					b.__decorate([k.property({
						readOnly: !0
					})], c.prototype, "isWrappable", null);
					b.__decorate([k.property({
						type: d.Integer,
						json: {
							write: !0
						}
					})], c.prototype, "latestWkid", void 0);
					b.__decorate([k.property({
						type: d.Integer,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: {
										overridePolicy() {
											return {
												isRequired: null === this.wkt ? !0 : !1
											}
										}
									}
								}
							}
						}
					})], c.prototype, "wkid", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							origins: {
								"web-scene": {
									write: {
										overridePolicy() {
											return {
												isRequired: null === this.wkid ?
													!0 : !1
											}
										}
									}
								}
							}
						}
					})], c.prototype, "wkt", void 0);
					b.__decorate([m.writer("wkt"), m.writer("web-scene", "wkt")], c.prototype, "writeWkt", null);
					b.__decorate([k.property({
						type: d.Integer,
						json: {
							write: !0
						}
					})], c.prototype, "vcsWkid", void 0);
					b.__decorate([k.property({
						type: d.Integer,
						json: {
							write: !0
						}
					})], c.prototype, "latestVcsWkid", void 0);
					b.__decorate([k.property()], c.prototype, "imageCoordinateSystem", void 0);
					c = g = b.__decorate([v.subclass("esri.geometry.SpatialReference")], c);
					c.prototype.toJSON.isDefaultToJSON = !0;
					c.GCS_NAD_1927 =
						new c({
							wkid: 4267,
							wkt: 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]'
						});
					c.WGS84 = new c(f.WGS84);
					c.WebMercator = new c(f.WebMercator);
					c.PlateCarree = new c(f.PlateCarree);
					Object.freeze && (Object.freeze(c.GCS_NAD_1927), Object.freeze(c.WGS84), Object.freeze(c.WebMercator));
					return c
				})
		},
		"esri/geometry/support/spatialReferenceUtils": function() {
			define(["exports", "../../core/maybe", "../../core/string",
				"./SupportedGCSWkids", "./WKIDUnitConversion"
			], function(a, b, c, e, d) {
				function k(q) {
					return l(q) && null != q.wkid && !0 === r[q.wkid]
				}

				function v(q) {
					return q === e.SupportedGCSWkids.GCSMARS2000 || q === e.SupportedGCSWkids.GCSMARS2000_SPHERE
				}

				function m(q) {
					return l(q) && null != q.wkid && v(q.wkid)
				}

				function f(q) {
					return q === e.SupportedGCSWkids.GCSMOON2000
				}

				function g(q) {
					return l(q) && null != q.wkid && f(q.wkid)
				}

				function l(q) {
					return b.isSome(q) && (null != q.wkid && 2E3 <= q.wkid || null != q.wkt)
				}
				const r = {
						102113: !0,
						102100: !0,
						3857: !0,
						3785: !0
					},
					p = {
						4326: !0,
						3785: !0,
						3857: !0,
						102113: !0,
						102100: !0,
						104905: !0,
						104971: !0
					},
					n = [-2.0037508342788905E7, 2.0037508342788905E7],
					t = [-2.0037508342787E7, 2.0037508342787E7],
					h = {
						102113: {
							wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]',
							valid: n,
							origin: t,
							dx: 1E-5
						},
						102100: {
							wkTemplate: 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]',
							valid: n,
							origin: t,
							dx: 1E-5
						},
						3785: {
							wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]',
							valid: n,
							origin: t,
							dx: 1E-5
						},
						3857: {
							wkTemplate: 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]',
							valid: n,
							origin: t,
							dx: 1E-5
						},
						4326: {
							wkTemplate: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",{Central_Meridian}],UNIT["Degree",0.0174532925199433]]',
							altTemplate: 'PROJCS["WGS_1984_Plate_Carree",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Plate_Carree"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],UNIT["Degrees",111319.491]]',
							valid: [-180, 180],
							origin: [-180, 90],
							dx: 1E-5
						},
						104971: {
							wkTemplate: 'GEOGCS["Mars_2000_(Sphere)",DATUM["Mars_2000_(Sphere)",SPHEROID["Mars_2000_(Sphere)",3396190.0,0.0]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]',
							valid: [-180, 180],
							origin: [-180, 90],
							dx: 1E-5
						},
						104905: {
							wkTemplate: 'GEOGCS["GCS_Mars_2000",DATUM["D_Mars_2000",SPHEROID["Mars_2000_IAU_IAG",3396190.0,169.8944472236118]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]',
							valid: [-180, 180],
							origin: [-180, 90],
							dx: 1E-5
						}
					};
				c = {
					wkid: 4326,
					wkt: c.replace(h[4326].wkTemplate, {
						Central_Meridian: "0.0"
					})
				};
				a.PlateCarree = {
					wkid: 32662
				};
				a.WGS84 = c;
				a.WebMercator = {
					wkid: 102100,
					latestWkid: 3857
				};
				a.equals = function(q, u) {
					return q === u ? !0 : b.isNone(q) || b.isNone(u) ? !1 : null != q.wkid || null != u.wkid ? q.wkid === u.wkid || k(q) && k(u) || null != u.latestWkid && q.wkid === u.latestWkid || null != q.latestWkid && u.wkid === q.latestWkid : q.wkt && u.wkt ? q.wkt.toUpperCase() === u.wkt.toUpperCase() : !1
				};
				a.getInfo = function(q) {
					return l(q) && q.wkid ? h[q.wkid] || null : null
				};
				a.isCGCS2000 =
					function(q) {
						return l(q) && q.wkid === e.SupportedGCSWkids.CGCS2000
					};
				a.isEarth = function(q) {
					return !(m(q) || g(q))
				};
				a.isGeographic = function(q) {
					return l(q) ? q.wkid ? null == d[q.wkid] : q.wkt ? !!/^\s*GEOGCS/i.test(q.wkt) : !1 : !1
				};
				a.isMars = m;
				a.isMoon = g;
				a.isPlateCarree = function(q) {
					return l(q) && 32662 === q.wkid
				};
				a.isValid = l;
				a.isWGS84 = function(q) {
					return l(q) && 4326 === q.wkid
				};
				a.isWKIDFromMars = v;
				a.isWKIDFromMoon = f;
				a.isWebMercator = k;
				a.isWrappable = function(q) {
					return l(q) && null != q.wkid && !0 === p[q.wkid]
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/SupportedGCSWkids": function() {
			define(["exports"], function(a) {
				a.SupportedGCSWkids = void 0;
				var b = a.SupportedGCSWkids || (a.SupportedGCSWkids = {});
				b[b.CGCS2000 = 4490] = "CGCS2000";
				b[b.GCSMARS2000 = 104971] = "GCSMARS2000";
				b[b.GCSMARS2000_SPHERE = 104905] = "GCSMARS2000_SPHERE";
				b[b.GCSMOON2000 = 104903] = "GCSMOON2000";
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/WKIDUnitConversion": function() {
			define(function() {
				let a;
				const b = {
					values: [1, .3048, .3048006096012192, .3047972654, .9143917962, .201166195164, .9143984146160287, .3047994715386762, 20.11676512155263, 20.11678249437587, .9143985307444408, .91439523, .3047997101815088, 20.1168, 20.116756, 5E4, 15E4],
					units: "Meter Foot Foot_US Foot_Clarke Yard_Clarke Link_Clarke Yard_Sears Foot_Sears Chain_Sears Chain_Benoit_1895_B Yard_Indian Yard_Indian_1937 Foot_Gold_Coast Chain Chain_Sears_1922_Truncated 50_Kilometers 150_Kilometers".split(" "),
					2066: 5,
					2136: 12,
					2155: 2,
					2157: 0,
					2158: 0,
					2159: 12,
					2160: 12,
					2204: 2,
					2219: 0,
					2220: 0,
					2254: 2,
					2255: 2,
					2256: 1,
					2265: 1,
					2266: 1,
					2267: 2,
					2268: 2,
					2269: 1,
					2270: 1,
					2271: 2,
					2272: 2,
					2273: 1,
					2294: 0,
					2295: 0,
					2314: 3,
					2899: 2,
					2900: 2,
					2901: 1,
					2909: 1,
					2910: 1,
					2911: 2,
					2912: 2,
					2913: 1,
					2914: 1,
					2992: 1,
					2993: 0,
					2994: 1,
					3080: 1,
					3089: 2,
					3090: 0,
					3091: 2,
					3102: 2,
					3141: 0,
					3142: 0,
					3167: 14,
					3359: 2,
					3360: 0,
					3361: 1,
					3362: 0,
					3363: 2,
					3364: 0,
					3365: 2,
					3366: 3,
					3404: 2,
					3405: 0,
					3406: 0,
					3407: 3,
					3439: 0,
					3440: 0,
					3479: 1,
					3480: 0,
					3481: 1,
					3482: 0,
					3483: 1,
					3484: 0,
					3485: 2,
					3486: 0,
					3487: 2,
					3488: 0,
					3489: 0,
					3490: 2,
					3491: 0,
					3492: 2,
					3493: 0,
					3494: 2,
					3495: 0,
					3496: 2,
					3497: 0,
					3498: 2,
					3499: 0,
					3500: 2,
					3501: 0,
					3502: 2,
					3503: 0,
					3504: 2,
					3505: 0,
					3506: 2,
					3507: 0,
					3508: 2,
					3509: 0,
					3510: 2,
					3511: 0,
					3512: 2,
					3513: 0,
					3514: 0,
					3515: 2,
					3516: 0,
					3517: 2,
					3518: 0,
					3519: 2,
					3520: 0,
					3521: 2,
					3522: 0,
					3523: 2,
					3524: 0,
					3525: 2,
					3526: 0,
					3527: 2,
					3528: 0,
					3529: 2,
					3530: 0,
					3531: 2,
					3532: 0,
					3533: 2,
					3534: 0,
					3535: 2,
					3536: 0,
					3537: 2,
					3538: 0,
					3539: 2,
					3540: 0,
					3541: 2,
					3542: 0,
					3543: 2,
					3544: 0,
					3545: 2,
					3546: 0,
					3547: 2,
					3548: 0,
					3549: 2,
					3550: 0,
					3551: 2,
					3552: 0,
					3553: 2,
					3582: 2,
					3583: 0,
					3584: 2,
					3585: 0,
					3586: 2,
					3587: 0,
					3588: 1,
					3589: 0,
					3590: 1,
					3591: 0,
					3592: 0,
					3593: 1,
					3598: 2,
					3599: 0,
					3600: 2,
					3605: 1,
					3606: 0,
					3607: 0,
					3608: 2,
					3609: 0,
					3610: 2,
					3611: 0,
					3612: 2,
					3613: 0,
					3614: 2,
					3615: 0,
					3616: 2,
					3617: 0,
					3618: 2,
					3619: 0,
					3620: 2,
					3621: 0,
					3622: 2,
					3623: 0,
					3624: 2,
					3625: 0,
					3626: 2,
					3627: 0,
					3628: 2,
					3629: 0,
					3630: 2,
					3631: 0,
					3632: 2,
					3633: 0,
					3634: 1,
					3635: 0,
					3636: 1,
					3640: 2,
					3641: 0,
					3642: 2,
					3643: 0,
					3644: 1,
					3645: 0,
					3646: 1,
					3647: 0,
					3648: 1,
					3649: 0,
					3650: 2,
					3651: 0,
					3652: 2,
					3653: 0,
					3654: 2,
					3655: 0,
					3656: 1,
					3657: 0,
					3658: 2,
					3659: 0,
					3660: 2,
					3661: 0,
					3662: 2,
					3663: 0,
					3664: 2,
					3668: 2,
					3669: 0,
					3670: 2,
					3671: 0,
					3672: 2,
					3673: 0,
					3674: 2,
					3675: 0,
					3676: 1,
					3677: 2,
					3678: 0,
					3679: 1,
					3680: 2,
					3681: 0,
					3682: 1,
					3683: 2,
					3684: 0,
					3685: 0,
					3686: 2,
					3687: 0,
					3688: 2,
					3689: 0,
					3690: 2,
					3691: 0,
					3692: 2,
					3696: 2,
					3697: 0,
					3698: 2,
					3699: 0,
					3700: 2,
					3793: 0,
					3794: 0,
					3812: 0,
					3854: 0,
					3857: 0,
					3920: 0,
					3978: 0,
					3979: 0,
					3991: 2,
					3992: 2,
					4026: 0,
					4037: 0,
					4038: 0,
					4071: 0,
					4082: 0,
					4083: 0,
					4087: 0,
					4088: 0,
					4217: 2,
					4414: 0,
					4415: 0,
					4417: 0,
					4434: 0,
					4437: 0,
					4438: 2,
					4439: 2,
					4462: 0,
					4467: 0,
					4471: 0,
					4474: 0,
					4559: 0,
					4647: 0,
					4822: 0,
					4826: 0,
					4839: 0,
					5018: 0,
					5048: 0,
					5167: 0,
					5168: 0,
					5221: 0,
					5223: 0,
					5234: 0,
					5235: 0,
					5243: 0,
					5247: 0,
					5266: 0,
					5316: 0,
					5320: 0,
					5321: 0,
					5325: 0,
					5337: 0,
					5361: 0,
					5362: 0,
					5367: 0,
					5382: 0,
					5383: 0,
					5396: 0,
					5456: 0,
					5457: 0,
					5469: 0,
					5472: 4,
					5490: 0,
					5513: 0,
					5514: 0,
					5523: 0,
					5559: 0,
					5588: 1,
					5589: 3,
					5596: 0,
					5627: 0,
					5629: 0,
					5641: 0,
					5643: 0,
					5644: 0,
					5646: 2,
					5654: 2,
					5655: 2,
					5659: 0,
					5700: 0,
					5825: 0,
					5836: 0,
					5837: 0,
					5839: 0,
					5842: 0,
					5844: 0,
					5858: 0,
					5879: 0,
					5880: 0,
					5887: 0,
					5890: 0,
					6128: 1,
					6129: 1,
					6141: 1,
					6204: 0,
					6210: 0,
					6211: 0,
					6307: 0,
					6312: 0,
					6316: 0,
					6362: 0,
					6391: 1,
					6405: 1,
					6406: 0,
					6407: 1,
					6408: 0,
					6409: 1,
					6410: 0,
					6411: 2,
					6412: 0,
					6413: 2,
					6414: 0,
					6415: 0,
					6416: 2,
					6417: 0,
					6418: 2,
					6419: 0,
					6420: 2,
					6421: 0,
					6422: 2,
					6423: 0,
					6424: 2,
					6425: 0,
					6426: 2,
					6427: 0,
					6428: 2,
					6429: 0,
					6430: 2,
					6431: 0,
					6432: 2,
					6433: 0,
					6434: 2,
					6435: 0,
					6436: 2,
					6437: 0,
					6438: 2,
					6439: 0,
					6440: 0,
					6441: 2,
					6442: 0,
					6443: 2,
					6444: 0,
					6445: 2,
					6446: 0,
					6447: 2,
					6448: 0,
					6449: 2,
					6450: 0,
					6451: 2,
					6452: 0,
					6453: 2,
					6454: 0,
					6455: 2,
					6456: 0,
					6457: 2,
					6458: 0,
					6459: 2,
					6460: 0,
					6461: 2,
					6462: 0,
					6463: 2,
					6464: 0,
					6465: 2,
					6466: 0,
					6467: 2,
					6468: 0,
					6469: 2,
					6470: 0,
					6471: 2,
					6472: 0,
					6473: 2,
					6474: 0,
					6475: 2,
					6476: 0,
					6477: 2,
					6478: 0,
					6479: 2,
					6484: 2,
					6485: 0,
					6486: 2,
					6487: 0,
					6488: 2,
					6489: 0,
					6490: 2,
					6491: 0,
					6492: 2,
					6493: 0,
					6494: 1,
					6495: 0,
					6496: 1,
					6497: 0,
					6498: 0,
					6499: 1,
					6500: 0,
					6501: 2,
					6502: 0,
					6503: 2,
					6504: 0,
					6505: 2,
					6506: 0,
					6507: 2,
					6508: 0,
					6509: 0,
					6510: 2,
					6515: 1,
					6516: 0,
					6518: 0,
					6519: 2,
					6520: 0,
					6521: 2,
					6522: 0,
					6523: 2,
					6524: 0,
					6525: 2,
					6526: 0,
					6527: 2,
					6528: 0,
					6529: 2,
					6530: 0,
					6531: 2,
					6532: 0,
					6533: 2,
					6534: 0,
					6535: 2,
					6536: 0,
					6537: 2,
					6538: 0,
					6539: 2,
					6540: 0,
					6541: 2,
					6542: 0,
					6543: 2,
					6544: 0,
					6545: 1,
					6546: 0,
					6547: 1,
					6548: 0,
					6549: 2,
					6550: 0,
					6551: 2,
					6552: 0,
					6553: 2,
					6554: 0,
					6555: 2,
					6556: 0,
					6557: 1,
					6558: 0,
					6559: 1,
					6560: 0,
					6561: 1,
					6562: 0,
					6563: 2,
					6564: 0,
					6565: 2,
					6566: 0,
					6567: 0,
					6568: 2,
					6569: 0,
					6570: 1,
					6571: 0,
					6572: 2,
					6573: 0,
					6574: 2,
					6575: 0,
					6576: 2,
					6577: 0,
					6578: 2,
					6582: 2,
					6583: 0,
					6584: 2,
					6585: 0,
					6586: 2,
					6587: 0,
					6588: 2,
					6589: 0,
					6590: 2,
					6591: 0,
					6592: 0,
					6593: 2,
					6594: 0,
					6595: 2,
					6596: 0,
					6597: 2,
					6598: 0,
					6599: 2,
					6600: 0,
					6601: 2,
					6602: 0,
					6603: 2,
					6605: 2,
					6606: 0,
					6607: 2,
					6608: 0,
					6609: 2,
					6610: 0,
					6611: 0,
					6612: 2,
					6613: 0,
					6614: 2,
					6615: 0,
					6616: 2,
					6617: 0,
					6618: 2,
					6633: 2,
					6646: 0,
					6703: 0,
					6784: 0,
					6785: 1,
					6786: 0,
					6787: 1,
					6788: 0,
					6789: 1,
					6790: 0,
					6791: 1,
					6792: 0,
					6793: 1,
					6794: 0,
					6795: 1,
					6796: 0,
					6797: 1,
					6798: 0,
					6799: 1,
					6800: 0,
					6801: 1,
					6802: 0,
					6803: 1,
					6804: 0,
					6805: 1,
					6806: 0,
					6807: 1,
					6808: 0,
					6809: 1,
					6810: 0,
					6811: 1,
					6812: 0,
					6813: 1,
					6814: 0,
					6815: 1,
					6816: 0,
					6817: 1,
					6818: 0,
					6819: 1,
					6820: 0,
					6821: 1,
					6822: 0,
					6823: 1,
					6824: 0,
					6825: 1,
					6826: 0,
					6827: 1,
					6828: 0,
					6829: 1,
					6830: 0,
					6831: 1,
					6832: 0,
					6833: 1,
					6834: 0,
					6835: 1,
					6836: 0,
					6837: 1,
					6838: 0,
					6839: 1,
					6840: 0,
					6841: 1,
					6842: 0,
					6843: 1,
					6844: 0,
					6845: 1,
					6846: 0,
					6847: 1,
					6848: 0,
					6849: 1,
					6850: 0,
					6851: 1,
					6852: 0,
					6853: 1,
					6854: 0,
					6855: 1,
					6856: 0,
					6857: 1,
					6858: 0,
					6859: 1,
					6860: 0,
					6861: 1,
					6862: 0,
					6863: 1,
					6867: 0,
					6868: 1,
					6870: 0,
					6875: 0,
					6876: 0,
					6879: 0,
					6880: 2,
					6884: 0,
					6885: 1,
					6886: 0,
					6887: 1,
					6915: 0,
					6922: 0,
					6923: 2,
					6924: 0,
					6925: 2,
					6962: 0,
					6984: 0,
					6991: 0,
					7128: 2,
					7131: 0,
					7132: 2,
					7142: 0,
					7257: 0,
					7258: 2,
					7259: 0,
					7260: 2,
					7261: 0,
					7262: 2,
					7263: 0,
					7264: 2,
					7265: 0,
					7266: 2,
					7267: 0,
					7268: 2,
					7269: 0,
					7270: 2,
					7271: 0,
					7272: 2,
					7273: 0,
					7274: 2,
					7275: 0,
					7276: 2,
					7277: 0,
					7278: 2,
					7279: 0,
					7280: 2,
					7281: 0,
					7282: 2,
					7283: 0,
					7284: 2,
					7285: 0,
					7286: 2,
					7287: 0,
					7288: 2,
					7289: 0,
					7290: 2,
					7291: 0,
					7292: 2,
					7293: 0,
					7294: 2,
					7295: 0,
					7296: 2,
					7297: 0,
					7298: 2,
					7299: 0,
					7300: 2,
					7301: 0,
					7302: 2,
					7303: 0,
					7304: 2,
					7305: 0,
					7306: 2,
					7307: 0,
					7308: 2,
					7309: 0,
					7310: 2,
					7311: 0,
					7312: 2,
					7313: 0,
					7314: 2,
					7315: 0,
					7316: 2,
					7317: 0,
					7318: 2,
					7319: 0,
					7320: 2,
					7321: 0,
					7322: 2,
					7323: 0,
					7324: 2,
					7325: 0,
					7326: 2,
					7327: 0,
					7328: 2,
					7329: 0,
					7330: 2,
					7331: 0,
					7332: 2,
					7333: 0,
					7334: 2,
					7335: 0,
					7336: 2,
					7337: 0,
					7338: 2,
					7339: 0,
					7340: 2,
					7341: 0,
					7342: 2,
					7343: 0,
					7344: 2,
					7345: 0,
					7346: 2,
					7347: 0,
					7348: 2,
					7349: 0,
					7350: 2,
					7351: 0,
					7352: 2,
					7353: 0,
					7354: 2,
					7355: 0,
					7356: 2,
					7357: 0,
					7358: 2,
					7359: 0,
					7360: 2,
					7361: 0,
					7362: 2,
					7363: 0,
					7364: 2,
					7365: 0,
					7366: 2,
					7367: 0,
					7368: 2,
					7369: 0,
					7370: 2,
					7877: 0,
					7878: 0,
					7882: 0,
					7883: 0,
					7887: 0,
					7899: 0,
					7991: 0,
					7992: 0,
					8035: 2,
					8036: 2,
					8058: 0,
					8059: 0,
					8082: 0,
					8083: 0,
					8088: 0,
					8090: 0,
					8091: 2,
					8092: 0,
					8093: 2,
					8095: 0,
					8096: 2,
					8097: 0,
					8098: 2,
					8099: 0,
					8100: 2,
					8101: 0,
					8102: 2,
					8103: 0,
					8104: 2,
					8105: 0,
					8106: 2,
					8107: 0,
					8108: 2,
					8109: 0,
					8110: 2,
					8111: 0,
					8112: 2,
					8113: 0,
					8114: 2,
					8115: 0,
					8116: 2,
					8117: 0,
					8118: 2,
					8119: 0,
					8120: 2,
					8121: 0,
					8122: 2,
					8123: 0,
					8124: 2,
					8125: 0,
					8126: 2,
					8127: 0,
					8128: 2,
					8129: 0,
					8130: 2,
					8131: 0,
					8132: 2,
					8133: 0,
					8134: 2,
					8135: 0,
					8136: 2,
					8137: 0,
					8138: 2,
					8139: 0,
					8140: 2,
					8141: 0,
					8142: 2,
					8143: 0,
					8144: 2,
					8145: 0,
					8146: 2,
					8147: 0,
					8148: 2,
					8149: 0,
					8150: 2,
					8151: 0,
					8152: 2,
					8153: 0,
					8154: 2,
					8155: 0,
					8156: 2,
					8157: 0,
					8158: 2,
					8159: 0,
					8160: 2,
					8161: 0,
					8162: 2,
					8163: 0,
					8164: 2,
					8165: 0,
					8166: 2,
					8167: 0,
					8168: 2,
					8169: 0,
					8170: 2,
					8171: 0,
					8172: 2,
					8173: 0,
					8177: 2,
					8179: 0,
					8180: 2,
					8181: 0,
					8182: 2,
					8184: 0,
					8185: 2,
					8187: 0,
					8189: 2,
					8191: 0,
					8193: 2,
					8196: 0,
					8197: 2,
					8198: 0,
					8200: 2,
					8201: 0,
					8202: 2,
					8203: 0,
					8204: 2,
					8205: 0,
					8206: 2,
					8207: 0,
					8208: 2,
					8209: 0,
					8210: 2,
					8212: 0,
					8213: 2,
					8214: 0,
					8216: 2,
					8218: 0,
					8220: 2,
					8222: 0,
					8224: 2,
					8225: 0,
					8226: 2,
					8311: 0,
					8312: 1,
					8313: 0,
					8314: 1,
					8315: 0,
					8316: 1,
					8317: 0,
					8318: 1,
					8319: 0,
					8320: 1,
					8321: 0,
					8322: 1,
					8323: 0,
					8324: 1,
					8325: 0,
					8326: 1,
					8327: 0,
					8328: 1,
					8329: 0,
					8330: 1,
					8331: 0,
					8332: 1,
					8333: 0,
					8334: 1,
					8335: 0,
					8336: 1,
					8337: 0,
					8338: 1,
					8339: 0,
					8340: 1,
					8341: 0,
					8342: 1,
					8343: 0,
					8344: 1,
					8345: 0,
					8346: 1,
					8347: 0,
					8348: 1,
					8352: 0,
					8353: 0,
					8379: 0,
					8380: 2,
					8381: 0,
					8382: 2,
					8383: 0,
					8384: 2,
					8385: 0,
					8387: 2,
					8391: 0,
					8395: 0,
					8433: 0,
					8441: 0,
					8455: 0,
					8456: 0,
					8531: 2,
					8682: 0,
					8686: 0,
					8687: 0,
					8692: 0,
					8693: 0,
					8826: 0,
					8903: 0,
					8950: 0,
					8951: 0,
					9039: 0,
					9040: 0,
					9141: 0,
					9149: 0,
					9150: 0,
					9191: 0,
					9221: 0,
					9222: 0,
					9249: 0,
					9250: 0,
					9252: 0,
					9254: 0,
					9265: 0,
					9284: 0,
					9285: 0,
					9300: 0,
					9354: 0,
					9367: 0,
					9373: 0,
					9377: 0,
					9387: 0,
					9391: 0,
					9456: 0,
					9473: 0,
					9498: 0,
					9674: 0,
					9678: 0,
					9680: 0,
					9709: 0,
					9712: 0,
					9713: 0,
					9716: 0,
					9741: 0,
					9748: 2,
					9749: 2,
					9761: 0,
					9766: 0,
					20499: 0,
					20538: 0,
					20539: 0,
					20790: 0,
					20791: 0,
					21291: 0,
					21292: 0,
					21500: 0,
					21817: 0,
					21818: 0,
					22032: 0,
					22033: 0,
					22091: 0,
					22092: 0,
					22332: 0,
					22391: 0,
					22392: 0,
					22700: 0,
					22770: 0,
					22780: 0,
					22832: 0,
					23090: 0,
					23095: 0,
					23239: 0,
					23240: 0,
					23433: 0,
					23700: 0,
					24047: 0,
					24048: 0,
					24100: 3,
					24200: 0,
					24305: 0,
					24306: 0,
					24382: 10,
					24383: 0,
					24500: 0,
					24547: 0,
					24548: 0,
					24571: 9,
					24600: 0,
					25E3: 0,
					25231: 0,
					25884: 0,
					25932: 0,
					26237: 0,
					26331: 0,
					26332: 0,
					26432: 0,
					26591: 0,
					26592: 0,
					26632: 0,
					26692: 0,
					27120: 0,
					27200: 0,
					27291: 6,
					27292: 6,
					27429: 0,
					27492: 0,
					27493: 0,
					27500: 0,
					27700: 0,
					28232: 0,
					28600: 0,
					28991: 0,
					28992: 0,
					29100: 0,
					29101: 0,
					29220: 0,
					29221: 0,
					29333: 0,
					29635: 0,
					29636: 0,
					29701: 0,
					29738: 0,
					29739: 0,
					29849: 0,
					29850: 0,
					29871: 8,
					29872: 7,
					29873: 0,
					29874: 0,
					30200: 5,
					30339: 0,
					30340: 0,
					30591: 0,
					30592: 0,
					30791: 0,
					30792: 0,
					30800: 0,
					31028: 0,
					31121: 0,
					31154: 0,
					31170: 0,
					31171: 0,
					31370: 0,
					31528: 0,
					31529: 0,
					31600: 0,
					31700: 0,
					31838: 0,
					31839: 0,
					31900: 0,
					31901: 0,
					32061: 0,
					32062: 0,
					32098: 0,
					32099: 2,
					32100: 0,
					32104: 0,
					32161: 0,
					32766: 0,
					53048: 0,
					53049: 0,
					54090: 0,
					54091: 0,
					65061: 2,
					65062: 2,
					65161: 0,
					65163: 0,
					102041: 2,
					102064: 11,
					102068: 15,
					102069: 16,
					102118: 2,
					102119: 1,
					102120: 2,
					102121: 2,
					102217: 2,
					102218: 0,
					102219: 2,
					102220: 2,
					102378: 1,
					102379: 1,
					102380: 0,
					102381: 1,
					102589: 2,
					102599: 2,
					102600: 2,
					102604: 2,
					102647: 0,
					102704: 2,
					102705: 2,
					102706: 0,
					102759: 1,
					102760: 1,
					102761: 2,
					102762: 0,
					102763: 2,
					102764: 0,
					102765: 0,
					102766: 2,
					102970: 1,
					102974: 2,
					102993: 0,
					102994: 0,
					102995: 2,
					102996: 2,
					103015: 0,
					103016: 2,
					103017: 0,
					103018: 2,
					103025: 0,
					103026: 0,
					103027: 2,
					103028: 2,
					103035: 0,
					103036: 0,
					103037: 2,
					103038: 2,
					103039: 0,
					103040: 0,
					103041: 2,
					103042: 2,
					103043: 0,
					103044: 0,
					103045: 2,
					103046: 2,
					103047: 0,
					103048: 0,
					103049: 2,
					103050: 2,
					103051: 0,
					103052: 2,
					103053: 0,
					103054: 2,
					103055: 0,
					103056: 2,
					103057: 0,
					103058: 0,
					103059: 2,
					103060: 2,
					103061: 0,
					103062: 0,
					103063: 2,
					103064: 2,
					103069: 2,
					103070: 0,
					103071: 0,
					103072: 2,
					103073: 2,
					103086: 0,
					103087: 0,
					103088: 2,
					103089: 2,
					103094: 1,
					103095: 0,
					103096: 2,
					103103: 0,
					103104: 2,
					103105: 0,
					103106: 2,
					103121: 0,
					103122: 2,
					103123: 0,
					103124: 0,
					103125: 1,
					103126: 1,
					103127: 0,
					103128: 0,
					103129: 2,
					103130: 2,
					103131: 0,
					103132: 0,
					103133: 2,
					103134: 2,
					103135: 0,
					103136: 0,
					103137: 1,
					103138: 1,
					103139: 0,
					103140: 2,
					103141: 0,
					103142: 2,
					103143: 0,
					103144: 2,
					103145: 0,
					103146: 1,
					103147: 0,
					103148: 0,
					103149: 2,
					103150: 2,
					103151: 0,
					103152: 2,
					103172: 0,
					103173: 2,
					103174: 0,
					103175: 0,
					103176: 2,
					103177: 2,
					103178: 0,
					103179: 0,
					103180: 2,
					103181: 2,
					103182: 0,
					103183: 0,
					103184: 2,
					103185: 2,
					103228: 0,
					103229: 0,
					103230: 2,
					103231: 2,
					103250: 0,
					103251: 2,
					103252: 0,
					103253: 2,
					103260: 0,
					103261: 0,
					103262: 2,
					103263: 2,
					103270: 0,
					103271: 0,
					103272: 2,
					103273: 2,
					103274: 0,
					103275: 0,
					103276: 2,
					103277: 2,
					103278: 0,
					103279: 0,
					103280: 2,
					103281: 2,
					103282: 0,
					103283: 0,
					103284: 2,
					103285: 2,
					103286: 0,
					103287: 2,
					103288: 0,
					103289: 2,
					103290: 0,
					103291: 2,
					103292: 0,
					103293: 0,
					103294: 2,
					103295: 2,
					103296: 0,
					103297: 0,
					103298: 2,
					103299: 2,
					103376: 2,
					103377: 0,
					103378: 0,
					103379: 2,
					103380: 2,
					103393: 0,
					103394: 0,
					103395: 2,
					103396: 2,
					103472: 0,
					103473: 1,
					103474: 0,
					103475: 2,
					103482: 0,
					103483: 2,
					103484: 0,
					103485: 2,
					103500: 0,
					103501: 2,
					103502: 0,
					103503: 0,
					103504: 1,
					103505: 1,
					103506: 0,
					103507: 0,
					103508: 2,
					103509: 2,
					103510: 0,
					103511: 0,
					103512: 2,
					103513: 2,
					103514: 0,
					103515: 2,
					103516: 0,
					103517: 2,
					103518: 0,
					103519: 2,
					103520: 0,
					103521: 1,
					103522: 0,
					103523: 0,
					103524: 2,
					103525: 2,
					103526: 0,
					103527: 2,
					103561: 2,
					103562: 2,
					103563: 0,
					103564: 0,
					103565: 2,
					103566: 2,
					103567: 0,
					103568: 0,
					103569: 2,
					103570: 2,
					103584: 0,
					103585: 2,
					103586: 0,
					103587: 2,
					103588: 1,
					103589: 0,
					103590: 2,
					103591: 1,
					103592: 0,
					103593: 2,
					103594: 1,
					103695: 2
				};
				for (a = 2E3; 2045 >= a; a++) b[a] = 0;
				for (a = 2056; 2065 >= a; a++) b[a] = 0;
				for (a = 2067; 2135 >= a; a++) b[a] = 0;
				for (a = 2137; 2154 >= a; a++) b[a] = 0;
				for (a = 2161; 2170 >= a; a++) b[a] = 0;
				for (a = 2172; 2193 >= a; a++) b[a] = 0;
				for (a = 2195; 2198 >= a; a++) b[a] = 0;
				for (a = 2200; 2203 >= a; a++) b[a] = 0;
				for (a = 2205; 2217 >= a; a++) b[a] = 0;
				for (a = 2222; 2224 >= a; a++) b[a] = 1;
				for (a = 2225; 2250 >= a; a++) b[a] = 2;
				for (a = 2251; 2253 >= a; a++) b[a] = 1;
				for (a = 2257; 2264 >= a; a++) b[a] = 2;
				for (a = 2274; 2279 >= a; a++) b[a] = 2;
				for (a = 2280; 2282 >= a; a++) b[a] = 1;
				for (a = 2283; 2289 >= a; a++) b[a] = 2;
				for (a = 2290; 2292 >= a; a++) b[a] =
					0;
				for (a = 2308; 2313 >= a; a++) b[a] = 0;
				for (a = 2315; 2491 >= a; a++) b[a] = 0;
				for (a = 2494; 2866 >= a; a++) b[a] = 0;
				for (a = 2867; 2869 >= a; a++) b[a] = 1;
				for (a = 2870; 2888 >= a; a++) b[a] = 2;
				for (a = 2891; 2895 >= a; a++) b[a] = 2;
				for (a = 2896; 2898 >= a; a++) b[a] = 1;
				for (a = 2902; 2908 >= a; a++) b[a] = 2;
				for (a = 2915; 2920 >= a; a++) b[a] = 2;
				for (a = 2921; 2923 >= a; a++) b[a] = 1;
				for (a = 2924; 2930 >= a; a++) b[a] = 2;
				for (a = 2931; 2962 >= a; a++) b[a] = 0;
				for (a = 2964; 2968 >= a; a++) b[a] = 2;
				for (a = 2969; 2973 >= a; a++) b[a] = 0;
				for (a = 2975; 2991 >= a; a++) b[a] = 0;
				for (a = 2995; 3051 >= a; a++) b[a] = 0;
				for (a = 3054; 3079 >= a; a++) b[a] =
					0;
				for (a = 3081; 3088 >= a; a++) b[a] = 0;
				for (a = 3092; 3101 >= a; a++) b[a] = 0;
				for (a = 3106; 3138 >= a; a++) b[a] = 0;
				for (a = 3146; 3151 >= a; a++) b[a] = 0;
				for (a = 3153; 3166 >= a; a++) b[a] = 0;
				for (a = 3168; 3172 >= a; a++) b[a] = 0;
				for (a = 3174; 3203 >= a; a++) b[a] = 0;
				for (a = 3294; 3358 >= a; a++) b[a] = 0;
				for (a = 3367; 3403 >= a; a++) b[a] = 0;
				for (a = 3408; 3416 >= a; a++) b[a] = 0;
				for (a = 3417; 3438 >= a; a++) b[a] = 2;
				for (a = 3441; 3446 >= a; a++) b[a] = 2;
				for (a = 3447; 3450 >= a; a++) b[a] = 0;
				for (a = 3451; 3459 >= a; a++) b[a] = 2;
				for (a = 3460; 3478 >= a; a++) b[a] = 0;
				for (a = 3554; 3559 >= a; a++) b[a] = 0;
				for (a = 3560; 3570 >= a; a++) b[a] =
					2;
				for (a = 3571; 3581 >= a; a++) b[a] = 0;
				for (a = 3594; 3597 >= a; a++) b[a] = 0;
				for (a = 3601; 3604 >= a; a++) b[a] = 0;
				for (a = 3637; 3639 >= a; a++) b[a] = 0;
				for (a = 3665; 3667 >= a; a++) b[a] = 0;
				for (a = 3693; 3695 >= a; a++) b[a] = 0;
				for (a = 3701; 3727 >= a; a++) b[a] = 0;
				for (a = 3728; 3739 >= a; a++) b[a] = 2;
				for (a = 3740; 3751 >= a; a++) b[a] = 0;
				for (a = 3753; 3760 >= a; a++) b[a] = 2;
				for (a = 3761; 3773 >= a; a++) b[a] = 0;
				for (a = 3775; 3777 >= a; a++) b[a] = 0;
				for (a = 3779; 3781 >= a; a++) b[a] = 0;
				for (a = 3783; 3785 >= a; a++) b[a] = 0;
				for (a = 3788; 3791 >= a; a++) b[a] = 0;
				for (a = 3797; 3802 >= a; a++) b[a] = 0;
				for (a = 3814; 3816 >= a; a++) b[a] =
					0;
				for (a = 3825; 3829 >= a; a++) b[a] = 0;
				for (a = 3832; 3841 >= a; a++) b[a] = 0;
				for (a = 3844; 3852 >= a; a++) b[a] = 0;
				for (a = 3873; 3885 >= a; a++) b[a] = 0;
				for (a = 3890; 3893 >= a; a++) b[a] = 0;
				for (a = 3907; 3912 >= a; a++) b[a] = 0;
				for (a = 3942; 3950 >= a; a++) b[a] = 0;
				for (a = 3968; 3970 >= a; a++) b[a] = 0;
				for (a = 3973; 3976 >= a; a++) b[a] = 0;
				for (a = 3986; 3989 >= a; a++) b[a] = 0;
				for (a = 3994; 3997 >= a; a++) b[a] = 0;
				for (a = 4048; 4051 >= a; a++) b[a] = 0;
				for (a = 4056; 4063 >= a; a++) b[a] = 0;
				for (a = 4093; 4096 >= a; a++) b[a] = 0;
				for (a = 4390; 4398 >= a; a++) b[a] = 0;
				for (a = 4399; 4413 >= a; a++) b[a] = 2;
				for (a = 4418; 4433 >= a; a++) b[a] =
					2;
				for (a = 4455; 4457 >= a; a++) b[a] = 2;
				for (a = 4484; 4489 >= a; a++) b[a] = 0;
				for (a = 4491; 4554 >= a; a++) b[a] = 0;
				for (a = 4568; 4589 >= a; a++) b[a] = 0;
				for (a = 4652; 4656 >= a; a++) b[a] = 0;
				for (a = 4766; 4800 >= a; a++) b[a] = 0;
				for (a = 5014; 5016 >= a; a++) b[a] = 0;
				for (a = 5069; 5072 >= a; a++) b[a] = 0;
				for (a = 5105; 5130 >= a; a++) b[a] = 0;
				for (a = 5173; 5188 >= a; a++) b[a] = 0;
				for (a = 5253; 5259 >= a; a++) b[a] = 0;
				for (a = 5269; 5275 >= a; a++) b[a] = 0;
				for (a = 5292; 5311 >= a; a++) b[a] = 0;
				for (a = 5329; 5331 >= a; a++) b[a] = 0;
				for (a = 5343; 5349 >= a; a++) b[a] = 0;
				for (a = 5355; 5357 >= a; a++) b[a] = 0;
				for (a = 5387; 5389 >= a; a++) b[a] =
					0;
				for (a = 5459; 5463 >= a; a++) b[a] = 0;
				for (a = 5479; 5482 >= a; a++) b[a] = 0;
				for (a = 5518; 5520 >= a; a++) b[a] = 0;
				for (a = 5530; 5539 >= a; a++) b[a] = 0;
				for (a = 5550; 5552 >= a; a++) b[a] = 0;
				for (a = 5562; 5583 >= a; a++) b[a] = 0;
				for (a = 5623; 5625 >= a; a++) b[a] = 2;
				for (a = 5631; 5639 >= a; a++) b[a] = 0;
				for (a = 5649; 5653 >= a; a++) b[a] = 0;
				for (a = 5663; 5680 >= a; a++) b[a] = 0;
				for (a = 5682; 5685 >= a; a++) b[a] = 0;
				for (a = 5875; 5877 >= a; a++) b[a] = 0;
				for (a = 5896; 5899 >= a; a++) b[a] = 0;
				for (a = 5921; 5940 >= a; a++) b[a] = 0;
				for (a = 6050; 6125 >= a; a++) b[a] = 0;
				for (a = 6244; 6275 >= a; a++) b[a] = 0;
				for (a = 6328; 6348 >= a; a++) b[a] =
					0;
				for (a = 6350; 6356 >= a; a++) b[a] = 0;
				for (a = 6366; 6372 >= a; a++) b[a] = 0;
				for (a = 6381; 6387 >= a; a++) b[a] = 0;
				for (a = 6393; 6404 >= a; a++) b[a] = 0;
				for (a = 6480; 6483 >= a; a++) b[a] = 0;
				for (a = 6511; 6514 >= a; a++) b[a] = 0;
				for (a = 6579; 6581 >= a; a++) b[a] = 0;
				for (a = 6619; 6624 >= a; a++) b[a] = 0;
				for (a = 6625; 6627 >= a; a++) b[a] = 2;
				for (a = 6628; 6632 >= a; a++) b[a] = 0;
				for (a = 6634; 6637 >= a; a++) b[a] = 0;
				for (a = 6669; 6692 >= a; a++) b[a] = 0;
				for (a = 6707; 6709 >= a; a++) b[a] = 0;
				for (a = 6720; 6723 >= a; a++) b[a] = 0;
				for (a = 6732; 6738 >= a; a++) b[a] = 0;
				for (a = 6931; 6933 >= a; a++) b[a] = 0;
				for (a = 6956; 6959 >= a; a++) b[a] =
					0;
				for (a = 7005; 7007 >= a; a++) b[a] = 0;
				for (a = 7057; 7070 >= a; a++) b[a] = 2;
				for (a = 7074; 7082 >= a; a++) b[a] = 0;
				for (a = 7109; 7118 >= a; a++) b[a] = 0;
				for (a = 7119; 7127 >= a; a++) b[a] = 1;
				for (a = 7374; 7376 >= a; a++) b[a] = 0;
				for (a = 7528; 7586 >= a; a++) b[a] = 0;
				for (a = 7587; 7645 >= a; a++) b[a] = 2;
				for (a = 7692; 7696 >= a; a++) b[a] = 0;
				for (a = 7755; 7787 >= a; a++) b[a] = 0;
				for (a = 7791; 7795 >= a; a++) b[a] = 0;
				for (a = 7799; 7801 >= a; a++) b[a] = 0;
				for (a = 7803; 7805 >= a; a++) b[a] = 0;
				for (a = 7825; 7831 >= a; a++) b[a] = 0;
				for (a = 7845; 7859 >= a; a++) b[a] = 0;
				for (a = 8013; 8032 >= a; a++) b[a] = 0;
				for (a = 8065; 8068 >= a; a++) b[a] =
					1;
				for (a = 8518; 8529 >= a; a++) b[a] = 2;
				for (a = 8533; 8536 >= a; a++) b[a] = 2;
				for (a = 8538; 8540 >= a; a++) b[a] = 2;
				for (a = 8677; 8679 >= a; a++) b[a] = 0;
				for (a = 8836; 8840 >= a; a++) b[a] = 0;
				for (a = 8857; 8859 >= a; a++) b[a] = 0;
				for (a = 8908; 8910 >= a; a++) b[a] = 0;
				for (a = 9154; 9159 >= a; a++) b[a] = 0;
				for (a = 9205; 9218 >= a; a++) b[a] = 0;
				for (a = 9271; 9273 >= a; a++) b[a] = 0;
				for (a = 9295; 9297 >= a; a++) b[a] = 0;
				for (a = 9356; 9360 >= a; a++) b[a] = 0;
				for (a = 9404; 9407 >= a; a++) b[a] = 0;
				for (a = 9476; 9482 >= a; a++) b[a] = 0;
				for (a = 9487; 9494 >= a; a++) b[a] = 0;
				for (a = 9697; 9699 >= a; a++) b[a] = 0;
				for (a = 20002; 20032 >=
					a; a++) b[a] = 0;
				for (a = 20062; 20092 >= a; a++) b[a] = 0;
				for (a = 20135; 20138 >= a; a++) b[a] = 0;
				for (a = 20248; 20258 >= a; a++) b[a] = 0;
				for (a = 20348; 20358 >= a; a++) b[a] = 0;
				for (a = 20436; 20440 >= a; a++) b[a] = 0;
				for (a = 20822; 20824 >= a; a++) b[a] = 0;
				for (a = 20904; 20932 >= a; a++) b[a] = 0;
				for (a = 20934; 20936 >= a; a++) b[a] = 0;
				for (a = 21004; 21032 >= a; a++) b[a] = 0;
				for (a = 21035; 21037 >= a; a++) b[a] = 0;
				for (a = 21095; 21097 >= a; a++) b[a] = 0;
				for (a = 21148; 21150 >= a; a++) b[a] = 0;
				for (a = 21207; 21264 >= a; a++) b[a] = 0;
				for (a = 21307; 21364 >= a; a++) b[a] = 0;
				for (a = 21413; 21423 >= a; a++) b[a] = 0;
				for (a = 21453; 21463 >=
					a; a++) b[a] = 0;
				for (a = 21473; 21483 >= a; a++) b[a] = 0;
				for (a = 21780; 21782 >= a; a++) b[a] = 0;
				for (a = 21891; 21894 >= a; a++) b[a] = 0;
				for (a = 21896; 21899 >= a; a++) b[a] = 0;
				for (a = 22171; 22177 >= a; a++) b[a] = 0;
				for (a = 22181; 22187 >= a; a++) b[a] = 0;
				for (a = 22191; 22197 >= a; a++) b[a] = 0;
				for (a = 22234; 22236 >= a; a++) b[a] = 0;
				for (a = 22521; 22525 >= a; a++) b[a] = 0;
				for (a = 22991; 22994 >= a; a++) b[a] = 0;
				for (a = 23028; 23038 >= a; a++) b[a] = 0;
				for (a = 23830; 23853 >= a; a++) b[a] = 0;
				for (a = 23866; 23872 >= a; a++) b[a] = 0;
				for (a = 23877; 23884 >= a; a++) b[a] = 0;
				for (a = 23886; 23894 >= a; a++) b[a] = 0;
				for (a = 23946; 23948 >=
					a; a++) b[a] = 0;
				for (a = 24311; 24313 >= a; a++) b[a] = 0;
				for (a = 24342; 24347 >= a; a++) b[a] = 0;
				for (a = 24370; 24374 >= a; a++) b[a] = 10;
				for (a = 24375; 24381 >= a; a++) b[a] = 0;
				for (a = 24718; 24721 >= a; a++) b[a] = 0;
				for (a = 24817; 24821 >= a; a++) b[a] = 0;
				for (a = 24877; 24882 >= a; a++) b[a] = 0;
				for (a = 24891; 24893 >= a; a++) b[a] = 0;
				for (a = 25391; 25395 >= a; a++) b[a] = 0;
				for (a = 25828; 25838 >= a; a++) b[a] = 0;
				for (a = 26191; 26195 >= a; a++) b[a] = 0;
				for (a = 26391; 26393 >= a; a++) b[a] = 0;
				for (a = 26701; 26722 >= a; a++) b[a] = 0;
				for (a = 26729; 26799 >= a; a++) b[a] = 2;
				for (a = 26801; 26803 >= a; a++) b[a] = 2;
				for (a = 26811; 26813 >=
					a; a++) b[a] = 2;
				for (a = 26847; 26870 >= a; a++) b[a] = 2;
				for (a = 26891; 26899 >= a; a++) b[a] = 0;
				for (a = 26901; 26923 >= a; a++) b[a] = 0;
				for (a = 26929; 26946 >= a; a++) b[a] = 0;
				for (a = 26948; 26998 >= a; a++) b[a] = 0;
				for (a = 27037; 27040 >= a; a++) b[a] = 0;
				for (a = 27205; 27232 >= a; a++) b[a] = 0;
				for (a = 27258; 27260 >= a; a++) b[a] = 0;
				for (a = 27391; 27398 >= a; a++) b[a] = 0;
				for (a = 27561; 27564 >= a; a++) b[a] = 0;
				for (a = 27571; 27574 >= a; a++) b[a] = 0;
				for (a = 27581; 27584 >= a; a++) b[a] = 0;
				for (a = 27591; 27594 >= a; a++) b[a] = 0;
				for (a = 28191; 28193 >= a; a++) b[a] = 0;
				for (a = 28348; 28358 >= a; a++) b[a] = 0;
				for (a = 28402; 28432 >=
					a; a++) b[a] = 0;
				for (a = 28462; 28492 >= a; a++) b[a] = 0;
				for (a = 29118; 29122 >= a; a++) b[a] = 0;
				for (a = 29168; 29172 >= a; a++) b[a] = 0;
				for (a = 29177; 29185 >= a; a++) b[a] = 0;
				for (a = 29187; 29195 >= a; a++) b[a] = 0;
				for (a = 29900; 29903 >= a; a++) b[a] = 0;
				for (a = 30161; 30179 >= a; a++) b[a] = 0;
				for (a = 30491; 30494 >= a; a++) b[a] = 0;
				for (a = 30729; 30732 >= a; a++) b[a] = 0;
				for (a = 31251; 31259 >= a; a++) b[a] = 0;
				for (a = 31265; 31268 >= a; a++) b[a] = 0;
				for (a = 31275; 31279 >= a; a++) b[a] = 0;
				for (a = 31281; 31297 >= a; a++) b[a] = 0;
				for (a = 31461; 31469 >= a; a++) b[a] = 0;
				for (a = 31491; 31495 >= a; a++) b[a] = 0;
				for (a = 31917; 31922 >=
					a; a++) b[a] = 0;
				for (a = 31965; 32E3 >= a; a++) b[a] = 0;
				for (a = 32001; 32003 >= a; a++) b[a] = 2;
				for (a = 32005; 32031 >= a; a++) b[a] = 2;
				for (a = 32033; 32060 >= a; a++) b[a] = 2;
				for (a = 32064; 32067 >= a; a++) b[a] = 2;
				for (a = 32074; 32077 >= a; a++) b[a] = 2;
				for (a = 32081; 32086 >= a; a++) b[a] = 0;
				for (a = 32107; 32130 >= a; a++) b[a] = 0;
				for (a = 32133; 32158 >= a; a++) b[a] = 0;
				for (a = 32164; 32167 >= a; a++) b[a] = 2;
				for (a = 32180; 32199 >= a; a++) b[a] = 0;
				for (a = 32201; 32260 >= a; a++) b[a] = 0;
				for (a = 32301; 32360 >= a; a++) b[a] = 0;
				for (a = 32601; 32662 >= a; a++) b[a] = 0;
				for (a = 32664; 32667 >= a; a++) b[a] = 2;
				for (a = 32701; 32761 >=
					a; a++) b[a] = 0;
				for (a = 53001; 53004 >= a; a++) b[a] = 0;
				for (a = 53008; 53019 >= a; a++) b[a] = 0;
				for (a = 53021; 53032 >= a; a++) b[a] = 0;
				for (a = 53034; 53037 >= a; a++) b[a] = 0;
				for (a = 53042; 53046 >= a; a++) b[a] = 0;
				for (a = 53074; 53080 >= a; a++) b[a] = 0;
				for (a = 54001; 54004 >= a; a++) b[a] = 0;
				for (a = 54008; 54019 >= a; a++) b[a] = 0;
				for (a = 54021; 54032 >= a; a++) b[a] = 0;
				for (a = 54034; 54037 >= a; a++) b[a] = 0;
				for (a = 54042; 54046 >= a; a++) b[a] = 0;
				for (a = 54048; 54053 >= a; a++) b[a] = 0;
				for (a = 54074; 54080 >= a; a++) b[a] = 0;
				for (a = 54098; 54101 >= a; a++) b[a] = 0;
				for (a = 102001; 102040 >= a; a++) b[a] = 0;
				for (a =
					102042; 102063 >= a; a++) b[a] = 0;
				for (a = 102065; 102067 >= a; a++) b[a] = 0;
				for (a = 102070; 102117 >= a; a++) b[a] = 0;
				for (a = 102122; 102216 >= a; a++) b[a] = 0;
				for (a = 102221; 102377 >= a; a++) b[a] = 0;
				for (a = 102382; 102388 >= a; a++) b[a] = 0;
				for (a = 102389; 102398 >= a; a++) b[a] = 2;
				for (a = 102399; 102444 >= a; a++) b[a] = 0;
				for (a = 102445; 102447 >= a; a++) b[a] = 2;
				for (a = 102448; 102458 >= a; a++) b[a] = 0;
				for (a = 102459; 102468 >= a; a++) b[a] = 2;
				for (a = 102469; 102499 >= a; a++) b[a] = 0;
				for (a = 102500; 102519 >= a; a++) b[a] = 1;
				for (a = 102520; 102524 >= a; a++) b[a] = 0;
				for (a = 102525; 102529 >= a; a++) b[a] =
					2;
				for (a = 102530; 102588 >= a; a++) b[a] = 0;
				for (a = 102590; 102598 >= a; a++) b[a] = 0;
				for (a = 102601; 102603 >= a; a++) b[a] = 0;
				for (a = 102605; 102628 >= a; a++) b[a] = 0;
				for (a = 102629; 102646 >= a; a++) b[a] = 2;
				for (a = 102648; 102700 >= a; a++) b[a] = 2;
				for (a = 102701; 102703 >= a; a++) b[a] = 0;
				for (a = 102707; 102730 >= a; a++) b[a] = 2;
				for (a = 102733; 102758 >= a; a++) b[a] = 2;
				for (a = 102767; 102900 >= a; a++) b[a] = 0;
				for (a = 102901; 102933 >= a; a++) b[a] = 2;
				for (a = 102934; 102950 >= a; a++) b[a] = 13;
				for (a = 102951; 102955 >= a; a++) b[a] = 0;
				for (a = 102961; 102963 >= a; a++) b[a] = 0;
				for (a = 102965; 102969 >= a; a++) b[a] =
					0;
				for (a = 102971; 102973 >= a; a++) b[a] = 0;
				for (a = 102975; 102989 >= a; a++) b[a] = 0;
				for (a = 102990; 102992 >= a; a++) b[a] = 1;
				for (a = 102997; 103002 >= a; a++) b[a] = 0;
				for (a = 103003; 103008 >= a; a++) b[a] = 2;
				for (a = 103009; 103011 >= a; a++) b[a] = 0;
				for (a = 103012; 103014 >= a; a++) b[a] = 2;
				for (a = 103019; 103021 >= a; a++) b[a] = 0;
				for (a = 103022; 103024 >= a; a++) b[a] = 2;
				for (a = 103029; 103031 >= a; a++) b[a] = 0;
				for (a = 103032; 103034 >= a; a++) b[a] = 2;
				for (a = 103065; 103068 >= a; a++) b[a] = 0;
				for (a = 103074; 103076 >= a; a++) b[a] = 0;
				for (a = 103077; 103079 >= a; a++) b[a] = 1;
				for (a = 103080; 103082 >= a; a++) b[a] =
					0;
				for (a = 103083; 103085 >= a; a++) b[a] = 2;
				for (a = 103090; 103093 >= a; a++) b[a] = 0;
				for (a = 103097; 103099 >= a; a++) b[a] = 0;
				for (a = 103100; 103102 >= a; a++) b[a] = 2;
				for (a = 103107; 103109 >= a; a++) b[a] = 0;
				for (a = 103110; 103112 >= a; a++) b[a] = 2;
				for (a = 103113; 103116 >= a; a++) b[a] = 0;
				for (a = 103117; 103120 >= a; a++) b[a] = 2;
				for (a = 103153; 103157 >= a; a++) b[a] = 0;
				for (a = 103158; 103162 >= a; a++) b[a] = 2;
				for (a = 103163; 103165 >= a; a++) b[a] = 0;
				for (a = 103166; 103168 >= a; a++) b[a] = 1;
				for (a = 103169; 103171 >= a; a++) b[a] = 2;
				for (a = 103186; 103188 >= a; a++) b[a] = 0;
				for (a = 103189; 103191 >= a; a++) b[a] =
					2;
				for (a = 103192; 103195 >= a; a++) b[a] = 0;
				for (a = 103196; 103199 >= a; a++) b[a] = 2;
				for (a = 103200; 103224 >= a; a++) b[a] = 0;
				for (a = 103225; 103227 >= a; a++) b[a] = 1;
				for (a = 103232; 103237 >= a; a++) b[a] = 0;
				for (a = 103238; 103243 >= a; a++) b[a] = 2;
				for (a = 103244; 103246 >= a; a++) b[a] = 0;
				for (a = 103247; 103249 >= a; a++) b[a] = 2;
				for (a = 103254; 103256 >= a; a++) b[a] = 0;
				for (a = 103257; 103259 >= a; a++) b[a] = 2;
				for (a = 103264; 103266 >= a; a++) b[a] = 0;
				for (a = 103267; 103269 >= a; a++) b[a] = 2;
				for (a = 103300; 103375 >= a; a++) b[a] = 0;
				for (a = 103381; 103383 >= a; a++) b[a] = 0;
				for (a = 103384; 103386 >= a; a++) b[a] =
					1;
				for (a = 103387; 103389 >= a; a++) b[a] = 0;
				for (a = 103390; 103392 >= a; a++) b[a] = 2;
				for (a = 103397; 103399 >= a; a++) b[a] = 0;
				for (a = 103400; 103471 >= a; a++) b[a] = 2;
				for (a = 103476; 103478 >= a; a++) b[a] = 0;
				for (a = 103479; 103481 >= a; a++) b[a] = 2;
				for (a = 103486; 103488 >= a; a++) b[a] = 0;
				for (a = 103489; 103491 >= a; a++) b[a] = 2;
				for (a = 103492; 103495 >= a; a++) b[a] = 0;
				for (a = 103496; 103499 >= a; a++) b[a] = 2;
				for (a = 103528; 103543 >= a; a++) b[a] = 0;
				for (a = 103544; 103548 >= a; a++) b[a] = 2;
				for (a = 103549; 103551 >= a; a++) b[a] = 0;
				for (a = 103552; 103554 >= a; a++) b[a] = 1;
				for (a = 103555; 103557 >= a; a++) b[a] =
					2;
				for (a = 103558; 103560 >= a; a++) b[a] = 0;
				for (a = 103571; 103573 >= a; a++) b[a] = 0;
				for (a = 103574; 103576 >= a; a++) b[a] = 2;
				for (a = 103577; 103580 >= a; a++) b[a] = 0;
				for (a = 103581; 103583 >= a; a++) b[a] = 2;
				for (a = 103595; 103694 >= a; a++) b[a] = 0;
				for (a = 103696; 103699 >= a; a++) b[a] = 0;
				for (a = 103700; 103793 >= a; a++) b[a] = 2;
				for (a = 103794; 103887 >= a; a++) b[a] = 0;
				for (a = 103900; 103971 >= a; a++) b[a] = 2;
				return b
			})
		},
		"esri/portal/Portal": function() {
			define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../config ../kernel ../request ../core/Error ../core/JSONSupport ../core/Loadable ../core/maybe ../core/promiseUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../geometry/Extent ../intl/locale ./PortalQueryParams ./PortalQueryResult ./PortalUser ../support/apiKeyUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A) {
					const B = D => Object.freeze(Object.defineProperty({
						__proto__: null,
						default: D
					}, Symbol.toStringTag, {
						value: "Module"
					}));
					var E;
					let z;
					const C = {
						PortalGroup: () => new Promise((D, J) => a(["./PortalGroup"], K => D(B(K)), J)),
						PortalItem: () => new Promise((D, J) => a(["./PortalItem"], K => D(B(K)), J)),
						PortalUser: () => new Promise((D, J) => a(["./PortalUser"], K => D(B(K)), J))
					};
					m = E = function(D) {
						function J(H) {
							H = D.call(this, H) || this;
							H._esriIdCredentialCreateHandle = null;
							H.access = null;
							H.allSSL = !1;
							H.authMode = "auto";
							H.authorizedCrossOriginDomains = null;
							H.basemapGalleryGroupQuery = null;
							H.bingKey = null;
							H.canListApps = !1;
							H.canListData = !1;
							H.canListPreProvisionedItems = !1;
							H.canProvisionDirectPurchase = !1;
							H.canSearchPublic = !0;
							H.canShareBingPublic = !1;
							H.canSharePublic = !1;
							H.canSignInArcGIS = !1;
							H.canSignInIDP = !1;
							H.colorSetsGroupQuery = null;
							H.commentsEnabled = !1;
							H.created = null;
							H.culture = null;
							H.customBaseUrl = null;
							H.defaultBasemap = null;
							H.defaultDevBasemap = null;
							H.defaultExtent = null;
							H.defaultVectorBasemap = null;
							H.description = null;
							H.devBasemapGalleryGroupQuery = null;
							H.eueiEnabled = null;
							H.featuredGroups = null;
							H.featuredItemsGroupQuery = null;
							H.galleryTemplatesGroupQuery = null;
							H.livingAtlasGroupQuery = null;
							H.hasCategorySchema = !1;
							H.helperServices = null;
							H.homePageFeaturedContent = null;
							H.homePageFeaturedContentCount = null;
							H.httpPort = null;
							H.httpsPort = null;
							H.id = null;
							H.ipCntryCode = null;
							H.isPortal = !1;
							H.isReadOnly = !1;
							H.layerTemplatesGroupQuery = null;
							H.maxTokenExpirationMinutes = null;
							H.modified = null;
							H.name = null;
							H.portalHostname =
								null;
							H.portalMode = null;
							H.portalProperties = null;
							H.region = null;
							H.rotatorPanels = null;
							H.showHomePageDescription = !1;
							H.sourceJSON = null;
							H.supportsHostedServices = !1;
							H.symbolSetsGroupQuery = null;
							H.templatesGroupQuery = null;
							H.units = null;
							H.url = e.portalUrl;
							H.urlKey = null;
							H.user = null;
							H.useStandardizedQuery = !1;
							H.useVectorBasemaps = !1;
							H.vectorBasemapGalleryGroupQuery = null;
							return H
						}
						b._inheritsLoose(J, D);
						var K = J.prototype;
						K.normalizeCtorArgs = function(H) {
							return "string" === typeof H ? {
								url: H
							} : H
						};
						K.destroy = function() {
							this._esriIdCredentialCreateHandle =
								g.removeMaybe(this._esriIdCredentialCreateHandle)
						};
						K.readAuthorizedCrossOriginDomains = function(H) {
							if (H)
								for (const G of H) e.request.trustedServers.includes(G) || e.request.trustedServers.push(G);
							return H
						};
						K.readDefaultBasemap = function(H) {
							return this._readBasemap(H)
						};
						K.readDefaultDevBasemap = function(H) {
							return this._readBasemap(H)
						};
						K.readDefaultVectorBasemap = function(H) {
							return this._readBasemap(H)
						};
						K.readUrlKey = function(H) {
							return H ? H.toLowerCase() : H
						};
						K.readUser = function(H) {
							let G = null;
							H && (G = w.fromJSON(H),
								G.portal = this);
							return G
						};
						K.load = function(H) {
							const G = (new Promise((F, L) => a(["../Basemap"], R => F(B(R)), L)))
								.then(({
									default: F
								}) => {
									l.throwIfAborted(H);
									z = F
								})
								.then(() => this.sourceJSON ? this.sourceJSON : this._fetchSelf(this.authMode, !1, H))
								.then(F => {
									if (d.id) {
										const L = d.id;
										this.credential = L.findCredential(this.restUrl);
										this.credential || this.authMode !== E.AUTH_MODE_AUTO || (this._esriIdCredentialCreateHandle = L.on("credential-create", () => {
											L.findCredential(this.restUrl) && this._signIn()
												.catch(() => {})
										}))
									}
									this.sourceJSON =
										F;
									this.read(F)
								});
							this.addResolvingPromise(G);
							return Promise.resolve(this)
						};
						K.createElevationLayers = function() {
							var H = b._asyncToGenerator(function*() {
								yield this.load();
								const G = this._getHelperService("defaultElevationLayers"),
									F = (yield new Promise((L, R) => a(["../layers/ElevationLayer"], V => L(B(V)), R)))
									.default;
								return G ? G.map(L => new F({
									id: L.id,
									url: L.url
								})) : []
							});
							return function() {
								return H.apply(this, arguments)
							}
						}();
						K.fetchBasemaps = function(H, G) {
							const F = new x;
							F.query = H || (e.apiKey && A.supportsApiKey(this.url) ?
								this.devBasemapGalleryGroupQuery : this.useVectorBasemaps ? this.vectorBasemapGalleryGroupQuery : this.basemapGalleryGroupQuery);
							F.disableExtraQuery = !0;
							return this.queryGroups(F, G)
								.then(L => {
									F.num = 100;
									F.query = 'type:"Web Map" -type:"Web Application"';
									return L.total ? (L = L.results[0], F.sortField = L.sortField || "name", F.sortOrder = L.sortOrder || "desc", L.queryItems(F, G)) : null
								})
								.then(L => L && L.total ? L.results.filter(R => "Web Map" === R.type)
									.map(R => new z({
										portalItem: R
									})) : [])
						};
						K.fetchCategorySchema = function(H) {
							return this.hasCategorySchema ?
								this._request(this.restUrl + "/portals/self/categorySchema", H)
								.then(G => G.categorySchema) : l.isAborted(H) ? Promise.reject(l.createAbortError()) : Promise.resolve([])
						};
						K.fetchFeaturedGroups = function(H) {
							const G = this.featuredGroups,
								F = new x;
							F.num = 100;
							F.sortField = "title";
							if (G && G.length) {
								const L = [];
								for (const R of G) L.push(`(title:"${R.title}" AND owner:${R.owner})`);
								F.query = L.join(" OR ");
								return this.queryGroups(F, H)
									.then(R => R.results)
							}
							return l.isAborted(H) ? Promise.reject(l.createAbortError()) : Promise.resolve([])
						};
						K.fetchRegions = function(H) {
							const G = this.user ? .culture || this.culture || u.getLocale();
							return this._request(this.restUrl + "/portals/regions", {
								...H,
								query: {
									culture: G
								}
							})
						};
						K.fetchSettings = function(H) {
							const G = this.user ? .culture || this.culture || u.getLocale();
							return this._request(this.restUrl + "/portals/self/settings", {
								...H,
								query: {
									culture: G
								}
							})
						};
						J.getDefault = function() {
							if (!E._default || E._default.destroyed) E._default = new E;
							return E._default
						};
						K.queryGroups = function(H, G) {
							return this._queryPortal("/community/groups",
								H, "PortalGroup", G)
						};
						K.queryItems = function(H, G) {
							return this._queryPortal("/search", H, "PortalItem", G)
						};
						K.queryUsers = function(H, G) {
							H.sortField || (H.sortField = "username");
							return this._queryPortal("/community/users", H, "PortalUser", G)
						};
						K.toJSON = function() {
							throw new v("internal:not-yet-implemented", "Portal.toJSON is not yet implemented");
						};
						J.fromJSON = function(H) {
							if (!H) return null;
							if (H.declaredClass) throw Error("JSON object is already hydrated");
							return new E({
								sourceJSON: H
							})
						};
						K._getHelperService = function(H) {
							const G =
								this.helperServices && this.helperServices[H];
							if (!G) throw new v("portal:service-not-found", `The \`helperServices\` do not include an entry named "${H}"`);
							return G
						};
						K._getHelperServiceUrl = function(H) {
							const G = this._getHelperService(H);
							if (!G ? .url) throw new v("portal:service-url-not-found", `The \`helperServices\` entry "${H}" does not include a \`url\` value`);
							return G.url
						};
						K._fetchSelf = function(H = this.authMode, G = !1, F) {
							const L = this.restUrl + "/portals/self";
							H = {
								authMode: H,
								query: {
									culture: u.getLocale()
										.toLowerCase()
								},
								...F
							};
							"auto" === H.authMode && (H.authMode = "no-prompt");
							G && (H.query.default = !0);
							return this._request(L, H)
						};
						K._queryPortal = function(H, G, F, L) {
							const R = n.ensureType(x, G),
								V = U => this._request(this.restUrl + H, {
									...R.toRequestOptions(this),
									...L
								})
								.then(W => {
									const M = R.clone();
									M.start = W.nextStart;
									return new y({
										nextQueryParams: M,
										queryParams: R,
										total: W.total,
										results: E._resultsToTypedArray(U, {
											portal: this
										}, W, L)
									})
								})
								.then(W => Promise.all(W.results.map(M => "function" === typeof M.when ? M.when() : W))
									.then(() => W, M => {
										l.throwIfAbortError(M);
										return W
									}));
							return F && C[F] ? C[F]()
								.then(({
									default: U
								}) => {
									l.throwIfAborted(L);
									return V(U)
								}) : V()
						};
						K._signIn = function() {
							if (this.authMode === E.AUTH_MODE_ANONYMOUS) return Promise.reject(new v("portal:invalid-auth-mode", `Current "authMode"' is "${this.authMode}"`));
							if ("failed" === this.loadStatus) return Promise.reject(this.loadError);
							const H = G => Promise.resolve()
								.then(() => {
									if ("not-loaded" === this.loadStatus) return G || (this.authMode = "immediate"), this.load()
										.then(() => null);
									if ("loading" === this.loadStatus) return this.load()
										.then(() => {
											if (this.credential) return null;
											this.credential = G;
											return this._fetchSelf("immediate")
										});
									if (this.user && this.credential === G) return null;
									this.credential = G;
									return this._fetchSelf("immediate")
								})
								.then(F => {
									F && (this.sourceJSON = F, this.read(F))
								});
							return d.id ? d.id.getCredential(this.restUrl)
								.then(G => H(G)) : H(this.credential)
						};
						K._normalizeSSL = function(H) {
							return H.replace(/^http:/i, "https:")
								.replace(":7080", ":7443")
						};
						K._normalizeUrl = function(H) {
							const G = this.credential && this.credential.token;
							return this._normalizeSSL(G ?
								H + (H.includes("?") ? "\x26" : "?") + "token\x3d" + G : H)
						};
						K._requestToTypedArray = function(H, G, F) {
							return this._request(H, G)
								.then(L => {
									const R = E._resultsToTypedArray(F, {
										portal: this
									}, L);
									return Promise.all(R.map(V => "function" === typeof V.when ? V.when() : L))
										.then(() => R, () => R)
								})
						};
						K._readBasemap = function(H) {
							return H ? (H = z.fromJSON(H), H.portalItem = {
								portal: this
							}, H) : null
						};
						K._request = function(H, G = {}) {
							const F = {
									f: "json",
									...G.query
								},
								{
									authMode: L = this.authMode === E.AUTH_MODE_ANONYMOUS ? "anonymous" : "auto",
									body: R = null,
									cacheBust: V = !1,
									method: U = "auto",
									responseType: W = "json",
									signal: M
								} = G;
							G = {
								authMode: L,
								body: R,
								cacheBust: V,
								method: U,
								query: F,
								responseType: W,
								timeout: 0,
								signal: M
							};
							return k(this._normalizeSSL(H), G)
								.then(T => T.data)
						};
						J._resultsToTypedArray = function(H, G, F, L) {
							if (F) {
								const R = g.isSome(L) ? L.signal : null;
								F = F.listings || F.notifications || F.userInvitations || F.tags || F.items || F.groups || F.comments || F.provisions || F.results || F.relatedItems || F;
								if (H || G) F = F.map(V => {
									V = Object.assign(H ? H.fromJSON(V) : V, G);
									"function" === typeof V.load && V.load(R);
									return V
								})
							} else F = [];
							return F
						};
						b._createClass(J, [{
							key: "extraQuery",
							get: function() {
								const H = !(this.user && this.user.orgId) || this.canSearchPublic;
								return this.id && !H ? ` AND orgid:${this.id}` : null
							}
						}, {
							key: "isOrganization",
							get: function() {
								return !!this.access
							}
						}, {
							key: "itemPageUrl",
							get: function() {
								return this.url ? `${this.url}/home/item.html` : null
							}
						}, {
							key: "restUrl",
							get: function() {
								let H = this.url;
								if (H) {
									const G = H.indexOf("/sharing");
									H = 0 < G ? H.substring(0, G) : this.url.replace(/\/+$/, "");
									H += "/sharing/rest"
								}
								return H
							}
						}, {
							key: "thumbnailUrl",
							get: function() {
								const H = this.restUrl,
									G = this.thumbnail;
								return H && G ? this._normalizeSSL(H + "/portals/self/resources/" + G) : null
							}
						}]);
						return J
					}(m.JSONSupportMixin(f));
					m.AUTH_MODE_ANONYMOUS = "anonymous";
					m.AUTH_MODE_AUTO = "auto";
					m.AUTH_MODE_IMMEDIATE = "immediate";
					c.__decorate([r.property()], m.prototype, "access", void 0);
					c.__decorate([r.property()], m.prototype, "allSSL", void 0);
					c.__decorate([r.property()], m.prototype, "authMode", void 0);
					c.__decorate([r.property()], m.prototype, "authorizedCrossOriginDomains", void 0);
					c.__decorate([t.reader("authorizedCrossOriginDomains")], m.prototype, "readAuthorizedCrossOriginDomains", null);
					c.__decorate([r.property()], m.prototype, "basemapGalleryGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "bingKey", void 0);
					c.__decorate([r.property()], m.prototype, "canListApps", void 0);
					c.__decorate([r.property()], m.prototype, "canListData", void 0);
					c.__decorate([r.property()], m.prototype, "canListPreProvisionedItems", void 0);
					c.__decorate([r.property()], m.prototype, "canProvisionDirectPurchase",
						void 0);
					c.__decorate([r.property()], m.prototype, "canSearchPublic", void 0);
					c.__decorate([r.property()], m.prototype, "canShareBingPublic", void 0);
					c.__decorate([r.property()], m.prototype, "canSharePublic", void 0);
					c.__decorate([r.property()], m.prototype, "canSignInArcGIS", void 0);
					c.__decorate([r.property()], m.prototype, "canSignInIDP", void 0);
					c.__decorate([r.property()], m.prototype, "colorSetsGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "commentsEnabled", void 0);
					c.__decorate([r.property({
							type: Date
						})],
						m.prototype, "created", void 0);
					c.__decorate([r.property()], m.prototype, "credential", void 0);
					c.__decorate([r.property()], m.prototype, "culture", void 0);
					c.__decorate([r.property()], m.prototype, "currentVersion", void 0);
					c.__decorate([r.property()], m.prototype, "customBaseUrl", void 0);
					c.__decorate([r.property()], m.prototype, "defaultBasemap", void 0);
					c.__decorate([t.reader("defaultBasemap")], m.prototype, "readDefaultBasemap", null);
					c.__decorate([r.property()], m.prototype, "defaultDevBasemap", void 0);
					c.__decorate([t.reader("defaultDevBasemap")],
						m.prototype, "readDefaultDevBasemap", null);
					c.__decorate([r.property({
						type: q
					})], m.prototype, "defaultExtent", void 0);
					c.__decorate([r.property()], m.prototype, "defaultVectorBasemap", void 0);
					c.__decorate([t.reader("defaultVectorBasemap")], m.prototype, "readDefaultVectorBasemap", null);
					c.__decorate([r.property()], m.prototype, "description", void 0);
					c.__decorate([r.property()], m.prototype, "devBasemapGalleryGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "eueiEnabled", void 0);
					c.__decorate([r.property({
							readOnly: !0
						})],
						m.prototype, "extraQuery", null);
					c.__decorate([r.property()], m.prototype, "featuredGroups", void 0);
					c.__decorate([r.property()], m.prototype, "featuredItemsGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "galleryTemplatesGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "livingAtlasGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "hasCategorySchema", void 0);
					c.__decorate([r.property()], m.prototype, "helpBase", void 0);
					c.__decorate([r.property()], m.prototype, "helperServices",
						void 0);
					c.__decorate([r.property()], m.prototype, "helpMap", void 0);
					c.__decorate([r.property()], m.prototype, "homePageFeaturedContent", void 0);
					c.__decorate([r.property()], m.prototype, "homePageFeaturedContentCount", void 0);
					c.__decorate([r.property()], m.prototype, "httpPort", void 0);
					c.__decorate([r.property()], m.prototype, "httpsPort", void 0);
					c.__decorate([r.property()], m.prototype, "id", void 0);
					c.__decorate([r.property()], m.prototype, "ipCntryCode", void 0);
					c.__decorate([r.property({
							readOnly: !0
						})], m.prototype,
						"isOrganization", null);
					c.__decorate([r.property()], m.prototype, "isPortal", void 0);
					c.__decorate([r.property()], m.prototype, "isReadOnly", void 0);
					c.__decorate([r.property({
						readOnly: !0
					})], m.prototype, "itemPageUrl", null);
					c.__decorate([r.property()], m.prototype, "layerTemplatesGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "maxTokenExpirationMinutes", void 0);
					c.__decorate([r.property({
						type: Date
					})], m.prototype, "modified", void 0);
					c.__decorate([r.property()], m.prototype, "name", void 0);
					c.__decorate([r.property()],
						m.prototype, "portalHostname", void 0);
					c.__decorate([r.property()], m.prototype, "portalMode", void 0);
					c.__decorate([r.property()], m.prototype, "portalProperties", void 0);
					c.__decorate([r.property()], m.prototype, "region", void 0);
					c.__decorate([r.property({
						readOnly: !0
					})], m.prototype, "restUrl", null);
					c.__decorate([r.property()], m.prototype, "rotatorPanels", void 0);
					c.__decorate([r.property()], m.prototype, "showHomePageDescription", void 0);
					c.__decorate([r.property()], m.prototype, "sourceJSON", void 0);
					c.__decorate([r.property()],
						m.prototype, "staticImagesUrl", void 0);
					c.__decorate([r.property({
						json: {
							name: "2DStylesGroupQuery"
						}
					})], m.prototype, "stylesGroupQuery2d", void 0);
					c.__decorate([r.property({
						json: {
							name: "stylesGroupQuery"
						}
					})], m.prototype, "stylesGroupQuery3d", void 0);
					c.__decorate([r.property()], m.prototype, "supportsHostedServices", void 0);
					c.__decorate([r.property()], m.prototype, "symbolSetsGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "templatesGroupQuery", void 0);
					c.__decorate([r.property()], m.prototype, "thumbnail",
						void 0);
					c.__decorate([r.property({
						readOnly: !0
					})], m.prototype, "thumbnailUrl", null);
					c.__decorate([r.property()], m.prototype, "units", void 0);
					c.__decorate([r.property()], m.prototype, "url", void 0);
					c.__decorate([r.property()], m.prototype, "urlKey", void 0);
					c.__decorate([t.reader("urlKey")], m.prototype, "readUrlKey", null);
					c.__decorate([r.property()], m.prototype, "user", void 0);
					c.__decorate([t.reader("user")], m.prototype, "readUser", null);
					c.__decorate([r.property()], m.prototype, "useStandardizedQuery", void 0);
					c.__decorate([r.property()], m.prototype, "useVectorBasemaps", void 0);
					c.__decorate([r.property()], m.prototype, "vectorBasemapGalleryGroupQuery", void 0);
					return m = E = c.__decorate([h.subclass("esri.portal.Portal")], m)
				})
		},
		"esri/kernel": function() {
			define("require exports ./chunks/_rollupPluginBabelHelpers ./core/has ./core/urlUtils ./support/revision".split(" "), function(a, b, c, e, d, k) {
				b.id = void 0;
				e("host-webworker") || console.debug(`Using ArcGIS API for JavaScript ${"4.25"} [Date: ${k.buildDate}, Revision: ${k.commitHash.slice(0,
8)}]`);
				b.buildDate = k.buildDate;
				b.revision = k.commitHash;
				b.addTokenParameter = function(v) {
					const m = b.id && b.id.findCredential(v);
					return m && m.token ? d.addQueryParameter(v, "token", m.token) : v
				};
				b.setId = function(v) {
					b.id = v
				};
				b.version = "4.25";
				b.workerMessages = {
					request(v, m) {
						return c._asyncToGenerator(function*() {
							var {
								default: f
							} = yield new Promise((r, p) => a(["./request"], n => r(Object.freeze(Object.defineProperty({
								__proto__: null,
								default: n
							}, Symbol.toStringTag, {
								value: "Module"
							}))), p)), g = v.options;
							const l = g.responseType;
							g.signal = m ? .signal;
							g.responseType = "native" === l || "native-request-init" === l ? "native-request-init" : l && ["blob", "json", "text"].includes(l) && d.getInterceptor(v.url) ? .after ? l : "array-buffer";
							f = yield f(v.url, g);
							g = {
								data: f.data,
								ssl: f.ssl
							};
							switch (f.requestOptions ? .responseType) {
								case "native-request-init":
									return delete g.data.signal, g;
								case "blob":
									g.data = yield g.data.arrayBuffer();
									break;
								case "json":
									g.data = (new TextEncoder)
										.encode(JSON.stringify(g.data))
										.buffer;
									break;
								case "text":
									g.data = (new TextEncoder)
										.encode(g.data)
										.buffer
							}
							return {
								result: g,
								transferList: [g.data]
							}
						})()
					}
				};
				Object.defineProperties(b, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/revision": function() {
			define(["exports"], function(a) {
				a.buildDate = "20221121";
				a.commitHash = "f520630575ed53cf8b49e5f1492799065ee366e5";
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/request": function() {
			define("require ./chunks/_rollupPluginBabelHelpers ./config ./kernel ./core/Error ./core/has ./core/lang ./core/maybe ./core/promiseUtils ./core/urlUtils ./portal/support/urlUtils ./support/apiKeyUtils ./support/requestUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					function n(da, ja) {
						return t.apply(this, arguments)
					}

					function t() {
						t = b._asyncToGenerator(function*(da, ja) {
							var sa = g.isDataProtocol(da);
							const I = g.isBlobProtocol(da);
							I || sa || (da = g.normalize(da));
							const N = {
								url: da,
								requestOptions: {
									...m.unwrap(ja)
								}
							};
							let ea = g.getInterceptor(da);
							if (ea) {
								da = yield J(ea, N);
								if (null != da) return {
									data: da,
									getHeader: Aa,
									requestOptions: N.requestOptions,
									url: N.url
								};
								ea.after || ea.error || (ea = null)
							}
							da = N.url;
							ja = N.requestOptions;
							if ("image" === ja.responseType) {
								if (k("host-webworker") ||
									k("host-node")) throw u("request:invalid-parameters", Error("responseType 'image' is not supported in Web Workers or Node environment"), N);
							} else if (sa) throw u("request:invalid-parameters", Error("Data URLs are not supported for responseType \x3d " + ja.responseType), N);
							if ("head" === ja.method) {
								if (ja.body) throw u("request:invalid-parameters", Error("body parameter cannot be set when method is 'head'"), N);
								if (sa || I) throw u("request:invalid-parameters", Error("data and blob URLs are not supported for method 'head'"),
									N);
							}
							yield x();
							if (W) return W.execute(da, ja);
							const pa = new AbortController;
							f.onAbort(ja, () => pa.abort());
							sa = yield F({
								controller: pa,
								credential: void 0,
								credentialToken: void 0,
								fetchOptions: void 0,
								hasToken: !1,
								interceptor: ea,
								params: N,
								redoRequest: !1,
								useIdentity: M.useIdentity,
								useProxy: !1,
								useSSL: !1,
								withCredentials: !1
							});
							ea ? .after ? .(sa);
							return sa
						});
						return t.apply(this, arguments)
					}

					function h(da) {
						(da = g.getOrigin(da)) && !n._corsServers.includes(da) && n._corsServers.push(da)
					}

					function q(da) {
						da = g.getOrigin(da);
						return !da ||
							da.endsWith(".arcgis.com") || n._corsServers.includes(da) || g.isTrustedServer(da)
					}

					function u(da, ja, sa, I) {
						let N = "Error";
						const ea = {
							url: sa.url,
							requestOptions: sa.requestOptions,
							getHeader: Aa,
							ssl: !1
						};
						if (ja instanceof d) return ja.details ? (ja.details = v.clone(ja.details), ja.details.url = sa.url, ja.details.requestOptions = sa.requestOptions) : ja.details = ea, ja;
						if (ja) {
							sa = I && (S => I.headers.get(S));
							const pa = I && I.status,
								xa = ja.message;
							xa && (N = xa);
							sa && (ea.getHeader = sa);
							ea.httpStatus = (null != ja.httpCode ? ja.httpCode : ja.code) ||
								pa || 0;
							ea.subCode = ja.subcode;
							ea.messageCode = ja.messageCode;
							ea.messages = "string" === typeof ja.details ? [ja.details] : ja.details;
							ea.raw = Ka in ja ? ja[Ka] : ja
						}
						return f.isAbortError(ja) ? f.createAbortError() : new d(da, N, ea)
					}

					function x() {
						return y.apply(this, arguments)
					}

					function y() {
						y = b._asyncToGenerator(function*() {
							k("host-webworker") ? W || (W = yield new Promise((da, ja) => a(["./core/workers/request"], da, ja))) : n._abortableFetch || (n._abortableFetch = globalThis.fetch.bind(globalThis))
						});
						return y.apply(this, arguments)
					}

					function w() {
						return A.apply(this,
							arguments)
					}

					function A() {
						A = b._asyncToGenerator(function*() {
							e.id || (yield new Promise((da, ja) => a(["./identity/IdentityManager"], sa => da(Object.freeze(Object.defineProperty({
								__proto__: null,
								default: sa
							}, Symbol.toStringTag, {
								value: "Module"
							}))), ja)))
						});
						return A.apply(this, arguments)
					}

					function B(da) {
						return E.apply(this, arguments)
					}

					function E() {
						E = b._asyncToGenerator(function*(da) {
							const ja = da.params.url,
								sa = da.params.requestOptions,
								I = da.controller.signal,
								N = sa.body;
							let ea = null,
								pa = null;
							T && "HTMLFormElement" in globalThis &&
								(N instanceof FormData ? ea = N : N instanceof HTMLFormElement && (ea = new FormData(N)));
							"string" === typeof N && (pa = N);
							da.fetchOptions = {
								cache: sa.cacheBust && !n._abortableFetch.polyfill ? "no-cache" : "default",
								credentials: "same-origin",
								headers: sa.headers || {},
								method: "head" === sa.method ? "HEAD" : "GET",
								mode: "cors",
								priority: M.priority,
								redirect: "follow",
								signal: I
							};
							if (ea || pa) da.fetchOptions.body = ea || pa;
							"anonymous" === sa.authMode && (da.useIdentity = !1);
							da.hasToken = !!(/token=/i.test(ja) || sa.query ? .token || ea ? .get("token"));
							!da.hasToken &&
								c.apiKey && r.supportsApiKey(ja) && (sa.query || (sa.query = {}), sa.query.token = c.apiKey, da.hasToken = !0);
							if (da.useIdentity && !da.hasToken && !da.credentialToken && !z(ja) && !f.isAborted(I)) {
								let xa;
								"immediate" === sa.authMode ? (yield w(), xa = yield e.id.getCredential(ja, {
									signal: I
								}), da.credential = xa) : "no-prompt" === sa.authMode ? (yield w(), xa = yield e.id.getCredential(ja, {
										prompt: !1,
										signal: I
									})
									.catch(() => {}), da.credential = xa) : e.id && (xa = e.id.findCredential(ja));
								xa && (da.credentialToken = xa.token, da.useSSL = !!xa.ssl)
							}
						});
						return E.apply(this,
							arguments)
					}

					function z(da) {
						return qa.some(ja => ja.test(da))
					}

					function C(da) {
						return D.apply(this, arguments)
					}

					function D() {
						D = b._asyncToGenerator(function*(da) {
							let ja = da.params.url;
							const sa = da.params.requestOptions,
								I = da.fetchOptions ? ? {},
								N = g.isBlobProtocol(ja) || g.isDataProtocol(ja),
								ea = sa.responseType || "json";
							var pa = N ? 0 : null != sa.timeout ? sa.timeout : M.timeout,
								xa = !1;
							if (!N) {
								da.useSSL && (ja = g.toHTTPS(ja));
								sa.cacheBust && "default" === I.cache && (ja = g.addQueryParameter(ja, "request.preventCache", Date.now()));
								var S = {
									...sa.query
								};
								da.credentialToken && (S.token = da.credentialToken);
								xa = g.objectToQuery(S);
								k("esri-url-encodes-apostrophe") && (xa = xa.replace(/'/g, "%27"));
								const P = ja.length + 1 + xa.length;
								xa = "delete" === sa.method || "post" === sa.method || "put" === sa.method || !!sa.body || P > M.maxUrlLength;
								const ca = sa.useProxy || !!g.getProxyRule(ja);
								if (ca) {
									const ka = g.getProxyUrl(ja);
									var ba = ka.path;
									!xa && ba.length + 1 + P > M.maxUrlLength && (xa = !0);
									ka.query && (S = {
										...ka.query,
										...S
									})
								}
								if ("HEAD" === I.method && (xa || ca)) {
									if (xa) {
										if (P > M.maxUrlLength) throw u("request:invalid-parameters",
											Error("URL exceeds maximum length"), da.params);
										throw u("request:invalid-parameters", Error("cannot use POST request when method is 'head'"), da.params);
									}
									if (ca) throw u("request:invalid-parameters", Error("cannot use proxy when method is 'head'"), da.params);
								}
								xa ? (I.method = "delete" === sa.method ? "DELETE" : "put" === sa.method ? "PUT" : "POST", sa.body ? ja = g.addQueryParameters(ja, S) : (I.body = g.objectToQuery(S), I.headers || (I.headers = {}), I.headers["Content-Type"] = "application/x-www-form-urlencoded")) : ja = g.addQueryParameters(ja,
									S);
								ca && (da.useProxy = !0, ja = `${ba}?${ja}`);
								S.token && T && I.body instanceof FormData && !l.isSecureProxyService(ja) && I.body.set("token", S.token);
								sa.hasOwnProperty("withCredentials") ? da.withCredentials = sa.withCredentials : g.hasSameOrigin(ja, g.getAppUrl()) || (g.isTrustedServer(ja) ? da.withCredentials = !0 : e.id && (ba = e.id.findServerInfo(ja)) && ba.webTierAuth && (da.withCredentials = !0));
								da.withCredentials && (I.credentials = "include", p.isNoCorsRequestRequired(ja) && (yield p.sendNoCorsRequest(xa ? g.addQueryParameters(ja, S) :
									ja)))
							}
							S = 0;
							let la = !1;
							0 < pa && (S = setTimeout(() => {
								la = !0;
								da.controller.abort()
							}, pa));
							pa = void 0;
							let ha;
							try {
								if ("native-request-init" === sa.responseType) ha = I, ha.url = ja;
								else if ("image" !== sa.responseType || "default" !== I.cache || "GET" !== I.method || xa || H(sa.headers) || !N && !da.useProxy && M.proxyUrl && !q(ja))
									if (pa = yield n._abortableFetch(ja, I), da.useProxy || h(ja), "native" === sa.responseType) ha = pa;
									else {
										if ("HEAD" !== I.method)
											if (pa.ok) {
												switch (ea) {
													case "array-buffer":
														ha = yield pa.arrayBuffer();
														break;
													case "blob":
													case "image":
														ha =
															yield pa.blob();
														break;
													default:
														ha = yield pa.text()
												}
												S && (clearTimeout(S), S = 0);
												if ("json" === ea || "xml" === ea || "document" === ea)
													if (ha) switch (ea) {
														case "json":
															ha = JSON.parse(ha);
															break;
														case "xml":
															ha = G(ha, "application/xml");
															break;
														case "document":
															ha = G(ha, "text/html")
													} else ha = null;
												if (ha) {
													if ("array-buffer" === ea || "blob" === ea) {
														const P = pa.headers.get("Content-Type");
														if (P && /application\/json|text\/plain/i.test(P) && 750 >= ha["blob" === ea ? "size" : "byteLength"]) try {
															const ca = yield(new Response(ha))
																.json();
															ca.error && (ha = ca)
														} catch {}
													}
													"image" ===
													ea && ha instanceof Blob && (ha = yield U(URL.createObjectURL(ha), da, !0))
												}
											} else ha = yield pa.text()
									}
								else ha = yield U(ja, da)
							} catch (P) {
								if ("AbortError" === P.name) {
									if (la) throw Error("Timeout exceeded");
									throw f.createAbortError("Request canceled");
								}
								if (!pa && P instanceof TypeError && M.proxyUrl && !sa.body && "delete" !== sa.method && "head" !== sa.method && "post" !== sa.method && "put" !== sa.method && !da.useProxy && !q(ja)) da.redoRequest = !0, g.addProxyRule({
									proxyUrl: M.proxyUrl,
									urlPrefix: g.getOrigin(ja) ? ? ""
								});
								else throw P;
							} finally {
								S &&
									clearTimeout(S)
							}
							return [pa, ha]
						});
						return D.apply(this, arguments)
					}

					function J(da, ja) {
						return K.apply(this, arguments)
					}

					function K() {
						K = b._asyncToGenerator(function*(da, ja) {
							if (null != da.responseData) return da.responseData;
							da.headers && (ja.requestOptions.headers = {
								...ja.requestOptions.headers,
								...da.headers
							});
							da.query && (ja.requestOptions.query = {
								...ja.requestOptions.query,
								...da.query
							});
							if (da.before) {
								let sa, I;
								try {
									I = yield da.before(ja)
								} catch (N) {
									sa = u("request:interceptor", N, ja)
								}
								if (I instanceof Error || I instanceof d) sa =
									u("request:interceptor", I, ja);
								if (sa) throw da.error && da.error(sa), sa;
								return I
							}
						});
						return K.apply(this, arguments)
					}

					function H(da) {
						if (da)
							for (const ja of Object.getOwnPropertyNames(da))
								if (da[ja]) return !0;
						return !1
					}

					function G(da, ja) {
						let sa;
						try {
							sa = (new DOMParser)
								.parseFromString(da, ja)
						} catch {}
						if (!sa || sa.getElementsByTagName("parsererror")
							.length) throw new SyntaxError("XML Parse error");
						return sa
					}

					function F(da) {
						return L.apply(this, arguments)
					}

					function L() {
						L = b._asyncToGenerator(function*(da) {
							yield B(da);
							let ja;
							try {
								do [ja, sa] = yield C(da); while (!(yield R(da, ja, sa)))
							} catch (ea) {
								var sa = u("request:server", ea, da.params, ja);
								sa.details.ssl = da.useSSL;
								da.interceptor && da.interceptor.error && da.interceptor.error(sa);
								throw sa;
							}
							var I = da.params.url;
							sa && /\/sharing\/rest\/(accounts|portals)\/self/i.test(I) && (da.hasToken || da.credentialToken || !sa.user ? .username || g.isTrustedServer(I) || (I = g.getOrigin(I, !0)) && M.trustedServers.push(I), Array.isArray(sa.authorizedCrossOriginNoCorsDomains) && p.registerNoCorsDomains(sa.authorizedCrossOriginNoCorsDomains));
							if ((I = da.credential) && e.id) {
								var N = e.id.findServerInfo(I.server);
								if (N = N && N.owningSystemUrl) N = N.replace(/\/?$/, "/sharing"), (I = e.id.findCredential(N, I.userId)) && -1 === e.id._getIdenticalSvcIdx(N, I) && I.resources.unshift(N)
							}
							return {
								data: sa,
								getHeader: ja ? ea => ja ? .headers.get(ea) : Aa,
								requestOptions: da.params.requestOptions,
								ssl: da.useSSL,
								url: da.params.url
							}
						});
						return L.apply(this, arguments)
					}

					function R(da, ja, sa) {
						return V.apply(this, arguments)
					}

					function V() {
						V = b._asyncToGenerator(function*(da, ja, sa) {
							if (da.redoRequest) return da.redoRequest = !1;
							var I = da.params.requestOptions;
							if (!ja || "native" === I.responseType || "native-request-init" === I.responseType) return !0;
							let N;
							if (!ja.ok) throw N = Error(`Unable to load ${ja.url} status: ${ja.status}`), N[Ka] = sa, N;
							sa && (sa.error ? N = sa.error : "error" === sa.status && Array.isArray(sa.messages) && (N = {
								...sa
							}, N[Ka] = sa, N.details = sa.messages));
							let ea;
							ja = null;
							let pa;
							N && (ea = Number(N.code), ja = N.hasOwnProperty("subcode") ? Number(N.subcode) : null, pa = (pa = N.messageCode) && pa.toUpperCase());
							I = I.authMode;
							if (403 === ea && (4 === ja || N.message &&
								N.message.toLowerCase()
								.includes("ssl") && !N.message.toLowerCase()
								.includes("permission"))) {
								if (!da.useSSL) return da.useSSL = !0, !1
							} else if (!da.hasToken && da.useIdentity && ("no-prompt" !== I || 498 === ea) && void 0 !== ea && Z.includes(ea) && !z(da.params.url) && (403 !== ea || pa && !oa.includes(pa) && (null == ja || 2 === ja && da.credentialToken))) {
								yield w();
								try {
									const xa = yield e.id.getCredential(da.params.url, {
										error: u("request:server", N, da.params),
										prompt: "no-prompt" !== I,
										signal: da.controller.signal,
										token: da.credentialToken
									});
									da.credential =
										xa;
									da.credentialToken = xa.token;
									da.useSSL = da.useSSL || xa.ssl;
									return !1
								} catch (xa) {
									if ("no-prompt" === I) return da.credential = void 0, da.credentialToken = void 0, !1;
									N = xa
								}
							}
							if (N) throw N;
							return !0
						});
						return V.apply(this, arguments)
					}

					function U(da, ja, sa = !1) {
						const I = ja.controller.signal,
							N = new Image;
						N.crossOrigin = ja.withCredentials ? "use-credentials" : "anonymous";
						N.alt = "";
						N.fetchPriority = M.priority;
						N.src = da;
						return p.loadImageAsync(N, da, sa, I)
					}
					let W;
					const M = c.request,
						T = "FormData" in globalThis,
						Z = [499, 498, 403, 401],
						oa = ["COM_0056",
							"COM_0057", "SB_0008"
						],
						qa = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i],
						Aa = () => null,
						Ka = Symbol();
					n._abortableFetch = null;
					n._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];
					return n
				})
		},
		"esri/portal/support/urlUtils": function() {
			define(["exports"], function(a) {
				const b = /^https:\/\/([a-z\d-]+)(\.maps([^.]*))?\.arcgis\.com/i,
					c = {
						devext: {
							customBaseUrl: "mapsdevext.arcgis.com",
							portalHostname: "devext.arcgis.com"
						},
						qaext: {
							customBaseUrl: "mapsqa.arcgis.com",
							portalHostname: "qaext.arcgis.com"
						},
						www: {
							customBaseUrl: "maps.arcgis.com",
							portalHostname: "www.arcgis.com"
						}
					};
				a.isSecureProxyService = function(e) {
					return /\/(sharing|usrsvcs)\/(appservices|servers)\//i.test(e)
				};
				a.parseKnownArcGISOnlineDomain = function(e) {
					e = e ? .match(b);
					if (!e) return null;
					const [, d, k, v] = e;
					if (!d) return null;
					let m = e = null,
						f = null;
					const {
						devext: g,
						qaext: l,
						www: r
					} = c;
					if (k)
						if (e = d, v) switch (v.toLowerCase()) {
							case "devext":
								({
									customBaseUrl: m,
									portalHostname: f
								} = g);
								break;
							case "qa":
								({
										customBaseUrl: m,
										portalHostname: f
									} =
									l);
								break;
							default:
								return null
						} else({
							customBaseUrl: m,
							portalHostname: f
						} = r);
						else switch (d.toLowerCase()) {
							case "devext":
								({
									customBaseUrl: m,
									portalHostname: f
								} = g);
								break;
							case "qaext":
								({
									customBaseUrl: m,
									portalHostname: f
								} = l);
								break;
							case "www":
								({
									customBaseUrl: m,
									portalHostname: f
								} = r);
								break;
							default:
								return null
						}
					return {
						customBaseUrl: m,
						isPortal: !1,
						portalHostname: f,
						urlKey: e
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/apiKeyUtils": function() {
			define(["exports",
				"../core/urlUtils"
			], function(a, b) {
				const c = ["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"];
				a.isApiKey = function(e) {
					return !!e && 4 < e.length && e.startsWith("AAPK")
				};
				a.supportsApiKey = function(e) {
					const d = b.getOrigin(e, !0);
					return d ? d.endsWith(".arcgis.com") && !c.includes(d) && !e.endsWith("/sharing/rest/generateToken") : !1
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/requestUtils": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../config ../core/has ../core/maybe ../core/promiseUtils ../core/urlUtils".split(" "),
				function(a, b, c, e, d, k, v) {
					function m() {
						try {
							return new DOMException("Aborted", "AbortError")
						} catch {
							const g = Error();
							g.name = "AbortError";
							return g
						}
					}

					function f() {
						f = b._asyncToGenerator(function*(g) {
							var l = c.request.crossOriginNoCorsDomains;
							const r = v.getOrigin(g);
							l && r && (l[r.toLowerCase()] = Date.now());
							l = v.urlToObject(g);
							g = l.path;
							"json" === l.query ? .f && (g += "?f\x3djson");
							try {
								yield fetch(g, {
									mode: "no-cors",
									credentials: "include"
								})
							} catch {}
						});
						return f.apply(this, arguments)
					}
					a.isNoCorsRequestRequired = function(g) {
						const l =
							c.request.crossOriginNoCorsDomains;
						return l && (g = v.getOrigin(g)) ? (g = g.toLowerCase(), !v.hasSameOrigin(g, v.getAppUrl()) && l[g] < Date.now() - 36E5) : !1
					};
					a.loadImageAsync = function(g, l, r = !1, p) {
						return new Promise((n, t) => {
							if (k.isAborted(p)) t(m());
							else {
								var h = () => {
										x();
										t(Error(`Unable to load ${l}`))
									},
									q = () => {
										const y = g;
										x();
										n(y)
									},
									u = () => {
										if (g) {
											var y = g;
											x();
											y.src = "";
											t(m())
										}
									},
									x = () => {
										e("esri-image-decode") || (g.removeEventListener("error", h), g.removeEventListener("load", q));
										g = q = h = null;
										d.isSome(p) && p.removeEventListener("abort",
											u);
										u = null;
										r && URL.revokeObjectURL(l)
									};
								d.isSome(p) && p.addEventListener("abort", u);
								e("esri-image-decode") ? g.decode()
									.then(q, h) : (g.addEventListener("error", h), g.addEventListener("load", q))
							}
						})
					};
					a.registerNoCorsDomains = function(g) {
						c.request.crossOriginNoCorsDomains || (c.request.crossOriginNoCorsDomains = {});
						const l = c.request.crossOriginNoCorsDomains;
						for (let r of g) r = r.toLowerCase(), /^https?:\/\//.test(r) ? l[v.getOrigin(r) ? ? ""] = 0 : (l[v.getOrigin("http://" + r) ? ? ""] = 0, l[v.getOrigin("https://" + r) ? ? ""] = 0)
					};
					a.sendNoCorsRequest =
						function(g) {
							return f.apply(this, arguments)
						};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/accessorSupport/decorators/reader": function() {
			define(["exports", "./property"], function(a, b) {
				a.reader = function(c, e, d) {
					let k, v;
					void 0 === e || Array.isArray(e) ? (v = c, d = e, k = [void 0]) : (v = e, k = Array.isArray(c) ? c : [c]);
					return (m, f) => {
						const g = m.constructor.prototype;
						k.forEach(l => {
							l = b.propertyJSONMeta(m, l, v);
							l.read && "object" === typeof l.read || (l.read = {});
							l.read.reader =
								g[f];
							d && (l.read.source = (l.read.source || [])
								.concat(d))
						})
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/Extent": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/maybe ../core/string ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./Geometry ./Point ./SpatialReference ./support/contains ./support/intersectsBase ./support/spatialReferenceUtils ./support/webMercatorUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					function h(u, x, y) {
						return null == x ? y : null == y ? x : u(x, y)
					}
					var q;
					k = q = function(u) {
						function x(...w) {
							w = u.call(this, ...w) || this;
							w.type = "extent";
							w.xmin = 0;
							w.ymin = 0;
							w.mmin = void 0;
							w.zmin = void 0;
							w.xmax = 0;
							w.ymax = 0;
							w.mmax = void 0;
							w.zmax = void 0;
							return w
						}
						a._inheritsLoose(x, u);
						var y = x.prototype;
						y.normalizeCtorArgs = function(w, A, B, E, z) {
							return !w || "esri.geometry.SpatialReference" !== w.declaredClass && null == w.wkid ? "object" === typeof w ? (w.spatialReference = null == w.spatialReference ? l.WGS84 :
								w.spatialReference, w) : {
								xmin: w,
								ymin: A,
								xmax: B,
								ymax: E,
								spatialReference: null == z ? l.WGS84 : z
							} : {
								spatialReference: w,
								xmin: 0,
								ymin: 0,
								xmax: 0,
								ymax: 0
							}
						};
						x.fromBounds = function(w, A) {
							return new q({
								xmin: w[0],
								ymin: w[1],
								xmax: w[2],
								ymax: w[3],
								spatialReference: A
							})
						};
						x.fromPoint = function(w) {
							return new q({
								xmin: w.x,
								ymin: w.y,
								zmin: w.z,
								xmax: w.x,
								ymax: w.y,
								zmax: w.z,
								spatialReference: w.spatialReference
							})
						};
						y.centerAt = function(w) {
							const A = this.center;
							return null != w.z && this.hasZ ? this.offset(w.x - A.x, w.y - A.y, w.z - A.z) : this.offset(w.x - A.x, w.y -
								A.y)
						};
						y.clone = function() {
							const w = new q;
							w.xmin = this.xmin;
							w.ymin = this.ymin;
							w.xmax = this.xmax;
							w.ymax = this.ymax;
							w.spatialReference = this.spatialReference;
							null != this.zmin && (w.zmin = this.zmin, w.zmax = this.zmax);
							null != this.mmin && (w.mmin = this.mmin, w.mmax = this.mmax);
							return w
						};
						y.contains = function(w) {
							if (!w) return !1;
							const A = this.spatialReference,
								B = w.spatialReference;
							A && B && !A.equals(B) && t.canProject(A, B) && (w = A.isWebMercator ? t.geographicToWebMercator(w) : t.webMercatorToGeographic(w, !0));
							return "point" === w.type ? r.extentContainsPoint(this,
								w) : "extent" === w.type ? r.extentContainsExtent(this, w) : !1
						};
						y.equals = function(w) {
							if (this === w) return !0;
							if (c.isNone(w)) return !1;
							const A = this.spatialReference,
								B = w.spatialReference;
							A && B && !A.equals(B) && t.canProject(A, B) && (w = A.isWebMercator ? t.geographicToWebMercator(w) : t.webMercatorToGeographic(w, !0));
							return this.xmin === w.xmin && this.ymin === w.ymin && this.zmin === w.zmin && this.mmin === w.mmin && this.xmax === w.xmax && this.ymax === w.ymax && this.zmax === w.zmax && this.mmax === w.mmax
						};
						y.expand = function(w) {
							w = .5 * (1 - w);
							var A = this.width *
								w;
							const B = this.height * w;
							this.xmin += A;
							this.ymin += B;
							this.xmax -= A;
							this.ymax -= B;
							this.hasZ && (A = (this.zmax - this.zmin) * w, this.zmin += A, this.zmax -= A);
							this.hasM && (w *= this.mmax - this.mmin, this.mmin += w, this.mmax -= w);
							return this
						};
						y.intersects = function(w) {
							if (c.isNone(w)) return !1;
							"mesh" === w.type && (w = w.extent);
							const A = this.spatialReference,
								B = w.spatialReference;
							A && B && !n.equals(A, B) && t.canProject(A, B) && (w = A.isWebMercator ? t.geographicToWebMercator(w) : t.webMercatorToGeographic(w, !0));
							return p.getFeatureExtentIntersector(w.type)(this,
								w)
						};
						y.normalize = function() {
							const w = this._normalize(!1, !0);
							return Array.isArray(w) ? w : [w]
						};
						y.offset = function(w, A, B) {
							this.xmin += w;
							this.ymin += A;
							this.xmax += w;
							this.ymax += A;
							null != B && (this.zmin += B, this.zmax += B);
							return this
						};
						y.shiftCentralMeridian = function() {
							return this._normalize(!0)
						};
						y.union = function(w) {
							if (this === w) return this;
							this.xmin = Math.min(this.xmin, w.xmin);
							this.ymin = Math.min(this.ymin, w.ymin);
							this.xmax = Math.max(this.xmax, w.xmax);
							this.ymax = Math.max(this.ymax, w.ymax);
							if (this.hasZ || w.hasZ) this.zmin =
								h(Math.min, this.zmin, w.zmin), this.zmax = h(Math.max, this.zmax, w.zmax);
							if (this.hasM || w.hasM) this.mmin = h(Math.min, this.mmin, w.mmin), this.mmax = h(Math.max, this.mmax, w.mmax);
							return this
						};
						y.intersection = function(w) {
							if (this === w) return this;
							if (c.isNone(w) || !this.intersects(w)) return null;
							this.xmin = Math.max(this.xmin, w.xmin);
							this.ymin = Math.max(this.ymin, w.ymin);
							this.xmax = Math.min(this.xmax, w.xmax);
							this.ymax = Math.min(this.ymax, w.ymax);
							if (this.hasZ || w.hasZ) this.zmin = h(Math.max, this.zmin, w.zmin), this.zmax = h(Math.min,
								this.zmax, w.zmax);
							if (this.hasM || w.hasM) this.mmin = h(Math.max, this.mmin, w.mmin), this.mmax = h(Math.min, this.mmax, w.mmax);
							return this
						};
						y.toJSON = function(w) {
							return this.write({}, w)
						};
						y._shiftCM = function(w = n.getInfo(this.spatialReference)) {
							if (!w || !this.spatialReference) return this;
							const A = this.spatialReference,
								B = this._getCM(w);
							if (B) {
								const E = A.isWebMercator ? t.webMercatorToGeographic(B) : B;
								this.xmin -= B.x;
								this.xmax -= B.x;
								A.isWebMercator || (E.x = this._normalizeX(E.x, w)
									.x);
								this.spatialReference = new l(e.replace((A.isWGS84 ?
									w.altTemplate : null) ? ? w.wkTemplate, {
									Central_Meridian: E.x
								}))
							}
							return this
						};
						y._getCM = function(w) {
							let A = null;
							const [B, E] = w.valid;
							w = this.xmin;
							const z = this.xmax;
							w >= B && w <= E && z >= B && z <= E || (A = this.center);
							return A
						};
						y._normalize = function(w, A, B) {
							const E = this.spatialReference;
							if (!E) return this;
							B = B ? ? n.getInfo(E);
							if (null == B) return this;
							const z = this._getParts(B)
								.map(J => J.extent);
							if (2 > z.length) return z[0] || this;
							if (2 < z.length) return w ? this._shiftCM(B) : this.set({
								xmin: B.valid[0],
								xmax: B.valid[1]
							});
							if (w) return this._shiftCM(B);
							if (A) return z;
							let C = !0,
								D = !0;
							z.forEach(J => {
								J.hasZ || (C = !1);
								J.hasM || (D = !1)
							});
							return {
								rings: z.map(J => {
									const K = [
										[J.xmin, J.ymin],
										[J.xmin, J.ymax],
										[J.xmax, J.ymax],
										[J.xmax, J.ymin],
										[J.xmin, J.ymin]
									];
									if (C) {
										var H = (J.zmax - J.zmin) / 2;
										for (let G = 0; G < K.length; G++) K[G].push(H)
									}
									if (D)
										for (J = (J.mmax - J.mmin) / 2, H = 0; H < K.length; H++) K[H].push(J);
									return K
								}),
								hasZ: C,
								hasM: D,
								spatialReference: E
							}
						};
						y._getParts = function(w) {
							let A = this.cache._parts;
							if (!A) {
								A = [];
								const {
									ymin: H,
									ymax: G,
									spatialReference: F
								} = this;
								var B = this.width,
									E = this.xmin,
									z =
									this.xmax;
								w = w || n.getInfo(F);
								const [L, R] = w.valid;
								var C = this._normalizeX(this.xmin, w);
								var D = C.x,
									J = C.frameId;
								C = this._normalizeX(this.xmax, w);
								w = C.x;
								C = C.frameId;
								var K = D === w && 0 < B;
								if (B > 2 * R) {
									B = new q(E < z ? D : w, H, R, G, F);
									E = new q(L, H, E < z ? w : D, G, F);
									z = new q(0, H, R, G, F);
									D = new q(L, H, 0, G, F);
									w = [];
									K = [];
									B.contains(z) && w.push(J);
									B.contains(D) && K.push(J);
									E.contains(z) && w.push(C);
									E.contains(D) && K.push(C);
									for (let V = J + 1; V < C; V++) w.push(V), K.push(V);
									A.push({
										extent: B,
										frameIds: [J]
									}, {
										extent: E,
										frameIds: [C]
									}, {
										extent: z,
										frameIds: w
									}, {
										extent: D,
										frameIds: K
									})
								} else D > w || K ? A.push({
									extent: new q(D, H, R, G, F),
									frameIds: [J]
								}, {
									extent: new q(L, H, w, G, F),
									frameIds: [C]
								}) : A.push({
									extent: new q(D, H, w, G, F),
									frameIds: [J]
								});
								this.cache._parts = A
							}
							C = this.hasZ;
							B = this.hasM;
							if (C || B)
								for (J = {}, C && (J.zmin = this.zmin, J.zmax = this.zmax), B && (J.mmin = this.mmin, J.mmax = this.mmax), C = 0; C < A.length; C++) A[C].extent.set(J);
							return A
						};
						y._normalizeX = function(w, A) {
							const [B, E] = A.valid;
							A = 2 * E;
							var z = 0;
							w > E ? (z = Math.ceil(Math.abs(w - E) / A), w -= z * A) : w < B && (z = Math.ceil(Math.abs(w - B) / A), w += z * A, z = -z);
							return {
								x: w,
								frameId: z
							}
						};
						a._createClass(x, [{
							key: "cache",
							get: function() {
								this.commitProperty("xmin");
								this.commitProperty("ymin");
								this.commitProperty("zmin");
								this.commitProperty("mmin");
								this.commitProperty("xmax");
								this.commitProperty("ymax");
								this.commitProperty("zmax");
								this.commitProperty("mmax");
								this.commitProperty("spatialReference");
								return {}
							}
						}, {
							key: "center",
							get: function() {
								const w = new g({
									x: .5 * (this.xmin + this.xmax),
									y: .5 * (this.ymin + this.ymax),
									spatialReference: this.spatialReference
								});
								this.hasZ && (w.z = .5 * (this.zmin +
									this.zmax));
								this.hasM && (w.m = .5 * (this.mmin + this.mmax));
								return w
							}
						}, {
							key: "extent",
							get: function() {
								return this.clone()
							}
						}, {
							key: "hasM",
							get: function() {
								return null != this.mmin && null != this.mmax
							}
						}, {
							key: "hasZ",
							get: function() {
								return null != this.zmin && null != this.zmax
							}
						}, {
							key: "height",
							get: function() {
								return Math.abs(this.ymax - this.ymin)
							}
						}, {
							key: "width",
							get: function() {
								return Math.abs(this.xmax - this.xmin)
							}
						}]);
						return x
					}(f);
					b.__decorate([d.property({
						readOnly: !0
					})], k.prototype, "cache", null);
					b.__decorate([d.property({
							readOnly: !0
						})],
						k.prototype, "center", null);
					b.__decorate([d.property({
						readOnly: !0
					})], k.prototype, "extent", null);
					b.__decorate([d.property({
						readOnly: !0,
						json: {
							write: {
								enabled: !1,
								overridePolicy: null
							}
						}
					})], k.prototype, "hasM", null);
					b.__decorate([d.property({
						readOnly: !0,
						json: {
							write: {
								enabled: !1,
								overridePolicy: null
							}
						}
					})], k.prototype, "hasZ", null);
					b.__decorate([d.property({
						readOnly: !0
					})], k.prototype, "height", null);
					b.__decorate([d.property({
						readOnly: !0
					})], k.prototype, "width", null);
					b.__decorate([d.property({
						type: Number,
						json: {
							type: [Number,
								String
							],
							write: {
								enabled: !0,
								allowNull: !0
							}
						}
					})], k.prototype, "xmin", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "ymin", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							origins: {
								"web-scene": {
									write: !1
								}
							},
							write: {
								overridePolicy() {
									return {
										enabled: this.hasM
									}
								}
							}
						}
					})], k.prototype, "mmin", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							origins: {
								"web-scene": {
									write: !1
								}
							},
							write: {
								overridePolicy() {
									return {
										enabled: this.hasZ
									}
								}
							}
						}
					})], k.prototype, "zmin", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "xmax", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "ymax", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							origins: {
								"web-scene": {
									write: !1
								}
							},
							write: {
								overridePolicy() {
									return {
										enabled: this.hasM
									}
								}
							}
						}
					})], k.prototype, "mmax", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							origins: {
								"web-scene": {
									write: !1
								}
							},
							write: {
								overridePolicy() {
									return {
										enabled: this.hasZ
									}
								}
							}
						}
					})], k.prototype, "zmax", void 0);
					k = q = b.__decorate([m.subclass("esri.geometry.Extent")],
						k);
					k.prototype.toJSON.isDefaultToJSON = !0;
					return k
				})
		},
		"esri/geometry/Geometry": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ./SpatialReference".split(" "), function(a, b, c, e, d, k, v, m, f) {
				c = function(g) {
					function l(...p) {
						p = g.call(this, ...p) || this;
						p.type = null;
						p.hasM = !1;
						p.hasZ = !1;
						p.spatialReference = f.WGS84;
						return p
					}
					a._inheritsLoose(l, g);
					var r = l.prototype;
					r.readSpatialReference = function(p, n) {
						if (p instanceof f) return p;
						if (null != p) {
							const t = new f;
							t.read(p, n);
							return t
						}
						return p
					};
					r.clone = function() {
						console.warn(".clone() is not implemented for " + this.declaredClass);
						return null
					};
					r.clearCache = function() {
						this.notifyChange("cache")
					};
					r.getCacheValue = function(p) {
						return this.cache[p]
					};
					r.setCacheValue = function(p, n) {
						this.cache[p] = n
					};
					a._createClass(l, [{
						key: "cache",
						get: function() {
							this.commitProperty("spatialReference");
							return {}
						}
					}, {
						key: "extent",
						get: function() {
							return null
						}
					}]);
					return l
				}(c.JSONSupport);
				b.__decorate([e.property()], c.prototype, "type", void 0);
				b.__decorate([e.property({
					readOnly: !0
				})], c.prototype, "cache", null);
				b.__decorate([e.property({
					readOnly: !0
				})], c.prototype, "extent", null);
				b.__decorate([e.property({
					type: Boolean,
					json: {
						write: {
							overridePolicy(g) {
								return {
									enabled: g
								}
							}
						}
					}
				})], c.prototype, "hasM", void 0);
				b.__decorate([e.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(g) {
									return {
										enabled: g
									}
								}
							}
						}
					})], c.prototype, "hasZ",
					void 0);
				b.__decorate([e.property({
					type: f,
					json: {
						write: !0
					}
				})], c.prototype, "spatialReference", void 0);
				b.__decorate([v.reader("spatialReference")], c.prototype, "readSpatialReference", null);
				return c = b.__decorate([m.subclass("esri.geometry.Geometry")], c)
			})
		},
		"esri/geometry/Point": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Logger ../core/maybe ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/accessorSupport/ensureType ./Geometry ./SpatialReference ./support/pointUtils ./support/spatialReferenceUtils ./support/webMercatorUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h) {
					function q(y) {
						return y && ("esri.geometry.SpatialReference" === y.declaredClass || null != y.wkid)
					}
					var u;
					const x = [0, 0];
					k = u = function(y) {
						function w(...B) {
							B = y.call(this, ...B) || this;
							B.x = 0;
							B.y = 0;
							B.z = void 0;
							B.m = void 0;
							B.type = "point";
							return B
						}
						a._inheritsLoose(w, y);
						w.copy = function(B, E) {
							E._set("x", B._get("x"));
							E._set("y", B._get("y"));
							E._set("z", B._get("z"));
							E._set("m", B._get("m"));
							B = B._get("spatialReference");
							E._set("spatialReference", Object.isFrozen(B) ? B : B.clone())
						};
						var A =
							w.prototype;
						A.normalizeCtorArgs = function(B, E, z, C, D) {
							let J;
							if (Array.isArray(B)) J = B, D = E, B = J[0], E = J[1], z = J[2], C = J[3];
							else if (B && "object" === typeof B) {
								if (J = B, B = null != J.x ? J.x : J.longitude, E = null != J.y ? J.y : J.latitude, z = J.z, C = J.m, (D = J.spatialReference) && "esri.geometry.SpatialReference" !== D.declaredClass && (D = new p(D)), null != J.longitude || null != J.latitude) null == J.longitude ? c.getLogger(this.declaredClass)
									.warn(".longitude\x3d", "Latitude was defined without longitude") : null == J.latitude ? c.getLogger(this.declaredClass)
									.warn(".latitude\x3d",
										"Longitude was defined without latitude") : !J.declaredClass && D && D.isWebMercator && (E = h.lngLatToXY(J.longitude, J.latitude, x), B = E[0], E = E[1])
							} else q(z) ? (D = z, z = null) : q(C) && (D = C, C = null);
							B = {
								x: B,
								y: E
							};
							null == B.x && null != B.y ? c.getLogger(this.declaredClass)
								.warn(".y\x3d", "Y coordinate was defined without an X coordinate") : null == B.y && null != B.x && c.getLogger(this.declaredClass)
								.warn(".x\x3d", "X coordinate was defined without a Y coordinate");
							null != D && (B.spatialReference = D);
							null != z && (B.z = z);
							null != C && (B.m = C);
							return B
						};
						A.writeX = function(B, E, z) {
							E[z] = isNaN(B) ? "NaN" : B
						};
						A.readX = function(B) {
							return "string" === typeof B ? NaN : B
						};
						A.clone = function() {
							const B = new u;
							B.x = this.x;
							B.y = this.y;
							B.z = this.z;
							B.m = this.m;
							B.spatialReference = this.spatialReference;
							return B
						};
						A.copy = function(B) {
							u.copy(B, this);
							return this
						};
						A.equals = function(B) {
							if (e.isNone(B)) return !1;
							const {
								x: E,
								y: z,
								z: C,
								m: D,
								spatialReference: J
							} = this, {
								z: K,
								m: H
							} = B;
							let {
								x: G,
								y: F,
								spatialReference: L
							} = B;
							if (!J.equals(L))
								if (J.isWebMercator && L.isWGS84)[G, F] = h.lngLatToXY(G, F), L = J;
								else if (J.isWGS84 &&
								L.isWebMercator)[G, F] = h.xyToLngLat(G, F), L = J;
							else return !1;
							return E === G && z === F && C === K && D === H && J.wkid === L.wkid
						};
						A.offset = function(B, E, z) {
							this.x += B;
							this.y += E;
							null != z && (this.z = (this.z ? ? 0) + z);
							return this
						};
						A.normalize = function() {
							if (!this.spatialReference) return this;
							var B = t.getInfo(this.spatialReference);
							if (!B) return this;
							let E = this.x;
							const [z, C] = B.valid;
							B = 2 * C;
							let D;
							E > C ? (D = Math.ceil(Math.abs(E - C) / B), E -= D * B) : E < z && (D = Math.ceil(Math.abs(E - z) / B), E += D * B);
							this._set("x", E);
							return this
						};
						A.distance = function(B) {
							return n.distance(this,
								B)
						};
						A.toArray = function() {
							const B = this.hasZ,
								E = this.hasM;
							return B && E ? [this.x, this.y, this.z, this.m] : B ? [this.x, this.y, this.z] : E ? [this.x, this.y, this.m] : [this.x, this.y]
						};
						A.toJSON = function(B) {
							return this.write({}, B)
						};
						a._createClass(w, [{
							key: "cache",
							get: function() {
								this.commitProperty("x");
								this.commitProperty("y");
								this.commitProperty("z");
								this.commitProperty("m");
								this.commitProperty("spatialReference");
								return {}
							}
						}, {
							key: "hasM",
							get: function() {
								return void 0 !== this.m
							},
							set: function(B) {
								const E = void 0 !== this._get("m");
								B !== E && (this._set("m", B ? 0 : void 0), this._set("hasM", B))
							}
						}, {
							key: "hasZ",
							get: function() {
								return void 0 !== this.z
							},
							set: function(B) {
								const E = void 0 !== this._get("z");
								B !== E && (this._set("z", B ? 0 : void 0), this._set("hasZ", B))
							}
						}, {
							key: "latitude",
							get: function() {
								const {
									spatialReference: B,
									x: E,
									y: z
								} = this;
								if (B) {
									if (B.isWebMercator) return h.xyToLngLat(E, z, x)[1];
									if (B.isGeographic) return z
								}
								return null
							},
							set: function(B) {
								const {
									spatialReference: E,
									x: z
								} = this;
								null != B && E && (E.isWebMercator ? this._set("y", h.lngLatToXY(z, B, x)[1]) : E.isGeographic &&
									this._set("y", B), this._set("latitude", B))
							}
						}, {
							key: "longitude",
							get: function() {
								const {
									x: B,
									y: E,
									spatialReference: z
								} = this;
								if (z) {
									if (z.isWebMercator) return h.xyToLngLat(B, E, x)[0];
									if (z.isGeographic) return B
								}
								return null
							},
							set: function(B) {
								const {
									y: E,
									spatialReference: z
								} = this;
								null != B && z && (z.isWebMercator ? this._set("x", h.lngLatToXY(B, E, x)[0]) : z.isGeographic && this._set("x", B), this._set("longitude", B))
							}
						}]);
						return w
					}(r);
					b.__decorate([d.property({
						readOnly: !0
					})], k.prototype, "cache", null);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							read: !1,
							write: {
								enabled: !1,
								overridePolicy: null
							}
						}
					})], k.prototype, "hasM", null);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							read: !1,
							write: {
								enabled: !1,
								overridePolicy: null
							}
						}
					})], k.prototype, "hasZ", null);
					b.__decorate([d.property({
						type: Number
					})], k.prototype, "latitude", null);
					b.__decorate([d.property({
						type: Number
					})], k.prototype, "longitude", null);
					b.__decorate([d.property({
							type: Number,
							json: {
								type: [Number, String],
								write: {
									isRequired: !0,
									allowNull: !0
								}
							}
						}), v.cast(y => isNaN(y) ? y : l.ensureNumber(y))], k.prototype, "x",
						void 0);
					b.__decorate([g.writer("x")], k.prototype, "writeX", null);
					b.__decorate([m.reader("x")], k.prototype, "readX", null);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "y", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: {
								overridePolicy() {
									return {
										enabled: this.hasZ
									}
								}
							}
						}
					})], k.prototype, "z", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: {
								overridePolicy() {
									return {
										enabled: this.hasM
									}
								}
							}
						}
					})], k.prototype, "m", void 0);
					k = u = b.__decorate([f.subclass("esri.geometry.Point")],
						k);
					k.prototype.toJSON.isDefaultToJSON = !0;
					return k
				})
		},
		"esri/core/accessorSupport/decorators/cast": function() {
			define(["exports", "../ensureType", "../metadata"], function(a, b, c) {
				function e(m) {
					const f = "__accessorMetadata__" in m ? b.ensureType(m) : m;
					return function(...g) {
						g.push(f);
						if ("number" === typeof g[2]) throw Error("Using @cast has parameter decorator is not supported since 4.16");
						return d.apply(this, g)
					}
				}

				function d(m, f, g, l) {
					c.getOwnPropertyMetadata(m, f)
						.cast = l
				}

				function k(m) {
					return (f, g) => {
						c.getOwnPropertyMetadata(f,
								m)
							.cast = f[g]
					}
				}
				const v = Object.prototype.toString;
				a.cast = function(...m) {
					if (3 !== m.length || "string" !== typeof m[1]) {
						if (1 === m.length && "[object Function]" === v.call(m[0])) return e(m[0]);
						if (1 === m.length && "string" === typeof m[0]) return k(m[0])
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/pointUtils": function() {
			define(["exports"], function(a) {
				a.distance = function(b, c) {
					const e = b.x - c.x,
						d = b.y - c.y;
					b = b.hasZ && c.hasZ ? b.z - c.z : 0;
					return Math.sqrt(e *
						e + d * d + b * b)
				};
				a.squareDistance = function(b, c) {
					const e = b.x - c.x,
						d = b.y - c.y;
					b = b.hasZ && c.hasZ ? b.z - c.z : 0;
					return e * e + d * d + b * b
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/webMercatorUtils": function() {
			define("exports ../../core/lang ../../core/maybe ../SpatialReference ./Ellipsoid ./spatialReferenceUtils".split(" "), function(a, b, c, e, d, k) {
				function v(r, p, n, t, h) {
					h.spatialReference = n;
					if ("x" in r && "x" in h)[h.x, h.y] = p(r.x, r.y, l, t);
					else if ("xmin" in
						r && "xmin" in h)[h.xmin, h.ymin] = p(r.xmin, r.ymin, l, t), [h.xmax, h.ymax] = p(r.xmax, r.ymax, l, t);
					else if ("paths" in r && "paths" in h || "rings" in r && "rings" in h) {
						r = "paths" in r ? r.paths : r.rings;
						n = [];
						for (let u = 0; u < r.length; u++) {
							const x = r[u];
							var q = [];
							n.push(q);
							for (let y = 0; y < x.length; y++) q.push(p(x[y][0], x[y][1], [0, 0], t)), 2 < x[y].length && q[y].push(x[y][2]), 3 < x[y].length && q[y].push(x[y][3])
						}
						"paths" in h ? h.paths = n : h.rings = n
					} else if ("points" in r && "points" in h) {
						r = r.points;
						n = [];
						for (q = 0; q < r.length; q++) n[q] = p(r[q][0], r[q][1],
							[0, 0], t), 2 < r[q].length && n[q].push(r[q][2]), 3 < r[q].length && n[q].push(r[q][3]);
						h.points = n
					}
					return h
				}

				function m(r, p) {
					const n = r && (null != r.wkid || null != r.wkt ? r : r.spatialReference),
						t = p && (null != p.wkid || null != p.wkt ? p : p.spatialReference);
					return r && "type" in r && "mesh" === r.type || p && "type" in p && "mesh" === p.type || !n || !t ? !1 : k.equals(t, n) ? !0 : k.isWebMercator(t) && k.isWGS84(n) || k.isWebMercator(n) && k.isWGS84(t)
				}

				function f(r, p, n = [0, 0]) {
					89.99999 < p ? p = 89.99999 : -89.99999 > p && (p = -89.99999);
					p *= .017453292519943;
					n[0] = .017453292519943 *
						r * d.earth.radius;
					n[1] = d.earth.halfSemiMajorAxis * Math.log((1 + Math.sin(p)) / (1 - Math.sin(p)));
					return n
				}

				function g(r, p, n = [0, 0], t = !1) {
					r = r / d.earth.radius * 57.29577951308232;
					n[0] = t ? r : r - 360 * Math.floor((r + 180) / 360);
					n[1] = 57.29577951308232 * (Math.PI / 2 - 2 * Math.atan(Math.exp(-p / d.earth.radius)));
					return n
				}
				const l = [0, 0];
				a.canProject = m;
				a.geographicToWebMercator = function(r, p = !1, n = b.clone(r)) {
					return v(r, f, e.WebMercator, p, n)
				};
				a.lngLatToXY = f;
				a.project = function(r, p) {
					if (c.isNone(r)) return null;
					const n = r.spatialReference;
					p =
						p && (null != p.wkid || null != p.wkt ? p : p.spatialReference);
					return m(n, p) ? k.equals(n, p) ? b.clone(r) : k.isWebMercator(p) ? v(r, f, e.WebMercator, !1, b.clone(r)) : k.isWGS84(p) ? v(r, g, e.WGS84, !1, b.clone(r)) : null : null
				};
				a.webMercatorToGeographic = function(r, p = !1, n = b.clone(r)) {
					return v(r, g, e.WGS84, p, n)
				};
				a.x2lon = function(r) {
					return r / d.earth.radius
				};
				a.xyToLngLat = g;
				a.y2lat = function(r) {
					return Math.PI / 2 - 2 * Math.atan(Math.exp(-r / d.earth.radius))
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/Ellipsoid": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers"], function(a, b) {
				let c = function() {
					function v(m, f, g, l) {
						this.semiMajorAxis = m;
						this.flattening = f;
						this.outerAtmosphereRimWidth = g;
						this.semiMinorAxis = this.semiMajorAxis * (1 - this.flattening);
						this.halfSemiMajorAxis = this.semiMajorAxis / 2;
						this.halfCircumference = Math.PI * this.semiMajorAxis;
						this.metersPerDegree = this.halfCircumference / 180;
						this.inverseFlattening = 1 / (1 - this.flattening) - 1;
						this.eccentricitySquared = l ? l :
							2 * this.flattening - this.flattening * this.flattening;
						this.meanRadiusSemiAxes = (2 * this.semiMajorAxis + this.semiMinorAxis) / 3
					}
					b._createClass(v, [{
						key: "radius",
						get: function() {
							return this.semiMajorAxis
						}
					}]);
					return v
				}();
				const e = new c(6378137, 1 / 298.257223563, 3E5, .006694379990137799),
					d = new c(3396190, .005886007555525457, 23E4),
					k = new c(1737400, 0, 0);
				a.Ellipsoid = c;
				a.earth = e;
				a.mars = d;
				a.moon = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/contains": function() {
			define(["exports",
				"../../core/maybe"
			], function(a, b) {
				function c(f, g) {
					return e(f, g[0], g[1])
				}

				function e(f, g, l, r) {
					return g >= f.xmin && g <= f.xmax && l >= f.ymin && l <= f.ymax ? null != r && f.hasZ ? r >= f.zmin && r <= f.zmax : !0 : !1
				}

				function d(f, g) {
					return k(f.rings, g)
				}

				function k(f, g) {
					if (!f) return !1;
					if (!Array.isArray(f[0][0])) return v(!1, f, g);
					let l = !1;
					for (let r = 0, p = f.length; r < p; r++) l = v(l, f[r], g);
					return l
				}

				function v(f, g, l) {
					const [r, p] = l;
					l = 0;
					for (let n = 0, t = g.length; n < t; n++) {
						l++;
						l === t && (l = 0);
						const [h, q] = g[n], [u, x] = g[l];
						(q < p && x >= p || x < p && q >= p) && h + (p -
							q) / (x - q) * (u - h) < r && (f = !f)
					}
					return f
				}
				const m = [0, 0];
				a.extentContainsCoords2D = c;
				a.extentContainsCoords3D = function(f, g) {
					return e(f, g[0], g[1], g[2])
				};
				a.extentContainsExtent = function(f, g) {
					const {
						xmin: l,
						ymin: r,
						zmin: p,
						xmax: n,
						ymax: t,
						zmax: h
					} = g;
					return f.hasZ && g.hasZ ? e(f, l, r, p) && e(f, l, t, p) && e(f, n, t, p) && e(f, n, r, p) && e(f, l, r, h) && e(f, l, t, h) && e(f, n, t, h) && e(f, n, r, h) : e(f, l, r) && e(f, l, t) && e(f, n, t) && e(f, n, r)
				};
				a.extentContainsMultipoint = function(f, g) {
					if (!g.points || g.points.length) return !1;
					for (const l of g.points)
						if (!c(f, l)) return !1;
					return !0
				};
				a.extentContainsPoint = function(f, g) {
					return b.isSome(g) ? e(f, g.x, g.y, g.z) : !1
				};
				a.extentContainsXYZ = e;
				a.polygonContainsCoords = d;
				a.polygonContainsPoint = function(f, g) {
					m[1] = g.y;
					m[0] = g.x;
					return d(f, m)
				};
				a.ringsContainsCoords = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/intersectsBase": function() {
			define(["exports", "./contains"], function(a, b) {
				function c(u, x) {
					return b.extentContainsPoint(u, x)
				}

				function e(u, x) {
					var y = u.hasZ && x.hasZ;
					if (u.xmin <= x.xmin) {
						var w = x.xmin;
						if (u.xmax < w) return !1
					} else if (w = u.xmin, x.xmax < w) return !1;
					if (u.ymin <= x.ymin) {
						if (w = x.ymin, u.ymax < w) return !1
					} else if (w = u.ymin, x.ymax < w) return !1;
					if (y && x.hasZ)
						if (u.zmin <= x.zmin) {
							if (y = x.zmin, u.zmax < y) return !1
						} else if (y = u.zmin, x.zmax < y) return !1;
					return !0
				}

				function d(u, x) {
					const {
						points: y,
						hasZ: w
					} = x;
					x = w ? b.extentContainsCoords3D : b.extentContainsCoords2D;
					for (const A of y)
						if (x(u, A)) return !0;
					return !1
				}

				function k(u, x) {
					return v(u, x.rings)
				}

				function v(u, x) {
					l[0] = u.xmin;
					l[1] = u.ymax;
					r[0] = u.xmax;
					r[1] = u.ymax;
					p[0] = u.xmin;
					p[1] = u.ymin;
					n[0] = u.xmax;
					n[1] = u.ymin;
					for (var y of t)
						if (b.ringsContainsCoords(x, y)) return !0;
					for (const w of x)
						if (w.length) {
							x = w[0];
							if (b.extentContainsCoords2D(u, x)) return !0;
							for (y = 1; y < w.length; y++) {
								const A = w[y];
								if (b.extentContainsCoords2D(u, A) || f(x, A, h)) return !0;
								x = A
							}
						} return !1
				}

				function m(u, x) {
					l[0] = u.xmin;
					l[1] = u.ymax;
					r[0] = u.xmax;
					r[1] = u.ymax;
					p[0] = u.xmin;
					p[1] = u.ymin;
					n[0] = u.xmax;
					n[1] = u.ymin;
					x = x.paths;
					for (const y of x) {
						if (!x.length) continue;
						let w = y[0];
						if (b.extentContainsCoords2D(u, w)) return !0;
						for (let A = 1; A < y.length; A++) {
							const B = y[A];
							if (b.extentContainsCoords2D(u, B) || f(w, B, h)) return !0;
							w = B
						}
					}
					return !1
				}

				function f(u, x, y) {
					for (let w = 0; w < y.length; w++)
						if (g(u, x, y[w][0], y[w][1])) return !0;
					return !1
				}

				function g(u, x, y, w, A) {
					const [B, E] = u, [z, C] = x, [D, J] = y, [K, H] = w;
					var G = K - D;
					u = B - D;
					x = z - B;
					const F = H - J;
					y = E - J;
					w = C - E;
					const L = F * x - G * w;
					if (0 === L) return !1;
					G = (G * y - F * u) / L;
					u = (x * y - w * u) / L;
					return 0 <= G && 1 >= G && 0 <= u && 1 >= u ? (A && (A[0] = B + G * (z - B), A[1] = E + G * (C - E)), !0) : !1
				}
				const l = [0, 0],
					r = [0, 0],
					p = [0, 0],
					n = [0, 0],
					t = [l, r, p, n],
					h = [
						[p, l],
						[l, r],
						[r, n],
						[n, p]
					],
					q = [0, 0];
				a.extentIntersectsExtent = e;
				a.extentIntersectsMultipoint = d;
				a.extentIntersectsPoint = c;
				a.extentIntersectsPolygon = k;
				a.extentIntersectsPolyline = m;
				a.extentIntersectsRings = v;
				a.getFeatureExtentIntersector = function(u) {
					switch (u) {
						case "esriGeometryEnvelope":
						case "extent":
							return e;
						case "esriGeometryMultipoint":
						case "multipoint":
							return d;
						case "esriGeometryPoint":
						case "point":
							return c;
						case "esriGeometryPolygon":
						case "polygon":
							return k;
						case "esriGeometryPolyline":
						case "polyline":
							return m
					}
				};
				a.isSelfIntersecting = function(u) {
					for (let C = 0; C < u.length; C++) {
						const D = u[C];
						for (var x = 0; x < D.length - 1; x++) {
							var y = D[x],
								w = D[x + 1];
							for (var A = C + 1; A < u.length; A++)
								for (var B = 0; B < u[A].length - 1; B++) {
									var E = u[A][B],
										z = u[A][B + 1];
									if (g(y, w, E, z, q) && !(q[0] === y[0] && q[1] === y[1] || q[0] === E[0] && q[1] === E[1] || q[0] === w[0] && q[1] === w[1] || q[0] === z[0] && q[1] === z[1])) return !0
								}
						}
						x = D.length;
						if (!(4 >= x))
							for (y = 0; y < x - 3; y++)
								for (w = x - 1, 0 === y && (w = x - 2), A = D[y], B = D[y + 1], E = y + 2; E < w; E++) {
									z = D[E];
									const J = D[E + 1];
									if (g(A, B, z, J, q) && !(q[0] === A[0] && q[1] ===
										A[1] || q[0] === z[0] && q[1] === z[1] || q[0] === B[0] && q[1] === B[1] || q[0] === J[0] && q[1] === J[1])) return !0
								}
					}
					return !1
				};
				a.segmentIntersects = g;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/intl/locale": function() {
			define(["exports"], function(a) {
				function b() {
					return m ? ? globalThis.navigator ? .language ? ? "en"
				}

				function c() {
					void 0 === v && (v = b());
					return v
				}

				function e(r = c()) {
					return /^([a-zA-Z]{2,3})(?:[_\-]\w+)*$/.exec(r) ? . [1].toLowerCase()
				}

				function d() {
					const r = k ? ? b();
					v !== r && (v =
						r, [...l].forEach(p => {
							p.call(null, r)
						}), [...g].forEach(p => {
							p.call(null, r)
						}))
				}
				let k = void 0,
					v = void 0;
				const m = globalThis.esriConfig ? .locale ? ? globalThis.dojoConfig ? .locale,
					f = {
						he: !0,
						ar: !0
					},
					g = [],
					l = [];
				globalThis.addEventListener ? .("languagechange", d);
				a.beforeLocaleChange = function(r) {
					l.push(r);
					return {
						remove() {
							g.splice(l.indexOf(r), 1)
						}
					}
				};
				a.getDefaultLocale = b;
				a.getLanguage = e;
				a.getLocale = c;
				a.onLocaleChange = function(r) {
					g.push(r);
					return {
						remove() {
							g.splice(g.indexOf(r), 1)
						}
					}
				};
				a.prefersRTL = function(r = c()) {
					r = e(r);
					return void 0 !==
						r && (f[r] || !1)
				};
				a.setLocale = function(r) {
					k = r ? r : void 0;
					d()
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/portal/PortalQueryParams": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/jsonMap ../core/lang ../core/maybe ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../geometry/Extent ../geometry/SpatialReference ../geometry/support/webMercatorUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					const n = new e.JSONMap({
						avgRating: "avg-rating",
						numRatings: "num-ratings",
						numComments: "num-comments",
						numViews: "num-views"
					});
					c = p = function(t) {
						function h(u) {
							u = t.call(this, u) || this;
							u.categories = null;
							u.disableExtraQuery = !1;
							u.extent = null;
							u.filter = null;
							u.num = 10;
							u.query = null;
							u.sortField = null;
							u.start = 1;
							return u
						}
						a._inheritsLoose(h, t);
						var q = h.prototype;
						q.clone = function() {
							return new p({
								categories: this.categories ? d.clone(this.categories) : null,
								disableExtraQuery: this.disableExtraQuery,
								extent: this.extent ? this.extent.clone() : null,
								filter: this.filter,
								num: this.num,
								query: this.query,
								sortField: this.sortField,
								sortOrder: this.sortOrder,
								start: this.start
							})
						};
						q.toRequestOptions = function(u, x) {
							let y;
							this.categories && (y = this.categories.map(B => Array.isArray(B) ? JSON.stringify(B) : B));
							let w;
							if (this.extent) {
								var A = r.project(this.extent, l.WGS84);
								k.isSome(A) && (w = `${A.xmin},${A.ymin},${A.xmax},${A.ymax}`)
							}
							A = this.query;
							!this.disableExtraQuery && u.extraQuery && (A = "(" + A + ")" + u.extraQuery);
							u = {
								categories: y,
								bbox: w,
								q: A,
								filter: this.filter,
								num: this.num,
								sortField: null,
								sortOrder: null,
								start: this.start
							};
							this.sortField && (u.sortField = this.sortField.split(",")
								.map(B => n.toJSON(B.trim()))
								.join(","), u.sortOrder = this.sortOrder);
							return {
								query: {
									...x,
									...u
								}
							}
						};
						a._createClass(h, [{
							key: "sortOrder",
							get: function() {
								return this._get("sortOrder") || "asc"
							},
							set: function(u) {
								"asc" !== u && "desc" !== u || this._set("sortOrder", u)
							}
						}]);
						return h
					}(c);
					b.__decorate([v.property()], c.prototype, "categories", void 0);
					b.__decorate([v.property()], c.prototype,
						"disableExtraQuery", void 0);
					b.__decorate([v.property({
						type: g
					})], c.prototype, "extent", void 0);
					b.__decorate([v.property()], c.prototype, "filter", void 0);
					b.__decorate([v.property()], c.prototype, "num", void 0);
					b.__decorate([v.property()], c.prototype, "query", void 0);
					b.__decorate([v.property()], c.prototype, "sortField", void 0);
					b.__decorate([v.property()], c.prototype, "sortOrder", null);
					b.__decorate([v.property()], c.prototype, "start", void 0);
					return c = p = b.__decorate([f.subclass("esri.portal.PortalQueryParams")],
						c)
				})
		},
		"esri/core/jsonMap": function() {
			define(["exports", "./object"], function(a, b) {
				let c = function() {
					function e(k, v = {
						ignoreUnknown: !1,
						useNumericKeys: !1
					}) {
						this._jsonToAPI = k;
						this._options = v;
						this.apiValues = [];
						this.jsonValues = [];
						this._apiToJSON = this._invertMap(k);
						this.apiValues = this._getKeysSorted(this._apiToJSON);
						this.jsonValues = this._getKeysSorted(this._jsonToAPI);
						this.read = m => this.fromJSON(m);
						this.write = (m, f, g) => {
							m = this.toJSON(m);
							void 0 !== m && b.setDeepValue(g, m, f)
						};
						this.write.isJSONMapWriter = !0
					}
					var d =
						e.prototype;
					d.toJSON = function(k) {
						return this._apiToJSON.hasOwnProperty(k) ? (k = this._apiToJSON[k], this._options.useNumericKeys ? +k : k) : this._options.ignoreUnknown ? void 0 : k
					};
					d.fromJSON = function(k) {
						return this._jsonToAPI.hasOwnProperty(k) ? this._jsonToAPI[k] : this._options.ignoreUnknown ? void 0 : k
					};
					d._invertMap = function(k) {
						const v = {};
						for (const m in k) v[k[m]] = m;
						return v
					};
					d._getKeysSorted = function(k) {
						const v = [];
						for (const m in k) v.push(m);
						v.sort();
						return v
					};
					return e
				}();
				a.JSONMap = c;
				a.strict = function() {
					return function(e,
						d) {
						return new c(e, {
							ignoreUnknown: !0,
							...d
						})
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/portal/PortalQueryResult": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v) {
				c = function(m) {
					function f(g) {
						g = m.call(this, g) || this;
						g.nextQueryParams =
							null;
						g.queryParams = null;
						g.results = null;
						g.total = null;
						return g
					}
					a._inheritsLoose(f, m);
					return f
				}(c);
				b.__decorate([e.property()], c.prototype, "nextQueryParams", void 0);
				b.__decorate([e.property()], c.prototype, "queryParams", void 0);
				b.__decorate([e.property()], c.prototype, "results", void 0);
				b.__decorate([e.property()], c.prototype, "total", void 0);
				return c = b.__decorate([v.subclass("esri.portal.PortalQueryResult")], c)
			})
		},
		"esri/portal/PortalUser": function() {
			define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Error ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./PortalFolder ./PortalGroup".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					d = r = function(p) {
						function n(...h) {
							h = p.call(this, ...h) || this;
							h.access = null;
							h.created = null;
							h.culture = null;
							h.description = null;
							h.email = null;
							h.fullName = null;
							h.modified = null;
							h.orgId = null;
							h.portal = null;
							h.preferredView = null;
							h.privileges = null;
							h.region = null;
							h.role = null;
							h.roleId = null;
							h.sourceJSON = null;
							h.units = null;
							h.username = null;
							h.userType = null;
							return h
						}
						b._inheritsLoose(n, p);
						var t = n.prototype;
						t.addItem = function(h) {
							const q = h && h.item;
							var u = h && h.data;
							h = h && h.folder;
							const x = {
								method: "post"
							};
							q && (x.query = q.createPostQuery(), null != u && ("string" === typeof u ? x.query.text = u : "object" === typeof u && (x.query.text = JSON.stringify(u))));
							u = this.userContentUrl;
							h && (u += "/" + ("string" === typeof h ? h : h.id));
							return this.portal._request(u + "/addItem", x)
								.then(y => {
									q.id = y.id;
									q.portal = this.portal;
									return q.loaded ? q.reload() : q.load()
								})
						};
						t.deleteItem = function(h) {
							let q = this.userContentUrl;
							h.ownerFolder && (q += "/" + h.ownerFolder);
							return this.portal._request(q + `/items/${h.id}/delete`, {
									method: "post"
								})
								.then(() => {
									h.id = null;
									h.portal = null
								})
						};
						t.deleteItems = function(h) {
							const q = this.userContentUrl + "/deleteItems";
							var u = h.map(x => x.id);
							return u.length ? (u = {
									method: "post",
									query: {
										items: u.join(",")
									}
								}, this.portal._request(q, u)
								.then(() => {
									h.forEach(x => {
										x.id = null;
										x.portal = null
									})
								})) : Promise.resolve(void 0)
						};
						t.fetchFolders = function() {
							return this.portal._request(this.userContentUrl ? ? "", {
									query: {
										num: 1
									}
								})
								.then(h => h && h.folders ? h.folders.map(q => {
									q = g.fromJSON(q);
									q.portal = this.portal;
									return q
								}) : [])
						};
						t.fetchGroups = function() {
							return this.portal._request(this.url ? ?
									"")
								.then(h => h && h.groups ? h.groups.map(q => {
									q = l.fromJSON(q);
									q.portal = this.portal;
									return q
								}) : [])
						};
						t.fetchItems = function(h) {
							const q = h ? ? {};
							let u = this.userContentUrl ? ? "";
							q.folder && (u += "/" + q.folder.id);
							let x;
							return (new Promise((y, w) => a(["./PortalItem"], A => y(Object.freeze(Object.defineProperty({
									__proto__: null,
									default: A
								}, Symbol.toStringTag, {
									value: "Module"
								}))), w)))
								.then(({
									default: y
								}) => {
									x = y;
									return this.portal._request(u, {
										query: {
											folders: !1,
											num: q.num || 10,
											start: q.start || 1,
											sortField: q.sortField || "created",
											sortOrder: q.sortOrder ||
												"asc"
										}
									})
								})
								.then(y => {
									let w;
									return y && y.items ? (w = y.items.map(A => {
											A = x.fromJSON(A);
											A.portal = this.portal;
											return A
										}), Promise.all(w.map(A => A.load()))
										.catch(A => A)
										.then(() => ({
											items: w,
											nextStart: y.nextStart,
											total: y.total
										}))) : {
										items: [],
										nextStart: -1,
										total: 0
									}
								})
						};
						t.fetchTags = function() {
							return this.portal._request(this.url + "/tags")
								.then(h => h.tags)
						};
						t.getThumbnailUrl = function(h) {
							let q = this.thumbnailUrl;
							q && h && (q += `&w=${h}`);
							return q
						};
						t.queryFavorites = function(h) {
							return this.favGroupId ? (this._favGroup || (this._favGroup =
								new l({
									id: this.favGroupId,
									portal: this.portal
								})), this._favGroup.queryItems(h)) : Promise.reject(new e("internal:unknown", "Unknown internal error", {
								internalError: "Unknown favGroupId"
							}))
						};
						t.toJSON = function() {
							throw new e("internal:not-yet-implemented", "PortalGroup.toJSON is not yet implemented");
						};
						n.fromJSON = function(h) {
							if (!h) return null;
							if (h.declaredClass) throw Error("JSON object is already hydrated");
							const q = new r;
							q.sourceJSON = h;
							q.read(h);
							return q
						};
						b._createClass(n, [{
							key: "thumbnailUrl",
							get: function() {
								const h =
									this.url,
									q = this.thumbnail;
								return h && q ? this.portal._normalizeUrl(`${h}/info/${q}?f=json`) : null
							}
						}, {
							key: "userContentUrl",
							get: function() {
								const h = this.get("portal.restUrl");
								return h ? `${h}/content/users/${this.username}` : null
							}
						}, {
							key: "url",
							get: function() {
								const h = this.get("portal.restUrl");
								return h ? `${h}/community/users/${this.username}` : null
							}
						}]);
						return n
					}(d.JSONSupport);
					c.__decorate([k.property()], d.prototype, "access", void 0);
					c.__decorate([k.property({
						type: Date
					})], d.prototype, "created", void 0);
					c.__decorate([k.property()],
						d.prototype, "culture", void 0);
					c.__decorate([k.property()], d.prototype, "description", void 0);
					c.__decorate([k.property()], d.prototype, "email", void 0);
					c.__decorate([k.property()], d.prototype, "favGroupId", void 0);
					c.__decorate([k.property()], d.prototype, "fullName", void 0);
					c.__decorate([k.property({
						type: Date
					})], d.prototype, "modified", void 0);
					c.__decorate([k.property()], d.prototype, "orgId", void 0);
					c.__decorate([k.property()], d.prototype, "portal", void 0);
					c.__decorate([k.property()], d.prototype, "preferredView",
						void 0);
					c.__decorate([k.property()], d.prototype, "privileges", void 0);
					c.__decorate([k.property()], d.prototype, "region", void 0);
					c.__decorate([k.property()], d.prototype, "role", void 0);
					c.__decorate([k.property()], d.prototype, "roleId", void 0);
					c.__decorate([k.property()], d.prototype, "sourceJSON", void 0);
					c.__decorate([k.property()], d.prototype, "thumbnail", void 0);
					c.__decorate([k.property({
						readOnly: !0
					})], d.prototype, "thumbnailUrl", null);
					c.__decorate([k.property()], d.prototype, "units", void 0);
					c.__decorate([k.property({
							readOnly: !0
						})],
						d.prototype, "userContentUrl", null);
					c.__decorate([k.property({
						readOnly: !0
					})], d.prototype, "url", null);
					c.__decorate([k.property()], d.prototype, "username", void 0);
					c.__decorate([k.property()], d.prototype, "userType", void 0);
					return d = r = c.__decorate([f.subclass("esri.portal.PortalUser")], d)
				})
		},
		"esri/portal/PortalFolder": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Error ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					e = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.created = null;
							l.id = null;
							l.portal = null;
							l.title = null;
							l.username = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.toJSON = function() {
							throw new c("internal:not-yet-implemented", "PortalFolder.toJSON is not yet implemented");
						};
						a._createClass(g, [{
							key: "url",
							get: function() {
								const l = this.get("portal.restUrl");
								return l ? `${l}/content/users/${this.username}/${this.id}` : null
							}
						}]);
						return g
					}(e.JSONSupport);
					b.__decorate([d.property({
							type: Date
						})],
						e.prototype, "created", void 0);
					b.__decorate([d.property()], e.prototype, "id", void 0);
					b.__decorate([d.property()], e.prototype, "portal", void 0);
					b.__decorate([d.property()], e.prototype, "title", void 0);
					b.__decorate([d.property({
						readOnly: !0
					})], e.prototype, "url", null);
					b.__decorate([d.property()], e.prototype, "username", void 0);
					return e = b.__decorate([m.subclass("esri.portal.PortalFolder")], e)
				})
		},
		"esri/portal/PortalGroup": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Error ../core/JSONSupport ../core/maybe ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./PortalQueryParams".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					e = function(l) {
						function r(n) {
							n = l.call(this, n) || this;
							n.access = null;
							n.created = null;
							n.description = null;
							n.id = null;
							n.isInvitationOnly = !1;
							n.modified = null;
							n.owner = null;
							n.portal = null;
							n.snippet = null;
							n.sortField = null;
							n.sortOrder = null;
							n.tags = null;
							n.title = null;
							return n
						}
						a._inheritsLoose(r, l);
						var p = r.prototype;
						p.fetchCategorySchema = function(n) {
							return d.unwrapOrThrow(this.portal)
								._request(this.url + "/categorySchema", n)
								.then(t => {
									t = t.categorySchema || [];
									return t.some(h => "contentCategorySetsGroupQuery.LivingAtlas" ===
										h.source) ? this._fetchCategorySchemaSet("LivingAtlas", n) : t
								})
						};
						p.fetchMembers = function(n) {
							return d.unwrapOrThrow(this.portal)
								._request(this.url + "/users", n)
						};
						p.getThumbnailUrl = function(n) {
							let t = this.thumbnailUrl;
							t && n && (t += `&w=${n}`);
							return t
						};
						p.toJSON = function() {
							throw new c("internal:not-yet-implemented", "PortalGroup.toJSON is not yet implemented");
						};
						p.queryItems = function(n, t) {
							n = m.ensureType(g, n);
							const h = d.unwrapOrThrow(this.portal);
							if (5 < parseFloat(h.currentVersion)) return n = n || new g, h._queryPortal(`/content/groups/${this.id}/search`,
								n, "PortalItem", t);
							n = n ? n.clone() : new g;
							n.query = "group:" + this.id + (n.query ? " " + n.query : "");
							return h.queryItems(n, t)
						};
						p._fetchCategorySchemaSet = function(n, t) {
							const h = d.unwrapOrThrow(this.portal);
							return h._fetchSelf(h.authMode, !0, t)
								.then(q => {
									if (q = q.contentCategorySetsGroupQuery) {
										const u = new g;
										u.disableExtraQuery = !0;
										u.num = 1;
										u.query = q;
										return h.queryGroups(u, t)
									}
									throw new c("portal-group:fetchCategorySchema", "contentCategorySetsGroupQuery value not found");
								})
								.then(q => {
									if (q.total) {
										q = q.results[0];
										const u = new g;
										u.num = 1;
										u.query = `typekeywords:"${n}"`;
										return q.queryItems(u, t)
									}
									throw new c("portal-group:fetchCategorySchema", "contentCategorySetsGroupQuery group not found");
								})
								.then(q => q.total ? q.results[0].fetchData("json", t)
									.then(u => (u = u && u.categorySchema) && u.length ? u : []) : [])
						};
						a._createClass(r, [{
							key: "thumbnailUrl",
							get: function() {
								const n = this.url,
									t = this.thumbnail;
								return n && t && this.portal ? this.portal ? ._normalizeUrl(`${n}/info/${t}?f=json`) : null
							}
						}, {
							key: "url",
							get: function() {
								const n = this.get("portal.restUrl");
								return n ?
									n + "/community/groups/" + this.id : null
							}
						}]);
						return r
					}(e.JSONSupport);
					b.__decorate([k.property()], e.prototype, "access", void 0);
					b.__decorate([k.property({
						type: Date
					})], e.prototype, "created", void 0);
					b.__decorate([k.property()], e.prototype, "description", void 0);
					b.__decorate([k.property()], e.prototype, "id", void 0);
					b.__decorate([k.property()], e.prototype, "isInvitationOnly", void 0);
					b.__decorate([k.property({
						type: Date
					})], e.prototype, "modified", void 0);
					b.__decorate([k.property()], e.prototype, "owner", void 0);
					b.__decorate([k.property()],
						e.prototype, "portal", void 0);
					b.__decorate([k.property()], e.prototype, "snippet", void 0);
					b.__decorate([k.property()], e.prototype, "sortField", void 0);
					b.__decorate([k.property()], e.prototype, "sortOrder", void 0);
					b.__decorate([k.property()], e.prototype, "tags", void 0);
					b.__decorate([k.property()], e.prototype, "thumbnail", void 0);
					b.__decorate([k.property({
						readOnly: !0
					})], e.prototype, "thumbnailUrl", null);
					b.__decorate([k.property()], e.prototype, "title", void 0);
					b.__decorate([k.property({
							readOnly: !0
						})], e.prototype,
						"url", null);
					return e = b.__decorate([f.subclass("esri.portal.PortalGroup")], e)
				})
		},
		"esri/portal/PortalItem": function() {
			define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../assets ../core/Error ../core/JSONSupport ../core/lang ../core/Loadable ../core/maybe ../core/urlUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../geometry/Extent ./Portal ./PortalItemResource ./PortalRating".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u) {
					var x;
					const y = new Set("Map Service;Feature Service;Feature Collection;Scene Service;Image Service;Stream Service;Vector Tile Service;GeoJson;CSV;KML;WFS;WMTS;WMS;Feed".split(";")),
						w = new Set(["KML", "GeoJson", "CSV"]);
					k = x = function(A) {
						function B(z) {
							z = A.call(this, z) || this;
							z.access = null;
							z.accessInformation = null;
							z.apiKey = null;
							z.applicationProxies = null;
							z.avgRating = null;
							z.categories = null;
							z.created = null;
							z.culture = null;
							z.description = null;
							z.extent = null;
							z.groupCategories =
								null;
							z.id = null;
							z.itemControl = null;
							z.licenseInfo = null;
							z.modified = null;
							z.name = null;
							z.numComments = null;
							z.numRatings = null;
							z.numViews = null;
							z.owner = null;
							z.ownerFolder = null;
							z.portal = null;
							z.screenshots = null;
							z.size = null;
							z.snippet = null;
							z.sourceJSON = null;
							z.spatialReference = null;
							z.tags = null;
							z.title = null;
							z.type = null;
							z.typeKeywords = null;
							z.url = null;
							return z
						}
						b._inheritsLoose(B, A);
						B.from = function(z) {
							return r.ensureClass(x, z)
						};
						var E = B.prototype;
						E.destroy = function() {
							this.portal = null
						};
						E.readExtent = function(z) {
							return z &&
								z.length ? new t(z[0][0], z[0][1], z[1][0], z[1][1]) : null
						};
						E.load = function(z) {
							const C = this.portal ? ? (this.portal = h.getDefault()),
								D = C.load(z)
								.then(() => this.sourceJSON ? this.sourceJSON : this.id && this.itemUrl ? C._request(this.itemUrl, {
									signal: f.isSome(z) ? z.signal : null,
									query: {
										token: this.apiKey
									}
								}) : {})
								.then(J => {
									this.sourceJSON = J;
									this.read(J)
								});
							this.addResolvingPromise(D);
							return Promise.resolve(this)
						};
						E.addRating = function() {
							var z = b._asyncToGenerator(function*(C) {
								const D = {
									method: "post",
									query: {}
								};
								C instanceof u && (C =
									C.rating);
								null == C || isNaN(C) || "number" !== typeof C || (D.query.rating = C);
								if (!this.portal) return null;
								yield this.portal._request(this.itemUrl + "/addRating", D);
								return new u({
									rating: C,
									created: new Date
								})
							});
							return function(C) {
								return z.apply(this, arguments)
							}
						}();
						E.clone = function() {
							const z = {
								access: this.access,
								accessInformation: this.accessInformation,
								applicationProxies: v.clone(this.applicationProxies),
								avgRating: this.avgRating,
								categories: v.clone(this.categories),
								created: v.clone(this.created),
								culture: this.culture,
								description: this.description,
								extent: v.clone(this.extent),
								groupCategories: v.clone(this.groupCategories),
								id: this.id,
								itemControl: this.itemControl,
								licenseInfo: this.licenseInfo,
								modified: v.clone(this.modified),
								name: this.name,
								numComments: this.numComments,
								numRatings: this.numRatings,
								numViews: this.numViews,
								owner: this.owner,
								ownerFolder: this.ownerFolder,
								portal: this.portal,
								screenshots: v.clone(this.screenshots),
								size: this.size,
								snippet: this.snippet,
								spatialReference: this.spatialReference,
								tags: v.clone(this.tags),
								thumbnail: this.thumbnail,
								title: this.title,
								type: this.type,
								typeKeywords: v.clone(this.typeKeywords),
								url: this.url
							};
							this.loaded && (z.loadStatus = "loaded");
							return (new x({
									sourceJSON: this.sourceJSON
								}))
								.set(z)
						};
						E.createPostQuery = function() {
							const z = this.toJSON();
							for (var C of ["tags", "typeKeywords", "categories"]) z[C] && (z[C] = z[C].join(", "));
							({
								extent: C
							} = z);
							C && (z.extent = JSON.stringify(C));
							return z
						};
						E.deleteRating = function() {
							var z = b._asyncToGenerator(function*() {
								yield f.unwrapOrThrow(this.portal)
									._request(this.itemUrl + "/deleteRating", {
										method: "post"
									})
							});
							return function() {
								return z.apply(this, arguments)
							}
						}();
						E.fetchData = function(z = "json", C) {
							return f.unwrapOrThrow(this.portal)
								._request(this.itemUrl + "/data", {
									responseType: z,
									...C,
									query: {
										token: this.apiKey
									}
								})
						};
						E.fetchRating = function() {
							var z = b._asyncToGenerator(function*(C) {
								C = yield f.unwrapOrThrow(this.portal)
									._request(this.itemUrl + "/rating", {
										query: {
											token: this.apiKey
										},
										...C
									});
								return null != C.rating ? (C.created = new Date(C.created), new u(C)) : null
							});
							return function(C) {
								return z.apply(this, arguments)
							}
						}();
						E.fetchRelatedItems =
							function(z, C) {
								return f.unwrapOrThrow(this.portal)
									._requestToTypedArray(this.itemUrl + "/relatedItems", {
										query: {
											...z,
											token: this.apiKey
										},
										...C
									}, x)
							};
						E.getThumbnailUrl = function(z) {
							let C = this.thumbnailUrl;
							C && z && (C += `&w=${z}`);
							return C
						};
						E.reload = function() {
							return f.unwrapOrThrow(this.portal)
								._request(this.itemUrl ? ? "", {
									cacheBust: !0,
									query: {
										token: this.apiKey
									}
								})
								.then(z => {
									this.sourceJSON = z;
									this.read(z);
									return this
								})
						};
						E.update = function(z) {
							return this.id ? this.load()
								.then(() => f.unwrapOrThrow(this.portal)
									._signIn())
								.then(() => {
									const C = z && z.data,
										D = {
											method: "post"
										};
									D.query = this.createPostQuery();
									for (const J in D.query) null === D.query[J] && (D.query[J] = "");
									D.query.clearEmptyFields = !0;
									null != C && ("string" === typeof C ? D.query.text = C : "object" === typeof C && (D.query.text = JSON.stringify(C)));
									return this.portal._request(`${this.userItemUrl}/update`, D)
										.then(() => this.reload())
								}) : Promise.reject(new d("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"))
						};
						E.updateThumbnail = function(z) {
							return this.id ? this.load()
								.then(() =>
									this.portal._signIn())
								.then(() => {
									const C = z.thumbnail,
										D = z.filename,
										J = {
											method: "post"
										};
									if ("string" === typeof C) g.isDataProtocol(C) ? J.query = {
										data: C
									} : J.query = {
										url: g.makeAbsolute(C)
									}, f.isSome(D) && (J.query.filename = D);
									else {
										const K = new FormData;
										f.isSome(D) ? K.append("file", C, D) : K.append("file", C);
										J.body = K
									}
									return this.portal._request(`${this.userItemUrl}/updateThumbnail`, J)
										.then(() => this.reload())
								}) : Promise.reject(new d("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"))
						};
						E.fetchResources =
							function() {
								var z = b._asyncToGenerator(function*(C = {}, D) {
									return (yield new Promise((J, K) => a(["./support/resourceUtils"], J, K)))
										.fetchResources(this, C, D)
								});
								return function() {
									return z.apply(this, arguments)
								}
							}();
						E.addResource = function() {
							var z = b._asyncToGenerator(function*(C, D, J) {
								const K = yield new Promise((H, G) => a(["./support/resourceUtils"], H, G));
								C.portalItem = this;
								return K.addOrUpdateResource(C, "add", D, J)
							});
							return function(C, D, J) {
								return z.apply(this, arguments)
							}
						}();
						E.removeResource = function() {
							var z = b._asyncToGenerator(function*(C,
								D) {
								const J = yield new Promise((K, H) => a(["./support/resourceUtils"], K, H));
								if (C.portalItem && C.portalItem.itemUrl !== this.itemUrl) throw new d("removeresource:portal-item-mismatch", "The portal item associated with the provided resource does not match the item");
								return J.removeResource(this, C, D)
							});
							return function(C, D) {
								return z.apply(this, arguments)
							}
						}();
						E.removeAllResources = function() {
							var z = b._asyncToGenerator(function*(C) {
								return (yield new Promise((D, J) => a(["./support/resourceUtils"], D, J)))
									.removeAllResources(this,
										C)
							});
							return function(C) {
								return z.apply(this, arguments)
							}
						}();
						E.resourceFromPath = function(z) {
							return new q({
								portalItem: this,
								path: z
							})
						};
						E.toJSON = function() {
							var z = this.extent;
							z = {
								accessInformation: this.accessInformation,
								categories: v.clone(this.categories),
								created: this.created && this.created.getTime(),
								description: this.description,
								extent: z && [
									[z.xmin, z.ymin],
									[z.xmax, z.ymax]
								],
								id: this.id,
								licenseInfo: this.licenseInfo,
								modified: this.modified && this.modified.getTime(),
								name: this.name,
								owner: this.owner,
								ownerFolder: this.ownerFolder,
								snippet: this.snippet,
								spatialReference: this.spatialReference,
								tags: v.clone(this.tags),
								thumbnail: this.thumbnail,
								title: this.title,
								type: this.type,
								typeKeywords: v.clone(this.typeKeywords),
								url: this.url
							};
							return v.fixJson(z)
						};
						B.fromJSON = function(z) {
							if (!z) return null;
							if (z.declaredClass) throw Error("JSON object is already hydrated");
							return new x({
								sourceJSON: z
							})
						};
						E._getPostQuery = function() {
							const z = this.toJSON();
							for (const C in z) "tags" === C && null !== z[C] && (z[C] = z[C].join(", ")), "typeKeywords" === C && null !== z[C] && (z[C] =
								z[C].join(", ")), "extent" === C && z[C] && (z[C] = JSON.stringify(z[C]));
							return z
						};
						b._createClass(B, [{
							key: "displayName",
							get: function() {
								const z = this.type,
									C = this.typeKeywords || [];
								let D = z;
								"Feature Service" === z || "Feature Collection" === z ? D = C.includes("Table") ? "Table" : C.includes("Route Layer") ? "Route Layer" : C.includes("Markup") ? "Markup" : "Feature Layer" : "Image Service" === z ? D = C.includes("Elevation 3D Layer") ? "Elevation Layer" : C.includes("Tiled Imagery") ? "Tiled Imagery Layer" : "Imagery Layer" : "Scene Service" === z ? D =
									"Scene Layer" : "Video Service" === z ? D = "Video Layer" : "Scene Package" === z ? D = "Scene Layer Package" : "Stream Service" === z ? D = "Feature Layer" : "Geoprocessing Service" === z && this.portal && this.portal.isPortal ? D = C.includes("Web Tool") ? "Tool" : "Geoprocessing Service" : "Geocoding Service" === z ? D = "Locator" : "Geoenrichment Service" === z ? D = "GeoEnrichment Service" : "Microsoft Powerpoint" === z ? D = "Microsoft PowerPoint" : "GeoJson" === z ? D = "GeoJSON" : "Globe Service" === z ? D = "Globe Layer" : "Vector Tile Service" === z ? D = "Tile Layer" : "netCDF" ===
									z ? D = "NetCDF" : "Map Service" === z ? D = C.includes("Spatiotemporal") || !C.includes("Hosted Service") && !C.includes("Tiled") || C.includes("Relational") ? "Map Image Layer" : "Tile Layer" : z && z.toLowerCase()
									.includes("add in") ? D = z.replace(/(add in)/gi, "Add-In") : "datastore catalog service" === z ? D = "Big Data File Share" : "Compact Tile Package" === z ? D = "Tile Package (tpkx)" : "OGCFeatureServer" === z ? D = "OGC Feature Layer" : "web mapping application" === z && C.includes("configurableApp") && (D = "Instant App");
								return D
							}
						}, {
							key: "iconUrl",
							get: function() {
								var z = this.type && this.type.toLowerCase() || "";
								const C = this.typeKeywords || [];
								let D = !1,
									J = !1,
									K = !1,
									H = !1,
									G = !1,
									F = !1;
								0 < z.indexOf("service") || "feature collection" === z || "kml" === z || "wms" === z || "wmts" === z || "wfs" === z ? (D = C.includes("Hosted Service"), "feature service" === z || "feature collection" === z || "kml" === z || "wfs" === z ? (J = C.includes("Table"), K = C.includes("Route Layer"), H = C.includes("Markup"), G = C.includes("Spatiotemporal"), F = C.includes("UtilityNetwork"), z = G && J ? "spatiotemporaltable" : J ? "table" : K ? "routelayer" :
											H ? "markup" : G ? "spatiotemporal" : D ? "featureshosted" : F ? "utilitynetwork" : "features") : z = "map service" === z || "wms" === z || "wmts" === z ? D || C.includes("Tiled") || "wmts" === z ? "maptiles" : "mapimages" : "scene service" === z ? C.includes("Line") ? "sceneweblayerline" : C.includes("3DObject") ? "sceneweblayermultipatch" : C.includes("Point") ? "sceneweblayerpoint" : C.includes("IntegratedMesh") ? "sceneweblayermesh" : C.includes("PointCloud") ? "sceneweblayerpointcloud" : C.includes("Polygon") ? "sceneweblayerpolygon" : C.includes("Building") ? "sceneweblayerbuilding" :
										C.includes("Voxel") ? "sceneweblayervoxel" : "sceneweblayer" : "image service" === z ? C.includes("Elevation 3D Layer") ? "elevationlayer" : C.includes("Tiled Imagery") ? "tiledimagerylayer" : "imagery" : "stream service" === z ? "streamlayer" : "video service" === z ? "mediaservice" : "vector tile service" === z ? "vectortile" : "datastore catalog service" === z ? "datastorecollection" : "geocoding service" === z ? "geocodeservice" : "geoprocessing service" === z ? C.includes("Web Tool") && this.portal && this.portal.isPortal ? "tool" : "layers" : "geodata service" ===
										z ? "geodataservice" : "layers") : z = "web map" === z || "cityengine web scene" === z ? "maps" : "web scene" === z ? C.includes("ViewingMode-Local") ? "webscenelocal" : "websceneglobal" : "web mapping application" === z && C.includes("configurableApp") ? "instantapps" : "web mapping application" === z || "mobile application" === z || "application" === z || "operation view" === z || "desktop application" === z ? "apps" : "map document" === z || "map package" === z || "published map" === z || "scene document" === z || "globe document" === z || "basemap package" === z || "mobile basemap package" ===
									z || "mobile map package" === z || "project package" === z || "project template" === z || "pro map" === z || "layout" === z || "layer" === z && C.includes("ArcGIS Pro") || "explorer map" === z && C.indexOf("Explorer Document") ? "mapsgray" : "service definition" === z || "csv" === z || "shapefile" === z || "cad drawing" === z || "geojson" === z || "360 vr experience" === z || "netcdf" === z || "administrative report" === z ? "datafiles" : "explorer add in" === z || "desktop add in" === z || "windows viewer add in" === z || "windows viewer configuration" === z ? "appsgray" : "arcgis pro add in" ===
									z || "arcgis pro configuration" === z ? "addindesktop" : "rule package" === z || "file geodatabase" === z || "sqlite geodatabase" === z || "csv collection" === z || "kml collection" === z || "windows mobile package" === z || "map template" === z || "desktop application template" === z || "gml" === z || "arcpad package" === z || "code sample" === z || "form" === z || "document link" === z || "earth configuration" === z || "operations dashboard add in" === z || "rules package" === z || "image" === z || "workflow manager package" === z || "explorer map" === z && C.includes("Explorer Mapping Application") ||
									C.includes("Document") ? "datafilesgray" : "network analysis service" === z || "geoprocessing service" === z || "geodata service" === z || "geometry service" === z || "geoprocessing package" === z || "locator package" === z || "geoprocessing sample" === z || "workflow manager service" === z ? "toolsgray" : "layer" === z || "layer package" === z || "explorer layer" === z ? "layersgray" : "scene package" === z ? "scenepackage" : "mobile scene package" === z ? "mobilescenepackage" : "tile package" === z || "compact tile package" === z ? "tilepackage" : "task file" === z ? "taskfile" :
									"report template" === z ? "report-template" : "statistical data collection" === z ? "statisticaldatacollection" : "insights workbook" === z ? "workbook" : "insights model" === z ? "insightsmodel" : "insights page" === z ? "insightspage" : "insights theme" === z ? "insightstheme" : "hub initiative" === z ? "hubinitiative" : "hubpage" === z ? "hubpage" : "hub event" === z ? "hubevent" : "hub site application" === z ? "hubsite" : "hub project" === z ? "hubproject" : "relational database connection" === z ? "relationaldatabaseconnection" : "big data file share" === z ? "datastorecollection" :
									"image collection" === z ? "imagecollection" : "style" === z ? "style" : "desktop style" === z ? "desktopstyle" : "dashboard" === z ? "dashboard" : "raster function template" === z ? "rasterprocessingtemplate" : "vector tile package" === z ? "vectortilepackage" : "ortho mapping project" === z ? "orthomappingproject" : "ortho mapping template" === z ? "orthomappingtemplate" : "solution" === z ? "solutions" : "geopackage" === z ? "geopackage" : "deep learning package" === z ? "deeplearningpackage" : "real time analytic" === z ? "realtimeanalytics" : "big data analytic" ===
									z ? "bigdataanalytics" : "feed" === z ? "feed" : "excalibur imagery project" === z ? "excaliburimageryproject" : "notebook" === z ? "notebook" : "storymap" === z ? "storymap" : "survey123 add in" === z ? "survey123addin" : "mission" === z ? "mission" : "mission report" === z ? "missionreport" : "quickcapture project" === z ? "quickcaptureproject" : "pro report" === z ? "proreport" : "pro report template" === z ? "proreporttemplate" : "urban model" === z ? "urbanmodel" : "web experience" === z ? "experiencebuilder" : "web experience template" === z ? "webexperiencetemplate" : "experience builder widget" ===
									z ? "experiencebuilderwidget" : "experience builder widget package" === z ? "experiencebuilderwidgetpackage" : "workflow" === z ? "workflow" : "insights script" === z ? "insightsscript" : "kernel gateway connection" === z ? "kernelgatewayconnection" : "hub initiative template" === z ? "hubinitiativetemplate" : "storymap theme" === z ? "storymaptheme" : "knowledge graph" === z ? "knowledgegraph" : "native application" === z ? "nativeapp" : "native application installer" === z ? "nativeappinstaller" : "link chart" === z ? "linkchart" : "investigation" === z ? "investigation" :
									"ogcfeatureserver" === z ? "features" : "pro project" === z ? "proproject" : "insights workbook package" === z ? "insightsworkbookpackage" : "apache parquet" === z ? "apacheparquet" : "notebook code snippets" === z || "notebook code snippet library" === z ? "notebookcodesnippets" : "suitability model" === z ? "suitabilitymodel" : "esri classifier definition" === z ? "classifierdefinition" : "esri classification schema" === z ? "classificationschema" : "insights data engineering workbook" === z ? "dataengineeringworkbook" : "insights data engineering model" ===
									z ? "dataengineeringmodel" : "deep learning studio project" === z ? "deeplearningproject" : "discussion" === z ? "discussion" : "maps";
								return z ? e.getAssetUrl("esri/images/portal/" + z + "16.png") : null
							}
						}, {
							key: "isLayer",
							get: function() {
								return null != this.type && y.has(this.type)
							}
						}, {
							key: "itemPageUrl",
							get: function() {
								const z = this.portal ? .itemPageUrl;
								return z && this.id ? `${z}?id=${this.id}` : null
							}
						}, {
							key: "itemUrl",
							get: function() {
								const z = this.portal ? .restUrl;
								return z && this.id ? `${z}/content/items/${this.id}` : null
							}
						}, {
							key: "thumbnailUrl",
							get: function() {
								const z = this.itemUrl,
									C = this.thumbnail;
								return z && C ? this.portal ? ._normalizeUrl(`${z}/info/${C}?f=json`) ? ? null : null
							}
						}, {
							key: "userItemUrl",
							get: function() {
								const z = this.get("portal.restUrl");
								if (!z) return null;
								const C = this.owner || this.get("portal.user.username");
								return C ? `${z}/content/users/${this.ownerFolder?`${C}/${this.ownerFolder}`:C}/items/${this.id}` : null
							}
						}]);
						return B
					}(k.JSONSupportMixin(m));
					c.__decorate([l.property({
						type: ["private", "shared", "org", "public"]
					})], k.prototype, "access", void 0);
					c.__decorate([l.property()], k.prototype, "accessInformation", void 0);
					c.__decorate([l.property({
						type: String
					})], k.prototype, "apiKey", void 0);
					c.__decorate([l.property({
						json: {
							read: {
								source: "appProxies"
							}
						}
					})], k.prototype, "applicationProxies", void 0);
					c.__decorate([l.property()], k.prototype, "avgRating", void 0);
					c.__decorate([l.property()], k.prototype, "categories", void 0);
					c.__decorate([l.property({
						type: Date
					})], k.prototype, "created", void 0);
					c.__decorate([l.property()], k.prototype, "culture", void 0);
					c.__decorate([l.property()],
						k.prototype, "description", void 0);
					c.__decorate([l.property({
						readOnly: !0
					})], k.prototype, "displayName", null);
					c.__decorate([l.property({
						type: t
					})], k.prototype, "extent", void 0);
					c.__decorate([p.reader("extent")], k.prototype, "readExtent", null);
					c.__decorate([l.property()], k.prototype, "groupCategories", void 0);
					c.__decorate([l.property({
						readOnly: !0
					})], k.prototype, "iconUrl", null);
					c.__decorate([l.property()], k.prototype, "id", void 0);
					c.__decorate([l.property({
						readOnly: !0
					})], k.prototype, "isLayer", null);
					c.__decorate([l.property()],
						k.prototype, "itemControl", void 0);
					c.__decorate([l.property({
						readOnly: !0
					})], k.prototype, "itemPageUrl", null);
					c.__decorate([l.property({
						readOnly: !0
					})], k.prototype, "itemUrl", null);
					c.__decorate([l.property()], k.prototype, "licenseInfo", void 0);
					c.__decorate([l.property({
						type: Date
					})], k.prototype, "modified", void 0);
					c.__decorate([l.property()], k.prototype, "name", void 0);
					c.__decorate([l.property()], k.prototype, "numComments", void 0);
					c.__decorate([l.property()], k.prototype, "numRatings", void 0);
					c.__decorate([l.property()],
						k.prototype, "numViews", void 0);
					c.__decorate([l.property()], k.prototype, "owner", void 0);
					c.__decorate([l.property()], k.prototype, "ownerFolder", void 0);
					c.__decorate([l.property({
						type: h
					})], k.prototype, "portal", void 0);
					c.__decorate([l.property()], k.prototype, "screenshots", void 0);
					c.__decorate([l.property()], k.prototype, "size", void 0);
					c.__decorate([l.property()], k.prototype, "snippet", void 0);
					c.__decorate([l.property()], k.prototype, "sourceJSON", void 0);
					c.__decorate([l.property({
							type: String
						})], k.prototype,
						"spatialReference", void 0);
					c.__decorate([l.property()], k.prototype, "tags", void 0);
					c.__decorate([l.property()], k.prototype, "thumbnail", void 0);
					c.__decorate([l.property({
						readOnly: !0
					})], k.prototype, "thumbnailUrl", null);
					c.__decorate([l.property()], k.prototype, "title", void 0);
					c.__decorate([l.property()], k.prototype, "type", void 0);
					c.__decorate([l.property()], k.prototype, "typeKeywords", void 0);
					c.__decorate([l.property({
						type: String,
						json: {
							read(A, B) {
								w.has(B.type) && (B = this.portal ? .restUrl, A || (A = B && this.id ? `${B}/content/items/${this.id}/data` :
									null));
								return A
							}
						}
					})], k.prototype, "url", void 0);
					c.__decorate([l.property({
						readOnly: !0
					})], k.prototype, "userItemUrl", null);
					return k = x = c.__decorate([n.subclass("esri.portal.PortalItem")], k)
				})
		},
		"esri/assets": function() {
			define("exports ./config ./request ./core/Error ./core/Logger ./core/urlUtils".split(" "), function(a, b, c, e, d, k) {
				function v(f) {
					if (!b.assetsPath) throw m.errorOnce("The API assets location needs to be set using config.assetsPath. More information: https://arcg.is/1OzLe50"), new e("assets:path-not-set",
						"config.assetsPath is not set");
					return k.join(b.assetsPath, f)
				}
				const m = d.getLogger("esri.assets");
				a.fetchAsset = function(f, g) {
					return c(v(f), g)
				};
				a.getAssetUrl = v;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/portal/PortalItemResource": function() {
			define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/Error ../core/Logger ../core/maybe ../core/urlUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					e = function(p) {
						function n(h) {
							h = p.call(this, h) || this;
							h.portalItem = null;
							return h
						}
						b._inheritsLoose(n, p);
						var t = n.prototype;
						t.normalizeCtorArgs = function(h) {
							return h && h.portalItem && h.path ? {
								...h,
								path: this._normalizePath(h.path, h.portalItem)
							} : h
						};
						t._castPath = function(h) {
							return this._normalizePath(h, this.portalItem)
						};
						t.fetch = function(h = "json", q) {
							const u = this.url;
							if (v.isNone(u)) throw new d("portal-item-resource:fetch", "Portal item resource does not refer to a valid item or path");
							return this.portalItem.portal._request(u, {
								responseType: h,
								query: {
									token: this.portalItem.apiKey
								},
								signal: v.get(q, "signal")
							})
						};
						t.update = function() {
							var h = b._asyncToGenerator(function*(q, u) {
								return (yield new Promise((x, y) => a(["./support/resourceUtils"], x, y)))
									.addOrUpdateResource(this, "update", q, u)
							});
							return function(q, u) {
								return h.apply(this, arguments)
							}
						}();
						t.hasPath = function() {
							return v.isSome(this.path)
						};
						t._normalizePath = function(h, q) {
							if (v.isNone(h)) return h;
							h = h.replace(/^\/+/, "");
							v.isSome(q) && m.isAbsolute(h) &&
								(h = m.makeRelative(h, q.itemUrl));
							return h.replace(/^\/+/, "")
								.replace(/^(\.\/)?resources\//, "")
						};
						b._createClass(n, [{
							key: "path",
							set: function(h) {
								v.isSome(h) && m.isAbsolute(h) ? k.getLogger(this.declaredClass)
									.error("portalitemresource:invalid-path", "A portal item resource path must be relative") : this._set("path", h)
							}
						}, {
							key: "url",
							get: function() {
								return this.portalItem && this.path ? `${this.portalItem.itemUrl}/resources/${this.path}` : null
							}
						}, {
							key: "itemRelativeUrl",
							get: function() {
								return this.portalItem && this.path ?
									`./resources/${this.path}` : null
							}
						}]);
						return n
					}(e);
					c.__decorate([f.property()], e.prototype, "portalItem", void 0);
					c.__decorate([f.property({
						type: String,
						value: null
					})], e.prototype, "path", null);
					c.__decorate([l.cast("path")], e.prototype, "_castPath", null);
					c.__decorate([f.property({
						type: String,
						readOnly: !0
					})], e.prototype, "url", null);
					c.__decorate([f.property({
						type: String,
						readOnly: !0
					})], e.prototype, "itemRelativeUrl", null);
					return e = c.__decorate([r.subclass("esri.portal.PortalItemResource")], e)
				})
		},
		"esri/portal/PortalRating": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f(g) {
							g = m.call(this, g) || this;
							g.created = null;
							g.rating = null;
							return g
						}
						a._inheritsLoose(f, m);
						return f
					}(c);
					b.__decorate([e.property()], c.prototype, "created", void 0);
					b.__decorate([e.property()], c.prototype, "rating", void 0);
					return c = b.__decorate([v.subclass("esri.portal.PortalRating")], c)
				})
		},
		"esri/support/basemapDefinitions": function() {
			define(["exports", "../chunks/_rollupPluginBabelHelpers", "../assets", "../intl/messages"], function(a, b, c, e) {
				function d() {
					d = b._asyncToGenerator(function*(k) {
						if (k) {
							var v =
								k.includes("-vector") ? k.slice(0, k.indexOf("-vector")) : k,
								m = yield e.fetchMessageBundle("esri/t9n/basemaps");
							return m[k] || m[v]
						}
					});
					return d.apply(this, arguments)
				}
				a.esriBasemapDefinitions = {
					streets: {
						id: "streets",
						classic: !0,
						deprecated: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets.jpg")
						},
						baseMapLayers: [{
							id: "streets-base-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Street Map",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					satellite: {
						id: "satellite",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/satellite.jpg")
						},
						baseMapLayers: [{
							id: "satellite-base-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Imagery",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					hybrid: {
						id: "hybrid",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/hybrid.jpg")
						},
						baseMapLayers: [{
							id: "hybrid-base-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Imagery",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}, {
							id: "hybrid-reference-layer",
							styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/30d6b8271e1849cd9c3042060001f425/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "Hybrid Reference Layer",
							isReference: !0,
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					terrain: {
						id: "terrain",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/terrain.jpg")
						},
						baseMapLayers: [{
							id: "terrain-base-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Terrain Base",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}, {
							id: "terrain-reference-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Reference Overlay",
							isReference: !0,
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					topo: {
						id: "topo",
						classic: !0,
						deprecated: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/topo.jpg")
						},
						baseMapLayers: [{
							id: "topo-base-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Topo Map",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					gray: {
						id: "gray",
						classic: !0,
						deprecated: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/gray.jpg")
						},
						baseMapLayers: [{
							id: "gray-base-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Light Gray Base",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}, {
							id: "gray-reference-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Light Gray Reference",
							isReference: !0,
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					"dark-gray": {
						id: "dark-gray",
						classic: !0,
						deprecated: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/dark-gray.jpg")
						},
						baseMapLayers: [{
							id: "dark-gray-base-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Dark Gray Base",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}, {
							id: "dark-gray-reference-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Dark Gray Reference",
							isReference: !0,
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					oceans: {
						id: "oceans",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/oceans.jpg")
						},
						baseMapLayers: [{
							id: "oceans-base-layer",
							url: "//services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Ocean Base",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}, {
							id: "oceans-reference-layer",
							url: "//services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Ocean Reference",
							isReference: !0,
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					"national-geographic": {
						id: "national-geographic",
						classic: !0,
						deprecated: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/national-geographic.jpg")
						},
						baseMapLayers: [{
							id: "national-geographic-base-layer",
							url: "//services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer",
							title: "NatGeo World Map",
							showLegend: !1,
							layerType: "ArcGISTiledMapServiceLayer",
							visibility: !0,
							opacity: 1
						}]
					},
					osm: {
						id: "osm",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/osm.jpg")
						},
						baseMapLayers: [{
							id: "osm-base-layer",
							layerType: "OpenStreetMap",
							title: "Open Street Map",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}]
					},
					"dark-gray-vector": {
						id: "dark-gray-vector",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/dark-gray-vector.jpg")
						},
						baseMapLayers: [{
							id: "dark-gray-base-layer",
							styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/5e9b3685f4c24d8781073dd928ebda50/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "Dark Gray Base",
							visibility: !0,
							opacity: 1
						}, {
							id: "dark-gray-reference-layer",
							styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/747cb7a5329c478cbe6981076cc879c5/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "Dark Gray Reference",
							isReference: !0,
							visibility: !0,
							opacity: 1
						}]
					},
					"gray-vector": {
						id: "gray-vector",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/gray-vector.jpg")
						},
						baseMapLayers: [{
							id: "gray-base-layer",
							styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/291da5eab3a0412593b66d384379f89f/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "Light Gray Base",
							visibility: !0,
							opacity: 1
						}, {
							id: "gray-reference-layer",
							styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/1768e8369a214dfab4e2167d5c5f2454/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "Light Gray Reference",
							isReference: !0,
							visibility: !0,
							opacity: 1
						}]
					},
					"streets-vector": {
						id: "streets-vector",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets-vector.jpg")
						},
						baseMapLayers: [{
							id: "streets-vector-base-layer",
							styleUrl: "//cdn.arcgis.com/sharing/rest/content/items/de26a3cf4cc9451298ea173c4b324736/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "World Streets",
							visibility: !0,
							opacity: 1
						}]
					},
					"topo-vector": {
						id: "topo-vector",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/topo-vector.jpg")
						},
						baseMapLayers: [{
							id: "world-hillshade-layer",
							url: "//services.arcgisonline.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Hillshade",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}, {
							id: "topo-vector-base-layer",
							styleUrl: "//cdn.arcgis.com/sharing/rest/content/items/7dc6cea0b1764a1f9af2e679f642f0f5/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "World Topo",
							visibility: !0,
							opacity: 1
						}]
					},
					"streets-night-vector": {
						id: "streets-night-vector",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets-night.jpg")
						},
						baseMapLayers: [{
							id: "streets-night-vector-base-layer",
							styleUrl: "//cdn.arcgis.com/sharing/rest/content/items/86f556a2d1fd468181855a35e344567f/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "World Streets Night",
							visibility: !0,
							opacity: 1
						}]
					},
					"streets-relief-vector": {
						id: "streets-relief-vector",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets-relief.jpg")
						},
						baseMapLayers: [{
							id: "world-hillshade-layer",
							url: "//services.arcgisonline.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer",
							layerType: "ArcGISTiledMapServiceLayer",
							title: "World Hillshade",
							showLegend: !1,
							visibility: !0,
							opacity: 1
						}, {
							id: "streets-relief-vector-base-layer",
							styleUrl: "//www.arcgis.com/sharing/rest/content/items/b266e6d17fc345b498345613930fbd76/resources/styles/root.json",
							title: "World Streets Relief",
							layerType: "VectorTileLayer",
							visibility: !0,
							opacity: 1
						}]
					},
					"streets-navigation-vector": {
						id: "streets-navigation-vector",
						classic: !0,
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets-navigation.jpg")
						},
						baseMapLayers: [{
							id: "streets-navigation-vector-base-layer",
							styleUrl: "//cdn.arcgis.com/sharing/rest/content/items/63c47b7177f946b49902c24129b87252/resources/styles/root.json",
							layerType: "VectorTileLayer",
							title: "World Streets Navigation",
							visibility: !0,
							opacity: 1
						}]
					},
					"arcgis-imagery": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/hybrid.jpg")
						},
						title: "Imagery Hybrid",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Imagery",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/World_Imagery/MapServer"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Imagery:Labels",
							title: "Hybrid Reference Layer",
							isReference: !0
						}]
					},
					"arcgis-imagery-standard": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/satellite.jpg")
						},
						title: "Imagery",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Imagery",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/World_Imagery/MapServer"
						}]
					},
					"arcgis-imagery-labels": {
						title: "Hybrid [Reference]",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Imagery:Labels",
							title: "Hybrid Reference Layer",
							isReference: !0
						}]
					},
					"arcgis-light-gray": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/gray-vector.jpg")
						},
						title: "Light Gray Canvas",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:LightGray:Base",
							title: "Light Gray Canvas Base"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:LightGray:Labels",
							title: "Light Gray Canvas Labels",
							isReference: !0
						}]
					},
					"arcgis-dark-gray": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/dark-gray.jpg")
						},
						title: "Dark Gray Canvas",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:DarkGray:Base",
							title: "Dark Gray Canvas Base"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:DarkGray:Labels",
							title: "Dark Gray Canvas Labels",
							isReference: !0
						}]
					},
					"arcgis-navigation": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets-navigation.jpg")
						},
						title: "Navigation",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Navigation",
							title: "World Navigation Map"
						}]
					},
					"arcgis-navigation-night": {
						title: "Navigation (Dark Mode)",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:NavigationNight",
							title: "World Navigation Map (Dark Mode)"
						}]
					},
					"arcgis-streets": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets-vector.jpg")
						},
						title: "Streets",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Streets",
							title: "World Street Map"
						}]
					},
					"arcgis-streets-night": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets-night.jpg")
						},
						title: "Streets (Night)",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:StreetsNight",
							title: "World Street Map (Night)"
						}]
					},
					"arcgis-streets-relief": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/streets-relief.jpg")
						},
						title: "Streets (with Relief)",
						baseMapLayers: [{
								layerType: "ArcGISTiledMapServiceLayer",
								showLegend: !1,
								title: "World Hillshade",
								url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
							},
							{
								layerType: "VectorTileLayer",
								styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:StreetsRelief:Base",
								title: "World Street Map (with Relief)"
							}
						]
					},
					"arcgis-topographic": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/topo.jpg")
						},
						title: "Topographic",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Hillshade",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Topographic:Base",
							title: "World Topographic Map"
						}]
					},
					"arcgis-oceans": {
						get thumbnailUrl() {
							return c.getAssetUrl("esri/images/basemap/oceans.jpg")
						},
						title: "Oceans",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Ocean Base",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Oceans:Labels",
							title: "World Ocean Reference",
							isReference: !0
						}]
					},
					"osm-standard": {
						title: "OpenStreetMap",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:Standard",
							title: "OpenStreetMap"
						}]
					},
					"osm-standard-relief": {
						title: "OpenStreetMap (with relief)",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Hillshade",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
						}, {
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:StandardRelief:Base",
							layerType: "VectorTileLayer",
							title: "OpenStreetMap Relief Base"
						}]
					},
					"osm-streets": {
						title: "OpenStreetMap (Streets)",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:Streets",
							title: "OpenStreetMap (Streets)"
						}]
					},
					"osm-streets-relief": {
						title: "OpenStreetMap (Streets with relief)",
						baseMapLayers: [{
								layerType: "ArcGISTiledMapServiceLayer",
								showLegend: !1,
								title: "World Hillshade",
								url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
							},
							{
								styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:StreetsRelief:Base",
								layerType: "VectorTileLayer",
								title: "OpenStreetMap Relief Base"
							}
						]
					},
					"osm-light-gray": {
						title: "OpenStreetMap (Light Gray Canvas)",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:LightGray:Base",
							title: "OSM (Light Gray Base)"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:LightGray:Labels",
							title: "OSM (Light Gray Reference)",
							isReference: !0
						}]
					},
					"osm-dark-gray": {
						title: "OpenStreetMap (Dark Gray Canvas)",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:DarkGray:Base",
							title: "OSM (Dark Gray Base)"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:DarkGray:Labels",
							title: "OSM (Dark Gray Reference)",
							isReference: !0
						}]
					},
					"arcgis-terrain": {
						title: "Terrain with Labels",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Hillshade",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Terrain:Base",
							title: "World Terrain Base"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Terrain:Detail",
							title: "World Terrain Reference",
							isReference: !0
						}]
					},
					"arcgis-community": {
						title: "Community",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Community",
							title: "Community"
						}]
					},
					"arcgis-charted-territory": {
						title: "Charted Territory",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Hillshade",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:ChartedTerritory:Base",
							title: "Charted Territory"
						}]
					},
					"arcgis-colored-pencil": {
						title: "Colored Pencil",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:ColoredPencil",
							title: "Colored Pencil"
						}]
					},
					"arcgis-nova": {
						title: "Nova",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Nova",
							title: "Nova"
						}]
					},
					"arcgis-modern-antique": {
						title: "Modern Antique",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Hillshade",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:ModernAntique:Base",
							title: "Modern Antique"
						}]
					},
					"arcgis-midcentury": {
						title: "Mid-Century",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Midcentury",
							title: "Mid-Century"
						}]
					},
					"arcgis-newspaper": {
						title: "Newspaper",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Newspaper",
							title: "Newspaper"
						}]
					},
					"arcgis-hillshade-light": {
						title: "Hillshade",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Hillshade",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer"
						}]
					},
					"arcgis-hillshade-dark": {
						title: "Hillshade (Dark)",
						baseMapLayers: [{
							layerType: "ArcGISTiledMapServiceLayer",
							showLegend: !1,
							title: "World Hillshade (Dark)",
							url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade_Dark/MapServer"
						}]
					},
					"arcgis-human-geography": {
						title: "Human Geography",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeography:Base",
							title: "Human Geography Base"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeography:Detail",
							title: "Human Geography Detail",
							isReference: !0
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeography:Label",
							title: "Human Geography Label",
							isReference: !0
						}]
					},
					"arcgis-human-geography-dark": {
						title: "Human Geography (Dark)",
						baseMapLayers: [{
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeographyDark:Base",
							title: "Human Geography Dark Base"
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeographyDark:Detail",
							title: "Human Geography Dark Detail",
							isReference: !0
						}, {
							layerType: "VectorTileLayer",
							styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeographyDark:Label",
							title: "Human Geography Dark Label",
							isReference: !0
						}]
					}
				};
				a.getBasemapTitle = function(k) {
					return d.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/intl/messages": function() {
			define(["exports", "../chunks/_rollupPluginBabelHelpers", "../core/Error", "../core/promiseUtils", "./locale"], function(a, b, c, e, d) {
				function k(q) {
					for (const u of n.keys()) g(q.pattern,
						u) && n.delete(u)
				}

				function v() {
					v = b._asyncToGenerator(function*(q) {
						const u = d.getLocale();
						n.has(q) || n.set(q, m(q, u));
						(q = n.get(q)) && (yield t.add(q));
						return q
					});
					return v.apply(this, arguments)
				}

				function m(q, u) {
					return f.apply(this, arguments)
				}

				function f() {
					f = b._asyncToGenerator(function*(q, u) {
						const x = [];
						for (const y of p)
							if (g(y.pattern, q)) try {
								return yield y.fetchMessageBundle(q, u)
							} catch (w) {
								x.push(w)
							}
						if (x.length) throw new c("intl:message-bundle-error", `Errors occurred while loading "${q}"`, {
							errors: x
						});
						throw new c("intl:no-message-bundle-loader",
							`No loader found for message bundle "${q}"`);
					});
					return f.apply(this, arguments)
				}

				function g(q, u) {
					return "string" === typeof q ? u.startsWith(q) : q.test(u)
				}
				const l = /^([a-z]{2})(?:[-_]([A-Za-z]{2}))?$/,
					r = {
						ar: !0,
						bg: !0,
						bs: !0,
						ca: !0,
						cs: !0,
						da: !0,
						de: !0,
						el: !0,
						en: !0,
						es: !0,
						et: !0,
						fi: !0,
						fr: !0,
						he: !0,
						hr: !0,
						hu: !0,
						id: !0,
						it: !0,
						ja: !0,
						ko: !0,
						lt: !0,
						lv: !0,
						nb: !0,
						nl: !0,
						pl: !0,
						"pt-BR": !0,
						"pt-PT": !0,
						ro: !0,
						ru: !0,
						sk: !0,
						sl: !0,
						sr: !0,
						sv: !0,
						th: !0,
						tr: !0,
						uk: !0,
						vi: !0,
						"zh-CN": !0,
						"zh-HK": !0,
						"zh-TW": !0
					},
					p = [],
					n = new Map;
				d.beforeLocaleChange(() => {
					n.clear()
				});
				const t = new(function() {
						function q() {
							this._numLoading = 0;
							this._dfd = null
						}
						var u = q.prototype;
						u.waitForAll = function() {
							var x = b._asyncToGenerator(function*() {
								this._dfd && (yield this._dfd.promise)
							});
							return function() {
								return x.apply(this, arguments)
							}
						}();
						u.add = function(x) {
							this._increase();
							x.then(() => this._decrease(), () => this._decrease());
							return this.waitForAll()
						};
						u._increase = function() {
							this._numLoading++;
							this._dfd || (this._dfd = e.createDeferred())
						};
						u._decrease = function() {
							this._numLoading = Math.max(this._numLoading -
								1, 0);
							this._dfd && 0 === this._numLoading && (this._dfd.resolve(), this._dfd = null)
						};
						return q
					}()),
					h = {
						cache: n,
						loaders: p
					};
				a.fetchMessageBundle = function(q) {
					return v.apply(this, arguments)
				};
				a.normalizeMessageBundleLocale = function(q) {
					if (!l.test(q)) return null;
					q = l.exec(q);
					if (null === q) return null;
					const [, u, x] = q;
					q = u + (x ? "-" + x.toUpperCase() : "");
					return r[q] ? ? !1 ? q : r[u] ? ? !1 ? u : null
				};
				a.registerMessageBundleLoader = function(q) {
					p.includes(q) || (k(q), p.unshift(q));
					return {
						remove() {
							const u = p.indexOf(q); - 1 < u && (p.splice(u, 1), k(q))
						}
					}
				};
				a.test = h;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/webdoc/support/writeUtils": function() {
			define("exports ../../core/Error ../../core/lang ../../core/maybe ../../core/object ../../core/accessorSupport/extensions/serializableProperty/writer ../../layers/support/layerUtils".split(" "), function(a, b, c, e, d, k, v) {
				function m(l, r) {
					"maxScale" in l && (r.maxScale = k.numberToJSON(l.maxScale));
					"minScale" in l && (r.minScale = k.numberToJSON(l.minScale))
				}
				const f = new Set("bing-maps imagery imagery-tile map-image open-street-map tile unknown unsupported vector-tile web-tile wms wmts".split(" ")),
					g = new Set("csv feature geo-rss geojson group imagery imagery-tile kml map-image map-notes ogc-feature route subtype-group tile unknown unsupported vector-tile web-tile wfs wms wmts".split(" "));
				a.disableRestrictedWriting = function(l) {
					f.add(l);
					g.add(l)
				};
				a.enableRestrictedWriting = function(l) {
					f.delete(l);
					g.delete(l)
				};
				a.getLayerJSON = function(l, r, p) {
					if (!("write" in l && l.write)) return p && p.messages && p.messages.push(new b("layer:unsupported", `Layers (${l.title}, ${l.id}) of type '${l.declaredClass}' cannot be persisted`, {
						layer: l
					})), null;
					if (p.restrictedWebMapWriting) {
						var n = "basemap" === p.layerContainerType ? f : "operational-layers" === p.layerContainerType ? g : null;
						n = e.isSome(n) ? n.has(l.type) && !v.isFeatureCollectionLayer(l) : !0
					} else n = !0;
					if (n) return r = {}, l.write(r, p) ? r : null;
					if (e.isSome(r) && (p = r = c.clone(r), v.isFeatureCollectionLayer(l) ? (n = (n = d.getDeepValue("featureCollection.layers", p)) && n[0] && n[0].layerDefinition) && m(l, n) : "stream" === l.type ? (n = p.layerDefinition = p.layerDefinition || {}, m(l, n)) : "group" !== l.type && m(l, p), "blendMode" in
						l && (p.blendMode = l.blendMode, "normal" === p.blendMode && delete p.blendMode), p.opacity = k.numberToJSON(l.opacity), p.title = l.title || "Layer", p.visibility = l.visible, "legendEnabled" in l && "wmts" !== l.type))
						if (v.isFeatureCollectionLayer(l)) {
							if (p = p.featureCollection) p.showLegend = l.legendEnabled
						} else p.showLegend = l.legendEnabled;
					return r
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/layerUtils": function() {
			define(["exports"], function(a) {
				a.areLabelsVisible =
					function(b) {
						return !0 === b.labelsVisible && null != b.labelingInfo && 0 < b.labelingInfo.length
					};
				a.getTileMaxtrixSetFromActiveLayer = function(b) {
					if (b.activeLayer) {
						const c = b.activeLayer.tileMatrixSet;
						if (c) return c;
						if (b = b.activeLayer.tileMatrixSets) return b
					}
					return null
				};
				a.isBaseLayer = function(b) {
					return "esri.Basemap" === b.parent ? .declaredClass && b.parent.baseLayers.includes(b)
				};
				a.isBasemapSupportedLayer = function(b) {
					b = b ? .type;
					return "imagery-tile" === b || "tile" === b || "open-street-map" === b || "vector-tile" === b || "web-tile" ===
						b || "wmts" === b
				};
				a.isFeatureCollectionLayer = function(b) {
					return "feature" === b ? .type && !b.url && "memory" === b.source ? .type
				};
				a.isFeatureServiceLayer = function(b) {
					return "feature" === b ? .type && "feature-layer" === b.source ? .type
				};
				a.isImageryTileLayer = function(b) {
					return "imagery-tile" === b ? .type
				};
				a.isTiledLayer = function(b) {
					b = b ? .type;
					return "base-tile" === b || "tile" === b || "elevation" === b || "imagery-tile" === b || "base-elevation" === b || "open-street-map" === b || "wcs" === b || "web-tile" === b || "wmts" === b || "vector-tile" === b
				};
				a.isVoxelLayer =
					function(b) {
						return "voxel" === b ? .type
					};
				a.serializeLayerDefinitions = function(b) {
					const c = /[:;]/,
						e = [];
					let d = !1;
					if (b && (b.forEach((k, v) => {
						e.push([v, k]);
						!d && c.test(k) && (d = !0)
					}), 0 < e.length)) {
						if (d) {
							const k = {};
							e.forEach(v => {
								k[v[0]] = v[1]
							});
							b = JSON.stringify(k)
						} else {
							const k = [];
							e.forEach(v => {
								k.push(v[0] + ":" + v[1])
							});
							b = k.join(";")
						}
						return b
					}
					return null
				};
				a.serializeTimeOptions = function(b) {
					if (b) {
						var c = [];
						b.forEach((e, d) => {
							c.push('"' + d + '":' + JSON.stringify(e))
						});
						if (c.length) return "{" + c.join(",") + "}"
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/Ground": function() {
			define("require ./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./Color ./core/Collection ./core/collectionUtils ./core/compilerUtils ./core/Error ./core/JSONSupport ./core/lang ./core/Loadable ./core/loadAll ./core/Logger ./core/promiseUtils ./core/accessorSupport/decorators/property ./core/accessorSupport/ensureType ./core/accessorSupport/decorators/subclass ./core/accessorSupport/decorators/writer ./ground/NavigationConstraint ./views/3d/support/debugFlags ./webdoc/support/opacityUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w) {
					function A(E) {
						return "elevation" === E.type || E && "createElevationSampler" in E
					}
					var B;
					f = B = function(E) {
						function z(D) {
							var J = E.call(this, D) || this;
							J.opacity = 1;
							J.shading = !y.TERRAIN_USE_LEGACY_SHADING;
							J.surfaceColor = null;
							J.navigationConstraint = null;
							J.layers = new d;
							J.layers.on("after-add", K => {
								K = K.item;
								K.parent && K.parent !== b._assertThisInitialized(J) && "remove" in K.parent && K.parent.remove(K);
								K.parent = b._assertThisInitialized(J);
								"elevation" !== K.type && "base-elevation" !==
									K.type && p.getLogger(J.declaredClass)
									.error(`Layer '${K.title}, id:${K.id}' of type '${K.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`)
							});
							J.layers.on("after-remove", K => {
								K.item.parent = null
							});
							return J
						}
						b._inheritsLoose(z, E);
						var C = z.prototype;
						C.initialize = function() {
							this.when()
								.catch(D => {
									p.getLogger(this.declaredClass)
										.error("#load()", "Failed to load ground", D)
								});
							this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context)
						};
						C.destroy = function() {
							const D = this.layers.removeAll();
							for (const J of D) J.destroy();
							this.layers.destroy()
						};
						C.normalizeCtorArgs = function(D) {
							D && "resourceInfo" in D && (this._set("resourceInfo", D.resourceInfo), D = {
								...D
							}, delete D.resourceInfo);
							return D
						};
						C.writeLayers = function(D, J, K, H) {
							const G = [];
							D && (H = {
								...H,
								layerContainerType: "ground"
							}, D.forEach(F => {
								if ("write" in F) {
									const L = {};
									v.typeCast(F)()
										.write(L, H) && G.push(L)
								} else H && H.messages && H.messages.push(new m("layer:unsupported", `Layers (${F.title}, ${F.id}) of type '${F.declaredClass}' cannot be persisted in the ground`, {
									layer: F
								}))
							}));
							J.layers = G
						};
						C.load = function(D) {
							this.addResolvingPromise(this._loadFromSource(D));
							return Promise.resolve(this)
						};
						C.loadAll = function() {
							return r.loadAll(this, D => {
								D(this.layers)
							})
						};
						C.queryElevation = function() {
							var D = b._asyncToGenerator(function*(J, K) {
								yield this.load({
									signal: K ? .signal
								});
								var {
									ElevationQuery: H
								} = yield new Promise((F, L) => a(["./layers/support/ElevationQuery"], F, L));
								n.throwIfAborted(K);
								H = new H;
								const G = this.layers.filter(A)
									.toArray();
								return H.queryAll(G, J, K)
							});
							return function(J,
								K) {
								return D.apply(this, arguments)
							}
						}();
						C.createElevationSampler = function() {
							var D = b._asyncToGenerator(function*(J, K) {
								yield this.load({
									signal: K ? .signal
								});
								var {
									ElevationQuery: H
								} = yield new Promise((F, L) => a(["./layers/support/ElevationQuery"], F, L));
								n.throwIfAborted(K);
								H = new H;
								const G = this.layers.filter(A)
									.toArray();
								return H.createSamplerAll(G, J, K)
							});
							return function(J, K) {
								return D.apply(this, arguments)
							}
						}();
						C.clone = function() {
							const D = {
								opacity: this.opacity,
								surfaceColor: g.clone(this.surfaceColor),
								navigationConstraint: g.clone(this.navigationConstraint),
								layers: this.layers.slice()
							};
							this.loaded && (D.loadStatus = "loaded");
							return (new B({
									resourceInfo: this.resourceInfo
								}))
								.set(D)
						};
						C.read = function(D, J) {
							this.resourceInfo || this._set("resourceInfo", {
								data: D,
								context: J
							});
							E.prototype.read.call(this, D, J)
						};
						C._loadFromSource = function(D) {
							const J = this.resourceInfo;
							return J ? this._loadLayersFromJSON(J.data, J.context, D) : Promise.resolve()
						};
						C._loadLayersFromJSON = function(D, J, K) {
							const H = J && J.origin || "web-scene",
								G = J && J.portal || null,
								F = J && J.url || null;
							return (new Promise((L, R) =>
									a(["./layers/support/layersCreator"], L, R)))
								.then(({
									populateOperationalLayers: L
								}) => {
									n.throwIfAborted(K);
									const R = [];
									D.layers && Array.isArray(D.layers) && R.push(L(this.layers, D.layers, {
										context: {
											origin: H,
											url: F,
											portal: G,
											layerContainerType: "ground"
										},
										defaultLayerType: "ArcGISTiledElevationServiceLayer"
									}));
									return n.eachAlways(R)
								})
								.then(() => {})
						};
						b._createClass(z, [{
							key: "layers",
							set: function(D) {
								this._set("layers", k.referenceSetter(D, this._get("layers")))
							}
						}]);
						return z
					}(f.JSONSupportMixin(l));
					c.__decorate([t.property({
							json: {
								read: !1
							}
						})],
						f.prototype, "layers", null);
					c.__decorate([u.writer("layers")], f.prototype, "writeLayers", null);
					c.__decorate([t.property({
						readOnly: !0
					})], f.prototype, "resourceInfo", void 0);
					c.__decorate([t.property({
						type: Number,
						nonNullable: !0,
						range: {
							min: 0,
							max: 1
						},
						json: {
							type: h.Integer,
							read: {
								reader: w.transparencyToOpacity,
								source: "transparency"
							},
							write: {
								writer: (E, z) => {
									z.transparency = w.opacityToTransparency(E)
								},
								target: "transparency"
							}
						}
					})], f.prototype, "opacity", void 0);
					c.__decorate([t.property({
							type: Boolean,
							nonNullable: !0,
							json: {
								read: !1
							}
						})],
						f.prototype, "shading", void 0);
					c.__decorate([t.property({
						type: e,
						json: {
							type: [h.Integer],
							write: (E, z) => {
								z.surfaceColor = E.toJSON()
									.slice(0, 3)
							}
						}
					})], f.prototype, "surfaceColor", void 0);
					c.__decorate([t.property({
						type: x.NavigationConstraint,
						json: {
							write: !0
						}
					})], f.prototype, "navigationConstraint", void 0);
					return f = B = c.__decorate([q.subclass("esri.Ground")], f)
				})
		},
		"esri/Color": function() {
			define(["./chunks/_rollupPluginBabelHelpers", "./colorUtils", "./core/mathUtils", "./core/maybe", "./core/accessorSupport/ensureType"],
				function(a, b, c, e, d) {
					function k(f) {
						return c.clamp(d.ensureInteger(f), 0, 255)
					}

					function v(f, g, l) {
						f = Number(f);
						return isNaN(f) ? l : f < g ? g : f > l ? l : f
					}
					let m = function() {
						function f(l) {
							this.b = this.g = this.r = 255;
							this.a = 1;
							l && this.setColor(l)
						}
						f.blendColors = function(l, r, p, n = new f) {
							n.r = Math.round(l.r + (r.r - l.r) * p);
							n.g = Math.round(l.g + (r.g - l.g) * p);
							n.b = Math.round(l.b + (r.b - l.b) * p);
							n.a = l.a + (r.a - l.a) * p;
							return n._sanitize()
						};
						f.fromRgb = function(l, r) {
							var p = l.toLowerCase()
								.match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
							if (p) {
								l = p[2].split(/\s*,\s*/);
								p = p[1];
								if ("rgb" === p && 3 === l.length || "rgba" === p && 4 === l.length) return p = l[0], "%" === p.charAt(p.length - 1) ? (p = l.map(n => 2.56 * parseFloat(n)), 4 === l.length && (p[3] = parseFloat(l[3])), f.fromArray(p, r)) : f.fromArray(l.map(n => parseFloat(n)), r);
								if ("hsl" === p && 3 === l.length || "hsla" === p && 4 === l.length) return f.fromArray(b.hsla2rgba(parseFloat(l[0]), parseFloat(l[1]) / 100, parseFloat(l[2]) / 100, parseFloat(l[3])), r)
							}
							return null
						};
						f.fromHex = function(l, r = new f) {
							if (4 !== l.length && 7 !== l.length || "#" !== l[0]) return null;
							const p = 4 ===
								l.length ? 4 : 8,
								n = (1 << p) - 1;
							let t = Number("0x" + l.substr(1));
							if (isNaN(t)) return null;
							["b", "g", "r"].forEach(h => {
								const q = t & n;
								t >>= p;
								r[h] = 4 === p ? 17 * q : q
							});
							r.a = 1;
							return r
						};
						f.fromArray = function(l, r = new f) {
							r._set(Number(l[0]), Number(l[1]), Number(l[2]), Number(l[3]));
							isNaN(r.a) && (r.a = 1);
							return r._sanitize()
						};
						f.fromString = function(l, r) {
							const p = b.isNamedColor(l) ? b.getNamedColor(l) : null;
							return p && f.fromArray(p, r) || f.fromRgb(l, r) || f.fromHex(l, r)
						};
						f.fromJSON = function(l) {
							return l && new f([l[0], l[1], l[2], l[3] / 255])
						};
						f.toUnitRGB =
							function(l) {
								return e.isSome(l) ? [l.r / 255, l.g / 255, l.b / 255] : null
							};
						f.toUnitRGBA = function(l) {
							return e.isSome(l) ? [l.r / 255, l.g / 255, l.b / 255, null != l.a ? l.a : 1] : null
						};
						var g = f.prototype;
						g.setColor = function(l) {
							"string" === typeof l ? f.fromString(l, this) : Array.isArray(l) ? f.fromArray(l, this) : (this._set(l.r ? ? 0, l.g ? ? 0, l.b ? ? 0, l.a ? ? 1), l instanceof f || this._sanitize());
							return this
						};
						g.toRgb = function() {
							return [this.r, this.g, this.b]
						};
						g.toRgba = function() {
							return [this.r, this.g, this.b, this.a]
						};
						g.toHex = function() {
							const l = this.r.toString(16),
								r = this.g.toString(16),
								p = this.b.toString(16);
							return `#${2>l.length?"0"+l:l}${2>r.length?"0"+r:r}${2>p.length?"0"+p:p}`
						};
						g.toCss = function(l = !1) {
							const r = this.r + ", " + this.g + ", " + this.b;
							return l ? `rgba(${r}, ${this.a})` : `rgb(${r})`
						};
						g.toString = function() {
							return this.toCss(!0)
						};
						g.toJSON = function() {
							return this.toArray()
						};
						g.toArray = function(l = f.AlphaMode.ALWAYS) {
							const r = k(this.r),
								p = k(this.g),
								n = k(this.b);
							return l === f.AlphaMode.ALWAYS || 1 !== this.a ? [r, p, n, k(255 * this.a)] : [r, p, n]
						};
						g.clone = function() {
							return new f(this.toRgba())
						};
						g.hash = function() {
							return this.r << 24 | this.g << 16 | this.b << 8 | 255 * this.a
						};
						g.equals = function(l) {
							return e.isSome(l) && l.r === this.r && l.g === this.g && l.b === this.b && l.a === this.a
						};
						g._sanitize = function() {
							this.r = Math.round(v(this.r, 0, 255));
							this.g = Math.round(v(this.g, 0, 255));
							this.b = Math.round(v(this.b, 0, 255));
							this.a = v(this.a, 0, 1);
							return this
						};
						g._set = function(l, r, p, n) {
							this.r = l;
							this.g = r;
							this.b = p;
							this.a = n
						};
						a._createClass(f, [{
							key: "isBright",
							get: function() {
								return 127 <= .299 * this.r + .587 * this.g + .114 * this.b
							}
						}]);
						return f
					}();
					m.prototype.declaredClass = "esri.Color";
					(function(f) {
						f = f.AlphaMode || (f.AlphaMode = {});
						f[f.ALWAYS = 0] = "ALWAYS";
						f[f.UNLESS_OPAQUE = 1] = "UNLESS_OPAQUE"
					})(m || (m = {}));
					return m
				})
		},
		"esri/colorUtils": function() {
			define(["exports"], function(a) {
				function b(d) {
					return e[d] ? ? e[d.toLowerCase()]
				}

				function c(d, k, v) {
					0 > v && ++v;
					1 < v && --v;
					const m = 6 * v;
					return 1 > m ? d + (k - d) * m : 1 > 2 * v ? k : 2 > 3 * v ? d + (k - d) * (2 / 3 - v) * 6 : d
				}
				const e = {
					transparent: [0, 0, 0, 0],
					black: [0, 0, 0, 1],
					silver: [192, 192, 192, 1],
					gray: [128, 128, 128, 1],
					white: [255, 255, 255, 1],
					maroon: [128,
						0, 0, 1
					],
					red: [255, 0, 0, 1],
					purple: [128, 0, 128, 1],
					fuchsia: [255, 0, 255, 1],
					green: [0, 128, 0, 1],
					lime: [0, 255, 0, 1],
					olive: [128, 128, 0, 1],
					yellow: [255, 255, 0, 1],
					navy: [0, 0, 128, 1],
					blue: [0, 0, 255, 1],
					teal: [0, 128, 128, 1],
					aqua: [0, 255, 255, 1],
					aliceblue: [240, 248, 255, 1],
					antiquewhite: [250, 235, 215, 1],
					aquamarine: [127, 255, 212, 1],
					azure: [240, 255, 255, 1],
					beige: [245, 245, 220, 1],
					bisque: [255, 228, 196, 1],
					blanchedalmond: [255, 235, 205, 1],
					blueviolet: [138, 43, 226, 1],
					brown: [165, 42, 42, 1],
					burlywood: [222, 184, 135, 1],
					cadetblue: [95, 158, 160, 1],
					chartreuse: [127,
						255, 0, 1
					],
					chocolate: [210, 105, 30, 1],
					coral: [255, 127, 80, 1],
					cornflowerblue: [100, 149, 237, 1],
					cornsilk: [255, 248, 220, 1],
					crimson: [220, 20, 60, 1],
					cyan: [0, 255, 255, 1],
					darkblue: [0, 0, 139, 1],
					darkcyan: [0, 139, 139, 1],
					darkgoldenrod: [184, 134, 11, 1],
					darkgray: [169, 169, 169, 1],
					darkgreen: [0, 100, 0, 1],
					darkgrey: [169, 169, 169, 1],
					darkkhaki: [189, 183, 107, 1],
					darkmagenta: [139, 0, 139, 1],
					darkolivegreen: [85, 107, 47, 1],
					darkorange: [255, 140, 0, 1],
					darkorchid: [153, 50, 204, 1],
					darkred: [139, 0, 0, 1],
					darksalmon: [233, 150, 122, 1],
					darkseagreen: [143, 188, 143,
						1
					],
					darkslateblue: [72, 61, 139, 1],
					darkslategray: [47, 79, 79, 1],
					darkslategrey: [47, 79, 79, 1],
					darkturquoise: [0, 206, 209, 1],
					darkviolet: [148, 0, 211, 1],
					deeppink: [255, 20, 147, 1],
					deepskyblue: [0, 191, 255, 1],
					dimgray: [105, 105, 105, 1],
					dimgrey: [105, 105, 105, 1],
					dodgerblue: [30, 144, 255, 1],
					firebrick: [178, 34, 34, 1],
					floralwhite: [255, 250, 240, 1],
					forestgreen: [34, 139, 34, 1],
					gainsboro: [220, 220, 220, 1],
					ghostwhite: [248, 248, 255, 1],
					gold: [255, 215, 0, 1],
					goldenrod: [218, 165, 32, 1],
					greenyellow: [173, 255, 47, 1],
					grey: [128, 128, 128, 1],
					honeydew: [240, 255,
						240, 1
					],
					hotpink: [255, 105, 180, 1],
					indianred: [205, 92, 92, 1],
					indigo: [75, 0, 130, 1],
					ivory: [255, 255, 240, 1],
					khaki: [240, 230, 140, 1],
					lavender: [230, 230, 250, 1],
					lavenderblush: [255, 240, 245, 1],
					lawngreen: [124, 252, 0, 1],
					lemonchiffon: [255, 250, 205, 1],
					lightblue: [173, 216, 230, 1],
					lightcoral: [240, 128, 128, 1],
					lightcyan: [224, 255, 255, 1],
					lightgoldenrodyellow: [250, 250, 210, 1],
					lightgray: [211, 211, 211, 1],
					lightgreen: [144, 238, 144, 1],
					lightgrey: [211, 211, 211, 1],
					lightpink: [255, 182, 193, 1],
					lightsalmon: [255, 160, 122, 1],
					lightseagreen: [32, 178, 170,
						1
					],
					lightskyblue: [135, 206, 250, 1],
					lightslategray: [119, 136, 153, 1],
					lightslategrey: [119, 136, 153, 1],
					lightsteelblue: [176, 196, 222, 1],
					lightyellow: [255, 255, 224, 1],
					limegreen: [50, 205, 50, 1],
					linen: [250, 240, 230, 1],
					magenta: [255, 0, 255, 1],
					mediumaquamarine: [102, 205, 170, 1],
					mediumblue: [0, 0, 205, 1],
					mediumorchid: [186, 85, 211, 1],
					mediumpurple: [147, 112, 219, 1],
					mediumseagreen: [60, 179, 113, 1],
					mediumslateblue: [123, 104, 238, 1],
					mediumspringgreen: [0, 250, 154, 1],
					mediumturquoise: [72, 209, 204, 1],
					mediumvioletred: [199, 21, 133, 1],
					midnightblue: [25,
						25, 112, 1
					],
					mintcream: [245, 255, 250, 1],
					mistyrose: [255, 228, 225, 1],
					moccasin: [255, 228, 181, 1],
					navajowhite: [255, 222, 173, 1],
					oldlace: [253, 245, 230, 1],
					olivedrab: [107, 142, 35, 1],
					orange: [255, 165, 0, 1],
					orangered: [255, 69, 0, 1],
					orchid: [218, 112, 214, 1],
					palegoldenrod: [238, 232, 170, 1],
					palegreen: [152, 251, 152, 1],
					paleturquoise: [175, 238, 238, 1],
					palevioletred: [219, 112, 147, 1],
					papayawhip: [255, 239, 213, 1],
					peachpuff: [255, 218, 185, 1],
					peru: [205, 133, 63, 1],
					pink: [255, 192, 203, 1],
					plum: [221, 160, 221, 1],
					powderblue: [176, 224, 230, 1],
					rebeccapurple: [102,
						51, 153, 1
					],
					rosybrown: [188, 143, 143, 1],
					royalblue: [65, 105, 225, 1],
					saddlebrown: [139, 69, 19, 1],
					salmon: [250, 128, 114, 1],
					sandybrown: [244, 164, 96, 1],
					seagreen: [46, 139, 87, 1],
					seashell: [255, 245, 238, 1],
					sienna: [160, 82, 45, 1],
					skyblue: [135, 206, 235, 1],
					slateblue: [106, 90, 205, 1],
					slategray: [112, 128, 144, 1],
					slategrey: [112, 128, 144, 1],
					snow: [255, 250, 250, 1],
					springgreen: [0, 255, 127, 1],
					steelblue: [70, 130, 180, 1],
					tan: [210, 180, 140, 1],
					thistle: [216, 191, 216, 1],
					tomato: [255, 99, 71, 1],
					turquoise: [64, 224, 208, 1],
					violet: [238, 130, 238, 1],
					wheat: [245,
						222, 179, 1
					],
					whitesmoke: [245, 245, 245, 1],
					yellowgreen: [154, 205, 50, 1]
				};
				a.getNamedColor = b;
				a.getNamedColorCopy = function(d) {
					return [...b(d)]
				};
				a.hex2rgba = function(d) {
					var k = 5 < d.length;
					const v = k ? 8 : 4,
						m = (1 << v) - 1,
						f = k ? 1 : 17;
					k = k ? 9 === d.length : 5 === d.length;
					d = Number("0x" + d.substr(1));
					if (isNaN(d)) return null;
					const g = [0, 0, 0, 1];
					k && (k = d & m, d >>= v, g[3] = f * k / 255);
					k = d & m;
					d >>= v;
					g[2] = f * k;
					k = d & m;
					d >>= v;
					g[1] = f * k;
					k = d & m;
					d >>= v;
					g[0] = f * k;
					return g
				};
				a.hsla2rgba = function(d, k, v, m = 1) {
					d = (d % 360 + 360) % 360 / 360;
					k = .5 >= v ? v * (k + 1) : v + k - v * k;
					v = 2 * v - k;
					return [Math.round(255 *
						c(v, k, d + 1 / 3)), Math.round(255 * c(v, k, d)), Math.round(255 * c(v, k, d - 1 / 3)), m]
				};
				a.isNamedColor = function(d) {
					return e[d] || e[d.toLowerCase()]
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/mathUtils": function() {
			define(["exports", "./maybe", "../chunks/vec3", "../chunks/vec4"], function(a, b, c, e) {
				function d(u, x, y) {
					return Math.min(Math.max(u, x), y)
				}

				function k(u, x, y) {
					return u + (x - u) * y
				}

				function v(u) {
					return Math.asin(d(u, -1, 1))
				}

				function m(u, x, y = 1E-6) {
					return u === x ?
						!0 : Number.isFinite(u) && Number.isFinite(x) ? (u > x ? u - x : x - u) <= y : !1
				}

				function f(u) {
					n.setFloat64(0, u);
					return n.getBigInt64(0)
				}

				function g(u) {
					n.setBigInt64(0, u);
					return n.getFloat64(0)
				}

				function l(u) {
					u = Math.abs(u);
					var x = f(u);
					x = x <= t ? g(t) : g(x - t);
					return Math.abs(u - x)
				}

				function r(u) {
					p[0] = u;
					return p[0]
				}
				const p = new Float32Array(1),
					n = new DataView(new ArrayBuffer(Float64Array.BYTES_PER_ELEMENT)),
					t = BigInt("1000000"),
					h = l(1),
					q = r(3.4028234663852886E38);
				a.NUMBER_MAX_FLOAT32 = q;
				a.acosClamped = function(u) {
					return Math.acos(d(u,
						-1, 1))
				};
				a.applyOpacity = function(u, x, y) {
					return e.set(u, x[0], x[1], x[2], x[3] * y)
				};
				a.asinClamped = v;
				a.cartesianToSpherical = function(u, x) {
					const y = c.length(u),
						w = v(u[2] / y);
					c.set(x, y, w, Math.atan2(u[1] / y, u[0] / y));
					return x
				};
				a.clamp = d;
				a.clampFloat32 = function(u) {
					return r(Math.max(-q, Math.min(u, q)))
				};
				a.deg2rad = function(u) {
					return u * Math.PI / 180
				};
				a.floatEqualAbsolute = m;
				a.floatEqualRelative = function(u, x, y = 1E-6) {
					if (u === x) return !0;
					if (!Number.isFinite(u) || !Number.isFinite(x)) return !1;
					const w = Math.abs(u - x),
						A = Math.abs(u),
						B = Math.abs(x);
					if (0 === u || 0 === x || 1E-12 > A && 1E-12 > B) {
						if (w > .01 * y) return !1
					} else if (w / (A + B) > y) return !1;
					return !0
				};
				a.floatEqualUlp = function(u, x, y = h) {
					if (u === x) return !0;
					if (!Number.isFinite(u) || !Number.isFinite(x)) return !1;
					if (b.isSome(y) && l(Math.min(Math.abs(u), Math.abs(x))) < y) return Math.abs(u - x) <= y;
					u = f(u);
					x = f(x);
					return 0 > u !== 0 > x || (u < x ? x - u : u - x) > t ? !1 : !0
				};
				a.hasScaling = function(u) {
					const x = u[3] * u[3] + u[4] * u[4] + u[5] * u[5],
						y = u[6] * u[6] + u[7] * u[7] + u[8] * u[8];
					return !(m(u[0] * u[0] + u[1] * u[1] + u[2] * u[2], 1) && m(x, 1) && m(y, 1))
				};
				a.isPowerOfTwo = function(u) {
					return 0 === (u & u - 1)
				};
				a.lerp = k;
				a.nextHighestPowerOfTen = function(u) {
					return 10 ** Math.ceil(Math.LOG10E * Math.log(u))
				};
				a.nextHighestPowerOfTwo = function(u) {
					--u;
					for (let x = 1; 32 > x; x <<= 1) u |= u >> x;
					return u + 1
				};
				a.nextPowerOfTwo = function(u) {
					u--;
					u |= u >> 1;
					u |= u >> 2;
					u |= u >> 4;
					u |= u >> 8;
					u |= u >> 16;
					u++;
					return u
				};
				a.rad2deg = function(u) {
					return 180 * u / Math.PI
				};
				a.reciprocalClamped = function(u, x = 1E-6) {
					return (0 > u ? -1 : 1) / Math.max(Math.abs(u), x)
				};
				a.roundToNearest = function(u, x) {
					return 0 === x ? 0 : Math.round(u / x) * x
				};
				a.scale =
					function(u, x, y, w, A) {
						return k(w, A, (u - x) / (y - x))
					};
				a.smoothstep = function(u, x, y) {
					u = d((y - u) / (x - u), 0, 1);
					return u * u * (3 - 2 * u)
				};
				a.sphericalToCartesian = function(u, x) {
					const y = u[0],
						w = u[1];
					u = u[2];
					const A = Math.cos(w);
					c.set(x, y * A * Math.cos(u), y * A * Math.sin(u), y * Math.sin(w))
				};
				a.step = function(u, x) {
					return x < u ? 0 : 1
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/chunks/vec3": function() {
			define(["exports", "./vec3f64", "./common"], function(a, b, c) {
				function e(da) {
					const ja = da[0],
						sa = da[1];
					da = da[2];
					return Math.sqrt(ja * ja + sa * sa + da * da)
				}

				function d(da, ja) {
					da[0] = ja[0];
					da[1] = ja[1];
					da[2] = ja[2];
					return da
				}

				function k(da, ja, sa, I) {
					da[0] = ja;
					da[1] = sa;
					da[2] = I;
					return da
				}

				function v(da, ja, sa) {
					da[0] = ja[0] + sa[0];
					da[1] = ja[1] + sa[1];
					da[2] = ja[2] + sa[2];
					return da
				}

				function m(da, ja, sa) {
					da[0] = ja[0] - sa[0];
					da[1] = ja[1] - sa[1];
					da[2] = ja[2] - sa[2];
					return da
				}

				function f(da, ja, sa) {
					da[0] = ja[0] * sa[0];
					da[1] = ja[1] * sa[1];
					da[2] = ja[2] * sa[2];
					return da
				}

				function g(da, ja, sa) {
					da[0] = ja[0] / sa[0];
					da[1] = ja[1] / sa[1];
					da[2] = ja[2] /
						sa[2];
					return da
				}

				function l(da, ja) {
					da[0] = Math.ceil(ja[0]);
					da[1] = Math.ceil(ja[1]);
					da[2] = Math.ceil(ja[2]);
					return da
				}

				function r(da, ja) {
					da[0] = Math.floor(ja[0]);
					da[1] = Math.floor(ja[1]);
					da[2] = Math.floor(ja[2]);
					return da
				}

				function p(da, ja) {
					da[0] = Math.abs(ja[0]);
					da[1] = Math.abs(ja[1]);
					da[2] = Math.abs(ja[2]);
					return da
				}

				function n(da, ja) {
					da[0] = Math.sign(ja[0]);
					da[1] = Math.sign(ja[1]);
					da[2] = Math.sign(ja[2]);
					return da
				}

				function t(da, ja, sa) {
					da[0] = Math.min(ja[0], sa[0]);
					da[1] = Math.min(ja[1], sa[1]);
					da[2] = Math.min(ja[2],
						sa[2]);
					return da
				}

				function h(da, ja, sa) {
					da[0] = Math.max(ja[0], sa[0]);
					da[1] = Math.max(ja[1], sa[1]);
					da[2] = Math.max(ja[2], sa[2]);
					return da
				}

				function q(da, ja) {
					da[0] = Math.round(ja[0]);
					da[1] = Math.round(ja[1]);
					da[2] = Math.round(ja[2]);
					return da
				}

				function u(da, ja, sa) {
					da[0] = ja[0] * sa;
					da[1] = ja[1] * sa;
					da[2] = ja[2] * sa;
					return da
				}

				function x(da, ja, sa, I) {
					da[0] = ja[0] + sa[0] * I;
					da[1] = ja[1] + sa[1] * I;
					da[2] = ja[2] + sa[2] * I;
					return da
				}

				function y(da, ja) {
					const sa = ja[0] - da[0],
						I = ja[1] - da[1];
					da = ja[2] - da[2];
					return Math.sqrt(sa * sa + I * I + da * da)
				}

				function w(da, ja) {
					const sa = ja[0] - da[0],
						I = ja[1] - da[1];
					da = ja[2] - da[2];
					return sa * sa + I * I + da * da
				}

				function A(da) {
					const ja = da[0],
						sa = da[1];
					da = da[2];
					return ja * ja + sa * sa + da * da
				}

				function B(da, ja) {
					da[0] = -ja[0];
					da[1] = -ja[1];
					da[2] = -ja[2];
					return da
				}

				function E(da, ja) {
					da[0] = 1 / ja[0];
					da[1] = 1 / ja[1];
					da[2] = 1 / ja[2];
					return da
				}

				function z(da, ja) {
					var sa = ja[0];
					const I = ja[1],
						N = ja[2];
					sa = sa * sa + I * I + N * N;
					0 < sa && (sa = 1 / Math.sqrt(sa), da[0] = ja[0] * sa, da[1] = ja[1] * sa, da[2] = ja[2] * sa);
					return da
				}

				function C(da, ja) {
					return da[0] * ja[0] + da[1] * ja[1] +
						da[2] * ja[2]
				}

				function D(da, ja, sa) {
					const I = ja[0],
						N = ja[1];
					ja = ja[2];
					const ea = sa[0],
						pa = sa[1];
					sa = sa[2];
					da[0] = N * sa - ja * pa;
					da[1] = ja * ea - I * sa;
					da[2] = I * pa - N * ea;
					return da
				}

				function J(da, ja, sa, I) {
					const N = ja[0],
						ea = ja[1];
					ja = ja[2];
					da[0] = N + I * (sa[0] - N);
					da[1] = ea + I * (sa[1] - ea);
					da[2] = ja + I * (sa[2] - ja);
					return da
				}

				function K(da, ja, sa, I, N, ea) {
					const pa = ea * ea,
						xa = pa * (2 * ea - 3) + 1,
						S = pa * (ea - 2) + ea,
						ba = pa * (ea - 1);
					ea = pa * (3 - 2 * ea);
					da[0] = ja[0] * xa + sa[0] * S + I[0] * ba + N[0] * ea;
					da[1] = ja[1] * xa + sa[1] * S + I[1] * ba + N[1] * ea;
					da[2] = ja[2] * xa + sa[2] * S + I[2] * ba + N[2] *
						ea;
					return da
				}

				function H(da, ja, sa, I, N, ea) {
					var pa = 1 - ea,
						xa = pa * pa;
					const S = ea * ea,
						ba = xa * pa;
					xa *= 3 * ea;
					pa *= 3 * S;
					ea *= S;
					da[0] = ja[0] * ba + sa[0] * xa + I[0] * pa + N[0] * ea;
					da[1] = ja[1] * ba + sa[1] * xa + I[1] * pa + N[1] * ea;
					da[2] = ja[2] * ba + sa[2] * xa + I[2] * pa + N[2] * ea;
					return da
				}

				function G(da, ja) {
					ja = ja || 1;
					var sa = c.RANDOM;
					const I = 2 * sa() * Math.PI;
					sa = 2 * sa() - 1;
					const N = Math.sqrt(1 - sa * sa) * ja;
					da[0] = Math.cos(I) * N;
					da[1] = Math.sin(I) * N;
					da[2] = sa * ja;
					return da
				}

				function F(da, ja, sa) {
					const I = ja[0],
						N = ja[1];
					ja = ja[2];
					da[0] = sa[0] * I + sa[4] * N + sa[8] * ja + sa[12];
					da[1] =
						sa[1] * I + sa[5] * N + sa[9] * ja + sa[13];
					da[2] = sa[2] * I + sa[6] * N + sa[10] * ja + sa[14];
					return da
				}

				function L(da, ja, sa) {
					const I = ja[0],
						N = ja[1];
					ja = ja[2];
					da[0] = I * sa[0] + N * sa[3] + ja * sa[6];
					da[1] = I * sa[1] + N * sa[4] + ja * sa[7];
					da[2] = I * sa[2] + N * sa[5] + ja * sa[8];
					return da
				}

				function R(da, ja, sa) {
					const I = sa[0],
						N = sa[1],
						ea = sa[2],
						pa = ja[0],
						xa = ja[1];
					ja = ja[2];
					let S = N * ja - ea * xa,
						ba = ea * pa - I * ja,
						la = I * xa - N * pa;
					sa = 2 * sa[3];
					da[0] = pa + S * sa + 2 * (N * la - ea * ba);
					da[1] = xa + ba * sa + 2 * (ea * S - I * la);
					da[2] = ja + la * sa + 2 * (I * ba - N * S);
					return da
				}

				function V(da, ja, sa, I) {
					const N = [],
						ea = [];
					N[0] = ja[0] - sa[0];
					N[1] = ja[1] - sa[1];
					N[2] = ja[2] - sa[2];
					ea[0] = N[0];
					ea[1] = N[1] * Math.cos(I) - N[2] * Math.sin(I);
					ea[2] = N[1] * Math.sin(I) + N[2] * Math.cos(I);
					da[0] = ea[0] + sa[0];
					da[1] = ea[1] + sa[1];
					da[2] = ea[2] + sa[2];
					return da
				}

				function U(da, ja, sa, I) {
					const N = [],
						ea = [];
					N[0] = ja[0] - sa[0];
					N[1] = ja[1] - sa[1];
					N[2] = ja[2] - sa[2];
					ea[0] = N[2] * Math.sin(I) + N[0] * Math.cos(I);
					ea[1] = N[1];
					ea[2] = N[2] * Math.cos(I) - N[0] * Math.sin(I);
					da[0] = ea[0] + sa[0];
					da[1] = ea[1] + sa[1];
					da[2] = ea[2] + sa[2];
					return da
				}

				function W(da, ja, sa, I) {
					const N = [],
						ea = [];
					N[0] = ja[0] -
						sa[0];
					N[1] = ja[1] - sa[1];
					N[2] = ja[2] - sa[2];
					ea[0] = N[0] * Math.cos(I) - N[1] * Math.sin(I);
					ea[1] = N[0] * Math.sin(I) + N[1] * Math.cos(I);
					ea[2] = N[2];
					da[0] = ea[0] + sa[0];
					da[1] = ea[1] + sa[1];
					da[2] = ea[2] + sa[2];
					return da
				}

				function M(da, ja) {
					d(Aa, da);
					d(Ka, ja);
					z(Aa, Aa);
					z(Ka, Ka);
					da = C(Aa, Ka);
					return 1 < da ? 0 : -1 > da ? Math.PI : Math.acos(da)
				}

				function T(da) {
					return "vec3(" + da[0] + ", " + da[1] + ", " + da[2] + ")"
				}

				function Z(da, ja) {
					return da[0] === ja[0] && da[1] === ja[1] && da[2] === ja[2]
				}

				function oa(da, ja) {
					if (da === ja) return !0;
					const sa = da[0],
						I = da[1];
					da = da[2];
					const N = ja[0],
						ea = ja[1];
					ja = ja[2];
					const pa = c.getEpsilon();
					return Math.abs(sa - N) <= pa * Math.max(1, Math.abs(sa), Math.abs(N)) && Math.abs(I - ea) <= pa * Math.max(1, Math.abs(I), Math.abs(ea)) && Math.abs(da - ja) <= pa * Math.max(1, Math.abs(da), Math.abs(ja))
				}

				function qa(da, ja, sa) {
					const I = sa[0] - ja[0],
						N = sa[1] - ja[1];
					ja = sa[2] - ja[2];
					sa = I * I + N * N + ja * ja;
					if (0 < sa) return sa = 1 / Math.sqrt(sa), da[0] = I * sa, da[1] = N * sa, da[2] = ja * sa, da;
					da[0] = 0;
					da[1] = 0;
					da[2] = 0;
					return da
				}
				const Aa = b.create(),
					Ka = b.create();
				b = Object.freeze(Object.defineProperty({
					__proto__: null,
					length: e,
					copy: d,
					set: k,
					add: v,
					subtract: m,
					multiply: f,
					divide: g,
					ceil: l,
					floor: r,
					abs: p,
					sign: n,
					min: t,
					max: h,
					round: q,
					scale: u,
					scaleAndAdd: x,
					distance: y,
					squaredDistance: w,
					squaredLength: A,
					negate: B,
					inverse: E,
					normalize: z,
					dot: C,
					cross: D,
					lerp: J,
					hermite: K,
					bezier: H,
					random: G,
					transformMat4: F,
					transformMat3: L,
					transformQuat: R,
					rotateX: V,
					rotateY: U,
					rotateZ: W,
					angle: M,
					str: T,
					exactEquals: Z,
					equals: oa,
					direction: qa,
					sub: m,
					mul: f,
					div: g,
					dist: y,
					sqrDist: w,
					len: e,
					sqrLen: A
				}, Symbol.toStringTag, {
					value: "Module"
				}));
				a.abs = p;
				a.add = v;
				a.angle = M;
				a.bezier =
					H;
				a.ceil = l;
				a.copy = d;
				a.cross = D;
				a.direction = qa;
				a.dist = y;
				a.distance = y;
				a.div = g;
				a.divide = g;
				a.dot = C;
				a.equals = oa;
				a.exactEquals = Z;
				a.floor = r;
				a.hermite = K;
				a.inverse = E;
				a.len = e;
				a.length = e;
				a.lerp = J;
				a.max = h;
				a.min = t;
				a.mul = f;
				a.multiply = f;
				a.negate = B;
				a.normalize = z;
				a.random = G;
				a.rotateX = V;
				a.rotateY = U;
				a.rotateZ = W;
				a.round = q;
				a.scale = u;
				a.scaleAndAdd = x;
				a.set = k;
				a.sign = n;
				a.sqrDist = w;
				a.sqrLen = A;
				a.squaredDistance = w;
				a.squaredLength = A;
				a.str = T;
				a.sub = m;
				a.subtract = m;
				a.transformMat3 = L;
				a.transformMat4 = F;
				a.transformQuat = R;
				a.vec3 = b
			})
		},
		"esri/chunks/vec3f64": function() {
			define(["exports"], function(a) {
				function b() {
					return [0, 0, 0]
				}

				function c(u) {
					return [u[0], u[1], u[2]]
				}

				function e(u, x, y) {
					return [u, x, y]
				}

				function d(u) {
					const x = b(),
						y = Math.min(3, u.length);
					for (let w = 0; w < y; ++w) x[w] = u[w];
					return x
				}

				function k(u, x) {
					return new Float64Array(u, x, 3)
				}

				function v() {
					return b()
				}

				function m() {
					return [1, 1, 1]
				}

				function f() {
					return [1, 0, 0]
				}

				function g() {
					return [0, 1, 0]
				}

				function l() {
					return [0, 0, 1]
				}
				const r = b(),
					p = m(),
					n = f(),
					t = g(),
					h = l(),
					q = Object.freeze(Object.defineProperty({
						__proto__: null,
						create: b,
						clone: c,
						fromValues: e,
						fromArray: d,
						createView: k,
						zeros: v,
						ones: m,
						unitX: f,
						unitY: g,
						unitZ: l,
						ZEROS: r,
						ONES: p,
						UNIT_X: n,
						UNIT_Y: t,
						UNIT_Z: h
					}, Symbol.toStringTag, {
						value: "Module"
					}));
				a.ONES = p;
				a.UNIT_X = n;
				a.UNIT_Y = t;
				a.UNIT_Z = h;
				a.ZEROS = r;
				a.clone = c;
				a.create = b;
				a.createView = k;
				a.fromArray = d;
				a.fromValues = e;
				a.ones = m;
				a.unitX = f;
				a.unitY = g;
				a.unitZ = l;
				a.vec3f64 = q;
				a.zeros = v
			})
		},
		"esri/chunks/common": function() {
			define(["exports"], function(a) {
				function b() {
					return v
				}

				function c(r) {
					v = r
				}

				function e(r) {
					return r * f
				}

				function d(r) {
					return r *
						g
				}

				function k(r, p) {
					return Math.abs(r - p) <= v * Math.max(1, Math.abs(r), Math.abs(p))
				}
				let v = 1E-6;
				const m = Math.random,
					f = Math.PI / 180,
					g = 180 / Math.PI,
					l = Object.freeze(Object.defineProperty({
						__proto__: null,
						getEpsilon: b,
						setEpsilon: c,
						RANDOM: m,
						toRadian: e,
						toDegree: d,
						equals: k
					}, Symbol.toStringTag, {
						value: "Module"
					}));
				a.RANDOM = m;
				a.common = l;
				a.equals = k;
				a.getEpsilon = b;
				a.setEpsilon = c;
				a.toDegree = d;
				a.toRadian = e
			})
		},
		"esri/chunks/vec4": function() {
			define(["exports", "./common"], function(a, b) {
				function c(F, L) {
					F[0] = L[0];
					F[1] = L[1];
					F[2] =
						L[2];
					F[3] = L[3];
					return F
				}

				function e(F, L, R, V, U) {
					F[0] = L;
					F[1] = R;
					F[2] = V;
					F[3] = U;
					return F
				}

				function d(F, L, R) {
					F[0] = L[0] + R[0];
					F[1] = L[1] + R[1];
					F[2] = L[2] + R[2];
					F[3] = L[3] + R[3];
					return F
				}

				function k(F, L, R) {
					F[0] = L[0] - R[0];
					F[1] = L[1] - R[1];
					F[2] = L[2] - R[2];
					F[3] = L[3] - R[3];
					return F
				}

				function v(F, L, R) {
					F[0] = L[0] * R[0];
					F[1] = L[1] * R[1];
					F[2] = L[2] * R[2];
					F[3] = L[3] * R[3];
					return F
				}

				function m(F, L, R) {
					F[0] = L[0] / R[0];
					F[1] = L[1] / R[1];
					F[2] = L[2] / R[2];
					F[3] = L[3] / R[3];
					return F
				}

				function f(F, L) {
					F[0] = Math.ceil(L[0]);
					F[1] = Math.ceil(L[1]);
					F[2] = Math.ceil(L[2]);
					F[3] = Math.ceil(L[3]);
					return F
				}

				function g(F, L) {
					F[0] = Math.floor(L[0]);
					F[1] = Math.floor(L[1]);
					F[2] = Math.floor(L[2]);
					F[3] = Math.floor(L[3]);
					return F
				}

				function l(F, L, R) {
					F[0] = Math.min(L[0], R[0]);
					F[1] = Math.min(L[1], R[1]);
					F[2] = Math.min(L[2], R[2]);
					F[3] = Math.min(L[3], R[3]);
					return F
				}

				function r(F, L, R) {
					F[0] = Math.max(L[0], R[0]);
					F[1] = Math.max(L[1], R[1]);
					F[2] = Math.max(L[2], R[2]);
					F[3] = Math.max(L[3], R[3]);
					return F
				}

				function p(F, L) {
					F[0] = Math.round(L[0]);
					F[1] = Math.round(L[1]);
					F[2] = Math.round(L[2]);
					F[3] = Math.round(L[3]);
					return F
				}

				function n(F, L, R) {
					F[0] = L[0] * R;
					F[1] = L[1] * R;
					F[2] = L[2] * R;
					F[3] = L[3] * R;
					return F
				}

				function t(F, L, R, V) {
					F[0] = L[0] + R[0] * V;
					F[1] = L[1] + R[1] * V;
					F[2] = L[2] + R[2] * V;
					F[3] = L[3] + R[3] * V;
					return F
				}

				function h(F, L) {
					const R = L[0] - F[0],
						V = L[1] - F[1],
						U = L[2] - F[2];
					F = L[3] - F[3];
					return Math.sqrt(R * R + V * V + U * U + F * F)
				}

				function q(F, L) {
					const R = L[0] - F[0],
						V = L[1] - F[1],
						U = L[2] - F[2];
					F = L[3] - F[3];
					return R * R + V * V + U * U + F * F
				}

				function u(F) {
					const L = F[0],
						R = F[1],
						V = F[2];
					F = F[3];
					return Math.sqrt(L * L + R * R + V * V + F * F)
				}

				function x(F) {
					const L = F[0],
						R = F[1],
						V = F[2];
					F = F[3];
					return L * L + R * R + V * V + F * F
				}

				function y(F, L) {
					F[0] = -L[0];
					F[1] = -L[1];
					F[2] = -L[2];
					F[3] = -L[3];
					return F
				}

				function w(F, L) {
					F[0] = 1 / L[0];
					F[1] = 1 / L[1];
					F[2] = 1 / L[2];
					F[3] = 1 / L[3];
					return F
				}

				function A(F, L) {
					const R = L[0],
						V = L[1],
						U = L[2];
					L = L[3];
					let W = R * R + V * V + U * U + L * L;
					0 < W && (W = 1 / Math.sqrt(W), F[0] = R * W, F[1] = V * W, F[2] = U * W, F[3] = L * W);
					return F
				}

				function B(F, L) {
					return F[0] * L[0] + F[1] * L[1] + F[2] * L[2] + F[3] * L[3]
				}

				function E(F, L, R, V) {
					const U = L[0],
						W = L[1],
						M = L[2];
					L = L[3];
					F[0] = U + V * (R[0] - U);
					F[1] = W + V * (R[1] - W);
					F[2] = M + V * (R[2] - M);
					F[3] = L + V * (R[3] - L);
					return F
				}

				function z(F, L) {
					var R = b.RANDOM;
					L = L || 1;
					let V, U, W, M, T, Z;
					do V = 2 * R() - 1, U = 2 * R() - 1, T = V * V + U * U; while (1 <= T);
					do W = 2 * R() - 1, M = 2 * R() - 1, Z = W * W + M * M; while (1 <= Z);
					R = Math.sqrt((1 - T) / Z);
					F[0] = L * V;
					F[1] = L * U;
					F[2] = L * W * R;
					F[3] = L * M * R;
					return F
				}

				function C(F, L, R) {
					const V = L[0],
						U = L[1],
						W = L[2];
					L = L[3];
					F[0] = R[0] * V + R[4] * U + R[8] * W + R[12] * L;
					F[1] = R[1] * V + R[5] * U + R[9] * W + R[13] * L;
					F[2] = R[2] * V + R[6] * U + R[10] * W + R[14] * L;
					F[3] = R[3] * V + R[7] * U + R[11] * W + R[15] * L;
					return F
				}

				function D(F, L, R) {
					var V = L[0];
					const U = L[1],
						W = L[2],
						M = R[0],
						T = R[1],
						Z = R[2];
					R = R[3];
					const oa =
						R * V + T * W - Z * U,
						qa = R * U + Z * V - M * W,
						Aa = R * W + M * U - T * V;
					V = -M * V - T * U - Z * W;
					F[0] = oa * R + V * -M + qa * -Z - Aa * -T;
					F[1] = qa * R + V * -T + Aa * -M - oa * -Z;
					F[2] = Aa * R + V * -Z + oa * -T - qa * -M;
					F[3] = L[3];
					return F
				}

				function J(F) {
					return "vec4(" + F[0] + ", " + F[1] + ", " + F[2] + ", " + F[3] + ")"
				}

				function K(F, L) {
					return F[0] === L[0] && F[1] === L[1] && F[2] === L[2] && F[3] === L[3]
				}

				function H(F, L) {
					const R = F[0],
						V = F[1],
						U = F[2];
					F = F[3];
					const W = L[0],
						M = L[1],
						T = L[2];
					L = L[3];
					const Z = b.getEpsilon();
					return Math.abs(R - W) <= Z * Math.max(1, Math.abs(R), Math.abs(W)) && Math.abs(V - M) <= Z * Math.max(1, Math.abs(V),
						Math.abs(M)) && Math.abs(U - T) <= Z * Math.max(1, Math.abs(U), Math.abs(T)) && Math.abs(F - L) <= Z * Math.max(1, Math.abs(F), Math.abs(L))
				}
				const G = Object.freeze(Object.defineProperty({
						__proto__: null,
						copy: c,
						set: e,
						add: d,
						subtract: k,
						multiply: v,
						divide: m,
						ceil: f,
						floor: g,
						min: l,
						max: r,
						round: p,
						scale: n,
						scaleAndAdd: t,
						distance: h,
						squaredDistance: q,
						length: u,
						squaredLength: x,
						negate: y,
						inverse: w,
						normalize: A,
						dot: B,
						lerp: E,
						random: z,
						transformMat4: C,
						transformQuat: D,
						str: J,
						exactEquals: K,
						equals: H,
						sub: k,
						mul: v,
						div: m,
						dist: h,
						sqrDist: q,
						len: u,
						sqrLen: x
					},
					Symbol.toStringTag, {
						value: "Module"
					}));
				a.add = d;
				a.ceil = f;
				a.copy = c;
				a.dist = h;
				a.distance = h;
				a.div = m;
				a.divide = m;
				a.dot = B;
				a.equals = H;
				a.exactEquals = K;
				a.floor = g;
				a.inverse = w;
				a.len = u;
				a.length = u;
				a.lerp = E;
				a.max = r;
				a.min = l;
				a.mul = v;
				a.multiply = v;
				a.negate = y;
				a.normalize = A;
				a.random = z;
				a.round = p;
				a.scale = n;
				a.scaleAndAdd = t;
				a.set = e;
				a.sqrDist = q;
				a.sqrLen = x;
				a.squaredDistance = q;
				a.squaredLength = x;
				a.str = J;
				a.sub = k;
				a.subtract = k;
				a.transformMat4 = C;
				a.transformQuat = D;
				a.vec4 = G
			})
		},
		"esri/core/compilerUtils": function() {
			define(["exports", "./has"],
				function(a, b) {
					a.neverReached = function(c) {};
					a.neverReachedSilent = function(c) {};
					a.typeCast = function(c) {
						return () => c
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/ground/NavigationConstraint": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/Logger ../core/accessorSupport/ensureType ../core/arrayUtils ../core/Error ../core/has ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					a.NavigationConstraint = r = function(p) {
						function n(t) {
							t = p.call(this, t) || this;
							t.type = "none";
							return t
						}
						b._inheritsLoose(n, p);
						n.prototype.clone = function() {
							return new r({
								type: this.type
							})
						};
						return n
					}(e.JSONSupport);
					c.__decorate([g.enumeration({
						none: "none",
						stayAbove: "stay-above"
					})], a.NavigationConstraint.prototype, "type", void 0);
					a.NavigationConstraint = r = c.__decorate([l.subclass("esri.ground.NavigationConstraint")], a.NavigationConstraint);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/accessorSupport/decorators/enumeration": function() {
			define(["exports", "../../jsonMap", "./property"], function(a, b, c) {
				a.enumeration = function(e, d = {}) {
					e = e instanceof b.JSONMap ? e : new b.JSONMap(e, d);
					e = {
						type: d ? .ignoreUnknown ? ? !0 ? e.apiValues : String,
						json: {
							type: e.jsonValues,
							read: d ? .readOnly ? !1 : {
								reader: e.read
							},
							write: {
								writer: e.write
							}
						}
					};
					void 0 !== d ? .readOnly && (e.readOnly = !!d.readOnly);
					void 0 !== d ? .default && (e.json.default = d.default);
					void 0 !== d ? .name && (e.json.name =
						d.name);
					return c.property(e)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/3d/support/debugFlags": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v) {
				c = function(m) {
					function f() {
						var g =
							m.apply(this, arguments) || this;
						g.SCENEVIEW_HITTEST_RETURN_INTERSECTOR = !1;
						g.DECONFLICTOR_SHOW_VISIBLE = !1;
						g.DECONFLICTOR_SHOW_INVISIBLE = !1;
						g.DECONFLICTOR_SHOW_GRID = !1;
						g.LABELS_SHOW_BORDER = !1;
						g.TEXT_SHOW_BASELINE = !1;
						g.TEXT_SHOW_BORDER = !1;
						g.OVERLAY_DRAW_DEBUG_TEXTURE = !1;
						g.OVERLAY_SHOW_CENTER = !1;
						g.SHOW_POI = !1;
						g.TESTS_DISABLE_OPTIMIZATIONS = !1;
						g.TESTS_DISABLE_FAST_UPDATES = !1;
						g.DRAW_MESH_GEOMETRY_NORMALS = !1;
						g.FEATURE_TILE_FETCH_SHOW_TILES = !1;
						g.FEATURE_TILE_TREE_SHOW_TILES = !1;
						g.TERRAIN_TILE_TREE_SHOW_TILES = !1;
						g.I3S_TREE_SHOW_TILES = !1;
						g.I3S_SHOW_MODIFICATIONS = !1;
						g.LOD_INSTANCE_RENDERER_DISABLE_UPDATES = !1;
						g.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL = !1;
						g.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES = !1;
						g.LINE_WIREFRAMES = !1;
						g.TERRAIN_USE_LEGACY_SHADING = !1;
						return g
					}
					a._inheritsLoose(f, m);
					return f
				}(c);
				b.__decorate([e.property()], c.prototype, "SCENEVIEW_HITTEST_RETURN_INTERSECTOR", void 0);
				b.__decorate([e.property()], c.prototype, "DECONFLICTOR_SHOW_VISIBLE", void 0);
				b.__decorate([e.property()], c.prototype, "DECONFLICTOR_SHOW_INVISIBLE",
					void 0);
				b.__decorate([e.property()], c.prototype, "DECONFLICTOR_SHOW_GRID", void 0);
				b.__decorate([e.property()], c.prototype, "LABELS_SHOW_BORDER", void 0);
				b.__decorate([e.property()], c.prototype, "TEXT_SHOW_BASELINE", void 0);
				b.__decorate([e.property()], c.prototype, "TEXT_SHOW_BORDER", void 0);
				b.__decorate([e.property()], c.prototype, "OVERLAY_DRAW_DEBUG_TEXTURE", void 0);
				b.__decorate([e.property()], c.prototype, "OVERLAY_SHOW_CENTER", void 0);
				b.__decorate([e.property()], c.prototype, "SHOW_POI", void 0);
				b.__decorate([e.property()],
					c.prototype, "TESTS_DISABLE_OPTIMIZATIONS", void 0);
				b.__decorate([e.property()], c.prototype, "TESTS_DISABLE_FAST_UPDATES", void 0);
				b.__decorate([e.property()], c.prototype, "DRAW_MESH_GEOMETRY_NORMALS", void 0);
				b.__decorate([e.property()], c.prototype, "FEATURE_TILE_FETCH_SHOW_TILES", void 0);
				b.__decorate([e.property()], c.prototype, "FEATURE_TILE_TREE_SHOW_TILES", void 0);
				b.__decorate([e.property()], c.prototype, "TERRAIN_TILE_TREE_SHOW_TILES", void 0);
				b.__decorate([e.property()], c.prototype, "I3S_TREE_SHOW_TILES",
					void 0);
				b.__decorate([e.property()], c.prototype, "I3S_SHOW_MODIFICATIONS", void 0);
				b.__decorate([e.property()], c.prototype, "LOD_INSTANCE_RENDERER_DISABLE_UPDATES", void 0);
				b.__decorate([e.property()], c.prototype, "LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL", void 0);
				b.__decorate([e.property()], c.prototype, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES", void 0);
				b.__decorate([e.property()], c.prototype, "LINE_WIREFRAMES", void 0);
				b.__decorate([e.property()], c.prototype, "TERRAIN_USE_LEGACY_SHADING", void 0);
				c = b.__decorate([v.subclass("esri.views.3d.support.DebugFlags")],
					c);
				return new c
			})
		},
		"esri/webdoc/support/opacityUtils": function() {
			define(["exports", "../../core/accessorSupport/ensureType"], function(a, b) {
				a.opacityToTransparency = function(c) {
					c = b.ensureInteger(100 * (1 - c));
					return Math.max(0, Math.min(c, 100))
				};
				a.transparencyToOpacity = function(c) {
					return Math.max(0, Math.min(1 - c / 100, 1))
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/CollectionFlattener": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Collection ./maybe ./has ./Error ./Logger ./accessorSupport/watch ./accessorSupport/trackingUtils ./accessorSupport/decorators/property ./arrayUtils ./accessorSupport/ensureType ./accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					d = function(n) {
						function t(q) {
							q = n.call(this, q) || this;
							q.getCollections = null;
							return q
						}
						a._inheritsLoose(t, n);
						var h = t.prototype;
						h.initialize = function() {
							this.own(f.autorun(() => this._refresh()))
						};
						h.destroy = function() {
							this.getCollections = null
						};
						h._refresh = function() {
							const q = e.isSome(this.getCollections) ? this.getCollections() : null;
							if (e.isNone(q)) this.removeAll();
							else {
								var u = 0;
								for (const x of q) e.isSome(x) && (u = this._processCollection(u, x));
								this.splice(u, this.length)
							}
						};
						h._createNewInstance =
							function(q) {
								return new c(q)
							};
						h._processCollection = function(q, u) {
							if (!u) return q;
							const x = this.itemFilterFunction ? this.itemFilterFunction : y => !!y;
							for (const y of u)
								if (y && (x(y) && (u = this.indexOf(y, q), 0 <= u ? u !== q && this.reorder(y, q) : this.add(y, q), ++q), this.getChildrenFunction))
									if (u = this.getChildrenFunction(y), Array.isArray(u))
										for (const w of u) q = this._processCollection(q, w);
									else q = this._processCollection(q, u);
							return q
						};
						return t
					}(c);
					b.__decorate([g.property()], d.prototype, "getCollections", void 0);
					b.__decorate([g.property()],
						d.prototype, "getChildrenFunction", void 0);
					b.__decorate([g.property()], d.prototype, "itemFilterFunction", void 0);
					return d = b.__decorate([p.subclass("esri.core.CollectionFlattener")], d)
				})
		},
		"esri/layers/support/editableLayers": function() {
			define(["exports"], function(a) {
				a.isEditableLayer = function(b) {
					return !(b && b.loaded && "capabilities" in b && b ? .capabilities ? .operations && "supportsEditing" in b.capabilities.operations) || !0 !== b.capabilities.operations.supportsEditing || "editingEnabled" in b && !b.editingEnabled ? !1 :
						!0
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/basemapUtils": function() {
			define("exports ../Basemap ../config ../core/Collection ../core/Logger ../core/maybe ../core/urlUtils ../core/accessorSupport/ensureType ./basemapDefinitions".split(" "), function(a, b, c, e, d, k, v, m, f) {
				function g(z, C) {
					let D;
					if ("string" === typeof z) {
						if (!(z in f.esriBasemapDefinitions)) return C = Object.entries(f.esriBasemapDefinitions)
							.filter(([, J]) => c.apiKey && !J.classic ||
								!c.apiKey && J.classic && !J.deprecated)
							.map(([J]) => `"${J}"`)
							.join(", "), B.warn(`Unable to find basemap definition for: ${z}. Try one of these: ${C}`), null;
						C && (D = C[z]);
						D || (D = b.fromId(z), C && (C[z] = D))
					} else D = m.ensureType(b, z);
					D ? .destroyed && (B.warn("The provided basemap is already destroyed", {
						basemap: D
					}), D = null);
					return D
				}

				function l(z, C) {
					const D = new e;
					z.forEach(J => {
						const K = C.find(H => w(h(J), h(H))) || J;
						D.includes(K) ? D.push(J) : D.push(K)
					});
					return D
				}

				function r(z) {
					if (p(z.url)) return !0;
					if ("vector-tile" === z.type)
						for (const C in z.sourceNameToSource)
							if (p(z.sourceNameToSource[C] ? .sourceUrl)) return !0;
					return !1
				}

				function p(z) {
					if (!z) return !1;
					z = new v.Url(v.makeAbsolute(z));
					return E.test(z.authority)
				}

				function n(z) {
					return z ? !z.loaded && z.resourceInfo ? q(z.resourceInfo.data) : {
						baseLayers: t(z.baseLayers),
						referenceLayers: t(z.referenceLayers)
					} : null
				}

				function t(z) {
					return (e.isCollection(z) ? z.toArray() : z)
						.map(h)
				}

				function h(z) {
					return {
						type: z.type,
						url: A("urlTemplate" in z && z.urlTemplate || z.url || "styleUrl" in z && z.styleUrl),
						minScale: "minScale" in z && null != z.minScale ? z.minScale : 0,
						maxScale: "maxScale" in z && null != z.maxScale ?
							z.maxScale : 0,
						opacity: null != z.opacity ? z.opacity : 1,
						visible: null != z.visible ? !!z.visible : !0,
						sublayers: "map-image" !== z.type && "wms" !== z.type || !k.isSome(z.sublayers) ? void 0 : z.sublayers ? .map(C => ({
							id: C.id,
							visible: C.visible
						})),
						activeLayerId: "wmts" === z.type ? z.activeLayer ? .id : void 0
					}
				}

				function q(z) {
					return z ? {
						baseLayers: u(z.baseMapLayers.filter(C => !C.isReference)),
						referenceLayers: u(z.baseMapLayers.filter(C => C.isReference))
					} : null
				}

				function u(z) {
					return z.map(C => {
						let D;
						switch (C.layerType) {
							case "VectorTileLayer":
								D =
									"vector-tile";
								break;
							case "ArcGISTiledMapServiceLayer":
								D = "tile";
								break;
							default:
								D = "unknown"
						}
						return {
							type: D,
							url: A(C.templateUrl || C.urlTemplate || C.styleUrl || C.url),
							minScale: null != C.minScale ? C.minScale : 0,
							maxScale: null != C.maxScale ? C.maxScale : 0,
							opacity: null != C.opacity ? C.opacity : 1,
							visible: null != C.visibility ? !!C.visibility : !0,
							sublayers: void 0,
							activeLayerId: void 0
						}
					})
				}

				function x(z, C, D) {
					return null != z !== (null != C) ? "not-equal" : z ? y(z.baseLayers, C.baseLayers) ? y(z.referenceLayers, C.referenceLayers) ? "equal" : D.mustMatchReferences ?
						"not-equal" : "base-layers-equal" : "not-equal" : "equal"
				}

				function y(z, C) {
					if (z.length !== C.length) return !1;
					for (let D = 0; D < z.length; D++)
						if (!w(z[D], C[D])) return !1;
					return !0
				}

				function w(z, C) {
					if (z.type !== C.type || z.url !== C.url || z.minScale !== C.minScale || z.maxScale !== C.maxScale || z.visible !== C.visible || z.opacity !== C.opacity) return !1;
					if (k.isSome(z.activeLayerId) || k.isSome(C.activeLayerId)) return z.activeLayerId === C.activeLayerId;
					if (k.isSome(z.sublayers) || k.isSome(C.sublayers)) {
						if (k.isNone(z.sublayers) || k.isNone(C.sublayers) ||
							z.sublayers.length !== C.sublayers.length) return !1;
						for (let D = 0; D < z.sublayers.length; D++) {
							const J = z.sublayers.at(D),
								K = C.sublayers.at(D);
							if (J.id !== K.id || J.visible !== K.visible) return !1
						}
					}
					return !0
				}

				function A(z) {
					return z ? v.normalize(z)
						.replace(/^\s*https?:/i, "")
						.toLowerCase() : ""
				}
				const B = d.getLogger("esri.support.basemapUtils"),
					E = /^(basemaps|ibasemaps).*-api\.arcgis\.com$/i;
				a.clonePreservingTiledLayers = function(z, C = null) {
					z = g(z);
					if (!z) return null;
					const D = new b({
						id: z.id,
						title: z.title,
						baseLayers: z.baseLayers.slice(),
						referenceLayers: z.referenceLayers.slice()
					});
					C && (D.baseLayers = l(D.baseLayers, C.baseLayers), D.referenceLayers = l(D.referenceLayers, C.referenceLayers));
					D.load()
						.catch(() => {});
					D.portalItem = z.portalItem;
					return D
				};
				a.contentEquals = function(z, C) {
					if (z === C) return !0;
					z = n(z);
					C = n(C);
					return "equal" === x(z, C, {
						mustMatchReferences: !0
					})
				};
				a.createCache = function() {
					return {}
				};
				a.destroyCache = function(z) {
					for (const C in z) {
						const D = z[C];
						!1 === D ? .destroyed && D.destroy();
						delete z[C]
					}
				};
				a.ensureType = g;
				a.findSpatialReference = function(z,
					C) {
					if (k.isNone(C) || k.isNone(z)) return {
						spatialReference: null,
						updating: !1
					};
					if ("not-loaded" === C.loadStatus) return C.load(), {
						spatialReference: null,
						updating: !0
					};
					if (C.spatialReference) return {
						spatialReference: C.spatialReference,
						updating: !1
					};
					if (0 === C.baseLayers.length) return {
						spatialReference: null,
						updating: !1
					};
					C = C.baseLayers.getItemAt(0);
					switch (C.loadStatus) {
						case "not-loaded":
							C.load();
						case "loading":
							return {
								spatialReference: null,
								updating: !0
							};
						case "failed":
							return {
								spatialReference: null,
								updating: !1
							}
					}
					C = (("supportedSpatialReferences" in
							C ? C.supportedSpatialReferences : null) || ["tileInfo" in C ? C.tileInfo ? .spatialReference : C.spatialReference])
						.filter(Boolean);
					return z.spatialReference ? {
						spatialReference: C.find(D => z.spatialReference.equals(D)) ? ? C[0] ? ? null,
						updating: !1
					} : {
						spatialReference: C[0],
						updating: !1
					}
				};
				a.getWellKnownBasemapId = function(z) {
					let C = null;
					z = n(z);
					const D = !z.baseLayers.length;
					for (const K in f.esriBasemapDefinitions) {
						var J = q(f.esriBasemapDefinitions[K]);
						J = x(z, J, {
							mustMatchReferences: D
						});
						if ("equal" === J) {
							C = K;
							break
						}
						"base-layers-equal" ===
						J && (C = K)
					}
					return C
				};
				a.hasDeveloperBasemapLayer = function(z) {
					return !!z ? .baseLayers.concat(z.referenceLayers)
						.some(r)
				};
				a.isDeveloperBasemapLayer = r;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/collectionUtils": function() {
			define(["exports", "../core/CollectionFlattener"], function(a, b) {
				a.createFlattenedTablesCollection = function(c) {
					return new b({
						getCollections: () => [c.tables, c.layers],
						getChildrenFunction: e => {
							const d = [];
							"tables" in e && d.push(e.tables);
							"layers" in e && d.push(e.layers);
							return d
						},
						itemFilterFunction: e => {
							const d = e.parent;
							return d && "tables" in d && d.tables.includes(e)
						}
					})
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/groundUtils": function() {
			define(["exports", "../Ground", "../core/Logger", "../core/accessorSupport/ensureType"], function(a, b, c, e) {
				const d = {
					"world-elevation": {
						id: "worldElevation",
						url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer",
						layerType: "ArcGISTiledElevationServiceLayer"
					},
					"world-topobathymetry": {
						id: "worldTopoBathymetry",
						url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/TopoBathy3D/ImageServer",
						layerType: "ArcGISTiledElevationServiceLayer"
					}
				};
				a.ensureType = function(k) {
					let v = null;
					"string" === typeof k ? k in d ? v = new b({
							resourceInfo: {
								data: {
									layers: [d[k]]
								}
							}
						}) : c.getLogger("esri.support.groundUtils")
						.warn(`Unable to find ground definition for: ${k}. Try "world-elevation"`) : v = e.ensureType(b, k);
					return v
				};
				a.groundElevationLayers =
					d;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/LayersMixin": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Collection ../core/collectionUtils ../core/Logger ../core/promiseUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../layers/Layer".split(" "), function(a, b, c, e, d, k, v, m, f, g, l, r) {
				function p(n, t,
					h) {
					if (n)
						for (let u = 0, x = n.length; u < x; u++) {
							var q = n.getItemAt(u);
							if (q[t] === h || "group" === q ? .type && (q = p(q.layers, t, h))) return q
						}
				}
				a.LayersMixin = n => {
					n = function(t) {
						function h(...u) {
							var x = t.call(this, ...u) || this;
							x.layers = new e;
							x.layers.on("before-add", y => {
								y = y.item;
								y.parent && "remove" in y.parent && y.parent.remove(y)
							});
							x.layers.on("after-add", y => {
								y = y.item;
								y.parent = b._assertThisInitialized(x);
								x.layerAdded(y);
								"elevation" !== y.type && "base-elevation" !== y.type || k.getLogger(x.declaredClass)
									.error(`Layer 'title:${y.title}, id:${y.id}' of type '${y.type}' is not supported as an operational layer and will therefore be ignored.`)
							});
							x.layers.on("after-remove", y => {
								y = y.item;
								y.parent = null;
								x.layerRemoved(y)
							});
							return x
						}
						b._inheritsLoose(h, t);
						var q = h.prototype;
						q.destroy = function() {
							const u = this.layers.removeAll();
							for (const x of u) this.layerRemoved(x), x.destroy();
							this.layers.destroy()
						};
						q.add = function(u, x) {
							const y = this.layers;
							x = y.getNextIndex(x);
							u instanceof r ? u.parent === this ? this.reorder(u, x) : y.add(u, x) : v.isPromiseLike(u) ? u.then(w => {
									this.destroyed || this.add(w, x)
								}) : k.getLogger(this.declaredClass)
								.error("#add()", "The item being added is not a Layer or a Promise that resolves to a Layer.")
						};
						q.addMany = function(u, x) {
							const y = this.layers;
							x = y.getNextIndex(x);
							u.slice()
								.forEach(w => {
									w.parent === this ? this.reorder(w, x) : (y.add(w, x), x += 1)
								})
						};
						q.findLayerById = function(u) {
							return p(this.layers, "id", u)
						};
						q.findLayerByUid = function(u) {
							return p(this.layers, "uid", u)
						};
						q.remove = function(u) {
							return this.layers.remove(u)
						};
						q.removeMany = function(u) {
							return this.layers.removeMany(u)
						};
						q.removeAll = function() {
							return this.layers.removeAll()
						};
						q.reorder = function(u, x) {
							return this.layers.reorder(u, x)
						};
						q.layerAdded = function(u) {};
						q.layerRemoved = function(u) {};
						b._createClass(h, [{
							key: "layers",
							set: function(u) {
								this._set("layers", d.referenceSetter(u, this._get("layers")))
							}
						}]);
						return h
					}(n);
					c.__decorate([m.property()], n.prototype, "layers", null);
					return n = c.__decorate([l.subclass("esri.support.LayersMixin")], n)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/Layer": function() {
			define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../geometry ../request ../core/Error ../core/Evented ../core/Identifiable ../core/Loadable ../core/Logger ../core/promiseUtils ../core/urlUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./support/fromPortalItem ../geometry/Extent ../geometry/SpatialReference".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x) {
					let y = 0;
					e = function(w) {
						function A() {
							var E = w.apply(this, arguments) || this;
							E.attributionDataUrl = null;
							E.fullExtent = new u(-180, -90, 180, 90, x.WGS84);
							E.id = Date.now()
								.toString(16) + "-layer-" + y++;
							E.legendEnabled = !0;
							E.listMode = "show";
							E.opacity = 1;
							E.parent = null;
							E.popupEnabled = !0;
							E.attributionVisible = !0;
							E.spatialReference = x.WGS84;
							E.title = null;
							E.type = null;
							E.url = null;
							E.visible = !0;
							return E
						}
						b._inheritsLoose(A, w);
						A.fromArcGISServerUrl = function() {
							var E = b._asyncToGenerator(function*(z) {
								z =
									"string" === typeof z ? {
										url: z
									} : z;
								return (yield new Promise((C, D) => a(["./support/arcgisLayers"], C, D)))
									.fromUrl(z)
							});
							return function(z) {
								return E.apply(this, arguments)
							}
						}();
						A.fromPortalItem = function(E) {
							return q.fromPortalItem(E)
						};
						var B = A.prototype;
						B.initialize = function() {
							this.when()
								.catch(E => {
									l.isAbortError(E) || g.getLogger(this.declaredClass)
										.error("#load()", `Failed to load layer (title: '${this.title??"no title"}', id: '${this.id??"no id"}')`, {
											error: E
										})
								})
						};
						B.destroy = function() {
							if (this.parent) {
								const E = this.parent;
								"layers" in E && E.layers.includes(this) ? E.layers.remove(this) : "tables" in E && E.tables.includes(this) ? E.tables.remove(this) : "baseLayers" in E && E.baseLayers.includes(this) ? E.baseLayers.remove(this) : "baseLayers" in E && E.referenceLayers.includes(this) && E.referenceLayers.remove(this)
							}
						};
						B.fetchAttributionData = function() {
							var E = b._asyncToGenerator(function*() {
								const z = this.attributionDataUrl;
								if (this.hasAttributionData && z) return (yield d(z, {
										query: {
											f: "json"
										},
										responseType: "json"
									}))
									.data;
								throw new k("layer:no-attribution-data",
									"Layer does not have attribution data");
							});
							return function() {
								return E.apply(this, arguments)
							}
						}();
						b._createClass(A, [{
							key: "hasAttributionData",
							get: function() {
								return null != this.attributionDataUrl
							}
						}, {
							key: "parsedUrl",
							get: function() {
								return r.urlToObject(this.url)
							}
						}]);
						return A
					}(v.EventedMixin(m.IdentifiableMixin(f)));
					c.__decorate([p.property({
						type: String
					})], e.prototype, "attributionDataUrl", void 0);
					c.__decorate([p.property({
						type: u
					})], e.prototype, "fullExtent", void 0);
					c.__decorate([p.property({
							readOnly: !0
						})],
						e.prototype, "hasAttributionData", null);
					c.__decorate([p.property({
						type: String,
						clonable: !1
					})], e.prototype, "id", void 0);
					c.__decorate([p.property({
						type: Boolean,
						nonNullable: !0
					})], e.prototype, "legendEnabled", void 0);
					c.__decorate([p.property({
						type: ["show", "hide", "hide-children"]
					})], e.prototype, "listMode", void 0);
					c.__decorate([p.property({
						type: Number,
						range: {
							min: 0,
							max: 1
						},
						nonNullable: !0
					})], e.prototype, "opacity", void 0);
					c.__decorate([p.property({
						clonable: !1
					})], e.prototype, "parent", void 0);
					c.__decorate([p.property({
							readOnly: !0
						})],
						e.prototype, "parsedUrl", null);
					c.__decorate([p.property({
						type: Boolean
					})], e.prototype, "popupEnabled", void 0);
					c.__decorate([p.property({
						type: Boolean
					})], e.prototype, "attributionVisible", void 0);
					c.__decorate([p.property({
						type: x
					})], e.prototype, "spatialReference", void 0);
					c.__decorate([p.property({
						type: String
					})], e.prototype, "title", void 0);
					c.__decorate([p.property({
						readOnly: !0,
						json: {
							read: !1
						}
					})], e.prototype, "type", void 0);
					c.__decorate([p.property()], e.prototype, "url", void 0);
					c.__decorate([p.property({
						type: Boolean,
						nonNullable: !0
					})], e.prototype, "visible", void 0);
					return e = c.__decorate([h.subclass("esri.layers.Layer")], e)
				})
		},
		"esri/geometry": function() {
			define("exports ./core/accessorSupport/ensureType ./geometry/Extent ./geometry/Geometry ./geometry/Multipoint ./geometry/Point ./geometry/Polygon ./geometry/Polyline ./geometry/SpatialReference ./geometry/support/typeUtils ./geometry/support/jsonUtils".split(" "), function(a, b, c, e, d, k, v, m, f, g, l) {
				const r = {
					base: e,
					key: "type",
					typeMap: {
						extent: c,
						multipoint: d,
						point: k,
						polyline: m,
						polygon: v
					}
				};
				b = b.ensureOneOfType(r);
				a.Extent = c;
				a.BaseGeometry = e;
				a.Multipoint = d;
				a.Point = k;
				a.Polygon = v;
				a.Polyline = m;
				a.SpatialReference = f;
				a.featureGeometryTypeKebabDictionary = g.featureGeometryTypeKebabDictionary;
				a.isFeatureGeometryType = g.isFeatureGeometryType;
				a.typeKebabDictionary = g.typeKebabDictionary;
				a.fromJSON = l.fromJSON;
				a.ensureType = b;
				a.geometryTypes = r;
				a.isGeometry = function(p) {
					return p instanceof e
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/Multipoint": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./Extent ./Geometry ./Point ./support/zmUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					function r(n) {
						return (t, h) => null == t ? h : null == h ? t : n(t, h)
					}
					var p;
					d = p = function(n) {
						function t(...q) {
							q = n.call(this, ...q) || this;
							q.points = [];
							q.type = "multipoint";
							return q
						}
						a._inheritsLoose(t, n);
						var h = t.prototype;
						h.normalizeCtorArgs = function(q, u) {
							if (!q && !u) return {};
							const x = {};
							Array.isArray(q) ? (x.points = q, x.spatialReference = u) : !q || "esri.geometry.SpatialReference" !== q.declaredClass && null == q.wkid ? (q.points && (x.points = q.points), q.spatialReference && (x.spatialReference = q.spatialReference),
								q.hasZ && (x.hasZ = q.hasZ), q.hasM && (x.hasM = q.hasM)) : x.spatialReference = q;
							if (q = x.points && x.points[0]) void 0 === x.hasZ && void 0 === x.hasM ? (x.hasZ = 2 < q.length, x.hasM = !1) : void 0 === x.hasZ ? x.hasZ = 3 < q.length : void 0 === x.hasM && (x.hasM = 3 < q.length);
							return x
						};
						h.writePoints = function(q, u) {
							u.points = c.clone(this.points)
						};
						h.addPoint = function(q) {
							l.updateSupportFromPoint(this, q);
							Array.isArray(q) ? this.points.push(q) : this.points.push(q.toArray());
							this.notifyChange("points");
							return this
						};
						h.clone = function() {
							const q = {
								points: c.clone(this.points),
								spatialReference: this.spatialReference
							};
							this.hasZ && (q.hasZ = !0);
							this.hasM && (q.hasM = !0);
							return new p(q)
						};
						h.getPoint = function(q) {
							if (!this._validateInputs(q)) return null;
							q = this.points[q];
							const u = {
								x: q[0],
								y: q[1],
								spatialReference: this.spatialReference
							};
							let x = 2;
							this.hasZ && (u.z = q[2], x = 3);
							this.hasM && (u.m = q[x]);
							return new g(u)
						};
						h.removePoint = function(q) {
							if (!this._validateInputs(q)) return null;
							q = new g(this.points.splice(q, 1)[0], this.spatialReference);
							this.notifyChange("points");
							return q
						};
						h.setPoint = function(q,
							u) {
							if (!this._validateInputs(q)) return this;
							l.updateSupportFromPoint(this, u);
							Array.isArray(u) || (u = u.toArray());
							this.points[q] = u;
							this.notifyChange("points");
							return this
						};
						h.toJSON = function(q) {
							return this.write({}, q)
						};
						h._validateInputs = function(q) {
							return null != q && 0 <= q && q < this.points.length
						};
						a._createClass(t, [{
							key: "cache",
							get: function() {
								this.commitProperty("points");
								this.commitProperty("hasZ");
								this.commitProperty("hasM");
								this.commitProperty("spatialReference");
								return {}
							}
						}, {
							key: "extent",
							get: function() {
								const q =
									this.points;
								if (!q.length) return null;
								const u = new m,
									x = this.hasZ,
									y = this.hasM,
									w = x ? 3 : 2;
								var A = q[0];
								const B = r(Math.min),
									E = r(Math.max);
								let [z, C] = A, [D, J] = A, K, H, G, F;
								for (let L = 0, R = q.length; L < R; L++) {
									A = q[L];
									const [V, U] = A;
									z = B(z, V);
									C = B(C, U);
									D = E(D, V);
									J = E(J, U);
									if (x && 2 < A.length) {
										const W = A[2];
										K = B(K, W);
										G = E(G, W)
									}
									y && A.length > w && (A = A[w], H = B(H, A), F = E(F, A))
								}
								u.xmin = z;
								u.ymin = C;
								u.xmax = D;
								u.ymax = J;
								u.spatialReference = this.spatialReference;
								x ? (u.zmin = K, u.zmax = G) : (u.zmin = void 0, u.zmax = void 0);
								y ? (u.mmin = H, u.mmax = F) : (u.mmin = void 0,
									u.mmax = void 0);
								return u
							}
						}]);
						return t
					}(f);
					b.__decorate([e.property({
						readOnly: !0
					})], d.prototype, "cache", null);
					b.__decorate([e.property()], d.prototype, "extent", null);
					b.__decorate([e.property({
						type: [
							[Number]
						],
						json: {
							write: {
								isRequired: !0
							}
						}
					})], d.prototype, "points", void 0);
					b.__decorate([v.writer("points")], d.prototype, "writePoints", null);
					d = p = b.__decorate([k.subclass("esri.geometry.Multipoint")], d);
					d.prototype.toJSON.isDefaultToJSON = !0;
					return d
				})
		},
		"esri/geometry/support/zmUtils": function() {
			define(["exports"],
				function(a) {
					a.updateSupportFromPoint = function(b, c, e = !1) {
						let {
							hasM: d,
							hasZ: k
						} = b;
						Array.isArray(c) ? 4 !== c.length || d || k ? 3 === c.length && e && !d ? (k = !0, d = !1) : 3 === c.length && d && k && (k = d = !1) : k = d = !0 : (k = !k && c.hasZ && (!d || c.hasM), d = !d && c.hasM && (!k || c.hasZ));
						b.hasZ = k;
						b.hasM = d
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/geometry/Polygon": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/arrayUtils ../core/lang ../core/maybe ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./Extent ./Geometry ./Point ./SpatialReference ./support/centroid ./support/contains ./support/coordsUtils ./support/extentUtils ./support/intersectsBase ./support/webMercatorUtils ./support/zmUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y) {
					var w;
					v = w = function(A) {
						function B(...z) {
							z = A.call(this, ...z) || this;
							z.rings = [];
							z.type = "polygon";
							return z
						}
						a._inheritsLoose(B, A);
						B.fromExtent = function(z) {
							var C = z.clone()
								.normalize();
							z = z.spatialReference;
							let D = !1,
								J = !1;
							for (const K of C) K.hasZ && (D = !0), K.hasM && (J = !0);
							C = {
								rings: C.map(K => {
									const H = [
										[K.xmin, K.ymin],
										[K.xmin, K.ymax],
										[K.xmax, K.ymax],
										[K.xmax, K.ymin],
										[K.xmin, K.ymin]
									];
									if (D && K.hasZ) {
										var G = K.zmin + .5 * (K.zmax - K.zmin);
										for (let F = 0; F < H.length; F++) H[F].push(G)
									}
									if (J &&
										K.hasM)
										for (K = K.mmin + .5 * (K.mmax - K.mmin), G = 0; G < H.length; G++) H[G].push(K);
									return H
								}),
								spatialReference: z
							};
							D && (C.hasZ = !0);
							J && (C.hasM = !0);
							return new w(C)
						};
						var E = B.prototype;
						E.normalizeCtorArgs = function(z, C) {
							let D = null,
								J, K, H = null;
							z && !Array.isArray(z) ? (D = z.rings ? z.rings : null, C || (z.spatialReference ? C = z.spatialReference : z.rings || (C = z)), J = z.hasZ, K = z.hasM) : D = z;
							D = D || [];
							C = C || p.WGS84;
							D.length && D[0] && null != D[0][0] && "number" === typeof D[0][0] && (D = [D]);
							if (H = D[0] && D[0][0]) void 0 === J && void 0 === K ? (J = 2 < H.length, K = 3 < H.length) :
								void 0 === J ? J = K ? 3 < H.length : 2 < H.length : void 0 === K && (K = J ? 3 < H.length : 2 < H.length);
							return {
								rings: D,
								spatialReference: C,
								hasZ: J,
								hasM: K
							}
						};
						E.writeRings = function(z, C) {
							C.rings = e.clone(this.rings)
						};
						E.addRing = function(z) {
							if (z) {
								var C = this.rings,
									D = C.length;
								if (Array.isArray(z[0])) C[D] = z.concat();
								else {
									const J = [];
									for (let K = 0, H = z.length; K < H; K++) J[K] = z[K].toArray();
									C[D] = J
								}
								this.notifyChange("rings");
								return this
							}
						};
						E.clone = function() {
							const z = new w;
							z.spatialReference = this.spatialReference;
							z.rings = e.clone(this.rings);
							z.hasZ =
								this.hasZ;
							z.hasM = this.hasM;
							return z
						};
						E.equals = function(z) {
							if (this === z) return !0;
							if (d.isNone(z)) return !1;
							var C = this.spatialReference,
								D = z.spatialReference;
							if (d.isSome(C) !== d.isSome(D) || d.isSome(C) && d.isSome(D) && !C.equals(D) || this.rings.length !== z.rings.length) return !1;
							C = ([J, K, H, G], [F, L, R, V]) => J === F && K === L && (null == H && null == R || H === R) && (null == G && null == V || G === V);
							for (D = 0; D < this.rings.length; D++)
								if (!c.equals(this.rings[D], z.rings[D], C)) return !1;
							return !0
						};
						E.contains = function(z) {
							if (!z) return !1;
							const C = x.project(z,
								this.spatialReference);
							return t.polygonContainsPoint(this, d.isSome(C) ? C : z)
						};
						E.isClockwise = function(z) {
							z = Array.isArray(z[0]) ? z : z.map(C => this.hasZ ? this.hasM ? [C.x, C.y, C.z, C.m] : [C.x, C.y, C.z] : [C.x, C.y]);
							return h.isClockwise(z, this.hasM, this.hasZ)
						};
						E.getPoint = function(z, C) {
							if (!this._validateInputs(z, C)) return null;
							z = this.rings[z][C];
							C = this.hasZ;
							const D = this.hasM;
							return C && !D ? new r(z[0], z[1], z[2], void 0, this.spatialReference) : D && !C ? new r(z[0], z[1], void 0, z[2], this.spatialReference) : C && D ? new r(z[0], z[1],
								z[2], z[3], this.spatialReference) : new r(z[0], z[1], this.spatialReference)
						};
						E.insertPoint = function(z, C, D) {
							if (!this._validateInputs(z, C, !0)) return this;
							y.updateSupportFromPoint(this, D);
							Array.isArray(D) || (D = D.toArray());
							this.rings[z].splice(C, 0, D);
							this.notifyChange("rings");
							return this
						};
						E.removePoint = function(z, C) {
							if (!this._validateInputs(z, C)) return null;
							z = new r(this.rings[z].splice(C, 1)[0], this.spatialReference);
							this.notifyChange("rings");
							return z
						};
						E.removeRing = function(z) {
							if (!this._validateInputs(z,
								null)) return null;
							z = this.rings.splice(z, 1)[0];
							const C = this.spatialReference;
							z = z.map(D => new r(D, C));
							this.notifyChange("rings");
							return z
						};
						E.setPoint = function(z, C, D) {
							if (!this._validateInputs(z, C)) return this;
							y.updateSupportFromPoint(this, D);
							Array.isArray(D) || (D = D.toArray());
							this.rings[z][C] = D;
							this.notifyChange("rings");
							return this
						};
						E._validateInputs = function(z, C, D = !1) {
							return null == z || 0 > z || z >= this.rings.length || null != C && (z = this.rings[z], D && (0 > C || C > z.length) || !D && (0 > C || C >= z.length)) ? !1 : !0
						};
						E.toJSON = function(z) {
							return this.write({},
								z)
						};
						a._createClass(B, [{
							key: "cache",
							get: function() {
								this.commitProperty("rings");
								this.commitProperty("hasZ");
								this.commitProperty("hasM");
								this.commitProperty("spatialReference");
								return {}
							}
						}, {
							key: "centroid",
							get: function() {
								const z = n.polygonCentroid(this);
								if (!z || isNaN(z[0]) || isNaN(z[1]) || this.hasZ && isNaN(z[2])) return null;
								const C = new r;
								C.x = z[0];
								C.y = z[1];
								C.spatialReference = this.spatialReference;
								this.hasZ && (C.z = z[2]);
								return C
							}
						}, {
							key: "extent",
							get: function() {
								const {
									spatialReference: z
								} = this;
								var C = q.getPolygonExtent(this);
								if (!C) return null;
								C = new g(C);
								C.spatialReference = z;
								return C
							}
						}, {
							key: "isSelfIntersecting",
							get: function() {
								return u.isSelfIntersecting(this.rings)
							}
						}]);
						return B
					}(l);
					b.__decorate([k.property({
						readOnly: !0
					})], v.prototype, "cache", null);
					b.__decorate([k.property({
						readOnly: !0
					})], v.prototype, "centroid", null);
					b.__decorate([k.property({
						readOnly: !0
					})], v.prototype, "extent", null);
					b.__decorate([k.property({
						readOnly: !0
					})], v.prototype, "isSelfIntersecting", null);
					b.__decorate([k.property({
							type: [
								[
									[Number]
								]
							],
							json: {
								write: {
									isRequired: !0
								}
							}
						})],
						v.prototype, "rings", void 0);
					b.__decorate([f.writer("rings")], v.prototype, "writeRings", null);
					v = w = b.__decorate([m.subclass("esri.geometry.Polygon")], v);
					v.prototype.toJSON.isDefaultToJSON = !0;
					return v
				})
		},
		"esri/geometry/support/centroid": function() {
			define(["exports", "./coordsUtils"], function(a, b) {
				function c(v, m) {
					if (!v || !v.length) return null;
					const f = [],
						g = [],
						l = m ? [Infinity, -Infinity, Infinity, -Infinity, Infinity, -Infinity] : [Infinity, -Infinity, Infinity, -Infinity];
					for (let r = 0, p = v.length; r < p; r++) {
						const n = e(v[r],
							m, l);
						n && g.push(n)
					}
					g.sort((r, p) => {
						let n = r[2] - p[2];
						0 === n && m && (n = r[4] - p[4]);
						return n
					});
					g.length && (f[0] = g[0][0], f[1] = g[0][1], m && (f[2] = g[0][3]), f[0] < l[0] || f[0] > l[1] || f[1] < l[2] || f[1] > l[3] || m && (f[2] < l[4] || f[2] > l[5])) && (f.length = 0);
					if (!f.length)
						if (v = v[0] && v[0].length ? d(v[0], m) : null) f[0] = v[0], f[1] = v[1], m && 2 < v.length && (f[2] = v[2]);
						else return null;
					return f
				}

				function e(v, m, f) {
					let g = 0,
						l = 0,
						r = 0,
						p = 0,
						n = 0;
					const t = v.length ? v[0][0] : 0,
						h = v.length ? v[0][1] : 0,
						q = v.length && m ? v[0][2] : 0;
					for (let w = 0; w < v.length; w++) {
						var u = v[w],
							x = v[(w + 1) % v.length];
						const [A, B, E] = u;
						var y = A - t;
						const z = B - h,
							[C, D, J] = x,
							K = C - t,
							H = D - h,
							G = y * H - K * z;
						p += G;
						g += (y + K) * G;
						l += (z + H) * G;
						m && 2 < u.length && 2 < x.length && (u = E - q, x = J - q, y = y * x - K * u, r += (u + x) * y, n += y);
						A < f[0] && (f[0] = A);
						A > f[1] && (f[1] = A);
						B < f[2] && (f[2] = B);
						B > f[3] && (f[3] = B);
						m && (E < f[4] && (f[4] = E), E > f[5] && (f[5] = E))
					}
					0 < p && (p *= -1);
					0 < n && (n *= -1);
					if (!p) return null;
					p *= .5;
					n *= .5;
					v = [g / (6 * p) + t, l / (6 * p) + h, p];
					m && (f[4] === f[5] || 0 === n ? (v[3] = (f[4] + f[5]) / 2, v[4] = 0) : (v[3] = r / (6 * n) + q, v[4] = n));
					return v
				}

				function d(v, m) {
					const f = m ? [0, 0, 0] : [0, 0],
						g = m ? [0, 0, 0] : [0, 0];
					let l = 0,
						r = 0,
						p = 0,
						n = 0;
					for (let h = 0, q = v.length; h < q - 1; h++) {
						var t = v[h];
						const u = v[h + 1];
						if (t && u) {
							f[0] = t[0];
							f[1] = t[1];
							g[0] = u[0];
							g[1] = u[1];
							m && 2 < t.length && 2 < u.length && (f[2] = t[2], g[2] = u[2]);
							const x = b.getLength(f, g);
							x && (l += x, t = b.getMidpoint(t, u), r += x * t[0], p += x * t[1], m && 2 < t.length && (n += x * t[2]))
						}
					}
					return 0 < l ? m ? [r / l, p / l, n / l] : [r / l, p / l] : v.length ? v[0] : null
				}
				const k = 1 / 3;
				a.extentCentroid = function(v) {
					return v ? v.hasZ ? [v.xmax - v.xmin / 2, v.ymax - v.ymin / 2, v.zmax - v.zmin / 2] : [v.xmax - v.xmin / 2, v.ymax - v.ymin / 2] : null
				};
				a.lineCentroid =
					d;
				a.polygonCentroid = function(v) {
					return v ? c(v.rings, v.hasZ ? ? !1) : null
				};
				a.ringCentroid = e;
				a.ringsCentroid = c;
				a.weightedAreaCentroid = function(v) {
					if (!v || !v.rings) return null;
					({
						rings: v
					} = v);
					let m = 0;
					for (var f = 0; f < v.length; f++) m += b.getRingArea(v[f]);
					if (1E-6 > m) return c(v, !1);
					f = [0, 0];
					const g = v[0][0];
					for (let t = 0; t < v.length; t++) a: {
						let h = void 0;
						var l = f,
							r = g,
							p = v[t];
						if (!l || !p || 3 > p.length) break a;
						var n = p[0];
						const q = [0, 0],
							u = [p[1][0] - n[0], p[1][1] - n[1]];
						for (let x = 2; x < p.length; x++) q[0] = p[x][0] - n[0],
						q[1] = p[x][1] - n[1],
						h = .5 *
						k * (q[0] * u[1] - q[1] * u[0]),
						l[0] += h * (u[0] + q[0]),
						l[1] += h * (u[1] + q[1]),
						u[0] = q[0],
						u[1] = q[1];p = b.getRingArea(p);n = [n[0], n[1]];n[0] -= r[0];n[1] -= r[1];n[0] *= p;n[1] *= p;l[0] += n[0];l[1] += n[1]
					}
					f[0] *= 1 / m;
					f[1] *= 1 / m;
					f[0] += g[0];
					f[1] += g[1];
					return f
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/coordsUtils": function() {
			define(["exports", "../../core/arrayUtils", "./spatialReferenceUtils"], function(a, b, c) {
				function e(r, p) {
					const n = p[0] - r[0],
						t = p[1] - r[1];
					return 2 <
						r.length && 2 < p.length ? (r = r[2] - p[2], Math.sqrt(n * n + t * t + r * r)) : Math.sqrt(n * n + t * t)
				}

				function d(r, p, n) {
					const t = r[0] + n * (p[0] - r[0]),
						h = r[1] + n * (p[1] - r[1]);
					return 2 < r.length && 2 < p.length ? [t, h, r[2] + n * (p[2] - r[2])] : [t, h]
				}

				function k(r, p, n, t) {
					let h = n[0];
					n = n[1];
					let q = t[0] - h,
						u = t[1] - n;
					if (0 !== q || 0 !== u) {
						const x = ((r - h) * q + (p - n) * u) / (q * q + u * u);
						1 < x ? (h = t[0], n = t[1]) : 0 < x && (h += q * x, n += u * x)
					}
					q = r - h;
					u = p - n;
					return q * q + u * u
				}

				function v(r, p, n) {
					const t = r.length;
					let h = 0,
						q = 0,
						u = 0;
					for (let x = 0; x < t; x++) {
						const y = r[x],
							w = r[(x + 1) % t];
						let A = 2;
						h += y[0] * w[1] -
							w[0] * y[1];
						2 < y.length && 2 < w.length && n && (q += y[0] * w[2] - w[0] * y[2], A = 3);
						y.length > A && w.length > A && p && (u += y[0] * w[A] - w[0] * y[A])
					}
					return 0 >= h && 0 >= q && 0 >= u
				}

				function m(r) {
					const p = r.length;
					return 2 < p && b.equals(r[0], r[p - 1])
				}

				function f(r) {
					if ("rings" in r)
						for (const p of r.rings) m(p) || p.push(p[0].slice())
				}

				function g(r, p) {
					var n = c.getInfo(p);
					if (n) {
						p = n.valid[0];
						n = n.valid[1];
						var t = n - p;
						for (const h of r) {
							r = Infinity;
							let q = -Infinity;
							for (const u of h) {
								const x = l(u[0], p, n);
								r = Math.min(r, x);
								q = Math.max(q, x);
								u[0] = x
							}
							r = q - r;
							t - r < r && h.forEach(u => {
								0 > u[0] && (u[0] += t)
							})
						}
					}
				}

				function l(r, p, n) {
					const t = n - p;
					return r < p ? n - (p - r) % t : r > n ? p + (r - p) % t : r
				}
				a.closeRings = f;
				a.closeRingsAndFixWinding = function(r) {
					if ("rings" in r && (f(r), 0 < r.rings.length && !v(r.rings[0], r.hasM ? ? !1, r.hasZ ? ? !1)))
						for (const p of r.rings) p.reverse()
				};
				a.distanceFromPointToPolygon = function(r, p, n) {
					n = n.rings;
					let t = !1,
						h = Infinity,
						q, u;
					for (let x = 0; x < n.length; x++) {
						const y = n[x];
						for (let w = 0, A = y.length - 1; w < y.length; A = w++) q = y[w], u = y[A], q[1] > p !== u[1] > p && r < (u[0] - q[0]) * (p - q[1]) / (u[1] - q[1]) + q[0] && (t = !t), h = Math.min(h,
							k(r, p, q, u))
					}
					return 0 === h ? 0 : (t ? 1 : -1) * Math.sqrt(h)
				};
				a.distanceToSegmentSquared = k;
				a.geometryToCoordinates = function(r) {
					if (!r) return null;
					if (Array.isArray(r)) return r;
					const p = r.hasZ,
						n = r.hasM;
					if ("point" === r.type) return n && p ? [r.x, r.y, r.z, r.m] : p ? [r.x, r.y, r.z] : n ? [r.x, r.y, r.m] : [r.x, r.y];
					if ("polygon" === r.type) return r.rings.slice(0);
					if ("polyline" === r.type) return r.paths.slice(0);
					if ("multipoint" === r.type) return r.points.slice(0);
					if ("extent" === r.type) {
						r = r.clone()
							.normalize();
						if (!r) return null;
						let t = !1,
							h = !1;
						r.forEach(q => {
							q.hasZ && (t = !0);
							q.hasM && (h = !0)
						});
						return r.map(q => {
							const u = [
								[q.xmin, q.ymin],
								[q.xmin, q.ymax],
								[q.xmax, q.ymax],
								[q.xmax, q.ymin],
								[q.xmin, q.ymin]
							];
							if (t && q.hasZ) {
								var x = .5 * (q.zmax - q.zmin);
								for (let y = 0; y < u.length; y++) u[y].push(x)
							}
							if (h && q.hasM)
								for (q = .5 * (q.mmax - q.mmin), x = 0; x < u.length; x++) u[x].push(q);
							return u
						})
					}
					return null
				};
				a.getLength = e;
				a.getMidpoint = function(r, p) {
					return d(r, p, .5)
				};
				a.getPathLength = function(r) {
					const p = r.length;
					let n = 0;
					for (let t = 0; t < p - 1; ++t) n += e(r[t], r[t + 1]);
					return n
				};
				a.getPointOnPath = function(r,
					p) {
					if (0 >= p) return r[0];
					const n = r.length;
					let t = 0;
					for (let h = 0; h < n - 1; ++h) {
						const q = e(r[h], r[h + 1]);
						if (p - t < q) return d(r[h], r[h + 1], (p - t) / q);
						t += q
					}
					return r[n - 1]
				};
				a.getRingArea = function(r) {
					if (!r || 3 > r.length) return 0;
					let p = 0;
					const n = r.length - 1;
					for (let t = 0; t < n; t++) p += (r[t][0] - r[t + 1][0]) * (r[t][1] + r[t + 1][1]);
					p += (r[n][0] - r[0][0]) * (r[n][1] + r[0][1]);
					return -.5 * p
				};
				a.isClockwise = v;
				a.isClosed = m;
				a.projectPointOnLine = function(r, p, n, t) {
					const [h, q] = p, [u, x] = n[t], [y, w] = n[t + 1];
					p = y - u;
					n = w - x;
					t = Math.min(1, Math.max(0, ((h - u) * p + (q -
						x) * n) / (p * p + n * n)));
					r[0] = u + p * t;
					r[1] = x + n * t;
					return r
				};
				a.unnormalizeGeometryOnDatelineCrossing = function(r) {
					if ("polygon" !== r.type && "polyline" !== r.type) return r;
					g("polygon" === r.type ? r.rings : r.paths, r.spatialReference);
					return r
				};
				a.unnormalizeVerticesOnDatelineCrossing = g;
				a.unnormalizedCoordinate = l;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/extentUtils": function() {
			define(["exports", "./boundsUtils"], function(a, b) {
				function c(f, g = !1, l = !1) {
					return g ?
						l ? {
							xmin: f[0],
							ymin: f[1],
							zmin: f[2],
							mmin: f[3],
							xmax: f[4],
							ymax: f[5],
							zmax: f[6],
							mmax: f[7]
						} : {
							xmin: f[0],
							ymin: f[1],
							zmin: f[2],
							xmax: f[3],
							ymax: f[4],
							zmax: f[5]
						} : l ? {
							xmin: f[0],
							ymin: f[1],
							mmin: f[2],
							xmax: f[3],
							ymax: f[4],
							mmax: f[5]
						} : {
							xmin: f[0],
							ymin: f[1],
							xmax: f[2],
							ymax: f[3]
						}
				}

				function e(f) {
					const {
						hasZ: g,
						hasM: l,
						points: r
					} = f;
					return c(b.getPointsBounds(m, r, g ? ? !1, l ? ? !1), g, l)
				}

				function d(f) {
					const {
						x: g,
						y: l,
						z: r,
						m: p
					} = f;
					f = null != p;
					return null != r ? f ? {
						xmin: g,
						ymin: l,
						zmin: r,
						mmin: p,
						xmax: g,
						ymax: l,
						zmax: r,
						mmax: p
					} : {
						xmin: g,
						ymin: l,
						zmin: r,
						xmax: g,
						ymax: l,
						zmax: r
					} : f ? {
						xmin: g,
						ymin: l,
						mmin: p,
						xmax: g,
						ymax: l,
						mmax: p
					} : {
						xmin: g,
						ymin: l,
						xmax: g,
						ymax: l
					}
				}

				function k(f) {
					const {
						hasZ: g,
						hasM: l,
						rings: r
					} = f;
					return (f = b.getRingsOrPathsBounds(m, r, g ? ? !1, l ? ? !1)) ? c(f, g, l) : null
				}

				function v(f) {
					const {
						hasZ: g,
						hasM: l,
						paths: r
					} = f;
					return (f = b.getRingsOrPathsBounds(m, r, g ? ? !1, l ? ? !1)) ? c(f, g, l) : null
				}
				const m = [];
				a.getGeometryExtent = function(f) {
					return f ? void 0 !== f.xmin && void 0 !== f.ymin && void 0 !== f.xmax && void 0 !== f.ymax ? f : void 0 !== f.x && void 0 !== f.y ? d(f) : void 0 !== f.rings ? k(f) : void 0 !== f.paths ?
						v(f) : void 0 !== f.points ? e(f) : null : null
				};
				a.getMultipointExtent = e;
				a.getPointExtent = d;
				a.getPolygonExtent = k;
				a.getPolylineExtent = v;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/boundsUtils": function() {
			define(["exports"], function(a) {
				function b(f) {
					return void 0 !== f.xmin && void 0 !== f.ymin && void 0 !== f.xmax && void 0 !== f.ymax
				}

				function c(f) {
					return function(g, l) {
						return null == g ? l : null == l ? g : f(g, l)
					}
				}

				function e(f, g, l, r) {
					const p = l ? 3 : 2;
					if (!g.length ||
						!g[0].length) return null;
					let [n, t] = g[0][0], [h, q] = g[0][0], u = void 0, x = void 0, y = void 0;
					var w = void 0;
					for (let A = 0; A < g.length; A++) {
						const B = g[A];
						for (let E = 0; E < B.length; E++) {
							const z = B[E],
								[C, D] = z;
							n = v(n, C);
							t = v(t, D);
							h = m(h, C);
							q = m(q, D);
							if (l && 2 < z.length) {
								const J = z[2];
								u = v(u, J);
								x = m(x, J)
							}
							r && z.length > p && (w = z[p], y = v(u, w), w = m(x, w))
						}
					}
					if (l) {
						if (r) return f[0] = n, f[1] = t, f[2] = u, f[3] = y, f[4] = h, f[5] = q, f[6] = x, f[7] = w, f.length = 8, f;
						f[0] = n;
						f[1] = t;
						f[2] = u;
						f[3] = h;
						f[4] = q;
						f[5] = x;
						f.length = 6;
						return f
					}
					if (r) return f[0] = n, f[1] = t, f[2] = y, f[3] =
						h, f[4] = q, f[5] = w, f.length = 6, f;
					f[0] = n;
					f[1] = t;
					f[2] = h;
					f[3] = q;
					f.length = 4;
					return f
				}

				function d(f, g, l, r, p, n) {
					l = g.xmin;
					r = g.xmax;
					const t = g.ymin,
						h = g.ymax;
					let q = g.zmin,
						u = g.zmax,
						x = g.mmin;
					g = g.mmax;
					if (p) {
						q = q || 0;
						u = u || 0;
						if (n) return f[0] = l, f[1] = t, f[2] = q, f[3] = x || 0, f[4] = r, f[5] = h, f[6] = u, f[7] = g || 0, f;
						f[0] = l;
						f[1] = t;
						f[2] = q;
						f[3] = r;
						f[4] = h;
						f[5] = u;
						return f
					}
					if (n) return f[0] = l, f[1] = t, f[2] = x || 0, f[3] = r, f[4] = h, f[5] = g || 0, f;
					f[0] = l;
					f[1] = t;
					f[2] = r;
					f[3] = h;
					return f
				}

				function k(f, g, l, r, p, n) {
					const t = l ? 3 : 2;
					r = r && n;
					l = l && p;
					if (!g.length || !g[0].length) return null;
					let [h, q] = g[0], [u, x] = g[0], y = void 0, w = void 0, A = void 0;
					var B = void 0;
					for (let E = 0; E < g.length; E++) {
						const z = g[E],
							[C, D] = z;
						h = v(h, C);
						q = v(q, D);
						u = m(u, C);
						x = m(x, D);
						if (l && 2 < z.length) {
							const J = z[2];
							y = v(y, J);
							w = m(w, J)
						}
						r && z.length > t && (B = z[t], A = v(y, B), B = m(w, B))
					}
					if (p) {
						y = y || 0;
						w = w || 0;
						if (n) return f[0] = h, f[1] = q, f[2] = y, f[3] = A || 0, f[4] = u, f[5] = x, f[6] = w, f[7] = B || 0, f;
						f[0] = h;
						f[1] = q;
						f[2] = y;
						f[3] = u;
						f[4] = x;
						f[5] = w;
						return f
					}
					if (n) return f[0] = h, f[1] = q, f[2] = A || 0, f[3] = u, f[4] = x, f[5] = B || 0, f;
					f[0] = h;
					f[1] = q;
					f[2] = u;
					f[3] = x;
					return f
				}
				const v = c(Math.min),
					m = c(Math.max);
				a.getBoundsXY = function(f, g) {
					if (void 0 !== g.paths) return e(f, g.paths, !1, !1);
					if (void 0 !== g.rings) return e(f, g.rings, !1, !1);
					if (void 0 !== g.points) return k(f, g.points, !1, !1, !1, !1);
					if (b(g)) return d(f, g);
					void 0 !== g.x && void 0 !== g.y && (f[0] = g.x, f[1] = g.y, f[2] = g.x, f[3] = g.y);
					return f
				};
				a.getBoundsXYZ = function(f, g) {
					if (void 0 !== g.paths) return e(f, g.paths, !0, !1);
					if (void 0 !== g.rings) return e(f, g.rings, !0, !1);
					if (void 0 !== g.points) return k(f, g.points, !0, !1, !0, !1);
					if (b(g)) return d(f, g, !0, !1, !0, !1);
					void 0 !==
						g.x && void 0 !== g.y && (f[0] = g.x, f[1] = g.y, f[2] = g.z, f[3] = g.x, f[4] = g.y, f[5] = g.z);
					return f
				};
				a.getExtentBounds = d;
				a.getPointsBounds = k;
				a.getPointsBoundsCenterX = function(f) {
					if (!f.length || !f[0].length) return null;
					let [g] = f[0], [l] = f[0];
					for (let r = 0; r < f.length; r++) {
						const [p] = f[r];
						g = v(g, p);
						l = m(l, p)
					}
					return g + .5 * (l - g)
				};
				a.getPointsBoundsWidth = function(f) {
					if (!f.length || !f[0].length) return null;
					let [g] = f[0], [l] = f[0];
					for (let r = 0; r < f.length; r++) {
						const [p] = f[r];
						g = v(g, p);
						l = m(l, p)
					}
					return l - g
				};
				a.getRingsOrPathsBounds = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/Polyline": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./Extent ./Geometry ./Point ./SpatialReference ./support/extentUtils ./support/zmUtils".split(" "), function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
				var n;
				d = n = function(t) {
					function h(...u) {
						u =
							t.call(this, ...u) || this;
						u.paths = [];
						u.type = "polyline";
						return u
					}
					a._inheritsLoose(h, t);
					var q = h.prototype;
					q.normalizeCtorArgs = function(u, x) {
						let y = null,
							w, A, B = null;
						u && !Array.isArray(u) ? (y = u.paths ? u.paths : null, x || (u.spatialReference ? x = u.spatialReference : u.paths || (x = u)), w = u.hasZ, A = u.hasM) : y = u;
						y = y || [];
						x = x || l.WGS84;
						y.length && y[0] && null != y[0][0] && "number" === typeof y[0][0] && (y = [y]);
						if (B = y[0] && y[0][0]) void 0 === w && void 0 === A ? (w = 2 < B.length, A = !1) : void 0 === w ? w = !A && 3 < B.length : void 0 === A && (A = !w && 3 < B.length);
						return {
							paths: y,
							spatialReference: x,
							hasZ: w,
							hasM: A
						}
					};
					q.writePaths = function(u, x) {
						x.paths = c.clone(this.paths)
					};
					q.addPath = function(u) {
						if (u) {
							var x = this.paths,
								y = x.length;
							if (Array.isArray(u[0])) x[y] = u.concat();
							else {
								const w = [];
								for (let A = 0, B = u.length; A < B; A++) w[A] = u[A].toArray();
								x[y] = w
							}
							this.notifyChange("paths");
							return this
						}
					};
					q.clone = function() {
						const u = new n;
						u.spatialReference = this.spatialReference;
						u.paths = c.clone(this.paths);
						u.hasZ = this.hasZ;
						u.hasM = this.hasM;
						return u
					};
					q.getPoint = function(u, x) {
						if (!this._validateInputs(u, x)) return null;
						u = this.paths[u][x];
						x = this.hasZ;
						const y = this.hasM;
						return x && !y ? new g(u[0], u[1], u[2], void 0, this.spatialReference) : y && !x ? new g(u[0], u[1], void 0, u[2], this.spatialReference) : x && y ? new g(u[0], u[1], u[2], u[3], this.spatialReference) : new g(u[0], u[1], this.spatialReference)
					};
					q.insertPoint = function(u, x, y) {
						if (!this._validateInputs(u, x, !0)) return this;
						p.updateSupportFromPoint(this, y);
						Array.isArray(y) || (y = y.toArray());
						this.paths[u].splice(x, 0, y);
						this.notifyChange("paths");
						return this
					};
					q.removePath = function(u) {
						if (!this._validateInputs(u,
							null)) return null;
						u = this.paths.splice(u, 1)[0];
						const x = this.spatialReference;
						u = u.map(y => new g(y, x));
						this.notifyChange("paths");
						return u
					};
					q.removePoint = function(u, x) {
						if (!this._validateInputs(u, x)) return null;
						u = new g(this.paths[u].splice(x, 1)[0], this.spatialReference);
						this.notifyChange("paths");
						return u
					};
					q.setPoint = function(u, x, y) {
						if (!this._validateInputs(u, x)) return this;
						p.updateSupportFromPoint(this, y);
						Array.isArray(y) || (y = y.toArray());
						this.paths[u][x] = y;
						this.notifyChange("paths");
						return this
					};
					q._validateInputs =
						function(u, x, y = !1) {
							return null == u || 0 > u || u >= this.paths.length || null != x && (u = this.paths[u], y && (0 > x || x > u.length) || !y && (0 > x || x >= u.length)) ? !1 : !0
						};
					q.toJSON = function(u) {
						return this.write({}, u)
					};
					a._createClass(h, [{
						key: "cache",
						get: function() {
							this.commitProperty("paths");
							this.commitProperty("hasZ");
							this.commitProperty("hasM");
							this.commitProperty("spatialReference");
							return {}
						}
					}, {
						key: "extent",
						get: function() {
							const {
								spatialReference: u
							} = this;
							var x = r.getPolylineExtent(this);
							if (!x) return null;
							x = new m(x);
							x.spatialReference =
								u;
							return x
						}
					}]);
					return h
				}(f);
				b.__decorate([e.property({
					readOnly: !0
				})], d.prototype, "cache", null);
				b.__decorate([e.property({
					readOnly: !0
				})], d.prototype, "extent", null);
				b.__decorate([e.property({
					type: [
						[
							[Number]
						]
					],
					json: {
						write: {
							isRequired: !0
						}
					}
				})], d.prototype, "paths", void 0);
				b.__decorate([v.writer("paths")], d.prototype, "writePaths", null);
				d = n = b.__decorate([k.subclass("esri.geometry.Polyline")], d);
				d.prototype.toJSON.isDefaultToJSON = !0;
				return d
			})
		},
		"esri/geometry/support/typeUtils": function() {
			define(["exports",
				"../../core/jsonMap"
			], function(a, b) {
				const c = b.strict()({
					esriGeometryPoint: "point",
					esriGeometryMultipoint: "multipoint",
					esriGeometryPolyline: "polyline",
					esriGeometryPolygon: "polygon"
				});
				b = b.strict()({
					esriGeometryPoint: "point",
					esriGeometryMultipoint: "multipoint",
					esriGeometryPolyline: "polyline",
					esriGeometryPolygon: "polygon",
					esriGeometryEnvelope: "extent",
					mesh: "mesh"
				});
				a.featureGeometryTypeKebabDictionary = c;
				a.isFeatureGeometryType = function(e) {
					return "point" === e || "multipoint" === e || "polyline" === e || "polygon" ===
						e
				};
				a.typeKebabDictionary = b;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/jsonUtils": function() {
			define("exports ../../core/maybe ../Extent ../Geometry ../Multipoint ../Point ../Polygon ../Polyline".split(" "), function(a, b, c, e, d, k, v, m) {
				function f(t) {
					return void 0 !== t.xmin && void 0 !== t.ymin && void 0 !== t.xmax && void 0 !== t.ymax
				}

				function g(t) {
					return void 0 !== t.points
				}

				function l(t) {
					return void 0 !== t.x && void 0 !== t.y
				}

				function r(t) {
					return void 0 !==
						t.paths
				}

				function p(t) {
					return void 0 !== t.rings
				}
				const n = {
					esriGeometryPoint: k,
					esriGeometryPolyline: m,
					esriGeometryPolygon: v,
					esriGeometryEnvelope: c,
					esriGeometryMultipoint: d
				};
				a.fromJSON = function(t) {
					return b.isNone(t) ? null : t instanceof e ? t : l(t) ? k.fromJSON(t) : r(t) ? m.fromJSON(t) : p(t) ? v.fromJSON(t) : g(t) ? d.fromJSON(t) : f(t) ? c.fromJSON(t) : null
				};
				a.getGeometryType = function(t) {
					return t && n[t] || null
				};
				a.getJsonType = function(t) {
					return t ? l(t) ? "esriGeometryPoint" : r(t) ? "esriGeometryPolyline" : p(t) ? "esriGeometryPolygon" :
						f(t) ? "esriGeometryEnvelope" : g(t) ? "esriGeometryMultipoint" : null : null
				};
				a.isExtent = f;
				a.isMesh = function(t) {
					return void 0 !== t.vertexAttributes
				};
				a.isMultipoint = g;
				a.isPoint = l;
				a.isPolygon = p;
				a.isPolyline = r;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/Identifiable": function() {
			define(["exports", "../chunks/_rollupPluginBabelHelpers", "../chunks/tslib.es6", "./accessorSupport/decorators/subclass"], function(a, b, c, e) {
				let d = 0;
				const k = v => {
					v = function(m) {
						function f(...g) {
							g =
								m.call(this, ...g) || this;
							Object.defineProperty(b._assertThisInitialized(g), "uid", {
								writable: !1,
								configurable: !1,
								value: Date.now()
									.toString(16) + "-object-" + d++
							});
							return g
						}
						b._inheritsLoose(f, m);
						return f
					}(v);
					return v = c.__decorate([e.subclass("esri.core.Identifiable")], v)
				};
				a.Identifiable = function(v) {
					function m() {
						return v.apply(this, arguments) || this
					}
					b._inheritsLoose(m, v);
					return m
				}(k(function() {
					return function() {}
				}()));
				a.Identifiable = c.__decorate([e.subclass("esri.core.Identifiable")], a.Identifiable);
				a.IdentifiableMixin =
					k;
				a.NumericIdentifiableMixin = v => {
					v = function(m) {
						function f(...g) {
							g = m.call(this, ...g) || this;
							Object.defineProperty(b._assertThisInitialized(g), "uid", {
								writable: !1,
								configurable: !1,
								value: d++
							});
							return g
						}
						b._inheritsLoose(f, m);
						return f
					}(v);
					return v = c.__decorate([e.subclass("esri.core.NumericIdentifiable")], v)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/fromPortalItem": function() {
			define(["require", "exports", "../../chunks/_rollupPluginBabelHelpers",
				"../../config", "../../core/Logger"
			], function(a, b, c, e, d) {
				function k() {
					k = c._asyncToGenerator(function*(v) {
						v = "portalItem" in v ? v : {
							portalItem: v
						};
						var m = yield new Promise((f, g) => a(["../../portal/support/portalLayers"], f, g));
						try {
							return yield m.fromItem(v)
						} catch (f) {
							throw v = (m = v && v.portalItem) && m.id || "unset", m = m && m.portal && m.portal.url || e.portalUrl, d.getLogger("esri.layers.support.fromPortalItem")
								.error("#fromPortalItem()", "Failed to create layer from portal item (portal: '" + m + "', id: '" + v + "')", f), f;
						}
					});
					return k.apply(this,
						arguments)
				}
				b.fromPortalItem = function(v) {
					return k.apply(this, arguments)
				};
				Object.defineProperties(b, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/TablesMixin": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Collection ../core/collectionUtils ../core/Logger ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c,
				e, d, k, v, m, f, g) {
				function l(r, p, n) {
					if (r)
						for (let h = 0, q = r.length; h < q; h++) {
							var t = r.getItemAt(h);
							if (t[p] === n || "group" === t ? .type && (t = l(t.tables, p, n))) return t
						}
				}
				a.TablesMixin = r => {
					r = function(p) {
						function n(...h) {
							var q = p.call(this, ...h) || this;
							q.tables = new e;
							q.tables.on("after-add", u => {
								u = u.item;
								u.parent && u.parent !== b._assertThisInitialized(q) && "tables" in u.parent && u.parent.tables.remove(u);
								u.parent = b._assertThisInitialized(q);
								"feature" !== u.type && k.getLogger(q.declaredClass)
									.error(`Layer 'title:${u.title}, id:${u.id}' of type '${u.type}' is not supported as a table and will therefore be ignored.`)
							});
							q.tables.on("after-remove", u => {
								u.item.parent = null
							});
							return q
						}
						b._inheritsLoose(n, p);
						var t = n.prototype;
						t.destroy = function() {
							const h = this.tables.removeAll();
							for (const q of h) q.destroy();
							this.tables.destroy()
						};
						t.findTableById = function(h) {
							return l(this.tables, "id", h)
						};
						t.findTableByUid = function(h) {
							return l(this.tables, "uid", h)
						};
						b._createClass(n, [{
							key: "tables",
							set: function(h) {
								this._set("tables", d.referenceSetter(h, this._get("tables")))
							}
						}]);
						return n
					}(r);
					c.__decorate([v.property()], r.prototype, "tables", null);
					return r = c.__decorate([g.subclass("esri.support.TablesMixin")], r)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/Viewpoint": function() {
			define("./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./Camera ./geometry ./core/JSONSupport ./core/maybe ./core/accessorSupport/decorators/property ./core/arrayUtils ./core/accessorSupport/decorators/cast ./core/accessorSupport/decorators/subclass ./geometry/support/jsonUtils".split(" "), function(a, b, c, e,
				d, k, v, m, f, g, l) {
				function r() {
					return {
						enabled: !this.camera
					}
				}
				var p;
				d = p = function(n) {
					function t(q) {
						q = n.call(this, q) || this;
						q.rotation = 0;
						q.scale = 0;
						q.targetGeometry = null;
						q.camera = null;
						return q
					}
					a._inheritsLoose(t, n);
					var h = t.prototype;
					h.castRotation = function(q) {
						q %= 360;
						0 > q && (q += 360);
						return q
					};
					h.clone = function() {
						return new p({
							rotation: this.rotation,
							scale: this.scale,
							targetGeometry: k.isSome(this.targetGeometry) ? this.targetGeometry.clone() : null,
							camera: k.isSome(this.camera) ? this.camera.clone() : null
						})
					};
					return t
				}(d.JSONSupport);
				b.__decorate([v.property({
					type: Number,
					json: {
						write: !0,
						origins: {
							"web-map": {
								default: 0,
								write: !0
							},
							"web-scene": {
								write: {
									overridePolicy: r
								}
							}
						}
					}
				})], d.prototype, "rotation", void 0);
				b.__decorate([f.cast("rotation")], d.prototype, "castRotation", null);
				b.__decorate([v.property({
					type: Number,
					json: {
						write: !0,
						origins: {
							"web-map": {
								default: 0,
								write: !0
							},
							"web-scene": {
								write: {
									overridePolicy: r
								}
							}
						}
					}
				})], d.prototype, "scale", void 0);
				b.__decorate([v.property({
					types: e.geometryTypes,
					json: {
						read: l.fromJSON,
						write: !0,
						origins: {
							"web-scene": {
								read: l.fromJSON,
								write: {
									overridePolicy: r
								}
							}
						}
					}
				})], d.prototype, "targetGeometry", void 0);
				b.__decorate([v.property({
					type: c,
					json: {
						write: !0
					}
				})], d.prototype, "camera", void 0);
				return d = p = b.__decorate([g.subclass("esri.Viewpoint")], d)
			})
		},
		"esri/Camera": function() {
			define("./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./core/Clonable ./core/Cyclical ./core/JSONSupport ./core/mathUtils ./core/maybe ./core/accessorSupport/decorators/property ./core/arrayUtils ./core/accessorSupport/decorators/cast ./core/accessorSupport/decorators/reader ./core/accessorSupport/decorators/subclass ./core/accessorSupport/decorators/writer ./core/accessorSupport/ensureType ./geometry/Point".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					c = function(h) {
						function q(...x) {
							x = h.call(this, ...x) || this;
							x.position = new t([0, 0, 0]);
							x.heading = 0;
							x.tilt = 0;
							x.fov = 55;
							return x
						}
						a._inheritsLoose(q, h);
						var u = q.prototype;
						u.normalizeCtorArgs = function(x, y, w, A) {
							return x && "object" === typeof x && ("x" in x || Array.isArray(x)) ? (x = {
								position: x
							}, null != y && (x.heading = y), null != w && (x.tilt = w), null != A && (x.fov = A), x) : x
						};
						u.writePosition = function(x, y, w, A) {
							const B = x.clone();
							B.x = n.ensureNumber(x.x || 0);
							B.y = n.ensureNumber(x.y || 0);
							B.z = x.hasZ ? n.ensureNumber(x.z ||
								0) : x.z;
							y[w] = B.write({}, A)
						};
						u.readPosition = function(x, y) {
							const w = new t;
							w.read(x, y);
							w.x = n.ensureNumber(w.x || 0);
							w.y = n.ensureNumber(w.y || 0);
							w.z = w.hasZ ? n.ensureNumber(w.z || 0) : w.z;
							return w
						};
						u.equals = function(x) {
							return v.isNone(x) ? !1 : this.tilt === x.tilt && this.heading === x.heading && this.fov === x.fov && this.position.equals(x.position)
						};
						return q
					}(c.ClonableMixin(d.JSONSupport));
					b.__decorate([m.property({
						type: t,
						json: {
							write: {
								isRequired: !0
							}
						}
					})], c.prototype, "position", void 0);
					b.__decorate([p.writer("position")], c.prototype,
						"writePosition", null);
					b.__decorate([l.reader("position")], c.prototype, "readPosition", null);
					b.__decorate([m.property({
						type: Number,
						nonNullable: !0,
						json: {
							write: {
								isRequired: !0
							}
						}
					}), g.cast(h => e.cyclicalDegrees.normalize(n.ensureNumber(h)))], c.prototype, "heading", void 0);
					b.__decorate([m.property({
						type: Number,
						nonNullable: !0,
						json: {
							write: {
								isRequired: !0
							}
						}
					}), g.cast(h => k.clamp(n.ensureNumber(h), -180, 180))], c.prototype, "tilt", void 0);
					b.__decorate([m.property({
							type: Number,
							nonNullable: !0,
							json: {
								read: !1,
								write: !1
							}
						})],
						c.prototype, "fov", void 0);
					return c = b.__decorate([r.subclass("esri.Camera")], c)
				})
		},
		"esri/core/Clonable": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Accessor ./has ./lang ./Logger ./maybe ./accessorSupport/PropertyOrigin ./accessorSupport/utils ./accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m, f, g, l) {
				d = r => {
					r = function(p) {
						function n() {
							return p.apply(this, arguments) || this
						}
						b._inheritsLoose(n, p);
						n.prototype.clone = function() {
							var t = m.unwrapOrThrow(g.getProperties(this),
									"unable to clone instance of non-accessor class"),
								h = t.metadatas;
							const q = t.store,
								u = {};
							t = new Map;
							for (var x in h) {
								var y = h[x];
								const w = q ? .originOf(x),
									A = y.clonable;
								if (y.readOnly || !1 === A || w !== f.OriginId.USER && w !== f.OriginId.DEFAULTS && w !== f.OriginId.WEB_MAP && w !== f.OriginId.WEB_SCENE) continue;
								y = this[x];
								let B = null;
								B = "function" === typeof A ? A(y) : "reference" === A ? y : k.tryClone(y);
								if (null == y || null != B) w === f.OriginId.DEFAULTS ? t.set(x, B) : u[x] = B
							}
							h = new(Object.getPrototypeOf(this)
								.constructor)(u);
							if (t.size && (x = g.getProperties(h) ? .store))
								for (const [w,
									A
								] of t) x.set(w, A, f.OriginId.DEFAULTS);
							return h
						};
						return n
					}(r);
					return r = c.__decorate([l.subclass("esri.core.Clonable")], r)
				};
				a.Clonable = function(r) {
					function p() {
						return r.apply(this, arguments) || this
					}
					b._inheritsLoose(p, r);
					return p
				}(d(e));
				a.Clonable = c.__decorate([l.subclass("esri.core.Clonable")], a.Clonable);
				a.ClonableMixin = d;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/Cyclical": function() {
			define(["exports", "./mathUtils"], function(a, b) {
				function c(m) {
					for (const f in m) {
						const g =
							m[f];
						g instanceof Function && (m[f] = g.bind(m))
					}
					return m
				}
				let e = function() {
					function m(g, l) {
						this.min = g;
						this.max = l;
						this.range = l - g
					}
					var f = m.prototype;
					f.ndiff = function(g, l = 0) {
						return Math.ceil((g - l) / this.range) * this.range + l
					};
					f._normalize = function(g, l, r, p = 0, n = !1) {
						r -= p;
						r < g ? r += this.ndiff(g - r) : r > l && (r -= this.ndiff(r - l));
						n && r === l && (r = g);
						return r + p
					};
					f.normalize = function(g, l = 0, r = !1) {
						return this._normalize(this.min, this.max, g, l, r)
					};
					f.clamp = function(g, l = 0) {
						return b.clamp(g - l, this.min, this.max) + l
					};
					f.monotonic = function(g,
						l, r) {
						return g < l ? l : l + this.ndiff(g - l, r)
					};
					f.minimalMonotonic = function(g, l, r) {
						return this._normalize(g, g + this.range, l, r)
					};
					f.center = function(g, l, r) {
						l = this.monotonic(g, l, r);
						return this.normalize((g + l) / 2, r)
					};
					f.diff = function(g, l, r) {
						return this.monotonic(g, l, r) - g
					};
					f.shortestSignedDiff = function(g, l) {
						g = this.normalize(g);
						l = this.normalize(l);
						const r = l - g;
						g = l < g ? this.minimalMonotonic(g, l) - g : l - this.minimalMonotonic(l, g);
						return Math.abs(r) < Math.abs(g) ? r : g
					};
					f.contains = function(g, l, r) {
						l = this.minimalMonotonic(g, l);
						r =
							this.minimalMonotonic(g, r);
						return r > g && r < l
					};
					return m
				}();
				const d = c(new e(0, 2 * Math.PI)),
					k = c(new e(-Math.PI, Math.PI)),
					v = c(new e(0, 360));
				a.Cyclical = e;
				a.cyclical2PI = d;
				a.cyclicalDegrees = v;
				a.cyclicalPI = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/mixins/OperationalLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Error ../../core/urlUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../core/accessorSupport/read ../../core/accessorSupport/write ./operationalLayers ../support/commonProperties".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					a.OperationalLayer = t => {
						t = function(h) {
							function q() {
								var x = h.apply(this, arguments) || this;
								x.title = null;
								return x
							}
							b._inheritsLoose(q, h);
							var u = q.prototype;
							u.writeListMode = function(x, y, w, A) {
								A && "ground" === A.layerContainerType ? y[w] = x : x && r.willPropertyWrite(this, w, {}, A) && (y[w] = x)
							};
							u.writeOperationalLayerType = function(x, y, w, A) {
								!x || A && "tables" === A.layerContainerType || (y.layerType = x)
							};
							u.writeTitle = function(x, y) {
								y.title = x ? ? "Layer"
							};
							u.read = function(x, y) {
								y && (y.layer = this);
								l.readLoadable(this,
									x, w => h.prototype.read.call(this, x, w), y)
							};
							u.write = function(x, y) {
								if (y ? .origin) {
									var w = `${y.origin}/${y.layerContainerType||"operational-layers"}`,
										A = p.supportedTypes[w];
									A = A && A[this.operationalLayerType];
									"ArcGISTiledElevationServiceLayer" === this.operationalLayerType && "web-scene/operational-layers" === w && (A = !1);
									"ArcGISDimensionLayer" === this.operationalLayerType && "web-map/operational-layers" === w && (A = !1);
									if (!A) return y.messages ? .push(new e("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${w}'`, {
										layer: this
									})), null
								}
								x = h.prototype.write.call(this, x, {
									...y,
									layer: this
								});
								w = !!y && !!y.messages && !!y.messages.filter(B => B instanceof e && "web-document-write:property-required" === B.name)
									.length;
								return d.isBlobProtocol(x ? .url) ? (y ? .messages ? .push(new e("layer:invalid-url", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' using a Blob URL cannot be written to web scenes and web maps`, {
									layer: this
								})), null) : !this.url && w ? null : x
							};
							u.beforeSave = function() {};
							return q
						}(t);
						c.__decorate([k.property({
							type: String,
							json: {
								write: {
									ignoreOrigin: !0
								},
								origins: {
									"web-scene": {
										write: {
											isRequired: !0,
											ignoreOrigin: !0
										}
									},
									"portal-item": {
										write: !1
									}
								}
							}
						})], t.prototype, "id", void 0);
						c.__decorate([k.property(n.listMode)], t.prototype, "listMode", void 0);
						c.__decorate([g.writer("listMode")], t.prototype, "writeListMode", null);
						c.__decorate([k.property({
							type: String,
							readOnly: !0,
							json: {
								read: !1,
								write: {
									target: "layerType",
									ignoreOrigin: !0
								},
								origins: {
									"portal-item": {
										write: !1
									}
								}
							}
						})], t.prototype, "operationalLayerType", void 0);
						c.__decorate([g.writer("operationalLayerType")],
							t.prototype, "writeOperationalLayerType", null);
						c.__decorate([k.property(n.opacity)], t.prototype, "opacity", void 0);
						c.__decorate([k.property({
							type: String,
							json: {
								write: {
									ignoreOrigin: !0,
									writerEnsuresNonNull: !0
								},
								origins: {
									"web-scene": {
										write: {
											isRequired: !0,
											ignoreOrigin: !0,
											writerEnsuresNonNull: !0
										}
									},
									"portal-item": {
										write: !1
									}
								}
							},
							value: "Layer"
						})], t.prototype, "title", void 0);
						c.__decorate([g.writer("title"), g.writer(["web-scene"], "title")], t.prototype, "writeTitle", null);
						c.__decorate([k.property({
								type: Boolean,
								json: {
									name: "visibility"
								}
							})],
							t.prototype, "visible", void 0);
						return t = c.__decorate([f.subclass("esri.layers.mixins.OperationalLayer")], t)
					};
					a.isOperationalLayer = function(t) {
						return "operationalLayerType" in t
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/mixins/operationalLayers": function() {
			define(["exports"], function(a) {
				a.supportedTypes = {
					"web-scene/operational-layers": {
						ArcGISDimensionLayer: !0,
						ArcGISFeatureLayer: !0,
						ArcGISImageServiceLayer: !0,
						ArcGISMapServiceLayer: !0,
						ArcGISSceneServiceLayer: !0,
						ArcGISTiledElevationServiceLayer: !0,
						ArcGISTiledImageServiceLayer: !0,
						ArcGISTiledMapServiceLayer: !0,
						BuildingSceneLayer: !0,
						GroupLayer: !0,
						IntegratedMeshLayer: !0,
						OGCFeatureLayer: !0,
						PointCloudLayer: !0,
						WebTiledLayer: !0,
						CSV: !0,
						GeoJSON: !0,
						VectorTileLayer: !0,
						WFS: !0,
						WMS: !0,
						KML: !0,
						RasterDataLayer: !0,
						Voxel: !0,
						LineOfSightLayer: !0
					},
					"web-scene/basemap": {
						ArcGISTiledImageServiceLayer: !0,
						ArcGISTiledMapServiceLayer: !0,
						WebTiledLayer: !0,
						OpenStreetMap: !0,
						VectorTileLayer: !0,
						ArcGISImageServiceLayer: !0,
						WMS: !0,
						ArcGISMapServiceLayer: !0
					},
					"web-scene/ground": {
						ArcGISTiledElevationServiceLayer: !0,
						RasterDataElevationLayer: !0
					},
					"web-map/operational-layers": {
						ArcGISAnnotationLayer: !0,
						ArcGISDimensionLayer: !0,
						ArcGISFeatureLayer: !0,
						ArcGISImageServiceLayer: !0,
						ArcGISImageServiceVectorLayer: !0,
						ArcGISMapServiceLayer: !0,
						ArcGISStreamLayer: !0,
						ArcGISTiledImageServiceLayer: !0,
						ArcGISTiledMapServiceLayer: !0,
						BingMapsAerial: !0,
						BingMapsHybrid: !0,
						BingMapsRoad: !0,
						CSV: !0,
						GeoRSS: !0,
						GeoJSON: !0,
						GroupLayer: !0,
						KML: !0,
						OGCFeatureLayer: !0,
						OrientedImageryLayer: !0,
						SubtypeGroupLayer: !0,
						VectorTileLayer: !0,
						WFS: !0,
						WMS: !0,
						WebTiledLayer: !0
					},
					"web-map/basemap": {
						ArcGISImageServiceLayer: !0,
						ArcGISImageServiceVectorLayer: !0,
						ArcGISMapServiceLayer: !0,
						ArcGISTiledImageServiceLayer: !0,
						ArcGISTiledMapServiceLayer: !0,
						OpenStreetMap: !0,
						VectorTileLayer: !0,
						WMS: !0,
						WebTiledLayer: !0,
						BingMapsAerial: !0,
						BingMapsRoad: !0,
						BingMapsHybrid: !0
					},
					"web-map/tables": {
						ArcGISFeatureLayer: !0
					},
					"portal-item/operational-layers": {
						ArcGISFeatureLayer: !0,
						ArcGISSceneServiceLayer: !0,
						PointCloudLayer: !0,
						BuildingSceneLayer: !0,
						IntegratedMeshLayer: !0,
						OrientedImageryLayer: !0
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/commonProperties": function() {
			define("exports ../../TimeExtent ../../geometry/Extent ../../geometry/SpatialReference ../../chunks/persistableUrlUtils ../../support/timeUtils ../../symbols/support/ElevationInfo ../../webdoc/support/opacityUtils".split(" "), function(a, b, c, e, d, k, v, m) {
				const f = {
						type: Boolean,
						value: !0,
						json: {
							origins: {
								service: {
									read: !1,
									write: !1
								},
								"web-map": {
									read: !1,
									write: !1
								}
							},
							name: "screenSizePerspective",
							write: !0
						}
					},
					g = {
						type: Boolean,
						value: !0,
						json: {
							name: "disablePopup",
							read: {
								reader(x, y) {
									return !y.disablePopup
								}
							},
							write: {
								enabled: !0,
								writer(x, y, w) {
									y[w] = !x
								}
							}
						}
					},
					l = {
						type: Boolean,
						value: !0,
						nonNullable: !0,
						json: {
							name: "showLabels",
							write: !0
						}
					};
				d = {
					type: String,
					json: {
						origins: {
							"portal-item": {
								write: !1
							}
						},
						write: {
							isRequired: !0,
							ignoreOrigin: !0,
							writer: d.write
						}
					}
				};
				const r = {
					type: Boolean,
					value: !0,
					nonNullable: !0,
					json: {
						origins: {
							service: {
								read: {
									enabled: !1
								}
							}
						},
						name: "showLegend",
						write: !0
					}
				};
				v = {
					value: null,
					type: v,
					json: {
						origins: {
							service: {
								name: "elevationInfo",
								write: !0
							}
						},
						name: "layerDefinition.elevationInfo",
						write: !0
					}
				};
				const p = {
						type: Number,
						json: {
							origins: {
								"web-document": {
									write: !0,
									read: !0
								},
								"portal-item": {
									write: !0
								}
							}
						}
					},
					n = {
						...p,
						json: {
							...p.json,
							origins: {
								"web-document": {
									...p.json.origins["web-document"],
									write: {
										enabled: !0,
										target: {
											opacity: {
												type: Number
											},
											"layerDefinition.drawingInfo.transparency": {
												type: Number
											}
										}
									}
								}
							},
							read: {
								source: ["layerDefinition.drawingInfo.transparency", "drawingInfo.transparency"],
								reader(x, y, w) {
									if ((!w ||
										"service" === w.origin) && y.drawingInfo && void 0 !== y.drawingInfo.transparency) return m.transparencyToOpacity(y.drawingInfo.transparency);
									if (y.layerDefinition && y.layerDefinition.drawingInfo && void 0 !== y.layerDefinition.drawingInfo.transparency) return m.transparencyToOpacity(y.layerDefinition.drawingInfo.transparency)
								}
							}
						}
					},
					t = {
						type: c,
						readOnly: !0,
						json: {
							origins: {
								service: {
									read: {
										source: ["fullExtent", "spatialReference"],
										reader: (x, y) => {
											x = c.fromJSON(x);
											null != y.spatialReference && "object" === typeof y.spatialReference &&
												(x.spatialReference = e.fromJSON(y.spatialReference));
											return x
										}
									}
								}
							},
							read: !1
						}
					},
					h = {
						type: String,
						json: {
							origins: {
								service: {
									read: !1
								},
								"portal-item": {
									read: !1
								}
							}
						}
					},
					q = {
						type: Number,
						json: {
							origins: {
								service: {
									write: {
										enabled: !1
									}
								}
							},
							read: {
								source: "layerDefinition.minScale"
							},
							write: {
								target: "layerDefinition.minScale"
							}
						}
					},
					u = {
						type: Number,
						json: {
							origins: {
								service: {
									write: {
										enabled: !1
									}
								}
							},
							read: {
								source: "layerDefinition.maxScale"
							},
							write: {
								target: "layerDefinition.maxScale"
							}
						}
					};
				a.combinedViewLayerTimeExtentProperty = {
					type: b,
					readOnly: !0,
					get() {
						if (!this.layer ? .timeInfo) return null;
						const {
							datesInUnknownTimezone: x,
							timeOffset: y,
							useViewTime: w
						} = this.layer;
						var A = this.view ? .timeExtent,
							B = this.layer.timeExtent;
						x && (B = k.toLocalTimeExtent(B));
						A = w ? A && B ? A.intersection(B) : A || B : B;
						if (!A || A.isEmpty || A.isAllTime) return A;
						y && (A = A.offset(-y.value, y.unit));
						x && (A = k.toUTCTimeExtent(A));
						B = this._get("timeExtent");
						return A.equals(B) ? B : A
					}
				};
				a.elevationInfo = v;
				a.id = h;
				a.labelsVisible = l;
				a.legendEnabled = r;
				a.listMode = {
					json: {
						write: {
							ignoreOrigin: !0
						},
						origins: {
							"web-map": {
								read: !1,
								write: !1
							}
						}
					}
				};
				a.maxScale = u;
				a.minScale =
					q;
				a.opacity = p;
				a.opacityDrawingInfo = n;
				a.popupEnabled = g;
				a.readOnlyService = function(x) {
					return {
						type: x,
						readOnly: !0,
						json: {
							origins: {
								service: {
									read: !0
								}
							},
							read: !1
						}
					}
				};
				a.sceneLayerFullExtent = t;
				a.screenSizePerspectiveEnabled = f;
				a.url = d;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/TimeExtent": function() {
			define("./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./core/JSONSupport ./core/maybe ./core/timeUtils ./core/accessorSupport/decorators/property ./core/arrayUtils ./core/accessorSupport/ensureType ./core/accessorSupport/decorators/reader ./core/accessorSupport/decorators/subclass ./core/accessorSupport/decorators/writer".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					c = r = function(t) {
						function h(u) {
							u = t.call(this, u) || this;
							u.end = null;
							u.start = null;
							return u
						}
						a._inheritsLoose(h, t);
						var q = h.prototype;
						q.readEnd = function(u, x) {
							return null != x.end ? new Date(x.end) : null
						};
						q.writeEnd = function(u, x) {
							x.end = u ? u.getTime() : null
						};
						q.readStart = function(u, x) {
							return null != x.start ? new Date(x.start) : null
						};
						q.writeStart = function(u, x) {
							x.start = u ? u.getTime() : null
						};
						q.clone = function() {
							return new r({
								end: this.end,
								start: this.start
							})
						};
						q.equals = function(u) {
							if (!u) return !1;
							const x = e.isSome(this.start) ? this.start.getTime() : this.start,
								y = e.isSome(this.end) ? this.end.getTime() : this.end,
								w = e.isSome(u.start) ? u.start.getTime() : u.start;
							u = e.isSome(u.end) ? u.end.getTime() : u.end;
							return x === w && y === u
						};
						q.expandTo = function(u) {
							if (this.isEmpty || this.isAllTime) return this.clone();
							const x = e.applySome(this.start, w => d.truncateDate(w, u)),
								y = e.applySome(this.end, w => {
									const A = d.truncateDate(w, u);
									return w.getTime() === A.getTime() ? A : d.offsetDate(A, 1, u)
								});
							return new r({
								start: x,
								end: y
							})
						};
						q.intersection =
							function(u) {
								if (!u) return this.clone();
								if (this.isEmpty || u.isEmpty) return r.empty;
								if (this.isAllTime) return u.clone();
								if (u.isAllTime) return this.clone();
								var x = e.mapOr(this.start, -Infinity, E => E.getTime());
								const y = e.mapOr(this.end, Infinity, E => E.getTime()),
									w = e.mapOr(u.start, -Infinity, E => E.getTime());
								u = e.mapOr(u.end, Infinity, E => E.getTime());
								let A, B;
								w >= x && w <= y ? A = w : x >= w && x <= u && (A = x);
								y >= w && y <= u ? B = y : u >= x && u <= y && (B = u);
								return null == A || null == B || isNaN(A) || isNaN(B) ? r.empty : (x = new r, x.start = -Infinity === A ? null : new Date(A),
									x.end = Infinity === B ? null : new Date(B), x)
							};
						q.offset = function(u, x) {
							if (this.isEmpty || this.isAllTime) return this.clone();
							const y = new r,
								{
									start: w,
									end: A
								} = this;
							e.isSome(w) && (y.start = d.offsetDate(w, u, x));
							e.isSome(A) && (y.end = d.offsetDate(A, u, x));
							return y
						};
						q.union = function(u) {
							if (!u || u.isEmpty) return this.clone();
							if (this.isEmpty) return u.clone();
							if (this.isAllTime || u.isAllTime) return p.clone();
							const x = e.isSome(this.start) && e.isSome(u.start) ? new Date(Math.min(this.start.getTime(), u.start.getTime())) : null;
							u = e.isSome(this.end) &&
								e.isSome(u.end) ? new Date(Math.max(this.end.getTime(), u.end.getTime())) : null;
							return new r({
								start: x,
								end: u
							})
						};
						a._createClass(h, [{
							key: "isAllTime",
							get: function() {
								return this.equals(r.allTime)
							}
						}, {
							key: "isEmpty",
							get: function() {
								return this.equals(r.empty)
							}
						}], [{
							key: "allTime",
							get: function() {
								return p
							}
						}, {
							key: "empty",
							get: function() {
								return n
							}
						}]);
						return h
					}(c.JSONSupport);
					b.__decorate([k.property({
						type: Date,
						json: {
							write: {
								allowNull: !0
							}
						}
					})], c.prototype, "end", void 0);
					b.__decorate([f.reader("end")], c.prototype, "readEnd",
						null);
					b.__decorate([l.writer("end")], c.prototype, "writeEnd", null);
					b.__decorate([k.property({
						readOnly: !0,
						json: {
							read: !1
						}
					})], c.prototype, "isAllTime", null);
					b.__decorate([k.property({
						readOnly: !0,
						json: {
							read: !1
						}
					})], c.prototype, "isEmpty", null);
					b.__decorate([k.property({
						type: Date,
						json: {
							write: {
								allowNull: !0
							}
						}
					})], c.prototype, "start", void 0);
					b.__decorate([f.reader("start")], c.prototype, "readStart", null);
					b.__decorate([l.writer("start")], c.prototype, "writeStart", null);
					c = r = b.__decorate([g.subclass("esri.TimeExtent")],
						c);
					const p = new c,
						n = new c({
							start: void 0,
							end: void 0
						});
					return c
				})
		},
		"esri/core/timeUtils": function() {
			define(["exports", "./has"], function(a, b) {
				function c(k, v, m) {
					return 0 === k ? 0 : k * e[v] / e[m]
				}
				const e = {
						milliseconds: 1,
						seconds: 1E3,
						minutes: 6E4,
						hours: 36E5,
						days: 864E5,
						weeks: 6048E5,
						months: 26784E5,
						years: 31536E6,
						decades: 31536E7,
						centuries: 31536E8
					},
					d = {
						milliseconds: {
							getter: "getMilliseconds",
							setter: "setMilliseconds",
							multiplier: 1
						},
						seconds: {
							getter: "getSeconds",
							setter: "setSeconds",
							multiplier: 1
						},
						minutes: {
							getter: "getMinutes",
							setter: "setMinutes",
							multiplier: 1
						},
						hours: {
							getter: "getHours",
							setter: "setHours",
							multiplier: 1
						},
						days: {
							getter: "getDate",
							setter: "setDate",
							multiplier: 1
						},
						weeks: {
							getter: "getDate",
							setter: "setDate",
							multiplier: 7
						},
						months: {
							getter: "getMonth",
							setter: "setMonth",
							multiplier: 1
						},
						years: {
							getter: "getFullYear",
							setter: "setFullYear",
							multiplier: 1
						},
						decades: {
							getter: "getFullYear",
							setter: "setFullYear",
							multiplier: 10
						},
						centuries: {
							getter: "getFullYear",
							setter: "setFullYear",
							multiplier: 100
						}
					};
				a.convertTime = c;
				a.makeUTCTime = function(k, v, m =
					"milliseconds") {
					v = new Date(c(v, m, "milliseconds"));
					v.setUTCFullYear(k.getUTCFullYear(), k.getUTCMonth(), k.getUTCDate());
					return v
				};
				a.offsetDate = function(k, v, m) {
					k = new Date(k.getTime());
					if (v && m) {
						const {
							getter: g,
							setter: l,
							multiplier: r
						} = d[m];
						if ("months" === m) {
							m = k.getFullYear();
							var f = k.getMonth() + v;
							m = new Date(m, f + 1, 1);
							m.setDate(0);
							m = m.getDate();
							k.getDate() > m && k.setDate(m)
						}
						k[l](k[g]() + v * r)
					}
					return k
				};
				a.offsetDateUTC = function(k, v, m = "milliseconds") {
					k = k.getTime();
					v = c(v, m, "milliseconds");
					return new Date(k + v)
				};
				a.resetUTCDate =
					function(k, v) {
						k = new Date(k.getTime());
						k.setUTCFullYear(v.getFullYear(), v.getMonth(), v.getDate());
						return k
					};
				a.timeSinceUTCMidnight = function(k, v = "milliseconds") {
					const m = c(k.getUTCHours(), "hours", "milliseconds"),
						f = c(k.getUTCMinutes(), "minutes", "milliseconds"),
						g = c(k.getUTCSeconds(), "seconds", "milliseconds");
					k = k.getUTCMilliseconds();
					return c(m + f + g + k, "milliseconds", v)
				};
				a.truncateDate = function(k, v) {
					switch (v) {
						case "milliseconds":
							return new Date(k.getTime());
						case "seconds":
							return new Date(k.getFullYear(),
								k.getMonth(), k.getDate(), k.getHours(), k.getMinutes(), k.getSeconds());
						case "minutes":
							return new Date(k.getFullYear(), k.getMonth(), k.getDate(), k.getHours(), k.getMinutes());
						case "hours":
							return new Date(k.getFullYear(), k.getMonth(), k.getDate(), k.getHours());
						case "days":
							return new Date(k.getFullYear(), k.getMonth(), k.getDate());
						case "weeks":
							return new Date(k.getFullYear(), k.getMonth(), k.getDate() - k.getDay());
						case "months":
							return new Date(k.getFullYear(), k.getMonth(), 1);
						case "years":
							return new Date(k.getFullYear(),
								0, 1);
						case "decades":
							return new Date(k.getFullYear() - k.getFullYear() % 10, 0, 1);
						case "centuries":
							return new Date(k.getFullYear() - k.getFullYear() % 100, 0, 1);
						default:
							return new Date
					}
				};
				a.truncateLocalTime = function(k) {
					const v = new Date(0);
					v.setHours(0);
					v.setMinutes(0);
					v.setSeconds(0);
					v.setMilliseconds(0);
					v.setFullYear(k.getUTCFullYear(), k.getUTCMonth(), k.getUTCDate());
					return v
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/chunks/persistableUrlUtils": function() {
			define(["exports",
				"../core/maybe", "../core/urlUtils"
			], function(a, b, c) {
				function e(t, h) {
					var q = h && h.url && h.url.path;
					t && q && (t = c.makeAbsolute(t, q, {
						preserveProtocolRelative: !0
					}), h.portalItem && h.readResourcePaths && (q = c.makeRelative(t, h.portalItem.itemUrl), null != q && p.test(q) && h.readResourcePaths.push(h.portalItem.resourceFromPath(q)
						.path)));
					return l(t, h && h.portal)
				}

				function d(t, h, q = a.MarkKeep.YES) {
					if (null == t) return t;
					!c.isAbsolute(t) && h && h.blockedRelativeUrls && h.blockedRelativeUrls.push(t);
					let u = c.makeAbsolute(t);
					if (h) {
						var x =
							h.verifyItemRelativeUrls && h.verifyItemRelativeUrls.rootPath || h.url && h.url.path;
						x && (x = l(x, h.portal), u = c.makeRelative(l(u, h.portal), x, x), null != u && u !== t && h.verifyItemRelativeUrls && h.verifyItemRelativeUrls.writtenUrls.push(u))
					}
					u = g(u, h ? .portal);
					c.isAbsolute(u) && (u = c.normalize(u));
					h ? .resources && h ? .portalItem && !c.isAbsolute(u) && !c.isDataProtocol(u) && q === a.MarkKeep.YES && h.resources.toKeep.push({
						resource: h.portalItem.resourceFromPath(u),
						compress: !1
					});
					return u
				}

				function k(t, h, q) {
					return e(t, q)
				}

				function v(t, h,
					q, u) {
					t = d(t, u);
					void 0 !== t && (h[q] = t)
				}

				function m(t) {
					return (t ? .match(r) ? ? null) ? . [1] ? ? null
				}

				function f(t) {
					t = t ? .match(r) ? ? null;
					if (null == t) return null;
					t = t[2];
					const h = t.lastIndexOf("/");
					if (-1 === h) {
						const {
							path: x,
							extension: y
						} = c.splitPathExtension(t);
						return {
							prefix: null,
							filename: x,
							extension: b.unwrap(y)
						}
					}
					const {
						path: q,
						extension: u
					} = c.splitPathExtension(t.slice(h + 1));
					return {
						prefix: t.slice(0, h),
						filename: q,
						extension: b.unwrap(u)
					}
				}

				function g(t, h) {
					return h && !h.isPortal && h.urlKey && h.customBaseUrl ? c.changeDomain(t, `${h.urlKey}.${h.customBaseUrl}`,
						h.portalHostname) : t
				}

				function l(t, h) {
					if (!h || h.isPortal || !h.urlKey || !h.customBaseUrl) return t;
					const q = `${h.urlKey}.${h.customBaseUrl}`,
						u = c.getAppUrl();
					return c.hasSameOrigin(u, `${u.scheme}://${q}`) ? c.changeDomain(t, h.portalHostname, q) : c.changeDomain(t, q, h.portalHostname)
				}
				const r = /\/items\/([^\/]+)\/resources\/(.*)/,
					p = /^\.\/resources\//;
				a.MarkKeep = void 0;
				(function(t) {
					t[t.YES = 0] = "YES";
					t[t.NO = 1] = "NO"
				})(a.MarkKeep || (a.MarkKeep = {}));
				const n = Object.freeze(Object.defineProperty({
					__proto__: null,
					fromJSON: e,
					toJSON: d,
					read: k,
					write: v,
					itemIdFromResourceUrl: m,
					prefixAndFilenameFromResourceUrl: f,
					ensureMainOnlineDomain: g,
					get MarkKeep() {
						return a.MarkKeep
					}
				}, Symbol.toStringTag, {
					value: "Module"
				}));
				a.ensureMainOnlineDomain = g;
				a.fromJSON = e;
				a.itemIdFromResourceUrl = m;
				a.persistableUrlUtils = n;
				a.prefixAndFilenameFromResourceUrl = f;
				a.read = k;
				a.toJSON = d;
				a.write = v
			})
		},
		"esri/support/timeUtils": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../TimeExtent ../core/maybe ../core/promiseUtils ../core/timeUtils".split(" "),
				function(a, b, c, e, d, k) {
					function v(f) {
						return void 0 !== f.timeInfo
					}

					function m() {
						m = b._asyncToGenerator(function*(f, g) {
							if (0 === f.length) return c.allTime;
							const l = f.filter(v);
							yield Promise.all(l.map(n => n.load({
								signal: g
							})));
							f = [];
							var r = [];
							for (var p of l) "feature" !== p ? .type && "map-image" !== p ? .type || !p.timeInfo.hasLiveData ? r.push(p) : f.push(p);
							p = n => e.isNone(n) || n.isAllTime;
							r = r.map(n => n.timeInfo.fullTimeExtent);
							if (r.some(p)) return c.allTime;
							f = f.map(function() {
								var n = b._asyncToGenerator(function*(t) {
									const {
										timeExtent: h
									} =
									yield t.fetchRecomputedExtents({
										signal: g
									});
									return h ? h : e.unwrap(t.timeInfo.fullTimeExtent)
								});
								return function(t) {
									return n.apply(this, arguments)
								}
							}());
							f = (yield d.eachAlways(f))
								.map(n => n.value);
							return f.some(p) ? c.allTime : f.concat(r)
								.reduce((n, t) => n.union(t))
						});
						return m.apply(this, arguments)
					}
					a.getTimeExtentFromLayers = function(f, g) {
						return m.apply(this, arguments)
					};
					a.toLocalTimeExtent = function(f) {
						if (!f) return f;
						const {
							start: g,
							end: l
						} = f;
						return new c({
							start: e.isSome(g) ? k.offsetDate(g, g.getTimezoneOffset(), "minutes") : g,
							end: e.isSome(l) ? k.offsetDate(l, l.getTimezoneOffset(), "minutes") : l
						})
					};
					a.toUTCTimeExtent = function(f) {
						if (!f) return f;
						const {
							start: g,
							end: l
						} = f;
						return new c({
							start: e.isSome(g) ? k.offsetDate(g, -g.getTimezoneOffset(), "minutes") : g,
							end: e.isSome(l) ? k.offsetDate(l, -l.getTimezoneOffset(), "minutes") : l
						})
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/ElevationInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./FeatureExpressionInfo ./unitConversionUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					var n;
					v = c.strict()({
						onTheGround: "on-the-ground",
						relativeToGround: "relative-to-ground",
						relativeToScene: "relative-to-scene",
						absoluteHeight: "absolute-height"
					});
					c = new c.JSONMap({
						foot: "feet",
						kilometer: "kilometers",
						meter: "meters",
						mile: "miles",
						"us-foot": "us-feet",
						yard: "yards"
					});
					e = n = function(t) {
						function h(u) {
							u = t.call(this, u) || this;
							u.offset = null;
							return u
						}
						a._inheritsLoose(h, t);
						var q = h.prototype;
						q.readFeatureExpressionInfo = function(u, x) {
							if (null != u) return u;
							if (x.featureExpression &&
								0 === x.featureExpression.value) return {
								expression: "0"
							}
						};
						q.writeFeatureExpressionInfo = function(u, x, y, w) {
							x[y] = u.write({}, w);
							"0" === u.expression && (x.featureExpression = {
								value: 0
							})
						};
						q.write = function(u, x) {
							return this.offset || this.mode || this.featureExpressionInfo || this.unit ? t.prototype.write.call(this, u, x) : null
						};
						q.clone = function() {
							return new n({
								mode: this.mode,
								offset: this.offset,
								featureExpressionInfo: this.featureExpressionInfo ? this.featureExpressionInfo.clone() : void 0,
								unit: this.unit
							})
						};
						q.equals = function(u) {
							return this.mode ===
								u.mode && this.offset === u.offset && this.unit === u.unit && d.equalsMaybe(this.featureExpressionInfo, u.featureExpressionInfo)
						};
						a._createClass(h, [{
							key: "mode",
							get: function() {
								const {
									offset: u,
									featureExpressionInfo: x
								} = this;
								return this._isOverridden("mode") ? this._get("mode") : d.isSome(u) || x ? "relative-to-ground" : "on-the-ground"
							},
							set: function(u) {
								this._override("mode", u)
							}
						}, {
							key: "unit",
							set: function(u) {
								this._set("unit", u)
							}
						}]);
						return h
					}(e.JSONSupport);
					b.__decorate([k.property({
							type: r,
							json: {
								write: !0
							}
						})], e.prototype, "featureExpressionInfo",
						void 0);
					b.__decorate([f.reader("featureExpressionInfo", ["featureExpressionInfo", "featureExpression"])], e.prototype, "readFeatureExpressionInfo", null);
					b.__decorate([l.writer("featureExpressionInfo", {
						featureExpressionInfo: {
							type: r
						},
						"featureExpression.value": {
							type: [0]
						}
					})], e.prototype, "writeFeatureExpressionInfo", null);
					b.__decorate([k.property({
						type: v.apiValues,
						nonNullable: !0,
						json: {
							type: v.jsonValues,
							read: v.read,
							write: {
								writer: v.write,
								isRequired: !0
							}
						}
					})], e.prototype, "mode", null);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0
						}
					})], e.prototype, "offset", void 0);
					b.__decorate([k.property({
						type: p.supportedUnits,
						json: {
							type: String,
							read: c.read,
							write: c.write
						}
					})], e.prototype, "unit", null);
					return e = n = b.__decorate([g.subclass("esri.layers.support.ElevationInfo")], e)
				})
		},
		"esri/symbols/support/FeatureExpressionInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../layers/support/fieldUtils".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					c = f = function(g) {
						function l(p) {
							return g.call(this, p) || this
						}
						a._inheritsLoose(l, g);
						var r = l.prototype;
						r.collectRequiredFields = function() {
							var p = a._asyncToGenerator(function*(n, t) {
								return m.collectArcadeFieldNames(n, t, this.expression)
							});
							return function(n, t) {
								return p.apply(this, arguments)
							}
						}();
						r.clone = function() {
							return new f({
								expression: this.expression,
								title: this.title
							})
						};
						r.equals = function(p) {
							return this.expression === p.expression && this.title === p.title
						};
						return l
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "expression", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "title", void 0);
					return c = f = b.__decorate([v.subclass("esri.layers.support.FeatureExpressionInfo")], c)
				})
		},
		"esri/layers/support/fieldUtils": function() {
			define("require exports ../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/maybe ../../core/object ./domainUtils ../../support/arcadeOnDemand".split(" "), function(a, b, c, e, d, k, v, m) {
				function f(ma,
					Q, aa) {
					if (ma)
						for (const ta of ma)(ma = (ma = k.getDeepValue(ta, Q)) && "function" !== typeof ma && aa.get(ma)) && k.setDeepValue(ta, ma.name, Q)
				}

				function g(ma, Q) {
					if (!ma || !Q) return [];
					ba.clear();
					l(ba, ma, Q);
					return Array.from(ba)
						.sort()
				}

				function l(ma, Q, aa) {
					if (aa)
						if (Q ? .fields ? .length)
							if (aa.includes("*"))
								for (const {
									name: ta
								} of Q.fields) ma.add(ta);
							else
								for (const ta of aa) r(ma, Q, ta);
					else if (aa.includes("*")) ma.clear(), ma.add("*");
					else
						for (const ta of aa) null != ta && ma.add(ta)
				}

				function r(ma, Q, aa) {
					"string" === typeof aa && (Q ? (Q =
						Q.get(aa)) && ma.add(Q.name) : ma.add(aa))
				}

				function p(ma, Q, aa) {
					return n.apply(this, arguments)
				}

				function n() {
					n = c._asyncToGenerator(function*(ma, Q, aa) {
						if (aa) {
							var {
								arcadeUtils: ta
							} = yield m.loadArcade();
							aa = ta.extractFieldNames(aa, Q ? .fields ? .map(Da => Da.name));
							for (const Da of aa) r(ma, Q, Da)
						}
					});
					return n.apply(this, arguments)
				}

				function t(ma, Q, aa) {
					return h.apply(this, arguments)
				}

				function h() {
					h = c._asyncToGenerator(function*(ma, Q, aa) {
						if (aa && "1\x3d1" !== aa) {
							const ta = (yield new Promise((Da, Ga) => a(["../../core/sql/WhereClause"],
									Da, Ga)))
								.WhereClause.create(aa, Q);
							if (!ta.isStandardized) throw new e("fieldUtils:collectFilterFields", "Where clause is not standardized", {
								where: aa
							});
							l(ma, Q, ta.fieldNames)
						}
					});
					return h.apply(this, arguments)
				}

				function q(ma, Q) {
					for (const aa of ma)
						if (aa && aa.valueType && aa.valueType === Q) return aa.name;
					return null
				}

				function u() {
					u = c._asyncToGenerator(function*(ma) {
						if (!ma) return [];
						const Q = new Set;
						yield x(Q, ma);
						return Array.from(Q)
							.sort()
					});
					return u.apply(this, arguments)
				}

				function x(ma, Q) {
					return y.apply(this, arguments)
				}

				function y() {
					y = c._asyncToGenerator(function*(ma, Q) {
						if (Q) {
							var aa = k.getDeepValue("elevationInfo.featureExpressionInfo", Q);
							if (aa) return aa.collectRequiredFields(ma, Q.fieldsIndex)
						}
					});
					return y.apply(this, arguments)
				}

				function w() {
					w = c._asyncToGenerator(function*(ma, Q, aa) {
						if (Q && aa && "fields" in aa) {
							var ta = [];
							ta.push(A(ma, Q, aa.popupTemplate));
							aa.fields && ta.push(...aa.fields.map(function() {
								var Da = c._asyncToGenerator(function*(Ga) {
									Ga.onStatisticExpression ? p(ma, Q.fieldsIndex, Ga.onStatisticExpression.expression) :
										ma.add(Ga.onStatisticField)
								});
								return function(Ga) {
									return Da.apply(this, arguments)
								}
							}()));
							yield Promise.all(ta)
						}
					});
					return w.apply(this, arguments)
				}

				function A(ma, Q, aa) {
					return B.apply(this, arguments)
				}

				function B() {
					B = c._asyncToGenerator(function*(ma, Q, aa) {
						const ta = [];
						aa ? .expressionInfos && ta.push(...aa.expressionInfos.map(Da => p(ma, Q.fieldsIndex, Da.expression)));
						aa = aa ? .content;
						if (Array.isArray(aa))
							for (const Da of aa) "expression" === Da.type && Da.expressionInfo && ta.push(p(ma, Q.fieldsIndex, Da.expressionInfo.expression));
						yield Promise.all(ta)
					});
					return B.apply(this, arguments)
				}

				function E() {
					E = c._asyncToGenerator(function*(ma, Q, aa) {
						Q && (Q.timeInfo && d.isSome(aa) && aa.timeExtent && l(ma, Q.fieldsIndex, [Q.timeInfo.startField, Q.timeInfo.endField]), Q.floorInfo && l(ma, Q.fieldsIndex, [Q.floorInfo.floorField]), d.isSome(aa) && d.isSome(aa.where) && (yield t(ma, Q.fieldsIndex, aa.where)))
					});
					return E.apply(this, arguments)
				}

				function z() {
					z = c._asyncToGenerator(function*(ma, Q, aa) {
						Q && aa && (yield Promise.all(aa.map(ta => C(ma, Q, ta))))
					});
					return z.apply(this,
						arguments)
				}

				function C(ma, Q, aa) {
					return D.apply(this, arguments)
				}

				function D() {
					D = c._asyncToGenerator(function*(ma, Q, aa) {
						Q && aa && (aa.valueExpression ? yield p(ma, Q.fieldsIndex, aa.valueExpression): aa.field && r(ma, Q.fieldsIndex, aa.field))
					});
					return D.apply(this, arguments)
				}

				function J() {
					J = c._asyncToGenerator(function*(ma) {
						if (!ma) return [];
						const Q = "timeInfo" in ma && ma.timeInfo;
						return Q ? g(ma.fieldsIndex, [ma.trackIdField, Q.startField, Q.endField]) : []
					});
					return J.apply(this, arguments)
				}

				function K() {
					K = c._asyncToGenerator(function*(ma) {
						if (!ma) return [];
						const Q = new Set;
						yield H(Q, ma);
						return Array.from(Q)
							.sort()
					});
					return K.apply(this, arguments)
				}

				function H(ma, Q) {
					return G.apply(this, arguments)
				}

				function G() {
					G = c._asyncToGenerator(function*(ma, Q) {
						const {
							labelingInfo: aa,
							fieldsIndex: ta
						} = Q;
						aa && aa.length && (yield Promise.all(aa.map(Da => F(ma, ta, Da))))
					});
					return G.apply(this, arguments)
				}

				function F(ma, Q, aa) {
					return L.apply(this, arguments)
				}

				function L() {
					L = c._asyncToGenerator(function*(ma, Q, aa) {
						if (aa) {
							var ta = aa.getLabelExpression();
							aa = aa.where;
							"arcade" === ta.type ? yield p(ma,
								Q, ta.expression): (ta = ta.expression.match(/{[^}]*}/g)) && ta.forEach(Da => {
								r(ma, Q, Da.slice(1, -1))
							});
							yield t(ma, Q, aa)
						}
					});
					return L.apply(this, arguments)
				}

				function R(ma) {
					return "number" === typeof ma && !isNaN(ma) && isFinite(ma)
				}

				function V(ma) {
					return null === ma || R(ma)
				}

				function U(ma) {
					return null === ma || la(ma)
				}

				function W(ma) {
					return null != ma && "string" === typeof ma
				}

				function M(ma) {
					return null === ma || W(ma)
				}

				function T() {
					return !0
				}

				function Z(ma, Q) {
					let aa;
					switch (ma.type) {
						case "date":
						case "integer":
						case "long":
						case "small-integer":
						case "esriFieldTypeDate":
						case "esriFieldTypeInteger":
						case "esriFieldTypeLong":
						case "esriFieldTypeSmallInteger":
							aa =
								ma.nullable ? U : la;
							break;
						case "double":
						case "single":
						case "esriFieldTypeSingle":
						case "esriFieldTypeDouble":
							aa = ma.nullable ? V : R;
							break;
						case "string":
						case "esriFieldTypeString":
							aa = ma.nullable ? M : W;
							break;
						default:
							aa = T
					}
					return 1 === arguments.length ? aa : aa(Q)
				}

				function oa(ma) {
					return null != ma && P.has(ma.type)
				}

				function qa(ma, Q) {
					return ma.nullable && null === Q ? null : oa(ma) && !Aa(ma.type, Number(Q)) ? b.NumericRangeValidationError.OUT_OF_RANGE : Z(ma, Q) ? ma.domain ? v.validateDomainValue(ma.domain, Q) : null : b.TypeValidationError.INVALID_TYPE
				}

				function Aa(ma, Q) {
					ma = "string" === typeof ma ? Ka(ma) : ma;
					if (!ma) return !1;
					const aa = ma.min,
						ta = ma.max;
					return ma.isInteger ? la(Q) && Q >= aa && Q <= ta : Q >= aa && Q <= ta
				}

				function Ka(ma) {
					switch (ma) {
						case "esriFieldTypeSmallInteger":
						case "small-integer":
							return ca;
						case "esriFieldTypeInteger":
						case "integer":
							return ka;
						case "esriFieldTypeSingle":
						case "single":
							return va;
						case "esriFieldTypeDouble":
						case "double":
							return Ca
					}
				}

				function da(ma, Q, aa) {
					if (!Q || !Q.attributes || !ma) {
						if (d.isSome(aa))
							for (var ta of ma ? ? []) aa.add(ta);
						return !0
					}
					Q =
						Q.attributes;
					ta = !1;
					for (const Da of ma)
						if (!(Da in Q))
							if (ta = !0, d.isSome(aa)) aa.add(Da);
							else break;
					return ta
				}

				function ja() {
					ja = c._asyncToGenerator(function*(ma, Q) {
						const aa = new Set;
						for (const ta of Q) yield p(aa, ma.fieldsIndex, ta);
						return Array.from(aa)
							.sort()
					});
					return ja.apply(this, arguments)
				}
				const sa = /^([0-9])/,
					I = /[^A-Za-z0-9_\u0080-\uffff]/g,
					N = /_{2,}/g,
					ea = /^_/,
					pa = /_$/,
					xa = "field field2 field3 normalizationField rotationInfo.field proportionalSymbolInfo.field proportionalSymbolInfo.normalizationField colorInfo.field colorInfo.normalizationField".split(" "),
					S = ["field", "normalizationField"],
					ba = new Set,
					la = (() => "isInteger" in Number ? Number.isInteger : ma => "number" === typeof ma && isFinite(ma) && Math.floor(ma) === ma)(),
					ha = ["integer", "small-integer", "single", "double"],
					P = new Set([...ha, "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble"]);
				b.NumericRangeValidationError = void 0;
				(b.NumericRangeValidationError || (b.NumericRangeValidationError = {}))
				.OUT_OF_RANGE = "numeric-range-validation-error::out-of-range";
				b.TypeValidationError =
					void 0;
				(b.TypeValidationError || (b.TypeValidationError = {}))
				.INVALID_TYPE = "type-validation-error::invalid-type";
				const ca = {
						min: -32768,
						max: 32767,
						isInteger: !0
					},
					ka = {
						min: -2147483648,
						max: 2147483647,
						isInteger: !0
					},
					va = {
						min: -3.4E38,
						max: 1.2E38,
						isInteger: !1
					},
					Ca = {
						min: -Number.MAX_VALUE,
						max: Number.MAX_VALUE,
						isInteger: !1
					};
				b.collectArcadeFieldNames = p;
				b.collectElevationFields = x;
				b.collectFeatureReductionFields = function(ma, Q, aa) {
					return w.apply(this, arguments)
				};
				b.collectField = r;
				b.collectFields = l;
				b.collectFilterFields = function(ma,
					Q, aa) {
					return E.apply(this, arguments)
				};
				b.collectLabelingFields = H;
				b.collectOrderByInfos = function(ma, Q, aa) {
					return z.apply(this, arguments)
				};
				b.collectPopupTemplateFields = A;
				b.doubleRange = Ca;
				b.featureHasFields = function(ma, Q) {
					return !da(ma, Q, null)
				};
				b.fixFields = g;
				b.fixRendererFields = function(ma, Q) {
					if (null != ma && null != Q)
						for (const aa of Array.isArray(ma) ? ma : [ma])
							if (f(xa, aa, Q), "visualVariables" in aa && aa.visualVariables)
								for (const ta of aa.visualVariables) f(S, ta, Q)
				};
				b.fixTimeInfoFields = function(ma, Q) {
					if (null != ma &&
						Q ? .fields ? .length)
						if ("startField" in ma) {
							var aa = Q.get(ma.startField);
							Q = Q.get(ma.endField);
							ma.startField = aa ? .name ? ? null;
							ma.endField = Q ? .name ? ? null
						} else aa = Q.get(ma.startTimeField), Q = Q.get(ma.endTimeField), ma.startTimeField = aa ? .name ? ? null, ma.endTimeField = Q ? .name ? ? null
				};
				b.getDisplayFieldName = function({
					displayField: ma,
					fields: Q
				}) {
					if (ma) return ma;
					if (!Q || !Q.length) return null;
					if (!(ma = q(Q, "name-or-title") || q(Q, "unique-identifier") || q(Q, "type-or-category"))) a: {
						for (const aa of Q)
							if (aa && aa.name && (Q = aa.name.toLowerCase(),
								Q.includes("name") || Q.includes("title"))) {
								ma = aa.name;
								break a
							} ma = null
					}
					return ma
				};
				b.getElevationFields = function(ma) {
					return u.apply(this, arguments)
				};
				b.getExpressionFields = function(ma, Q) {
					return ja.apply(this, arguments)
				};
				b.getFeatureEditFields = function(ma) {
					if (!ma) return [];
					const Q = "editFieldsInfo" in ma && ma.editFieldsInfo;
					return Q ? g(ma.fieldsIndex, [Q && Q.creatorField, Q && Q.creationDateField, Q && Q.editorField, Q && Q.editDateField]) : []
				};
				b.getFeatureGeometryFields = function(ma) {
					if (!ma) return [];
					const Q = ma.geometryFieldsInfo;
					return Q ? g(ma.fieldsIndex, [Q.shapeAreaField, Q.shapeLengthField]) : []
				};
				b.getFieldDefaultValue = function(ma) {
					const Q = ma.defaultValue;
					if (void 0 !== Q && Z(ma, Q)) return Q;
					if (ma.nullable) return null
				};
				b.getFieldRange = function(ma) {
					const Q = v.getDomainRange(ma.domain);
					if (Q) return Q;
					if (oa(ma)) return Ka(ma.type)
				};
				b.getLabelingFields = function(ma) {
					return K.apply(this, arguments)
				};
				b.getNumericTypeForValue = function(ma) {
					if (!R(ma)) return null;
					if (la(ma)) {
						if (ma >= ca.min && ma <= ca.max) return "esriFieldTypeSmallInteger";
						if (ma >=
							ka.min && ma <= ka.max) return "esriFieldTypeInteger"
					}
					return ma >= va.min && ma <= va.max ? "esriFieldTypeSingle" : "esriFieldTypeDouble"
				};
				b.getTimeFields = function(ma) {
					return J.apply(this, arguments)
				};
				b.integerRange = ka;
				b.isDateField = function(ma) {
					return null != ma && ("date" === ma.type || "esriFieldTypeDate" === ma.type)
				};
				b.isNumberInRange = Aa;
				b.isNumericField = oa;
				b.isRasterPixelValueField = function(ma) {
					return ["raster.itempixelvalue", "raster.servicepixelvalue"].some(Q => ma.toLowerCase()
						.startsWith(Q))
				};
				b.isStringField = function(ma) {
					return null !=
						ma && ("string" === ma.type || "esriFieldTypeString" === ma.type)
				};
				b.isValidFieldValue = function(ma, Q) {
					return null === qa(ma, Q)
				};
				b.isValueMatchingFieldType = Z;
				b.normalizeFieldName = function(ma) {
					return ma ? ma.trim()
						.replace(I, "_")
						.replace(N, "_")
						.replace(ea, "")
						.replace(pa, "")
						.replace(sa, "F$1") : null
				};
				b.numericTypes = ha;
				b.packFields = function(ma, Q, aa = 1) {
					if (!Q || !ma) return [];
					if (Q.includes("*")) return ["*"];
					Q = g(ma, Q);
					return Q.length / ma.fields.length >= aa ? ["*"] : Q
				};
				b.populateMissingFields = da;
				b.rendererFields = xa;
				b.sanitizeNullFieldValue =
					function(ma) {
						return null == ma || "number" === typeof ma && isNaN(ma) ? null : ma
					};
				b.singleRange = va;
				b.smallIntegerRange = ca;
				b.unpackFieldNames = function(ma, Q) {
					return d.isNone(Q) || d.isNone(ma) ? [] : Q.includes("*") ? (ma.fields ? ? [])
						.map(aa => aa.name) : Q
				};
				b.validateFieldValue = qa;
				b.validationErrorToString = function(ma, Q, aa) {
					switch (ma) {
						case v.DomainValidationError.INVALID_CODED_VALUE:
							return `Value ${aa} is not in the coded domain - field: ${Q.name}, domain: ${JSON.stringify(Q.domain)}`;
						case v.DomainValidationError.VALUE_OUT_OF_RANGE:
							return `Value ${aa} is out of the range of valid values - field: ${Q.name}, domain: ${JSON.stringify(Q.domain)}`;
						case b.TypeValidationError.INVALID_TYPE:
							return `Value ${aa} is not a valid value for the field type - field: ${Q.name}, type: ${Q.type}, nullable: ${Q.nullable}`;
						case b.NumericRangeValidationError.OUT_OF_RANGE:
							const {
								min: ta,
								max: Da
							} = Ka(Q.type);
							return `Value ${aa} is out of range for the number type - field: ${Q.name}, type: ${Q.type}, value range is ${ta} to ${Da}`
					}
				};
				b.visualVariableFields = S;
				Object.defineProperties(b, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/domainUtils": function() {
			define(["exports"],
				function(a) {
					a.DomainValidationError = void 0;
					(function(b) {
						b.VALUE_OUT_OF_RANGE = "domain-validation-error::value-out-of-range";
						b.INVALID_CODED_VALUE = "domain-validation-error::invalid-coded-value"
					})(a.DomainValidationError || (a.DomainValidationError = {}));
					a.getDomainRange = function(b) {
						if (b && "range" === b.type) return {
							min: "range" in b ? b.range[0] : b.minValue,
							max: "range" in b ? b.range[1] : b.maxValue
						}
					};
					a.validateDomainValue = function(b, c) {
						switch (b.type) {
							case "range":
								const e = "range" in b ? b.range[0] : b.minValue;
								b = "range" in
									b ? b.range[1] : b.maxValue;
								if (null != e && +c < e || null != b && +c > b) return a.DomainValidationError.VALUE_OUT_OF_RANGE;
								break;
							case "coded-value":
								if (null == b.codedValues || b.codedValues.every(d => null == d || d.code !== c)) return a.DomainValidationError.INVALID_CODED_VALUE;
								break;
							case "codedValue":
								if (null == b.codedValues || b.codedValues.every(d => null == d || d.code !== c)) return a.DomainValidationError.INVALID_CODED_VALUE
						}
						return null
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/support/arcadeOnDemand": function() {
			define("require exports ../chunks/_rollupPluginBabelHelpers ../geometry ../core/Error ../core/Logger ../core/maybe ../geometry/SpatialReference".split(" "),
				function(a, b, c, e, d, k, v, m) {
					function f() {
						l || (l = c._asyncToGenerator(function*() {
							const p = yield new Promise((n, t) => a(["./arcadeUtils"], n, t));
							return {
								arcade: p.arcade,
								arcadeUtils: p,
								Dictionary: p.Dictionary,
								Feature: p.arcadeFeature
							}
						})());
						return l
					}
					const g = k.getLogger("esri.support.arcadeOnDemand");
					let l;
					e = (p, n, t) => r.create(p, n, t, null, ["$feature", "$view"]);
					let r = function() {
						function p(t, h, q, u, x, y, w, A) {
							this.script = t;
							this.evaluate = x;
							this.fields = Array.isArray(w) ? w : w.fields;
							this._syntaxTree = u;
							this._arcade = h;
							this._arcadeDictionary =
								q;
							this._arcadeFeature = y;
							this._spatialReference = A;
							this._referencesGeometry = h.scriptTouchesGeometry(this._syntaxTree);
							this._referencesScale = this._arcade.referencesMember(this._syntaxTree, "scale")
						}
						p.create = function() {
							var t = c._asyncToGenerator(function*(h, q, u, x, y, w) {
								const {
									arcade: A,
									Feature: B,
									Dictionary: E
								} = yield f(), z = m.fromJSON(q);
								q = null;
								try {
									q = A.parseScript(h, w)
								} catch (F) {
									return g.error(new d("arcade-bad-expression", "Failed to parse arcade script", {
										script: h,
										error: F
									})), null
								}
								w = y.reduce((F, L) => ({
									...F,
									[L]: null
								}), {});
								let C = null;
								v.isSome(x) && (C = new E(x), C.immutable = !0, w.$config = null);
								var D = (x = A.scriptUsesGeometryEngine(q)) && A.enableGeometrySupport();
								const J = A.scriptUsesFeatureSet(q) && A.enableFeatureSetSupport(),
									K = (y = A.scriptIsAsync(q)) && A.enableAsyncSupport();
								w = {
									vars: w,
									spatialReference: z,
									useAsync: !!K
								};
								yield Promise.all([D, J, K]);
								D = new Set;
								yield A.loadDependentModules(D, q, null, y, x);
								const H = new E;
								H.immutable = !1;
								H.setField("scale", 0);
								const G = A.compileScript(q, w);
								return new p(h, A, E, q, F => {
									"$view" in F && F.$view && (H.setField("scale",
										F.$view.scale), F.$view = H);
									C && (F.$config = C);
									return G({
										vars: F,
										spatialReference: z
									})
								}, new B, u, z)
							});
							return function(h, q, u, x, y, w) {
								return t.apply(this, arguments)
							}
						}();
						var n = p.prototype;
						n.repurposeFeature = function(t) {
							t.geometry && !t.geometry.spatialReference && (t.geometry.spatialReference = this._spatialReference);
							this._arcadeFeature.repurposeFromGraphicLikeObject(t.geometry, t.attributes, {
								fields: this.fields
							});
							return this._arcadeFeature
						};
						n.createDictionary = function() {
							return new this._arcadeDictionary
						};
						n.referencesMember =
							function(t) {
								return this._arcade.referencesMember(this._syntaxTree, t)
							};
						n.referencesFunction = function(t) {
							return this._arcade.referencesFunction(this._syntaxTree, t)
						};
						n.referencesGeometry = function() {
							return this._referencesGeometry
						};
						n.referencesScale = function() {
							return this._referencesScale
						};
						n.extractFieldLiterals = function() {
							return this._arcade.extractExpectedFieldLiterals(this._syntaxTree)
						};
						return p
					}();
					b.ArcadeExpression = r;
					b.createDictionaryExpression = (p, n, t, h) => r.create(p, n, t, h, ["$feature", "$view"]);
					b.createLabelExpression = (p, n, t) => r.create(p, n, t, null, ["$feature"]);
					b.createRendererExpression = e;
					b.createVVExpression = e;
					b.loadArcade = f;
					Object.defineProperties(b, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/unitConversionUtils": function() {
			define(["exports", "../../renderers/support/lengthUtils"], function(a, b) {
				const c = function() {
					const e = Object.keys(b.meterIn);
					e.sort();
					return e
				}();
				a.getMetersPerUnit = function(e) {
					return 1 / (b.meterIn[e] || 1)
				};
				a.supportedUnits = c;
				a.supportsUnit =
					function(e) {
						return null != b.meterIn[e]
					};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/renderers/support/lengthUtils": function() {
			define(["exports", "../../core/unitUtils", "../../geometry/support/Ellipsoid"], function(a, b, c) {
				b = {
					inches: b.convertUnit(1, "meters", "inches"),
					feet: b.convertUnit(1, "meters", "feet"),
					"us-feet": b.convertUnit(1, "meters", "us-feet"),
					yards: b.convertUnit(1, "meters", "yards"),
					miles: b.convertUnit(1, "meters", "miles"),
					"nautical-miles": b.convertUnit(1,
						"meters", "nautical-miles"),
					millimeters: b.convertUnit(1, "meters", "millimeters"),
					centimeters: b.convertUnit(1, "meters", "centimeters"),
					decimeters: b.convertUnit(1, "meters", "decimeters"),
					meters: b.convertUnit(1, "meters", "meters"),
					kilometers: b.convertUnit(1, "meters", "kilometers"),
					"decimal-degrees": 1 / b.lengthToDegrees(1, "meters", c.earth.radius)
				};
				a.meterIn = b;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/unitUtils": function() {
			define("exports ./has ./jsonMap ./maybe ../geometry/projectionEllipsoid ../geometry/support/Ellipsoid ../geometry/support/spatialReferenceUtils ../geometry/support/WKIDUnitConversion".split(" "),
				function(a, b, c, e, d, k, v, m) {
					function f(M) {
						M = L[M];
						if (!M) throw Error("unknown type");
						return M
					}

					function g(M) {
						return F[M].baseUnit
					}

					function l(M, T = null) {
						T = T || f(M);
						return F[T].baseUnit === M
					}

					function r(M, T, Z) {
						if (T === Z) return M;
						const oa = f(T);
						if (oa !== f(Z)) throw Error("incompatible units");
						M = l(T, oa) ? M : M * F[oa].units[T].inBaseUnits;
						return l(Z, oa) ? M : M / F[oa].units[Z].inBaseUnits
					}

					function p(M, T) {
						M = r(M, T, "meters");
						return 3E3 > Math.abs(M) ? "meters" : "kilometers"
					}

					function n(M, T) {
						M = r(M, T, "meters");
						return 1E5 > Math.abs(M) ?
							"meters" : "kilometers"
					}

					function t(M, T) {
						M = r(M, T, "feet");
						return 1E3 > Math.abs(M) ? "feet" : "miles"
					}

					function h(M, T) {
						M = r(M, T, "feet");
						return 1E5 > Math.abs(M) ? "feet" : "miles"
					}

					function q(M, T) {
						M = r(M, T, "square-meters");
						return 3E6 > Math.abs(M) ? "square-meters" : "square-kilometers"
					}

					function u(M, T) {
						M = r(M, T, "square-feet");
						return 1E6 > Math.abs(M) ? "square-feet" : "square-miles"
					}

					function x(M) {
						return G.fromJSON(M.toLowerCase()) || null
					}

					function y(M) {
						const T = w(M),
							Z = d.getReferenceEllipsoid(M)
							.metersPerDegree;
						return T >= Z ? "meters" :
							E(M)
					}

					function w(M, T = k.earth.metersPerDegree) {
						return e.unwrapOr(A(M, !0), T)
					}

					function A(M, T = !1) {
						const Z = e.isSome(M) ? M.wkid : null;
						M = e.isSome(M) ? M.wkt : null;
						let oa = null;
						if (Z) {
							if (v.isWKIDFromMars(Z)) return k.mars.metersPerDegree;
							if (v.isWKIDFromMoon(Z)) return k.moon.metersPerDegree;
							oa = J.values[J[Z]];
							!oa && T && H.has(Z) && (oa = C)
						} else M && (/^PROJCS/i.test(M) ? oa = B(D.exec(M), oa) : /^GEOCCS/i.test(M) && (oa = B(K.exec(M), oa)));
						return oa
					}

					function B(M, T) {
						return M && M[1] ? parseFloat(M[1].split(",")[1]) : T
					}

					function E(M) {
						var T = e.isSome(M) ?
							M.wkid : null,
							Z = e.isSome(M) ? M.wkt : null;
						M = null;
						if (T) M = J.units[J[T]];
						else if (Z && (T = /^PROJCS/i.test(Z) ? D : /^GEOCCS/i.test(Z) ? K : null) && (T = T.exec(Z)) && T[1] && (T = T[1], M = (M = /[\\"\\']{1}([^\\"\\']+)/.exec(T)) && M[1], !M || !J.units.includes(M))) {
							T = parseFloat(T.split(",")[1]);
							M = null;
							Z = J.values;
							for (let oa = 0; oa < Z.length; ++oa)
								if (1E-7 > Math.abs(T - Z[oa])) {
									M = J.units[oa];
									break
								}
						}
						return e.isSome(M) ? x(M) : null
					}

					function z(M) {
						M = E(M);
						if (e.isNone(M)) return null;
						switch (M) {
							case "feet":
							case "us-feet":
							case "clarke-feet":
							case "clarke-yards":
							case "clarke-links":
							case "sears-yards":
							case "sears-feet":
							case "sears-chains":
							case "benoit-1895-b-chains":
							case "indian-yards":
							case "indian-1937-yards":
							case "gold-coast-feet":
							case "sears-1922-truncated-chains":
								return "imperial";
							case "50-kilometers":
							case "150-kilometers":
							case "meters":
								return "metric"
						}
						return null
					}
					const C = k.earth.radius * Math.PI / 200,
						D = /UNIT\[([^\]]+)\]\]$/i,
						J = m,
						K = /UNIT\[([^\]]+)\]/i,
						H = new Set([4261, 4305, 4807, 4810, 4811, 4812, 4816, 4819, 4821, 4901, 4902, 37225, 104139, 104140]),
						G = c.strict()({
							meter: "meters",
							foot: "feet",
							foot_us: "us-feet",
							foot_clarke: "clarke-feet",
							yard_clarke: "clarke-yards",
							link_clarke: "clarke-links",
							yard_sears: "sears-yards",
							foot_sears: "sears-feet",
							chain_sears: "sears-chains",
							chain_benoit_1895_b: "benoit-1895-b-chains",
							yard_indian: "indian-yards",
							yard_indian_1937: "indian-1937-yards",
							foot_gold_coast: "gold-coast-feet",
							chain_sears_1922_truncated: "sears-1922-truncated-chains",
							"50_kilometers": "50-kilometers",
							"150_kilometers": "150-kilometers"
						});
					b = {
						millimeters: {
							inBaseUnits: .001
						},
						centimeters: {
							inBaseUnits: .01
						},
						decimeters: {
							inBaseUnits: .1
						},
						meters: {
							inBaseUnits: 1
						},
						kilometers: {
							inBaseUnits: 1E3
						},
						inches: {
							inBaseUnits: .0254
						},
						feet: {
							inBaseUnits: .3048
						},
						yards: {
							inBaseUnits: .9144
						},
						miles: {
							inBaseUnits: 1609.344
						},
						"nautical-miles": {
							inBaseUnits: 1852
						},
						"us-feet": {
							inBaseUnits: 1200 / 3937
						}
					};
					m = {
						"square-millimeters": {
							inBaseUnits: 1E-6
						},
						"square-centimeters": {
							inBaseUnits: 1E-4
						},
						"square-decimeters": {
							inBaseUnits: .1 * .1
						},
						"square-meters": {
							inBaseUnits: 1
						},
						"square-kilometers": {
							inBaseUnits: 1E6
						},
						"square-inches": {
							inBaseUnits: 6.4516E-4
						},
						"square-feet": {
							inBaseUnits: .09290304
						},
						"square-yards": {
							inBaseUnits: .83612736
						},
						"square-miles": {
							inBaseUnits: 2589988.110336
						},
						"square-us-feet": {
							inBaseUnits: (M => M * M)(1200 / 3937)
						},
						acres: {
							inBaseUnits: 4046.8564224
						},
						ares: {
							inBaseUnits: 100
						},
						hectares: {
							inBaseUnits: 1E4
						}
					};
					const F = {
							length: {
								baseUnit: "meters",
								units: b
							},
							area: {
								baseUnit: "square-meters",
								units: m
							},
							volume: {
								baseUnit: "liters",
								units: {
									liters: {
										inBaseUnits: 1
									},
									"cubic-millimeters": {
										inBaseUnits: 1E3 * 1E-9
									},
									"cubic-centimeters": {
										inBaseUnits: .001
									},
									"cubic-decimeters": {
										inBaseUnits: 1
									},
									"cubic-meters": {
										inBaseUnits: 1E3
									},
									"cubic-kilometers": {
										inBaseUnits: 1E12
									},
									"cubic-inches": {
										inBaseUnits: .016387064
									},
									"cubic-feet": {
										inBaseUnits: .09290304 * 304.8
									},
									"cubic-yards": {
										inBaseUnits: 764.554857984
									},
									"cubic-miles": {
										inBaseUnits: 4.16818182544058E12
									}
								}
							},
							angle: {
								baseUnit: "radians",
								units: {
									radians: {
										inBaseUnits: 1
									},
									degrees: {
										inBaseUnits: Math.PI / 180
									}
								}
							}
						},
						L = (() => {
							const M = {};
							for (const T in F)
								for (const Z in F[T].units) M[Z] = T;
							return M
						})(),
						R = "metric imperial inches feet yards miles nautical-miles us-feet meters kilometers".split(" "),
						V = new Map([
							["meters", "square-meters"],
							["feet", "square-feet"],
							["us-feet", "square-us-feet"]
						]),
						U = {
							esriAcres: "acres",
							esriAres: "ares",
							esriHectares: "hectares",
							esriSquareCentimeters: "square-centimeters",
							esriSquareDecimeters: "square-decimeters",
							esriSquareFeet: "square-feet",
							esriSquareInches: "square-inches",
							esriSquareKilometers: "square-kilometers",
							esriSquareMeters: "square-meters",
							esriSquareMiles: "square-miles",
							esriSquareMillimeters: "square-millimeters",
							esriSquareUsFeet: "square-us-feet",
							esriSquareYards: "square-yards"
						},
						W = {
							esriCentimeters: "centimeters",
							esriDecimeters: "decimeters",
							esriFeet: "feet",
							esriInches: "inches",
							esriKilometers: "kilometers",
							esriMeters: "meters",
							esriMiles: "miles",
							esriMillimeters: "millimeters",
							esriNauticalMiles: "nautical-miles",
							esriYards: "yards"
						};
					b = c.strict()(U);
					m = c.strict()(W);
					c = c.strict()({
						...U,
						...W
					});
					a.areaUnitFromSpatialReference = function(M) {
						M = E(M);
						return e.isNone(M) ? null : V.get(M)
					};
					a.areaUnitsJSONMap = b;
					a.baseUnitForUnit = function(M) {
						return g(f(M))
					};
					a.baseUnitForUnitType = g;
					a.convertUnit = r;
					a.getDefaultUnitForView = function(M) {
						if (e.isNone(M)) return "metric";
						var T = M.map;
						if (T = T && "portalItem" in T ? T.portalItem ? .portal : null) switch (T ? .user ? .units ? ? T.units) {
							case "metric":
								return "metric";
							case "english":
								return "imperial"
						}
						return e.unwrapOr(z(M.spatialReference),
							"metric")
					};
					a.getDefaultUnitSystem = z;
					a.getMetersPerUnit = A;
					a.getMetersPerUnitForSR = w;
					a.getMetersPerVerticalUnitForSR = function(M) {
						if (e.isSome(M) && !v.isEarth(M)) return 1;
						M = w(M);
						return 1E5 < M ? 1 : M
					};
					a.getUnitString = E;
					a.getVerticalUnitStringForSR = y;
					a.inchesPerMeter = 39.37;
					a.isBaseUnit = l;
					a.isMeasurementSystem = function(M) {
						return "imperial" === M || "metric" === M
					};
					a.lengthToDegrees = function(M, T, Z) {
						return r(M, T, "meters") / (Z * Math.PI / 180)
					};
					a.lengthUnitFromSpatialReference = function(M) {
						M = E(M);
						return e.isNone(M) || !R.includes(M) ?
							null : M
					};
					a.lengthUnitsJSONMap = m;
					a.measurementAreaUnits = "metric imperial square-inches square-feet square-yards square-miles square-us-feet square-meters square-kilometers acres ares hectares".split(" ");
					a.measurementLengthUnits = R;
					a.preferredAreaUnit = function(M, T, Z) {
						switch (Z) {
							case "metric":
								return q(M, T);
							case "imperial":
								return u(M, T);
							default:
								return Z
						}
					};
					a.preferredImperialAreaUnit = u;
					a.preferredImperialLengthUnit = t;
					a.preferredImperialVerticalLengthUnit = h;
					a.preferredLengthUnit = function(M, T, Z) {
						switch (Z) {
							case "metric":
								return p(M,
									T);
							case "imperial":
								return t(M, T);
							default:
								return Z
						}
					};
					a.preferredMetricAreaUnit = q;
					a.preferredMetricLengthUnit = p;
					a.preferredMetricVerticalLengthUnit = n;
					a.preferredVerticalLengthUnit = function(M, T, Z) {
						switch (Z) {
							case "metric":
								return n(M, T);
							case "imperial":
								return h(M, T);
							default:
								return Z
						}
					};
					a.unitFromRESTJSON = x;
					a.unitToRESTJSON = function(M) {
						return G.toJSON(M) || null
					};
					a.unitType = f;
					a.unitsJSONMap = c;
					a.verticalLengthUnitFromSpatialReference = function(M) {
						M = y(M);
						return e.isNone(M) || !R.includes(M) ? null : M
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/geometry/projectionEllipsoid": function() {
			define(["exports", "../core/maybe", "./SpatialReference", "./support/Ellipsoid", "./support/spatialReferenceUtils"], function(a, b, c, e, d) {
				function k(l) {
					return new c({
						wkt: `GEOCCS["Spherical geocentric",\n    DATUM["Not specified",\n      SPHEROID["Sphere",${l.radius},0]],\n    PRIMEM["Greenwich",0.0,\n      AUTHORITY["EPSG","8901"]],\n    UNIT["m",1.0],\n    AXIS["Geocentric X",OTHER],\n    AXIS["Geocentric Y",EAST],\n    AXIS["Geocentric Z",NORTH]\n  ]`
					})
				}
				const v = k(e.earth),
					m = k(e.mars),
					f = k(e.moon),
					g = new c({
						wkt: `GEOCCS["WGS 84",\n  DATUM["WGS_1984",\n    SPHEROID["WGS 84",${e.earth.radius},298.257223563,\n      AUTHORITY["EPSG","7030"]],\n    AUTHORITY["EPSG","6326"]],\n  PRIMEM["Greenwich",0,\n    AUTHORITY["EPSG","8901"]],\n  UNIT["m",1.0,\n    AUTHORITY["EPSG","9001"]],\n  AXIS["Geocentric X",OTHER],\n  AXIS["Geocentric Y",OTHER],\n  AXIS["Geocentric Z",NORTH],\n  AUTHORITY["EPSG","4978"]\n]`
					});
				a.SphericalECEFSpatialReference = v;
				a.SphericalPCPFMars =
					m;
				a.SphericalPCPFMoon = f;
				a.WGS84ECEFSpatialReference = g;
				a.createSphericalPCPF = k;
				a.getReferenceEllipsoid = function(l) {
					return b.isSome(l) && (d.isMars(l) || l === m) ? e.mars : b.isSome(l) && (d.isMoon(l) || l === f) ? e.moon : e.earth
				};
				a.getReferenceEllipsoidFromWKID = function(l) {
					return d.isWKIDFromMars(l) ? e.mars : d.isWKIDFromMoon(l) ? e.moon : e.earth
				};
				a.getSphericalPCPF = function(l) {
					return l && (d.isMars(l) || l === m) ? m : l && (d.isMoon(l) || l === f) ? f : v
				};
				a.getSphericalPCPFForEllipsoid = function(l) {
					return l && l === e.mars ? m : l && l === e.moon ? f :
						v
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/mixins/PortalLayer": function() {
			define("require exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../kernel ../../request ../../core/asyncUtils ../../core/Error ../../core/Logger ../../core/maybe ../../core/promiseUtils ../../core/urlUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../portal/Portal ../../portal/PortalItem ../../portal/PortalUser".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w) {
					var A = null,
						B = null;
					b.PortalLayer = E => {
						E = function(z) {
							function C() {
								var J = z.apply(this, arguments) || this;
								J.resourceReferences = {
									portalItem: null,
									paths: []
								};
								J.userHasEditingPrivileges = !0;
								return J
							}
							c._inheritsLoose(C, z);
							var D = C.prototype;
							D.destroy = function() {
								this.portalItem = g.destroyMaybe(this.portalItem)
							};
							D.readPortalItem = function(J, K, H) {
								if (K.itemId) return new y({
									id: K.itemId,
									portal: H && H.portal
								})
							};
							D.writePortalItem = function(J, K) {
								J && J.id && (K.itemId = J.id)
							};
							D.loadFromPortal =
								function() {
									var J = c._asyncToGenerator(function*(K, H) {
										if (this.portalItem && this.portalItem.id) try {
											const G = yield new Promise((F, L) => a(["../../portal/support/layersLoader"], F, L));
											l.throwIfAborted(H);
											return yield G.load({
												instance: this,
												supportedTypes: K.supportedTypes,
												validateItem: K.validateItem,
												supportsData: K.supportsData,
												layerModuleTypeMap: K.layerModuleTypeMap
											}, H)
										} catch (G) {
											throw l.isAbortError(G) || f.getLogger(this.declaredClass)
												.warn(`Failed to load layer (${this.title}, ${this.id}) portal item (${this.portalItem.id})\n  ${G}`),
												G;
										}
									});
									return function(K, H) {
										return J.apply(this, arguments)
									}
								}();
							D.finishLoadEditablePortalLayer = function() {
								var J = c._asyncToGenerator(function*(K) {
									this._set("userHasEditingPrivileges", yield this._fetchUserHasEditingPrivileges(K)
										.catch(H => {
											l.throwIfAbortError(H);
											return !0
										}))
								});
								return function(K) {
									return J.apply(this, arguments)
								}
							}();
							D._fetchUserHasEditingPrivileges = function() {
								var J = c._asyncToGenerator(function*(K) {
									const H = this.url ? d.id ? .findCredential(this.url) : null;
									if (!H) return !0;
									K = A === H ? B : yield this._fetchEditingUser(K);
									A = H;
									B = K;
									return g.isNone(K) || null == K.privileges || K.privileges.includes("features:user:edit")
								});
								return function(K) {
									return J.apply(this, arguments)
								}
							}();
							D._fetchEditingUser = function() {
								var J = c._asyncToGenerator(function*(K) {
									var H = this.portalItem ? .portal ? .user;
									if (H) return H;
									H = d.id.findServerInfo(this.url ? ? "");
									if (!H ? .owningSystemUrl) return null;
									H = `${H.owningSystemUrl}/sharing/rest`;
									const G = x.getDefault();
									if (G && G.loaded && r.normalize(G.restUrl) === r.normalize(H)) return G.user;
									H = `${H}/community/self`;
									K = g.isSome(K) ?
										K.signal : null;
									K = yield v.result(k(H, {
										authMode: "no-prompt",
										query: {
											f: "json"
										},
										signal: K
									}));
									return K.ok ? w.fromJSON(K.value.data) : null
								});
								return function(K) {
									return J.apply(this, arguments)
								}
							}();
							D.read = function(J, K) {
								K && (K.layer = this);
								z.prototype.read.call(this, J, K)
							};
							D.write = function(J, K) {
								const H = K && K.portal,
									G = this.portalItem && this.portalItem.id && (this.portalItem.portal || x.getDefault());
								return H && G && !r.hasSamePortal(G.restUrl, H.restUrl) ? (K.messages && K.messages.push(new m("layer:cross-portal", `The layer '${this.title} (${this.id})' cannot be persisted because it refers to an item on a different portal than the one being saved to. To save, set layer.portalItem to null or save to the same portal as the item associated with the layer`, {
									layer: this
								})), null) : z.prototype.write.call(this, J, {
									...K,
									layer: this
								})
							};
							c._createClass(C, [{
								key: "portalItem",
								set: function(J) {
									J !== this._get("portalItem") && (this.removeOrigin("portal-item"), this._set("portalItem", J))
								}
							}]);
							return C
						}(E);
						e.__decorate([p.property({
							type: y
						})], E.prototype, "portalItem", null);
						e.__decorate([h.reader("web-document", "portalItem", ["itemId"])], E.prototype, "readPortalItem", null);
						e.__decorate([u.writer("web-document", "portalItem", {
								itemId: {
									type: String
								}
							})], E.prototype, "writePortalItem",
							null);
						e.__decorate([p.property({
							clonable: !1
						})], E.prototype, "resourceReferences", void 0);
						e.__decorate([p.property({
							readOnly: !0
						})], E.prototype, "userHasEditingPrivileges", void 0);
						return E = e.__decorate([q.subclass("esri.layers.mixins.PortalLayer")], E)
					};
					Object.defineProperties(b, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/mixins/ScaleRangeLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					a.ScaleRangeLayer = m => {
						m = function(f) {
							function g() {
								var l = f.apply(this, arguments) || this;
								l.minScale = 0;
								l.maxScale = 0;
								return l
							}
							b._inheritsLoose(g, f);
							b._createClass(g, [{
								key: "effectiveScaleRange",
								get: function() {
									const l = {
										minScale: this.minScale,
										maxScale: this.maxScale
									};
									var r = this.parent;
									r && "effectiveScaleRange" in r && (r = r.effectiveScaleRange, l.minScale = 0 < l.minScale ? 0 < r.minScale ? Math.min(l.minScale, r.minScale) : l.minScale : r.minScale, l.maxScale = 0 < l.maxScale ? 0 < r.maxScale ? Math.max(l.maxScale,
										r.maxScale) : l.maxScale : r.maxScale);
									return (r = this._get("effectiveScaleRange")) && r.minScale === l.minScale && r.maxScale === l.maxScale ? r : l
								}
							}]);
							return g
						}(m);
						c.__decorate([e.property({
							type: Number,
							nonNullable: !0,
							json: {
								write: !0
							}
						})], m.prototype, "minScale", void 0);
						c.__decorate([e.property({
							type: Number,
							nonNullable: !0,
							json: {
								write: !0
							}
						})], m.prototype, "maxScale", void 0);
						c.__decorate([e.property({
							readOnly: !0
						})], m.prototype, "effectiveScaleRange", null);
						return m = c.__decorate([v.subclass("esri.layers.mixins.ScaleRangeLayer")],
							m)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/mixins/RefreshableLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Logger ../../core/promiseUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./refresh".split(" "), function(a, b, c, e, d, k, v, m, f, g) {
				a.RefreshableLayer = l => {
					l = function(r) {
						function p(...t) {
							var h =
								r.call(this, ...t) || this;
							h.refreshInterval = 0;
							h.refreshTimestamp = 0;
							h._debounceHasDataChanged = d.debounce(() => h.hasDataChanged());
							h.when()
								.then(() => {
									g.registerLayer(b._assertThisInitialized(h))
								}, () => {});
							return h
						}
						b._inheritsLoose(p, r);
						var n = p.prototype;
						n.destroy = function() {
							g.unregisterLayer(this)
						};
						n.refresh = function(t = Date.now()) {
							d.ignoreAbortErrors(this._debounceHasDataChanged())
								.then(h => {
									h && this._set("refreshTimestamp", t);
									this.emit("refresh", {
										dataChanged: h
									})
								}, h => {
									e.getLogger(this.declaredClass)
										.error(h);
									this.emit("refresh", {
										dataChanged: !1,
										error: h
									})
								})
						};
						n.hasDataChanged = function() {
							var t = b._asyncToGenerator(function*() {
								return !0
							});
							return function() {
								return t.apply(this, arguments)
							}
						}();
						b._createClass(p, [{
							key: "refreshParameters",
							get: function() {
								return {
									_ts: this.refreshTimestamp || null
								}
							}
						}]);
						return p
					}(l);
					c.__decorate([k.property({
						type: Number,
						cast: r => .1 <= r ? r : 0 >= r ? 0 : .1,
						json: {
							write: !0
						}
					})], l.prototype, "refreshInterval", void 0);
					c.__decorate([k.property({
						readOnly: !0
					})], l.prototype, "refreshTimestamp", void 0);
					c.__decorate([k.property()],
						l.prototype, "refreshParameters", null);
					return l = c.__decorate([f.subclass("esri.layers.mixins.RefreshableLayer")], l)
				};
				a.isRefreshableLayer = function(l) {
					return null != l && "object" === typeof l && "refreshTimestamp" in l && "refresh" in l
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/mixins/refresh": function() {
			define("exports ../../core/Collection ../../chunks/_rollupPluginBabelHelpers ../../core/has ../../core/Error ../../core/Logger ../../core/accessorSupport/watch ../../core/accessorSupport/trackingUtils".split(" "),
				function(a, b, c, e, d, k, v, m) {
					function f(h) {
						return null != h && "object" === typeof h && "refreshInterval" in h && "refresh" in h
					}

					function g(h, q) {
						return Number.isFinite(h) && Number.isFinite(q) ? 0 >= q ? h : g(q, h % q) : 0
					}

					function l() {
						const h = Date.now();
						for (const q of r)
							if (q.refreshInterval) {
								const u = p.get(q) ? ? 0;
								h - u + 5 >= 6E4 * q.refreshInterval && (p.set(q, h), q.refresh(h))
							}
					}
					const r = new b,
						p = new WeakMap;
					let n = 0,
						t = 0;
					m.autorun(() => {
						const h = Date.now();
						let q = 0;
						for (const u of r) q = g(Math.round(6E4 * u.refreshInterval), q), u.refreshInterval ? p.get(u) ||
							p.set(u, h) : p.delete(u);
						q !== t && (t = q, clearInterval(n), n = 0 === t ? 0 : setInterval(l, t))
					});
					a.registerLayer = function(h) {
						f(h) && r.push(h)
					};
					a.test = {
						get hasRefreshTimer() {
							return 0 < n
						},
						get tickInterval() {
							return t
						},
						forceRefresh() {
							l()
						},
						hasLayer(h) {
							return f(h) && r.includes(h)
						},
						clear() {
							for (const h of r) p.delete(h);
							r.removeAll()
						}
					};
					a.unregisterLayer = function(h) {
						f(h) && r.includes(h) && r.remove(h)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/layersCreator": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/Collection ../../core/has ../../core/promiseUtils ./lazyLayerLoader ../../portal/PortalItem ../../portal/support/featureCollectionUtils ../../portal/support/portalLayers ../../renderers/support/styleUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					function l(H, G, F) {
						return r.apply(this, arguments)
					}

					function r() {
						r = b._asyncToGenerator(function*(H, G, F) {
							if (G) {
								var L = [];
								for (const R of G) G = p(R, F), "GroupLayer" === R.layerType ? L.push(y(G, R, F)) : L.push(G);
								L = yield d.eachAlways(L);
								for (const R of L) !R.value || F.filter && !F.filter(R.value) || H.add(R.value)
							}
						});
						return r.apply(this, arguments)
					}

					function p(H, G) {
						return n.apply(this, arguments)
					}

					function n() {
						n = b._asyncToGenerator(function*(H, G) {
							const F = yield q(H, G);
							return t(F, H, G)
						});
						return n.apply(this,
							arguments)
					}

					function t(H, G, F) {
						return h.apply(this, arguments)
					}

					function h() {
						h = b._asyncToGenerator(function*(H, G, F) {
							H = new H;
							H.read(G, F.context);
							"group" === H.type && x(G) && (yield A(H, G, F.context));
							yield g.loadStyleRenderer(H, F.context);
							return H
						});
						return h.apply(this, arguments)
					}

					function q(H, G) {
						return u.apply(this, arguments)
					}

					function u() {
						u = b._asyncToGenerator(function*(H, G) {
							var F = G.context;
							let L;
							switch (F.origin) {
								case "web-scene":
									switch (F.layerContainerType) {
										case "basemap":
											L = C;
											break;
										case "ground":
											L = z;
											break;
										default:
											L = E
									}
									break;
								default:
									switch (F.layerContainerType) {
										case "basemap":
											L = K;
											break;
										case "tables":
											L = J;
											break;
										default:
											L = D
									}
							}
							let R = H.layerType || H.type;
							!R && G && G.defaultLayerType && (R = G.defaultLayerType);
							G = (G = L[R]) ? k.layerLookupMap[G] : k.layerLookupMap.UnknownLayer;
							"Feature Collection" === H.type ? (F = F ? .portal, H.itemId && (H = new v({
									id: H.itemId,
									portal: F
								}), yield H.load(), H = (yield f.selectLayerClassPath(H))
									.className || "UnknownLayer", G = k.layerLookupMap[H])) : "ArcGISFeatureLayer" === R ? m.isMapNotesLayer(H) || m.isMarkupLayer(H) ?
								G = k.layerLookupMap.MapNotesLayer : m.isRouteLayer(H) ? G = k.layerLookupMap.RouteLayer : x(H) && (G = k.layerLookupMap.GroupLayer) : H.wmtsInfo && H.wmtsInfo.url && H.wmtsInfo.layerIdentifier ? G = k.layerLookupMap.WMTSLayer : "WFS" === R && "2.0.0" !== H.wfsInfo.version && (G = k.layerLookupMap.UnsupportedLayer);
							return G()
						});
						return u.apply(this, arguments)
					}

					function x(H) {
						return "ArcGISFeatureLayer" !== H.layerType || "Feature Collection" === H.type ? !1 : 1 < (H.featureCollection ? .layers ? .length ? ? 0)
					}

					function y(H, G, F) {
						return w.apply(this, arguments)
					}

					function w() {
						w = b._asyncToGenerator(function*(H, G, F) {
							const L = new c;
							G = l(L, Array.isArray(G.layers) ? G.layers : [], F);
							H = yield H;
							yield G;
							if ("group" === H.type) return H.layers.addMany(L), H
						});
						return w.apply(this, arguments)
					}

					function A(H, G, F) {
						return B.apply(this, arguments)
					}

					function B() {
						B = b._asyncToGenerator(function*(H, G, F) {
							const L = yield(0, k.layerLookupMap.FeatureLayer)();
							var R = G.featureCollection;
							const V = R.showLegend;
							R = R.layers.map((U, W) => {
								const M = new L;
								M.read(U, F);
								U = {
									...F,
									ignoreDefaults: !0
								};
								M.read({
									id: `${H.id}-sublayer-${W}`,
									visibility: G.visibleLayers ? .includes(W) ? ? !0
								}, U);
								null != V && M.read({
									showLegend: V
								}, U);
								return M
							});
							H.layers.addMany(R)
						});
						return B.apply(this, arguments)
					}
					const E = {
							ArcGISDimensionLayer: "DimensionLayer",
							ArcGISFeatureLayer: "FeatureLayer",
							ArcGISImageServiceLayer: "ImageryLayer",
							ArcGISMapServiceLayer: "MapImageLayer",
							PointCloudLayer: "PointCloudLayer",
							ArcGISSceneServiceLayer: "SceneLayer",
							IntegratedMeshLayer: "IntegratedMeshLayer",
							OGCFeatureLayer: "OGCFeatureLayer",
							BuildingSceneLayer: "BuildingSceneLayer",
							ArcGISTiledElevationServiceLayer: "ElevationLayer",
							ArcGISTiledImageServiceLayer: "ImageryTileLayer",
							ArcGISTiledMapServiceLayer: "TileLayer",
							GroupLayer: "GroupLayer",
							GeoJSON: "GeoJSONLayer",
							WebTiledLayer: "WebTileLayer",
							CSV: "CSVLayer",
							VectorTileLayer: "VectorTileLayer",
							WFS: "WFSLayer",
							WMS: "WMSLayer",
							DefaultTileLayer: "TileLayer",
							KML: "KMLLayer",
							RasterDataLayer: "UnsupportedLayer",
							Voxel: "VoxelLayer",
							LineOfSightLayer: "LineOfSightLayer"
						},
						z = {
							ArcGISTiledElevationServiceLayer: "ElevationLayer",
							DefaultTileLayer: "ElevationLayer",
							RasterDataElevationLayer: "UnsupportedLayer"
						},
						C = {
							ArcGISTiledMapServiceLayer: "TileLayer",
							ArcGISTiledImageServiceLayer: "ImageryTileLayer",
							OpenStreetMap: "OpenStreetMapLayer",
							WebTiledLayer: "WebTileLayer",
							VectorTileLayer: "VectorTileLayer",
							ArcGISImageServiceLayer: "UnsupportedLayer",
							WMS: "UnsupportedLayer",
							ArcGISMapServiceLayer: "UnsupportedLayer",
							DefaultTileLayer: "TileLayer"
						},
						D = {
							ArcGISAnnotationLayer: "UnsupportedLayer",
							ArcGISDimensionLayer: "UnsupportedLayer",
							ArcGISFeatureLayer: "FeatureLayer",
							ArcGISImageServiceLayer: "ImageryLayer",
							ArcGISImageServiceVectorLayer: "ImageryLayer",
							ArcGISMapServiceLayer: "MapImageLayer",
							ArcGISStreamLayer: "StreamLayer",
							ArcGISTiledImageServiceLayer: "ImageryTileLayer",
							ArcGISTiledMapServiceLayer: "TileLayer",
							BingMapsAerial: "BingMapsLayer",
							BingMapsRoad: "BingMapsLayer",
							BingMapsHybrid: "BingMapsLayer",
							CSV: "CSVLayer",
							DefaultTileLayer: "TileLayer",
							GeoRSS: "GeoRSSLayer",
							GeoJSON: "GeoJSONLayer",
							GroupLayer: "GroupLayer",
							KML: "KMLLayer",
							OGCFeatureLayer: "OGCFeatureLayer",
							OrientedImageryLayer: "OrientedImageryLayer",
							SubtypeGroupLayer: "SubtypeGroupLayer",
							VectorTileLayer: "VectorTileLayer",
							WFS: "WFSLayer",
							WMS: "WMSLayer",
							WebTiledLayer: "WebTileLayer"
						},
						J = {
							ArcGISFeatureLayer: "FeatureLayer"
						},
						K = {
							ArcGISImageServiceLayer: "ImageryLayer",
							ArcGISImageServiceVectorLayer: "ImageryLayer",
							ArcGISMapServiceLayer: "MapImageLayer",
							ArcGISTiledImageServiceLayer: "ImageryTileLayer",
							ArcGISTiledMapServiceLayer: "TileLayer",
							OpenStreetMap: "OpenStreetMapLayer",
							VectorTileLayer: "VectorTileLayer",
							WebTiledLayer: "WebTileLayer",
							BingMapsAerial: "BingMapsLayer",
							BingMapsRoad: "BingMapsLayer",
							BingMapsHybrid: "BingMapsLayer",
							WMS: "WMSLayer",
							DefaultTileLayer: "TileLayer"
						};
					a.populateOperationalLayers = l;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/lazyLayerLoader": function() {
			define(["require", "exports", "../../chunks/_rollupPluginBabelHelpers"], function(a, b, c) {
				const e = k => Object.freeze(Object.defineProperty({
						__proto__: null,
						default: k
					}, Symbol.toStringTag, {
						value: "Module"
					})),
					d = {
						BingMapsLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../BingMapsLayer"],
										f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						BuildingSceneLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../BuildingSceneLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						CSVLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../CSVLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						DimensionLayer: function() {
							var k =
								c._asyncToGenerator(function*() {
									return (yield new Promise((v, m) => a(["../DimensionLayer"], f => v(e(f)), m)))
										.default
								});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						ElevationLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../ElevationLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						FeatureLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../FeatureLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						GroupLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../GroupLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						GeoRSSLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../GeoRSSLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						GeoJSONLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v,
										m) => a(["../GeoJSONLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						ImageryLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../ImageryLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						ImageryTileLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../ImageryTileLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						IntegratedMeshLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../IntegratedMeshLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						KMLLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../KMLLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						LineOfSightLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../LineOfSightLayer"],
										f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						MapImageLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../MapImageLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						MapNotesLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../MapNotesLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						OGCFeatureLayer: function() {
							var k =
								c._asyncToGenerator(function*() {
									return (yield new Promise((v, m) => a(["../OGCFeatureLayer"], f => v(e(f)), m)))
										.default
								});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						OpenStreetMapLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../OpenStreetMapLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						OrientedImageryLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../OrientedImageryLayer"],
										f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						PointCloudLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../PointCloudLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						RouteLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../RouteLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						SceneLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v,
										m) => a(["../SceneLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						StreamLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../StreamLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						SubtypeGroupLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../SubtypeGroupLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						TileLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../TileLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						UnknownLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../UnknownLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						UnsupportedLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../UnsupportedLayer"],
										f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						VectorTileLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../VectorTileLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						VoxelLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../VoxelLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						WebTileLayer: function() {
							var k =
								c._asyncToGenerator(function*() {
									return (yield new Promise((v, m) => a(["../WebTileLayer"], f => v(e(f)), m)))
										.default
								});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						WFSLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../WFSLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}(),
						WMSLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../WMSLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this,
									arguments)
							}
						}(),
						WMTSLayer: function() {
							var k = c._asyncToGenerator(function*() {
								return (yield new Promise((v, m) => a(["../WMTSLayer"], f => v(e(f)), m)))
									.default
							});
							return function() {
								return k.apply(this, arguments)
							}
						}()
					};
				b.layerLookupMap = d;
				Object.defineProperties(b, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/portal/support/featureCollectionUtils": function() {
			define(["exports"], function(a) {
				function b(c, e) {
					return c.layerType && "ArcGISFeatureLayer" === c.layerType ? c.featureCollectionType === e ?
						!0 : !1 : !1
				}
				a.isMapNotesLayer = function(c) {
					return b(c, "notes")
				};
				a.isMarkupLayer = function(c) {
					return b(c, "markup")
				};
				a.isRouteLayer = function(c) {
					return b(c, "route")
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/portal/support/portalLayers": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../layers/support/lazyLayerLoader ../PortalItem ./layersLoader ./portalItemUtils ../../support/requestPresets".split(" "), function(a,
				b, c, e, d, k, v, m) {
				function f(A) {
					switch (A.type) {
						case "Map Service":
							return l(A);
						case "Feature Service":
							return r(A);
						case "Feature Collection":
							return n(A);
						case "Scene Service":
							return p(A);
						case "Image Service":
							return h(A);
						case "Stream Service":
							return {
								className: "StreamLayer"
							};
						case "Vector Tile Service":
							return {
								className: "VectorTileLayer"
							};
						case "GeoJson":
							return {
								className: "GeoJSONLayer"
							};
						case "CSV":
							return {
								className: "CSVLayer"
							};
						case "KML":
							return {
								className: "KMLLayer"
							};
						case "WFS":
							return {
								className: "WFSLayer"
							};
						case "WMTS":
							return {
								className: "WMTSLayer"
							};
						case "WMS":
							return {
								className: "WMSLayer"
							};
						case "Feed":
							return {
								className: "StreamLayer"
							};
						default:
							return Promise.reject(new c("portal:unknown-item-type", "Unknown item type '${type}'", {
								type: A.type
							}))
					}
				}

				function g(A) {
					return (0, e.layerLookupMap[A.className])()
						.then(B => ({
							constructor: B,
							properties: A.properties
						}))
				}

				function l(A) {
					return x(A)
						.then(B => B ? {
							className: "TileLayer"
						} : {
							className: "MapImageLayer"
						})
				}

				function r(A) {
					return v.hasTypeKeyword(A, "Oriented Imagery Layer") ? u(A) : y(A)
						.then(B => {
							if ("object" === typeof B) {
								const E = {};
								null != B.id && (E.layerId = B.id);
								return {
									className: B.className || "FeatureLayer",
									properties: E
								}
							}
							return {
								className: "GroupLayer"
							}
						})
				}

				function p(A) {
					return y(A)
						.then(B => {
							if ("object" === typeof B) {
								const E = {};
								null != B.id ? (E.layerId = B.id, B = `${A.url}/layers/${B.id}`) : B = A.url;
								if (Array.isArray(A.typeKeywords) && 0 < A.typeKeywords.length) {
									const z = {
										IntegratedMesh: "IntegratedMeshLayer",
										"3DObject": "SceneLayer",
										Point: "SceneLayer",
										PointCloud: "PointCloudLayer",
										Building: "BuildingSceneLayer"
									};
									for (const C of Object.keys(z))
										if (A.typeKeywords.includes(C)) return {
											className: z[C]
										}
								}
								return m.requestArcGISServiceJSON(B)
									.then(z => {
										let C = "SceneLayer";
										const D = {
											Point: "SceneLayer",
											"3DObject": "SceneLayer",
											IntegratedMesh: "IntegratedMeshLayer",
											PointCloud: "PointCloudLayer",
											Building: "BuildingSceneLayer"
										};
										z && z.layerType && D[z.layerType] && (C = D[z.layerType]);
										return {
											className: C,
											properties: E
										}
									})
							}
							return !1 === B ? m.requestArcGISServiceJSON(A.url)
								.then(E => "Voxel" === E ? .layerType ? {
									className: "VoxelLayer"
								} : {
									className: "GroupLayer"
								}) : {
									className: "GroupLayer"
								}
						})
				}

				function n(A) {
					return t.apply(this, arguments)
				}

				function t() {
					t = b._asyncToGenerator(function*(A) {
						yield A.load();
						const B = v.hasTypeKeyword(A, "Map Notes"),
							E = v.hasTypeKeyword(A, "Markup");
						if (B || E) return {
							className: "MapNotesLayer"
						};
						if (v.hasTypeKeyword(A, "Route Layer")) return {
							className: "RouteLayer"
						};
						A = yield A.fetchData();
						return 1 === k.getNumLayersAndTables(A) ? {
							className: "FeatureLayer"
						} : {
							className: "GroupLayer"
						}
					});
					return t.apply(this, arguments)
				}

				function h(A) {
					return q.apply(this, arguments)
				}

				function q() {
					q = b._asyncToGenerator(function*(A) {
						yield A.load();
						var B = A.typeKeywords ? .map(E => E.toLowerCase()) ? ? [];
						if (B.includes("elevation 3d layer")) return {
							className: "ElevationLayer"
						};
						if (B.includes("tiled imagery")) return {
							className: "ImageryTileLayer"
						};
						B = (yield A.fetchData()) ? .layerType;
						if ("ArcGISTiledImageServiceLayer" === B) return {
							className: "ImageryTileLayer"
						};
						if ("ArcGISImageServiceLayer" === B) return {
							className: "ImageryLayer"
						};
						B = yield m.requestArcGISServiceJSON(A.url);
						A = B.cacheType ? .toLowerCase();
						B = B.capabilities ? .toLowerCase()
							.includes("tilesonly");
						return "map" === A || B ? {
							className: "ImageryTileLayer"
						} : {
							className: "ImageryLayer"
						}
					});
					return q.apply(this, arguments)
				}

				function u(A) {
					return A.load()
						.then(() =>
							A.fetchData())
						.then(B => B.coverage ? {
							className: "GroupLayer"
						} : {
							className: "OrientedImageryLayer",
							properties: B
						})
				}

				function x(A) {
					return m.requestArcGISServiceJSON(A.url)
						.then(B => B.tileInfo)
				}

				function y(A) {
					return !A.url || A.url.match(/\/\d+$/) ? Promise.resolve({}) : A.load()
						.then(() => A.fetchData())
						.then(function() {
							var B = b._asyncToGenerator(function*(E) {
								if ("Feature Service" === A.type) {
									var z = yield k.preprocessFSItemData(E, A.url);
									z = w(z);
									"object" === typeof z && (E = k.getSubtypeGroupLayerIds(E), z.className = E.includes(z.id) ?
										"SubtypeGroupLayer" : "FeatureLayer");
									return z
								}
								return 0 < k.getNumLayersAndTables(E) ? w(E) : m.requestArcGISServiceJSON(A.url)
									.then(w)
							});
							return function(E) {
								return B.apply(this, arguments)
							}
						}())
				}

				function w(A) {
					return 1 === k.getNumLayersAndTables(A) ? {
						id: k.getFirstLayerOrTableId(A)
					} : !1
				}
				a.fromItem = function(A) {
					!A.portalItem || A.portalItem instanceof d || (A = {
						...A,
						portalItem: new d(A.portalItem)
					});
					return A.portalItem.load()
						.then(f)
						.then(g)
						.then(B => new B.constructor({
							portalItem: A.portalItem,
							...B.properties
						}))
				};
				a.selectLayerClassPath =
					f;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/portal/support/layersLoader": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../layers/Layer ../../layers/support/arcgisLayerUrl ../Portal ../PortalItem ./jsonContext ./portalItemUtils ../../renderers/support/styleUtils ../../support/requestPresets".split(" "), function(a, b, c, e, d, k, v, m, f, g, l) {
				function r() {
					r = b._asyncToGenerator(function*(D, J) {
						var K = D.instance.portalItem;
						if (K && K.id) {
							yield K.load(J);
							K = D.instance.portalItem;
							if (!D.supportedTypes.includes(K.type)) throw new c("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}'", {
								type: K.type,
								expectedType: D.supportedTypes.join(", ")
							});
							return p(D, J)
						}
					});
					return r.apply(this, arguments)
				}

				function p(D, J) {
					return n.apply(this, arguments)
				}

				function n() {
					n = b._asyncToGenerator(function*(D, J) {
						const K = D.instance,
							H = K.portalItem,
							{
								url: G,
								title: F
							} = H,
							L = m.createForItemRead(H);
						if ("group" === K.type) return K.read({
								title: F
							},
							L), t(K, D);
						G && K.read({
							url: G
						}, L);
						(D = yield x(D, J)) && K.read(D, L);
						K.resourceReferences = {
							portalItem: H,
							paths: L.readResourcePaths
						};
						"subtype-group" !== K.type && K.read({
							title: F
						}, L);
						return g.loadStyleRenderer(K, L)
					});
					return n.apply(this, arguments)
				}

				function t(D, J) {
					const K = D.portalItem.type,
						H = J.layerModuleTypeMap;
					var G = f.hasTypeKeyword(D.portalItem, "Oriented Imagery Layer") ? ? !1;
					switch (K) {
						case "Feature Service":
							G = G ? H.OrientedImageryLayer : H.FeatureLayer;
							break;
						case "Stream Service":
							G = H.StreamLayer;
							break;
						case "Scene Service":
							G =
								H.SceneLayer;
							break;
						case "Feature Collection":
							G = H.FeatureLayer;
							break;
						default:
							throw new c("portal:unsupported-item-type-as-group", `The item type '${K}' is not supported as a 'IGroupLayer'`);
					}
					let F;
					return G()
						.then(L => {
							F = L;
							return x(J)
						})
						.then(function() {
							var L = b._asyncToGenerator(function*(R) {
								let V = () => F;
								if ("Feature Service" === K) {
									R = yield y(R, D.portalItem.url);
									if (C(R)
										.length) {
										const U = yield(0, H.SubtypeGroupLayer)();
										V = W => "SubtypeGroupLayer" === W.layerType ? U : F
									}
									return q(D, V, R)
								}
								return 0 < E(R) ? q(D, V, R) : h(D, V)
							});
							return function(R) {
								return L.apply(this, arguments)
							}
						}())
				}

				function h(D, J) {
					return D.portalItem.url ? l.requestArcGISServiceJSON(D.portalItem.url)
						.then(K => {
							function H(G) {
								return {
									id: G.id,
									name: G.name
								}
							}
							K && q(D, J, {
								layers: K.layers ? .map(H),
								tables: K.tables ? .map(H)
							})
						}) : Promise.resolve()
				}

				function q(D, J, K) {
					let H = K.layers || [];
					const G = K.tables || [];
					"Feature Collection" === D.portalItem.type && (H.forEach(F => {
						"Table" === F ? .layerDefinition ? .type && G.push(F)
					}), H = H.filter(F => "Table" !== F ? .layerDefinition ? .type));
					if ("coverage" in K) {
						const F =
							z(K);
						D.add(F)
					}
					H.reverse()
						.forEach(F => {
							F = u(D, J(F), K, F);
							D.add(F)
						});
					G.reverse()
						.forEach(F => {
							F = u(D, J(F), K, F);
							D.tables.add(F)
						})
				}

				function u(D, J, K, H) {
					J = new J({
						portalItem: D.portalItem.clone(),
						layerId: H.id
					});
					"subtype-group" !== J.type && (J.sublayerTitleMode = "service-name");
					"Feature Collection" === D.portalItem.type && (D = {
						origin: "portal-item",
						portal: D.portalItem.portal || k.getDefault()
					}, J.read(H, D), K = K.showLegend, null != K && J.read({
						showLegend: K
					}, D));
					return J
				}

				function x(D, J) {
					if (!1 === D.supportsData) return Promise.resolve(void 0);
					const K = D.instance;
					return K.portalItem.fetchData("json", J)
						.catch(() => null)
						.then(H => {
							var G = "stream" === K.type || "oriented-imagery" === K.type ? !1 : "layerId" in K;
							if (G) {
								G = !0;
								if (H && 0 < E(H)) {
									if (null == K.layerId) {
										var F = C(H);
										K.layerId = "subtype-group" === K.type ? F ? . [0] : A(H)
									}
									if (F = B(H, K)) 1 === E(H) && (G = !1), null != H.showLegend && (F.showLegend = H.showLegend)
								}
								G && "service-name" !== K.sublayerTitleMode && (K.sublayerTitleMode = "item-title-and-service-name");
								return F
							}
							return H
						})
				}

				function y(D, J) {
					return w.apply(this, arguments)
				}

				function w() {
					w =
						b._asyncToGenerator(function*(D, J) {
							if (null == D ? .layers || null == D ? .tables) J = yield l.requestArcGISServiceJSON(J), D = D || {}, D.layers = D.layers || J ? .layers, D.tables = D.tables || J ? .tables;
							return D
						});
					return w.apply(this, arguments)
				}

				function A(D) {
					const J = D.layers;
					return J && J.length ? J[0].id : (D = D.tables) && D.length ? D[0].id : null
				}

				function B(D, J) {
					const {
						layerId: K
					} = J;
					D = D.layers ? .find(G => G.id === K) || D.tables ? .find(G => G.id === K);
					var H;
					if (H = D) H = "feature" === J.type && "layerType" in D && "SubtypeGroupLayer" === D.layerType || "subtype-group" ===
						J.type && !("layerType" in D) ? !1 : !0;
					return H ? D : null
				}

				function E(D) {
					return (D ? .layers ? .length ? ? 0) + (D ? .tables ? .length ? ? 0)
				}

				function z(D) {
					var {
						coverage: J
					} = D;
					if (!J) return null;
					D = new URL(J);
					if (J.toLowerCase()
						.includes("item.html")) return J = D.searchParams.get("id"), e.fromPortalItem({
						portalItem: new v({
							id: J,
							url: D.origin
						})
					});
					if (d.isArcGISUrl(J)) return e.fromArcGISServerUrl({
						url: J
					});
					throw new c("portal:oriented-imagery-layer-coverage", "the provided coverage url couldn't be loaded as a layer");
				}

				function C(D) {
					const J = [];
					D ? .layers ? .forEach(K => {
						"SubtypeGroupLayer" === K.layerType && J.push(K.id)
					});
					return J
				}
				a.getFirstLayerOrTableId = A;
				a.getNumLayersAndTables = E;
				a.getSubtypeGroupLayerIds = C;
				a.load = function(D, J) {
					return r.apply(this, arguments)
				};
				a.preprocessFSItemData = y;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/arcgisLayerUrl": function() {
			define(["exports", "../../core/maybe", "../../core/urlUtils", "../../chunks/persistableUrlUtils"], function(a, b, c, e) {
				function d(p) {
					if (b.isNone(p)) return null;
					p = c.urlToObject(p);
					p = p.path.match(g) || p.path.match(l);
					if (!p) return null;
					const [, n, t, h, q] = p;
					p = t.indexOf("/");
					return {
						title: v(-1 !== p ? t.slice(p + 1) : t),
						serverType: m[h.toLowerCase()],
						sublayer: null != q && "" !== q ? parseInt(q, 10) : null,
						url: {
							path: n
						}
					}
				}

				function k(p) {
					return (p = c.urlToObject(p)
						.path.match(r)) ? {
						serviceUrl: p[1],
						sublayerId: Number(p[2])
					} : null
				}

				function v(p) {
					p = p.replace(/\s*[/_]+\s*/g, " ");
					return p[0].toUpperCase() + p.slice(1)
				}
				const m = {
						mapserver: "MapServer",
						imageserver: "ImageServer",
						featureserver: "FeatureServer",
						sceneserver: "SceneServer",
						streamserver: "StreamServer",
						vectortileserver: "VectorTileServer"
					},
					f = Object.values(m),
					g = new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/rest\\/services\\/(.+?)\\/(${f.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i"),
					l = new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/([^\\/\\n]+)\\/(${f.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i"),
					r = /(.*?)\/(?:layers\/)?(\d+)\/?$/i;
				a.cleanTitle = v;
				a.isAGOLUrl = function(p) {
					if (!p) return !1;
					p = (new c.Url(c.makeAbsolute(p)))
						.authority ? .toLowerCase();
					return null != p &&
						p.includes("arcgis.com")
				};
				a.isArcGISUrl = function(p) {
					return !!g.test(p)
				};
				a.isHostedAgolService = function(p) {
					if (!p) return !1;
					p = p.toLowerCase();
					const n = p.includes(".arcgis.com/");
					p = p.includes("//services") || p.includes("//tiles") || p.includes("//features");
					return n && p
				};
				a.isHostedSecuredProxyService = function(p, n) {
					return null != n && null != p && p.toLowerCase()
						.includes(n.toLowerCase())
				};
				a.isServerOrServicesAGOLUrl = function(p) {
					if (!p) return !1;
					p = (new c.Url(c.makeAbsolute(p)))
						.authority ? .toLowerCase();
					return "server.arcgisonline.com" ===
						p || "services.arcgisonline.com" === p
				};
				a.isWmsServer = function(p) {
					if (!p) return !1;
					var n = p.toLowerCase();
					p = n.includes("/services/");
					const t = n.includes("/mapserver/wmsserver"),
						h = n.includes("/imageserver/wmsserver");
					n = n.includes("/wmsserver");
					return p && (t || h || n)
				};
				a.parse = d;
				a.parseNonStandardSublayerUrl = k;
				a.sanitizeUrl = function(p, n) {
					return p ? c.removeTrailingSlash(c.removeQueryParameters(p, n)) : p
				};
				a.sanitizeUrlWithLayerId = function(p) {
					let {
						url: n
					} = p;
					if (!n) return {
						url: n
					};
					n = c.removeQueryParameters(n, p.logger);
					const t =
						c.urlToObject(n),
						h = d(t.path);
					let q = void 0;
					b.isSome(h) ? (null != h.sublayer && null == p.layer.layerId && (q = h.sublayer), n = h.url.path) : p.nonStandardUrlAllowed && (p = k(t.path), b.isSome(p) && (n = p.serviceUrl, q = p.sublayerId));
					return {
						url: c.removeTrailingSlash(n),
						layerId: q
					}
				};
				a.serverTypes = f;
				a.titleFromUrlAndName = function(p, n) {
					const t = [];
					p && (p = d(p), b.isSome(p) && p.title && t.push(p.title));
					n && (n = v(n), t.push(n));
					if (2 === t.length) {
						if (t[0].toLowerCase()
							.includes(t[1].toLowerCase())) return t[0];
						if (t[1].toLowerCase()
							.includes(t[0].toLowerCase())) return t[1]
					}
					return t.join(" - ")
				};
				a.writeUrlWithLayerId = function(p, n, t, h, q) {
					e.write(n, h, "url", q);
					h.url && null != p.layerId && (h.url = c.join(h.url, t, p.layerId.toString()))
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/portal/support/jsonContext": function() {
			define(["exports", "../../core/urlUtils", "../Portal"], function(a, b, c) {
				a.createForItemRead = function(e) {
					return {
						origin: "portal-item",
						url: b.urlToObject(e.itemUrl),
						portal: e.portal || c.getDefault(),
						portalItem: e,
						readResourcePaths: []
					}
				};
				a.createForItemWrite =
					function(e) {
						return {
							origin: "portal-item",
							messages: [],
							writtenProperties: [],
							url: e.itemUrl ? b.urlToObject(e.itemUrl) : null,
							portal: e.portal || c.getDefault(),
							portalItem: e
						}
					};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/portal/support/portalItemUtils": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../geometry/projection", "../../geometry/SpatialReference", "../../geometry/support/webMercatorUtils"], function(a, b, c, e, d) {
				function k(g) {
					return v.apply(this,
						arguments)
				}

				function v() {
					v = b._asyncToGenerator(function*(g) {
						const l = g.spatialReference;
						if (l.isWGS84) return g.clone();
						if (l.isWebMercator) return d.webMercatorToGeographic(g);
						const r = e.WGS84;
						yield c.initializeProjection(l, r);
						return c.project(g, r)
					});
					return v.apply(this, arguments)
				}

				function m(g, l) {
					return !!g.typeKeywords ? .includes(l)
				}

				function f() {
					f = b._asyncToGenerator(function*(g) {
						g = g.clone()
							.normalize();
						let l;
						if (1 < g.length)
							for (const r of g) l ? r.width > l.width && (l = r) : l = r;
						else l = g[0];
						return k(l)
					});
					return f.apply(this,
						arguments)
				}
				a.TypeKeyword = {
					DEVELOPER_BASEMAP: "DeveloperBasemap",
					JSAPI: "ArcGIS API for JavaScript",
					METADATA: "Metadata",
					MULTI_LAYER: "Multilayer",
					SINGLE_LAYER: "Singlelayer",
					TABLE: "Table"
				};
				a.addTypeKeyword = function(g, l) {
					if (!m(g, l)) {
						const r = g.typeKeywords;
						r ? r.push(l) : g.typeKeywords = [l]
					}
				};
				a.getWGS84ExtentForItem = function(g) {
					return f.apply(this, arguments)
				};
				a.hasTypeKeyword = m;
				a.removeTypeKeyword = function(g, l) {
					if (g = g.typeKeywords) l = g.indexOf(l), -1 < l && g.splice(l, 1)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/projection": function() {
			define("require exports ../chunks/_rollupPluginBabelHelpers ../core/Error ../core/mathUtils ../core/maybe ../core/promiseUtils ../core/unitUtils ../core/accessorSupport/tracking ../core/accessorSupport/tracking/SimpleObservable ../chunks/mat4 ../chunks/vec3 ../chunks/vec3f64 ./Extent ./Multipoint ../chunks/pe ./Point ./Polygon ./Polyline ./projectionEllipsoid ./support/aaBoundingRect ./support/Ellipsoid ./support/geodesicConstants ./support/GeographicTransformation ./support/spatialReferenceUtils ./support/SupportedGCSWkids ./support/zscale".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D) {
					function J() {
						return !!Qa && h.isLoaded()
					}

					function K(ia) {
						k.isNone(O) && (O = Promise.all([h.load(), (new Promise((ra, na) => a(["../chunks/geometryEngineBase"], ra, na)))
							.then(ra => ra.geometryEngineBase), new Promise((ra, na) => a(["./geometryAdapters/hydrated"], ra, na))
						]));
						return O.then(([, ra, {
							hydratedAdapter: na
						}]) => {
							v.throwIfAborted(ia);
							Ba = na;
							Qa = ra.default;
							Qa._enableProjection(h.pe);
							ya.notify()
						})
					}

					function H(ia, ra, na = null, wa = null) {
						return Array.isArray(ia) ?
							0 === ia.length ? [] : G(Ba, ia, ia[0].spatialReference, ra, na, wa) : G(Ba, [ia], ia.spatialReference, ra, na, wa)[0]
					}

					function G(ia, ra, na, wa, Ja = null, ua = null) {
						if (k.isNone(na) || k.isNone(wa)) return ra;
						if (V(na, wa, Ja)) return ra.map(Ia => k.unwrap(W(Ia, na, wa)));
						if (k.isNone(Ja)) {
							const Ia = E.cacheKey(na, wa);
							void 0 !== Y[Ia] ? Ja = Y[Ia] : (Ja = L(na, wa, void 0), k.isNone(Ja) && (Ja = new E), Y[Ia] = Ja)
						}
						if (k.isNone(Qa) || k.isNone(ia)) throw new za;
						return k.isSome(ua) ? Qa._project(ia, ra, na, wa, Ja, ua) : Qa._project(ia, ra, na, wa, Ja)
					}

					function F(ia, ra) {
						if (!J())
							for (const na of ia)
								if (k.isSome(na) &&
									!z.equals(na.spatialReference, ra) && z.isValid(na.spatialReference) && z.isValid(ra) && !V(na.spatialReference, ra)) return f.trackAccess(ya), {
									pending: K(),
									geometries: null
								};
						return {
							pending: null,
							geometries: ia.map(na => k.isNone(na) ? null : z.equals(na.spatialReference, ra) ? na : z.isValid(na.spatialReference) && z.isValid(ra) ? R(na, ra) : null)
						}
					}

					function L(ia, ra, na = null) {
						if (k.isNone(ia) || k.isNone(ra)) return null;
						if (k.isNone(Qa) || k.isNone(Ba)) throw new za;
						ia = Qa._getTransformation(Ba, ia, ra, na, na ? .spatialReference);
						return null !==
							ia ? E.fromGE(ia) : null
					}

					function R(ia, ra) {
						try {
							const na = H(ia, ra);
							if (null == na) return null;
							"xmin" in ia && "xmin" in na && (na.zmin = ia.zmin, na.zmax = ia.zmax);
							const wa = D.getGeometryZScaler(na.type, ia.spatialReference, ra);
							k.isSome(wa) && wa(na);
							return na
						} catch (na) {
							if (!(na instanceof za)) throw na;
							return null
						}
					}

					function V(ia, ra, na) {
						return na ? !1 : z.equals(ia, ra) ? !0 : z.isValid(ia) && z.isValid(ra) && !!$a(ia, ra, fb)
					}

					function U() {
						U = c._asyncToGenerator(function*(ia, ra, na, wa) {
							if (J()) return v.waitTick(wa);
							if (Array.isArray(ia))
								for (const {
									source: Ja,
									dest: ua,
									geographicTransformation: Ia
								} of ia) {
									if (!V(Ja, ua, Ia)) return K(wa)
								} else if (!V(ia, ra, na)) return K(wa);
							return v.waitTick(wa)
						});
						return U.apply(this, arguments)
					}

					function W(ia, ra, na) {
						return ia ? "x" in ia ? M(ia, ra, new q, na, 0) : "xmin" in ia ? qa(ia, ra, new n, na, 0) : "rings" in ia ? oa(ia, ra, new u, na, 0) : "paths" in ia ? Z(ia, ra, new x, na, 0) : "points" in ia ? T(ia, ra, new t, na, 0) : null : null
					}

					function M(ia, ra, na, wa, Ja) {
						Fa[0] = ia.x;
						Fa[1] = ia.y;
						const ua = ia.z;
						Fa[2] = void 0 !== ua ? ua : Ja;
						if (!ja(Fa, ra, 0, Fa, wa, 0, 1)) return null;
						na.x = Fa[0];
						na.y = Fa[1];
						na.spatialReference = wa;
						void 0 === ua ? (na.z = void 0, na.hasZ = !1) : (na.z = Fa[2], na.hasZ = !0);
						void 0 === ia.m ? (na.m = void 0, na.hasM = !1) : (na.m = ia.m, na.hasM = !0);
						return na
					}

					function T(ia, ra, na, wa, Ja) {
						const {
							points: ua,
							hasZ: Ia,
							hasM: X
						} = ia;
						ia = [];
						const Ea = ua.length,
							Ha = [];
						for (var La of ua) Ha.push(La[0], La[1], Ia ? La[2] : Ja);
						if (!ja(Ha, ra, 0, Ha, wa, 0, Ea)) return null;
						for (ra = 0; ra < Ea; ++ra) {
							Ja = 3 * ra;
							La = Ha[Ja];
							const Oa = Ha[Ja + 1];
							Ia && X ? ia.push([La, Oa, Ha[Ja + 2], ua[ra][3]]) : Ia ? ia.push([La, Oa, Ha[Ja + 2]]) : X ? ia.push([La, Oa, ua[ra][2]]) :
								ia.push([La, Oa])
						}
						na.points = ia;
						na.spatialReference = wa;
						na.hasZ = Ia;
						na.hasM = X;
						return na
					}

					function Z(ia, ra, na, wa, Ja) {
						const {
							paths: ua,
							hasZ: Ia,
							hasM: X
						} = ia;
						ia = [];
						if (!sa(ua, Ia ? ? !1, X ? ? !1, ra, ia, wa, Ja)) return null;
						na.paths = ia;
						na.spatialReference = wa;
						na.hasZ = Ia;
						na.hasM = X;
						return na
					}

					function oa(ia, ra, na, wa, Ja) {
						const {
							rings: ua,
							hasZ: Ia,
							hasM: X
						} = ia;
						ia = [];
						if (!sa(ua, Ia ? ? !1, X ? ? !1, ra, ia, wa, Ja)) return null;
						na.rings = ia;
						na.spatialReference = wa;
						na.hasZ = Ia;
						na.hasM = X;
						return na
					}

					function qa(ia, ra, na, wa, Ja) {
						const {
							xmin: ua,
							ymin: Ia,
							xmax: X,
							ymax: Ea,
							hasZ: Ha,
							hasM: La
						} = ia;
						if (!Aa(ua, Ia, Ha ? ia.zmin : Ja, ra, Fa, wa)) return null;
						na.xmin = Fa[0];
						na.ymin = Fa[1];
						Ha && (na.zmin = Fa[2]);
						if (!Aa(X, Ea, Ha ? ia.zmax : Ja, ra, Fa, wa)) return null;
						na.xmax = Fa[0];
						na.ymax = Fa[1];
						Ha && (na.zmax = Fa[2]);
						La && (na.mmin = ia.mmin, na.mmax = ia.mmax);
						na.spatialReference = wa;
						return na
					}

					function Aa(ia, ra, na, wa, Ja, ua) {
						cb[0] = ia;
						cb[1] = ra;
						cb[2] = na;
						return ja(cb, wa, 0, Ja, ua, 0, 1)
					}

					function Ka(ia, ra, na, wa) {
						if (k.isNone(ra) || k.isNone(wa) || 2 > ia.length) return !1;
						2 === ia.length && (cb[0] = ia[0], cb[1] = ia[1], cb[2] =
							0, ia = cb);
						return ja(ia, ra, 0, na, wa, 0, 1)
					}

					function da(ia, ra, na) {
						if (k.isNone(ra)) return !1;
						ra = pa(ra, Za);
						ra = Ua[ra][fa.WGS84_COMPARABLE_LON_LAT];
						if (k.isNone(ra)) return !1;
						ra(ia, 0, cb, 0);
						na !== cb && (na[0] = cb[0], na[1] = cb[1], 2 < na.length && (na[2] = cb[2]));
						return !0
					}

					function ja(ia, ra, na, wa, Ja, ua, Ia = 1) {
						ra = $a(ra, Ja, fb);
						if (k.isNone(ra)) return !1;
						if (ra === xa) {
							if (ia === wa && na === ua) return !0;
							Ia = na + 3 * Ia;
							for (let X = na, Ea = ua; X < Ia; X++, Ea++) wa[Ea] = ia[X];
							return !0
						}
						Ia = na + 3 * Ia;
						for (let X = na, Ea = ua; X < Ia; X += 3, Ea += 3) ra(ia, X, wa, Ea);
						return !0
					}

					function sa(ia, ra, na, wa, Ja, ua, Ia = 0) {
						const X = [];
						for (const Ea of ia)
							for (const Ha of Ea) X.push(Ha[0], Ha[1], ra ? Ha[2] : Ia);
						if (!ja(X, wa, 0, X, ua, 0, X.length / 3)) return !1;
						wa = 0;
						Ja.length = 0;
						for (const Ea of ia) {
							ia = [];
							for (const Ha of Ea) ra && na ? ia.push([X[wa++], X[wa++], X[wa++], Ha[3]]) : ra ? ia.push([X[wa++], X[wa++], X[wa++]]) : (na ? ia.push([X[wa++], X[wa++], Ha[2]]) : ia.push([X[wa++], X[wa++]]), wa++);
							Ja.push(ia)
						}
						return !0
					}

					function I(ia, ra, na, wa) {
						ra = wa + ra;
						if (ra < wa / 2 || na > ra) return Number.MAX_VALUE;
						ia = Math.abs(gb * ia) + Math.asin(na /
							ra);
						return ia >= Math.PI / 2 ? Number.MAX_VALUE : na / Math.cos(ia)
					}

					function N(ia, ra, na) {
						const wa = Math.sin(ia);
						ia = Math.cos(ia);
						const Ja = Math.sin(ra);
						ra = Math.cos(ra);
						na[0] = -wa;
						na[4] = -Ja * ia;
						na[8] = ra * ia;
						na[12] = 0;
						na[1] = ia;
						na[5] = -Ja * wa;
						na[9] = ra * wa;
						na[13] = 0;
						na[2] = 0;
						na[6] = ra;
						na[10] = Ja;
						na[14] = 0;
						na[3] = 0;
						na[7] = 0;
						na[11] = 0;
						na[15] = 1;
						return na
					}

					function ea(ia, ra, na) {
						N(ia, ra, na);
						l.transpose(na, na);
						return na
					}

					function pa(ia, ra) {
						if (!ia) return fa.UNKNOWN;
						if (ra.spatialReference === ia) return ra.spatialReferenceId;
						ra.spatialReference =
							ia;
						"metersPerUnit" in ra && (ra.metersPerUnit = m.getMetersPerUnitForSR(ia, 1));
						return ia.wkt === y.SphericalECEFSpatialReference.wkt ? ra.spatialReferenceId = fa.SPHERICAL_ECEF : z.isWGS84(ia) ? ra.spatialReferenceId = fa.WGS84 : z.isWebMercator(ia) ? ra.spatialReferenceId = fa.WEB_MERCATOR : z.isPlateCarree(ia) ? ra.spatialReferenceId = fa.PLATE_CARREE : ia.wkt === y.WGS84ECEFSpatialReference.wkt ? ra.spatialReferenceId = fa.WGS84_ECEF : ia.wkid === C.SupportedGCSWkids.CGCS2000 ? ra.spatialReferenceId = fa.CGCS2000 : ia.wkt === y.SphericalPCPFMars.wkt ?
							ra.spatialReferenceId = fa.SPHERICAL_MARS_PCPF : ia.wkt === y.SphericalPCPFMoon.wkt ? ra.spatialReferenceId = fa.SPHERICAL_MOON_PCPF : z.isMars(ia) ? ra.spatialReferenceId = fa.GCSMARS2000 : z.isMoon(ia) ? ra.spatialReferenceId = fa.GCSMOON2000 : ra.spatialReferenceId = fa.UNKNOWN
					}

					function xa(ia, ra, na, wa) {
						ia !== na && (na[wa++] = ia[ra++], na[wa++] = ia[ra++], na[wa] = ia[ra])
					}

					function S(ia, ra, na, wa) {
						na[wa++] = kb * (ia[ra++] / A.earth.radius);
						na[wa++] = kb * (Math.PI / 2 - 2 * Math.atan(Math.exp(-ia[ra++] / A.earth.radius)));
						na[wa] = ia[ra]
					}

					function ba(ia,
						ra, na, wa) {
						S(ia, ra, na, wa);
						aa(na, wa, na, wa)
					}

					function la(ia, ra, na, wa) {
						S(ia, ra, na, wa);
						Ra(na, wa, na, wa)
					}

					function ha(ia, ra, na, wa, Ja) {
						var ua = .4999999 * Math.PI;
						ua = d.clamp(gb * ia[ra + 1], -ua, ua);
						ua = Math.sin(ua);
						na[wa++] = gb * ia[ra] * Ja.radius;
						na[wa++] = Ja.halfSemiMajorAxis * Math.log((1 + ua) / (1 - ua));
						na[wa] = ia[ra + 2]
					}

					function P(ia, ra, na, wa) {
						ha(ia, ra, na, wa, A.earth)
					}

					function ca(ia, ra, na, wa) {
						na[wa] = ia[ra] * Pa;
						na[wa + 1] = ia[ra + 1] * Pa;
						na[wa + 2] = ia[ra + 2]
					}

					function ka(ia, ra, na, wa) {
						na[wa] = ia[ra] * Sa;
						na[wa + 1] = ia[ra + 1] * Sa;
						na[wa + 2] = ia[ra +
							2]
					}

					function va(ia, ra, na, wa) {
						S(ia, ra, na, wa);
						ca(na, wa, na, wa)
					}

					function Ca(ia, ra, na, wa, Ja) {
						Ja += ia[ra + 2];
						const ua = gb * ia[ra + 1];
						ia = gb * ia[ra];
						ra = Math.cos(ua);
						na[wa++] = Math.cos(ia) * ra * Ja;
						na[wa++] = Math.sin(ia) * ra * Ja;
						na[wa] = Math.sin(ua) * Ja
					}

					function ma(ia, ra, na, wa) {
						Ca(ia, ra, na, wa, A.moon.radius)
					}

					function Q(ia, ra, na, wa) {
						Ca(ia, ra, na, wa, A.mars.radius)
					}

					function aa(ia, ra, na, wa) {
						Ca(ia, ra, na, wa, A.earth.radius)
					}

					function ta(ia, ra, na, wa, Ja) {
						var ua = ia[ra];
						const Ia = ia[ra + 1];
						ra = ia[ra + 2];
						ia = Math.sqrt(ua * ua + Ia * Ia + ra * ra);
						ra =
							d.asinClamped(ra / (0 === ia ? 1 : ia));
						ua = Math.atan2(Ia, ua);
						na[wa++] = kb * ua;
						na[wa++] = kb * ra;
						na[wa] = ia - Ja
					}

					function Da(ia, ra, na, wa) {
						ta(ia, ra, na, wa, A.moon.radius)
					}

					function Ga(ia, ra, na, wa) {
						ta(ia, ra, na, wa, A.mars.radius)
					}

					function Na(ia, ra, na, wa) {
						ta(ia, ra, na, wa, A.earth.radius)
					}

					function Ma(ia, ra, na, wa) {
						Na(ia, ra, na, wa);
						P(na, wa, na, wa)
					}

					function Ta(ia, ra, na, wa) {
						Na(ia, ra, na, wa);
						Ra(na, wa, na, wa)
					}

					function Ra(ia, ra, na, wa) {
						var Ja = A.earth;
						const ua = gb * ia[ra];
						var Ia = gb * ia[ra + 1];
						ia = ia[ra + 2];
						ra = Math.sin(Ia);
						Ia = Math.cos(Ia);
						const X =
							Ja.radius / Math.sqrt(1 - Ja.eccentricitySquared * ra * ra);
						na[wa++] = (X + ia) * Ia * Math.cos(ua);
						na[wa++] = (X + ia) * Ia * Math.sin(ua);
						na[wa++] = (X * (1 - Ja.eccentricitySquared) + ia) * ra
					}

					function Wa(ia, ra, na, wa) {
						var Ja = B.earthEllipsoidConstants,
							ua = ia[ra],
							Ia = ia[ra + 1];
						ia = ia[ra + 2];
						let X;
						ra = Math.abs(ia);
						var Ea = ua * ua + Ia * Ia;
						var Ha = Math.sqrt(Ea);
						var La = Ea + ia * ia;
						var Oa = Math.sqrt(La);
						ua = Math.atan2(Ia, ua);
						var Va = ia * ia / La;
						La = Ea / La;
						Ia = Ja.a2 / Oa;
						Ea = Ja.a3 - Ja.a4 / Oa;
						.3 < La ? (Va = ra / Oa * (1 + La * (Ja.a1 + Ia + Va * Ea) / Oa), Oa = Math.asin(Va), Ia = Va * Va, La =
							Math.sqrt(1 - Ia)) : (La = Ha / Oa * (1 - Va * (Ja.a5 - Ia - La * Ea) / Oa), Oa = Math.acos(La), Ia = 1 - La * La, Va = Math.sqrt(Ia));
						X = 1 - A.earth.eccentricitySquared * Ia;
						Ia = A.earth.radius / Math.sqrt(X);
						Ja = Ja.a6 * Ia;
						Ia = Ha - Ia * La;
						Ea = ra - Ja * Va;
						ra = La * Ia + Va * Ea;
						Ha = La * Ea - Va * Ia;
						Ja = Ha / (Ja / X + ra);
						Oa += Ja;
						0 > ia && (Oa = -Oa);
						na[wa++] = kb * ua;
						na[wa++] = kb * Oa;
						na[wa] = ra + Ha * Ja / 2
					}

					function Xa(ia, ra, na, wa) {
						Wa(ia, ra, na, wa);
						aa(na, wa, na, wa)
					}

					function bb(ia, ra, na, wa) {
						Wa(ia, ra, na, wa);
						P(na, wa, na, wa)
					}

					function $a(ia, ra, na = ab()) {
						return k.isNone(ia) || k.isNone(ra) ? null : Ya(ia,
								ra, na)
							.projector
					}

					function Ya(ia, ra, na) {
						if (k.isNone(ia) || k.isNone(ra) || na.source.spatialReference === ia && na.dest.spatialReference === ra) return na;
						const wa = pa(ia, na.source),
							Ja = pa(ra, na.dest);
						wa === fa.UNKNOWN && Ja === fa.UNKNOWN ? z.equals(ia, ra) ? na.projector = xa : na.projector = null : na.projector = Ua[wa][Ja];
						return na
					}

					function ab() {
						return {
							source: {
								spatialReference: null,
								spatialReferenceId: fa.UNKNOWN,
								metersPerUnit: 1
							},
							dest: {
								spatialReference: null,
								spatialReferenceId: fa.UNKNOWN,
								metersPerUnit: 1
							},
							projector: xa
						}
					}
					let Qa = null,
						Ba = null,
						O = null,
						Y = {};
					const ya = new g.SimpleObservable;
					let za = function(ia) {
						function ra() {
							return ia.call(this, "projection:not-loaded", "projection engine not fully loaded yet, please call load()") || this
						}
						c._inheritsLoose(ra, ia);
						return ra
					}(e);
					var fa;
					(function(ia) {
						ia[ia.UNKNOWN = 0] = "UNKNOWN";
						ia[ia.SPHERICAL_ECEF = 1] = "SPHERICAL_ECEF";
						ia[ia.WGS84 = 2] = "WGS84";
						ia[ia.WEB_MERCATOR = 3] = "WEB_MERCATOR";
						ia[ia.WGS84_ECEF = 4] = "WGS84_ECEF";
						ia[ia.CGCS2000 = 5] = "CGCS2000";
						ia[ia.WGS84_COMPARABLE_LON_LAT = 6] = "WGS84_COMPARABLE_LON_LAT";
						ia[ia.SPHERICAL_MARS_PCPF = 7] = "SPHERICAL_MARS_PCPF";
						ia[ia.GCSMARS2000 = 8] = "GCSMARS2000";
						ia[ia.SPHERICAL_MOON_PCPF = 9] = "SPHERICAL_MOON_PCPF";
						ia[ia.GCSMOON2000 = 10] = "GCSMOON2000";
						ia[ia.LON_LAT = 11] = "LON_LAT";
						ia[ia.PLATE_CARREE = 12] = "PLATE_CARREE"
					})(fa || (fa = {}));
					const Pa = A.earth.radius * Math.PI / 180,
						Sa = 180 / (A.earth.radius * Math.PI),
						Ua = {
							[fa.WGS84]: {
								[fa.CGCS2000]: null,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: xa,
								[fa.WGS84_COMPARABLE_LON_LAT]: xa,
								[fa.SPHERICAL_ECEF]: aa,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: P,
								[fa.PLATE_CARREE]: ca,
								[fa.WGS84]: xa,
								[fa.WGS84_ECEF]: Ra
							},
							[fa.CGCS2000]: {
								[fa.CGCS2000]: xa,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: xa,
								[fa.WGS84_COMPARABLE_LON_LAT]: xa,
								[fa.SPHERICAL_ECEF]: aa,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: null,
								[fa.PLATE_CARREE]: ca,
								[fa.WGS84]: null,
								[fa.WGS84_ECEF]: Ra
							},
							[fa.GCSMARS2000]: {
								[fa.CGCS2000]: null,
								[fa.GCSMARS2000]: xa,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: xa,
								[fa.WGS84_COMPARABLE_LON_LAT]: null,
								[fa.SPHERICAL_ECEF]: null,
								[fa.SPHERICAL_MARS_PCPF]: Q,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: null,
								[fa.PLATE_CARREE]: null,
								[fa.WGS84]: null,
								[fa.WGS84_ECEF]: null
							},
							[fa.GCSMOON2000]: {
								[fa.CGCS2000]: null,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: xa,
								[fa.LON_LAT]: xa,
								[fa.WGS84_COMPARABLE_LON_LAT]: null,
								[fa.SPHERICAL_ECEF]: null,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: ma,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: null,
								[fa.PLATE_CARREE]: null,
								[fa.WGS84]: null,
								[fa.WGS84_ECEF]: null
							},
							[fa.WEB_MERCATOR]: {
								[fa.CGCS2000]: null,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: S,
								[fa.WGS84_COMPARABLE_LON_LAT]: S,
								[fa.SPHERICAL_ECEF]: ba,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: xa,
								[fa.PLATE_CARREE]: va,
								[fa.WGS84]: S,
								[fa.WGS84_ECEF]: la
							},
							[fa.WGS84_ECEF]: {
								[fa.CGCS2000]: Wa,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: Wa,
								[fa.WGS84_COMPARABLE_LON_LAT]: Wa,
								[fa.SPHERICAL_ECEF]: Xa,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: bb,
								[fa.PLATE_CARREE]: function(ia, ra, na, wa) {
									Wa(ia, ra, na, wa);
									ca(na, wa, na, wa)
								},
								[fa.WGS84]: Wa,
								[fa.WGS84_ECEF]: xa
							},
							[fa.SPHERICAL_ECEF]: {
								[fa.CGCS2000]: Na,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: Na,
								[fa.WGS84_COMPARABLE_LON_LAT]: Na,
								[fa.SPHERICAL_ECEF]: xa,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: Ma,
								[fa.PLATE_CARREE]: function(ia, ra, na, wa) {
									Na(ia, ra, na, wa);
									ca(na, wa, na, wa)
								},
								[fa.WGS84]: Na,
								[fa.WGS84_ECEF]: Ta
							},
							[fa.SPHERICAL_MARS_PCPF]: {
								[fa.CGCS2000]: null,
								[fa.GCSMARS2000]: Ga,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: Ga,
								[fa.WGS84_COMPARABLE_LON_LAT]: null,
								[fa.SPHERICAL_ECEF]: null,
								[fa.SPHERICAL_MARS_PCPF]: xa,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: null,
								[fa.PLATE_CARREE]: null,
								[fa.WGS84]: null,
								[fa.WGS84_ECEF]: null
							},
							[fa.SPHERICAL_MOON_PCPF]: {
								[fa.CGCS2000]: null,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: Da,
								[fa.LON_LAT]: Da,
								[fa.WGS84_COMPARABLE_LON_LAT]: null,
								[fa.SPHERICAL_ECEF]: null,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: xa,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: null,
								[fa.PLATE_CARREE]: null,
								[fa.WGS84]: null,
								[fa.WGS84_ECEF]: null
							},
							[fa.UNKNOWN]: {
								[fa.CGCS2000]: null,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: null,
								[fa.WGS84_COMPARABLE_LON_LAT]: null,
								[fa.SPHERICAL_ECEF]: null,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: xa,
								[fa.WEB_MERCATOR]: null,
								[fa.PLATE_CARREE]: null,
								[fa.WGS84]: null,
								[fa.WGS84_ECEF]: null
							},
							[fa.LON_LAT]: {
								[fa.CGCS2000]: xa,
								[fa.GCSMARS2000]: xa,
								[fa.GCSMOON2000]: xa,
								[fa.LON_LAT]: xa,
								[fa.WGS84_COMPARABLE_LON_LAT]: xa,
								[fa.SPHERICAL_ECEF]: aa,
								[fa.SPHERICAL_MARS_PCPF]: Q,
								[fa.SPHERICAL_MOON_PCPF]: ma,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: P,
								[fa.PLATE_CARREE]: ca,
								[fa.WGS84]: xa,
								[fa.WGS84_ECEF]: Ra
							},
							[fa.WGS84_COMPARABLE_LON_LAT]: {
								[fa.CGCS2000]: null,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: xa,
								[fa.WGS84_COMPARABLE_LON_LAT]: xa,
								[fa.SPHERICAL_ECEF]: aa,
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: null,
								[fa.PLATE_CARREE]: ca,
								[fa.WGS84]: xa,
								[fa.WGS84_ECEF]: Ra
							},
							[fa.PLATE_CARREE]: {
								[fa.CGCS2000]: ka,
								[fa.GCSMARS2000]: null,
								[fa.GCSMOON2000]: null,
								[fa.LON_LAT]: ka,
								[fa.WGS84_COMPARABLE_LON_LAT]: ka,
								[fa.SPHERICAL_ECEF]: function(ia, ra, na, wa) {
									ka(ia, ra, na, wa);
									aa(na, wa, na, wa)
								},
								[fa.SPHERICAL_MARS_PCPF]: null,
								[fa.SPHERICAL_MOON_PCPF]: null,
								[fa.UNKNOWN]: null,
								[fa.WEB_MERCATOR]: function(ia, ra, na, wa) {
									ka(ia, ra, na, wa);
									P(na, wa, na, wa)
								},
								[fa.PLATE_CARREE]: xa,
								[fa.WGS84]: ka,
								[fa.WGS84_ECEF]: function(ia, ra, na,
									wa) {
									ka(ia, ra, na, wa);
									Ra(na, wa, na, wa)
								}
							}
						},
						Za = {
							spatialReference: null,
							spatialReferenceId: fa.UNKNOWN
						},
						db = {
							spatialReference: null,
							spatialReferenceId: fa.UNKNOWN
						},
						fb = ab(),
						ib = ab(),
						gb = d.deg2rad(1),
						kb = d.rad2deg(1),
						cb = p.create(),
						jb = p.create(),
						lb = p.create(),
						Fa = p.create(),
						hb = p.create();
					b.canProjectToWGS84ComparableLonLat = function(ia) {
						if (k.isNone(ia)) return !1;
						ia = pa(ia, Za);
						return !!Ua[ia][fa.WGS84_COMPARABLE_LON_LAT]
					};
					b.canProjectWithoutEngine = V;
					b.computeENUToSphericalPCPFLocalRotation = N;
					b.computeSphericalPCPFToENULocalRotation =
						ea;
					b.computeTranslationToOriginAndRotation = function(ia, ra, na, wa) {
						if (k.isNone(ia) || k.isNone(wa)) return !1;
						var Ja = pa(ia, Za),
							ua = pa(wa, db);
						if (Ja === ua && ua !== fa.SPHERICAL_ECEF && ua !== fa.SPHERICAL_MARS_PCPF && ua !== fa.SPHERICAL_MOON_PCPF && (Ja !== fa.UNKNOWN || z.equals(ia, wa))) return l.fromTranslation(na, ra), !0;
						if (ua === fa.SPHERICAL_ECEF || ua === fa.SPHERICAL_MARS_PCPF || ua === fa.SPHERICAL_MOON_PCPF) {
							Ja = Ua[Ja][fa.LON_LAT];
							ua = Ua[fa.LON_LAT][ua];
							if (k.isNone(Ja) || k.isNone(ua)) return !1;
							Ja(ra, 0, jb, 0);
							ua(jb, 0, lb, 0);
							N(gb * jb[0],
								gb * jb[1], na);
							na[12] = lb[0];
							na[13] = lb[1];
							na[14] = lb[2];
							return !0
						}
						if ((ua === fa.WEB_MERCATOR || ua === fa.PLATE_CARREE) && (Ja === fa.WGS84 || Ja === fa.CGCS2000 && ua === fa.PLATE_CARREE || Ja === fa.SPHERICAL_ECEF || Ja === fa.WEB_MERCATOR)) {
							ia = Ua[Ja][fa.LON_LAT];
							ua = Ua[fa.LON_LAT][ua];
							if (k.isNone(ia) || k.isNone(ua)) return !1;
							ia(ra, 0, jb, 0);
							ua(jb, 0, lb, 0);
							Ja === fa.SPHERICAL_ECEF ? ea(gb * jb[0], gb * jb[1], na) : l.identity(na);
							na[12] = lb[0];
							na[13] = lb[1];
							na[14] = lb[2];
							return !0
						}
						return !1
					};
					b.getProjectorName = function(ia, ra) {
						switch ($a(ia, ra, fb)) {
							case xa:
								return "copy3";
							case aa:
								return "wgs84ToSphericalECEF";
							case P:
								return "wgs84ToWebMercator";
							case ca:
								return "wgs84ToPlateCarree";
							case Ra:
								return "wgs84ToWGS84ECEF";
							case S:
								return "webMercatorToWGS84";
							case ba:
								return "webMercatorToSphericalECEF";
							case la:
								return "webMercatorToWGS84ECEF";
							case va:
								return "webMercatorToPlateCarree";
							case Wa:
								return "wgs84ECEFToWGS84";
							case Xa:
								return "wgs84ECEFToSphericalECEF";
							case bb:
								return "wgs84ECEFToWebMercator";
							case Na:
								return "sphericalECEFToWGS84";
							case Ma:
								return "sphericalECEFToWebMercator";
							case Ga:
								return "sphericalMarsPCPFToMars2000";
							case Da:
								return "sphericalMoonPCPFToMoon2000";
							case Ta:
								return "sphericalECEFToWGS84ECEF";
							case Q:
								return "mars2000ToSphericalPCPF";
							case ma:
								return "moon2000ToSphericalPCPF";
							default:
								return null
						}
					};
					b.getTransformation = L;
					b.getTransformations = function(ia, ra, na = null) {
						if (k.isNone(Qa) || k.isNone(Ba)) throw new za;
						ia = Qa._getTransformationBySuitability(Ba, ia, ra, na, na ? .spatialReference);
						if (null !== ia) {
							ra = [];
							for (const wa of ia) ra.push(E.fromGE(wa));
							return ra
						}
						return []
					};
					b.initializeProjection = function(ia, ra, na, wa) {
						return U.apply(this,
							arguments)
					};
					b.isLoaded = J;
					b.load = K;
					b.localLinearScaleFactors = function(ia, ra, na, wa) {
						if (k.isNone(ra) || k.isNone(wa)) return !1;
						const Ja = pa(ra, Za);
						var ua = pa(wa, db);
						if (Ja === ua && Ja !== fa.UNKNOWN || z.equals(ra, wa)) return na[0] = 1, na[1] = 1, na[2] = 1, !0;
						if (Ja === fa.SPHERICAL_ECEF) {
							ra = r.length(ia);
							ia = ra / Math.sqrt(ia[0] * ia[0] + ia[1] * ia[1]);
							ra /= A.earth.radius;
							if (ua === fa.WEB_MERCATOR) return na[0] = ia * ra, na[1] = ia * ra, na[2] = 1, !0;
							if (ua === fa.WGS84 || ua === fa.CGCS2000) return ua = Sa, na[0] = ua * ia * ra, na[1] = ua * ra, na[2] = 1, !0
						} else if (Ja ===
							fa.PLATE_CARREE) {
							if (ua === fa.WGS84 || ua === fa.CGCS2000) return na[0] = Sa, na[1] = Sa, na[2] = 1, !0;
							if (ua === fa.WEB_MERCATOR) return ua = ia[1] / A.earth.radius, na[0] = 1, na[1] = 1 / Math.cos(ua), na[2] = 1, !0
						}
						return !1
					};
					b.lonLatToSphericalPCPF = function(ia, ra, na, wa) {
						const Ja = Math.cos(na);
						ia[0] = Math.cos(ra) * Ja * wa;
						ia[1] = Math.sin(ra) * Ja * wa;
						ia[2] = Math.sin(na) * wa
					};
					b.lonLatToWebMercatorComparable = ha;
					b.project = H;
					b.projectBoundingRect = function(ia, ra, na, wa) {
						if (null == ia) return !1;
						if (z.equals(ra, wa)) return w.copy(na, ia), !0;
						cb[0] = ia[0];
						cb[1] = ia[1];
						cb[2] = 0;
						if (!ja(cb, ra, 0, cb, wa, 0, 1)) return !1;
						na[0] = cb[0];
						na[1] = cb[1];
						cb[0] = ia[2];
						cb[1] = ia[3];
						cb[2] = 0;
						if (!ja(cb, ra, 0, cb, wa, 0, 1)) return !1;
						na[2] = cb[0];
						na[3] = cb[1];
						return !0
					};
					b.projectBoundingSphere = function(ia, ra, na, wa) {
						if (k.isNone(ra) || k.isNone(wa)) return !1;
						ra = Ya(ra, wa, ib);
						if (ra.projector === xa) return na[0] = ia[0], na[1] = ia[1], na[2] = ia[2], na[3] = ia[3], !0;
						if (k.isNone(ra.projector)) return !1;
						const {
							source: Ja,
							dest: ua
						} = ra;
						if (ua.spatialReferenceId === fa.WEB_MERCATOR) {
							ra = Ua[Ja.spatialReferenceId][fa.WGS84];
							if (k.isNone(ra)) return !1;
							ra(ia, 0, jb, 0);
							P(jb, 0, na, 0);
							na[3] = I(jb[1], ia[2], ia[3], A.earth.radius);
							return !0
						}
						if (Ja.spatialReferenceId !== fa.WGS84 && Ja.spatialReferenceId !== fa.CGCS2000 || ua.spatialReferenceId !== fa.PLATE_CARREE) ra.projector(ia, 0, na, 0), na[3] = ia[3] * (Ja.metersPerUnit ? ? 1) / (ua.metersPerUnit ? ? 1);
						else {
							wa = Ua[fa.SPHERICAL_ECEF][fa.PLATE_CARREE];
							let Ia = ia[3];
							k.isSome(Ua[Ja.spatialReferenceId][fa.SPHERICAL_ECEF]) && k.isSome(wa) && (Ia = I(ia[1], ia[2], ia[3], A.earth.radius));
							ra.projector(ia, 0, na, 0);
							na[3] = Ia
						}
						return !0
					};
					b.projectBuffer = ja;
					b.projectDirection = function(ia, ra, na, wa, Ja) {
						r.copy(Fa, ia);
						r.add(hb, ia, ra);
						Ka(Fa, na, Fa, Ja);
						Ka(hb, na, hb, Ja);
						r.subtract(wa, hb, Fa);
						r.normalize(wa, wa)
					};
					b.projectExtent = function(ia, ra, na = ra.spatialReference, wa = 0) {
						return k.isSome(ia.spatialReference) && k.isSome(na) && k.isSome(qa(ia, ia.spatialReference, ra, na, wa))
					};
					b.projectMany = G;
					b.projectMultipoint = function(ia, ra, na = ra.spatialReference, wa = 0) {
						return k.isSome(ia.spatialReference) && k.isSome(na) && k.isSome(T(ia, ia.spatialReference, ra, na, wa))
					};
					b.projectOrLoad = function(ia, ra) {
						ia = F([ia], ra);
						return k.isSome(ia.pending) ? {
							pending: ia.pending,
							geometry: null
						} : k.isSome(ia.geometries) ? {
							pending: null,
							geometry: ia.geometries[0]
						} : {
							pending: null,
							geometry: null
						}
					};
					b.projectOrLoadMany = F;
					b.projectPoint = function(ia, ra, na = ra.spatialReference, wa = 0) {
						return k.isSome(na) && k.isSome(ia.spatialReference) && k.isSome(M(ia, ia.spatialReference, ra, na, wa))
					};
					b.projectPointToVector = function(ia, ra, na, wa = 0) {
						Fa[0] = ia.x;
						Fa[1] = ia.y;
						const Ja = ia.z;
						Fa[2] = void 0 !== Ja ? Ja : wa;
						return ja(Fa,
							ia.spatialReference, 0, ra, na, 0, 1)
					};
					b.projectPointToWGS84ComparableLonLat = function(ia, ra) {
						Fa[0] = ia.x;
						Fa[1] = ia.y;
						const na = ia.z;
						Fa[2] = void 0 !== na ? na : 0;
						return da(Fa, ia.spatialReference, ra)
					};
					b.projectPolygon = function(ia, ra, na = ra.spatialReference, wa = 0) {
						return k.isSome(ia.spatialReference) && k.isSome(na) && k.isSome(oa(ia, ia.spatialReference, ra, na, wa))
					};
					b.projectPolygonToWGS84ComparableLonLat = function({
						hasZ: ia,
						spatialReference: ra,
						rings: na
					}, wa, Ja = 0) {
						ra = pa(ra, Za);
						ra = Ua[ra][fa.WGS84_COMPARABLE_LON_LAT];
						if (k.isNone(ra)) return !1;
						ia = ia ? ua => ua : ua => r.set(Fa, ua[0], ua[1], Ja);
						for (const ua of na) {
							na = [];
							for (const Ia of ua) {
								const X = [0, 0, Ja];
								ra(ia(Ia), 0, X, 0);
								na.push(X)
							}
							wa.push(na)
						}
						return !0
					};
					b.projectPolyline = function(ia, ra, na = ra.spatialReference, wa = 0) {
						return k.isSome(ia.spatialReference) && k.isSome(na) && k.isSome(Z(ia, ia.spatialReference, ra, na, wa))
					};
					b.projectPolylineToWGS84ComparableLonLat = function({
						hasZ: ia,
						spatialReference: ra,
						paths: na
					}, wa, Ja = 0) {
						ra = pa(ra, Za);
						ra = Ua[ra][fa.WGS84_COMPARABLE_LON_LAT];
						if (k.isNone(ra)) return !1;
						ia = ia ? ua => ua :
							ua => r.set(Fa, ua[0], ua[1], Ja);
						for (const ua of na) {
							na = [];
							for (const Ia of ua) {
								const X = [0, 0, Ja];
								ra(ia(Ia), 0, X, 0);
								na.push(X)
							}
							wa.push(na)
						}
						return !0
					};
					b.projectVectorToDehydratedPoint = function(ia, ra, na) {
						return ja(ia, ra, 0, Fa, na.spatialReference, 0, 1) ? (na.x = Fa[0], na.y = Fa[1], na.z = Fa[2], na) : null
					};
					b.projectVectorToPoint = function(ia, ra, na) {
						if (k.isNone(ra) || k.isNone(na)) return null;
						const wa = new q({
							spatialReference: na
						});
						return ja(ia, ra, 0, Fa, na, 0, 1) ? (wa.x = Fa[0], wa.y = Fa[1], wa.z = Fa[2], wa) : null
					};
					b.projectVectorToVector =
						Ka;
					b.projectVectorToWGS84ComparableLonLat = function(ia, ra, na) {
						return da(ia, ra, na)
					};
					b.projectWithoutEngine = W;
					b.projectXYZToVector = Aa;
					b.sphericalPCPFtoLonLatElevation = ta;
					b.test = {
						get loadPromise() {
							return O
						}
					};
					b.tryProjectWithZConversion = R;
					b.unload = function() {
						O = Ba = Qa = null;
						Y = {}
					};
					Object.defineProperties(b, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/chunks/mat4": function() {
			define(["exports", "./vec3f64", "./common"], function(a, b, c) {
				function e(I, N) {
					I[0] = N[0];
					I[1] = N[1];
					I[2] = N[2];
					I[3] =
						N[3];
					I[4] = N[4];
					I[5] = N[5];
					I[6] = N[6];
					I[7] = N[7];
					I[8] = N[8];
					I[9] = N[9];
					I[10] = N[10];
					I[11] = N[11];
					I[12] = N[12];
					I[13] = N[13];
					I[14] = N[14];
					I[15] = N[15];
					return I
				}

				function d(I, N, ea, pa, xa, S, ba, la, ha, P, ca, ka, va, Ca, ma, Q, aa) {
					I[0] = N;
					I[1] = ea;
					I[2] = pa;
					I[3] = xa;
					I[4] = S;
					I[5] = ba;
					I[6] = la;
					I[7] = ha;
					I[8] = P;
					I[9] = ca;
					I[10] = ka;
					I[11] = va;
					I[12] = Ca;
					I[13] = ma;
					I[14] = Q;
					I[15] = aa;
					return I
				}

				function k(I) {
					I[0] = 1;
					I[1] = 0;
					I[2] = 0;
					I[3] = 0;
					I[4] = 0;
					I[5] = 1;
					I[6] = 0;
					I[7] = 0;
					I[8] = 0;
					I[9] = 0;
					I[10] = 1;
					I[11] = 0;
					I[12] = 0;
					I[13] = 0;
					I[14] = 0;
					I[15] = 1;
					return I
				}

				function v(I, N) {
					if (I ===
						N) {
						const ea = N[1],
							pa = N[2],
							xa = N[3],
							S = N[6],
							ba = N[7],
							la = N[11];
						I[1] = N[4];
						I[2] = N[8];
						I[3] = N[12];
						I[4] = ea;
						I[6] = N[9];
						I[7] = N[13];
						I[8] = pa;
						I[9] = S;
						I[11] = N[14];
						I[12] = xa;
						I[13] = ba;
						I[14] = la
					} else I[0] = N[0], I[1] = N[4], I[2] = N[8], I[3] = N[12], I[4] = N[1], I[5] = N[5], I[6] = N[9], I[7] = N[13], I[8] = N[2], I[9] = N[6], I[10] = N[10], I[11] = N[14], I[12] = N[3], I[13] = N[7], I[14] = N[11], I[15] = N[15];
					return I
				}

				function m(I, N) {
					const ea = N[0],
						pa = N[1],
						xa = N[2],
						S = N[3],
						ba = N[4],
						la = N[5],
						ha = N[6],
						P = N[7],
						ca = N[8],
						ka = N[9],
						va = N[10],
						Ca = N[11],
						ma = N[12],
						Q = N[13],
						aa = N[14];
					N = N[15];
					const ta = ea * la - pa * ba,
						Da = ea * ha - xa * ba,
						Ga = ea * P - S * ba,
						Na = pa * ha - xa * la,
						Ma = pa * P - S * la,
						Ta = xa * P - S * ha,
						Ra = ca * Q - ka * ma,
						Wa = ca * aa - va * ma,
						Xa = ca * N - Ca * ma,
						bb = ka * aa - va * Q,
						$a = ka * N - Ca * Q,
						Ya = va * N - Ca * aa;
					let ab = ta * Ya - Da * $a + Ga * bb + Na * Xa - Ma * Wa + Ta * Ra;
					if (!ab) return null;
					ab = 1 / ab;
					I[0] = (la * Ya - ha * $a + P * bb) * ab;
					I[1] = (xa * $a - pa * Ya - S * bb) * ab;
					I[2] = (Q * Ta - aa * Ma + N * Na) * ab;
					I[3] = (va * Ma - ka * Ta - Ca * Na) * ab;
					I[4] = (ha * Xa - ba * Ya - P * Wa) * ab;
					I[5] = (ea * Ya - xa * Xa + S * Wa) * ab;
					I[6] = (aa * Ga - ma * Ta - N * Da) * ab;
					I[7] = (ca * Ta - va * Ga + Ca * Da) * ab;
					I[8] = (ba * $a - la * Xa + P * Ra) * ab;
					I[9] =
						(pa * Xa - ea * $a - S * Ra) * ab;
					I[10] = (ma * Ma - Q * Ga + N * ta) * ab;
					I[11] = (ka * Ga - ca * Ma - Ca * ta) * ab;
					I[12] = (la * Wa - ba * bb - ha * Ra) * ab;
					I[13] = (ea * bb - pa * Wa + xa * Ra) * ab;
					I[14] = (Q * Da - ma * Na - aa * ta) * ab;
					I[15] = (ca * Na - ka * Da + va * ta) * ab;
					return I
				}

				function f(I, N) {
					const ea = N[0],
						pa = N[1],
						xa = N[2],
						S = N[3],
						ba = N[4],
						la = N[5],
						ha = N[6],
						P = N[7],
						ca = N[8],
						ka = N[9],
						va = N[10],
						Ca = N[11],
						ma = N[12],
						Q = N[13],
						aa = N[14];
					N = N[15];
					I[0] = la * (va * N - Ca * aa) - ka * (ha * N - P * aa) + Q * (ha * Ca - P * va);
					I[1] = -(pa * (va * N - Ca * aa) - ka * (xa * N - S * aa) + Q * (xa * Ca - S * va));
					I[2] = pa * (ha * N - P * aa) - la * (xa * N - S * aa) + Q * (xa * P -
						S * ha);
					I[3] = -(pa * (ha * Ca - P * va) - la * (xa * Ca - S * va) + ka * (xa * P - S * ha));
					I[4] = -(ba * (va * N - Ca * aa) - ca * (ha * N - P * aa) + ma * (ha * Ca - P * va));
					I[5] = ea * (va * N - Ca * aa) - ca * (xa * N - S * aa) + ma * (xa * Ca - S * va);
					I[6] = -(ea * (ha * N - P * aa) - ba * (xa * N - S * aa) + ma * (xa * P - S * ha));
					I[7] = ea * (ha * Ca - P * va) - ba * (xa * Ca - S * va) + ca * (xa * P - S * ha);
					I[8] = ba * (ka * N - Ca * Q) - ca * (la * N - P * Q) + ma * (la * Ca - P * ka);
					I[9] = -(ea * (ka * N - Ca * Q) - ca * (pa * N - S * Q) + ma * (pa * Ca - S * ka));
					I[10] = ea * (la * N - P * Q) - ba * (pa * N - S * Q) + ma * (pa * P - S * la);
					I[11] = -(ea * (la * Ca - P * ka) - ba * (pa * Ca - S * ka) + ca * (pa * P - S * la));
					I[12] = -(ba * (ka * aa - va *
						Q) - ca * (la * aa - ha * Q) + ma * (la * va - ha * ka));
					I[13] = ea * (ka * aa - va * Q) - ca * (pa * aa - xa * Q) + ma * (pa * va - xa * ka);
					I[14] = -(ea * (la * aa - ha * Q) - ba * (pa * aa - xa * Q) + ma * (pa * ha - xa * la));
					I[15] = ea * (la * va - ha * ka) - ba * (pa * va - xa * ka) + ca * (pa * ha - xa * la);
					return I
				}

				function g(I) {
					const N = I[0],
						ea = I[1],
						pa = I[2],
						xa = I[3],
						S = I[4],
						ba = I[5],
						la = I[6],
						ha = I[7],
						P = I[8],
						ca = I[9],
						ka = I[10],
						va = I[11],
						Ca = I[12],
						ma = I[13],
						Q = I[14];
					I = I[15];
					return (N * ba - ea * S) * (ka * I - va * Q) - (N * la - pa * S) * (ca * I - va * ma) + (N * ha - xa * S) * (ca * Q - ka * ma) + (ea * la - pa * ba) * (P * I - va * Ca) - (ea * ha - xa * ba) * (P * Q - ka * Ca) + (pa *
						ha - xa * la) * (P * ma - ca * Ca)
				}

				function l(I, N, ea) {
					const pa = N[0],
						xa = N[1],
						S = N[2],
						ba = N[3],
						la = N[4],
						ha = N[5],
						P = N[6],
						ca = N[7],
						ka = N[8],
						va = N[9],
						Ca = N[10],
						ma = N[11],
						Q = N[12],
						aa = N[13],
						ta = N[14];
					N = N[15];
					let Da = ea[0],
						Ga = ea[1],
						Na = ea[2],
						Ma = ea[3];
					I[0] = Da * pa + Ga * la + Na * ka + Ma * Q;
					I[1] = Da * xa + Ga * ha + Na * va + Ma * aa;
					I[2] = Da * S + Ga * P + Na * Ca + Ma * ta;
					I[3] = Da * ba + Ga * ca + Na * ma + Ma * N;
					Da = ea[4];
					Ga = ea[5];
					Na = ea[6];
					Ma = ea[7];
					I[4] = Da * pa + Ga * la + Na * ka + Ma * Q;
					I[5] = Da * xa + Ga * ha + Na * va + Ma * aa;
					I[6] = Da * S + Ga * P + Na * Ca + Ma * ta;
					I[7] = Da * ba + Ga * ca + Na * ma + Ma * N;
					Da = ea[8];
					Ga = ea[9];
					Na = ea[10];
					Ma = ea[11];
					I[8] = Da * pa + Ga * la + Na * ka + Ma * Q;
					I[9] = Da * xa + Ga * ha + Na * va + Ma * aa;
					I[10] = Da * S + Ga * P + Na * Ca + Ma * ta;
					I[11] = Da * ba + Ga * ca + Na * ma + Ma * N;
					Da = ea[12];
					Ga = ea[13];
					Na = ea[14];
					Ma = ea[15];
					I[12] = Da * pa + Ga * la + Na * ka + Ma * Q;
					I[13] = Da * xa + Ga * ha + Na * va + Ma * aa;
					I[14] = Da * S + Ga * P + Na * Ca + Ma * ta;
					I[15] = Da * ba + Ga * ca + Na * ma + Ma * N;
					return I
				}

				function r(I, N, ea) {
					const pa = ea[0],
						xa = ea[1];
					ea = ea[2];
					if (N === I) I[12] = N[0] * pa + N[4] * xa + N[8] * ea + N[12], I[13] = N[1] * pa + N[5] * xa + N[9] * ea + N[13], I[14] = N[2] * pa + N[6] * xa + N[10] * ea + N[14], I[15] = N[3] * pa + N[7] * xa + N[11] * ea + N[15];
					else {
						const S =
							N[0],
							ba = N[1],
							la = N[2],
							ha = N[3],
							P = N[4],
							ca = N[5],
							ka = N[6],
							va = N[7],
							Ca = N[8],
							ma = N[9],
							Q = N[10],
							aa = N[11];
						I[0] = S;
						I[1] = ba;
						I[2] = la;
						I[3] = ha;
						I[4] = P;
						I[5] = ca;
						I[6] = ka;
						I[7] = va;
						I[8] = Ca;
						I[9] = ma;
						I[10] = Q;
						I[11] = aa;
						I[12] = S * pa + P * xa + Ca * ea + N[12];
						I[13] = ba * pa + ca * xa + ma * ea + N[13];
						I[14] = la * pa + ka * xa + Q * ea + N[14];
						I[15] = ha * pa + va * xa + aa * ea + N[15]
					}
					return I
				}

				function p(I, N, ea) {
					const pa = ea[0],
						xa = ea[1];
					ea = ea[2];
					I[0] = N[0] * pa;
					I[1] = N[1] * pa;
					I[2] = N[2] * pa;
					I[3] = N[3] * pa;
					I[4] = N[4] * xa;
					I[5] = N[5] * xa;
					I[6] = N[6] * xa;
					I[7] = N[7] * xa;
					I[8] = N[8] * ea;
					I[9] = N[9] * ea;
					I[10] =
						N[10] * ea;
					I[11] = N[11] * ea;
					I[12] = N[12];
					I[13] = N[13];
					I[14] = N[14];
					I[15] = N[15];
					return I
				}

				function n(I, N, ea, pa) {
					let xa = pa[0],
						S = pa[1];
					pa = pa[2];
					let ba = Math.sqrt(xa * xa + S * S + pa * pa);
					var la = void 0,
						ha = void 0;
					let P = void 0,
						ca = void 0,
						ka = void 0,
						va = void 0,
						Ca = void 0,
						ma = void 0,
						Q = void 0,
						aa = void 0,
						ta = void 0,
						Da = void 0,
						Ga = void 0,
						Na = void 0,
						Ma = void 0,
						Ta = void 0,
						Ra = void 0,
						Wa = void 0,
						Xa = void 0,
						bb = void 0,
						$a = void 0,
						Ya = void 0;
					ha = la = void 0;
					if (ba < c.getEpsilon()) return null;
					ba = 1 / ba;
					xa *= ba;
					S *= ba;
					pa *= ba;
					la = Math.sin(ea);
					ha = Math.cos(ea);
					P =
						1 - ha;
					ca = N[0];
					ka = N[1];
					va = N[2];
					Ca = N[3];
					ma = N[4];
					Q = N[5];
					aa = N[6];
					ta = N[7];
					Da = N[8];
					Ga = N[9];
					Na = N[10];
					Ma = N[11];
					Ta = xa * xa * P + ha;
					Ra = S * xa * P + pa * la;
					Wa = pa * xa * P - S * la;
					Xa = xa * S * P - pa * la;
					bb = S * S * P + ha;
					$a = pa * S * P + xa * la;
					Ya = xa * pa * P + S * la;
					la = S * pa * P - xa * la;
					ha = pa * pa * P + ha;
					I[0] = ca * Ta + ma * Ra + Da * Wa;
					I[1] = ka * Ta + Q * Ra + Ga * Wa;
					I[2] = va * Ta + aa * Ra + Na * Wa;
					I[3] = Ca * Ta + ta * Ra + Ma * Wa;
					I[4] = ca * Xa + ma * bb + Da * $a;
					I[5] = ka * Xa + Q * bb + Ga * $a;
					I[6] = va * Xa + aa * bb + Na * $a;
					I[7] = Ca * Xa + ta * bb + Ma * $a;
					I[8] = ca * Ya + ma * la + Da * ha;
					I[9] = ka * Ya + Q * la + Ga * ha;
					I[10] = va * Ya + aa * la + Na * ha;
					I[11] = Ca * Ya +
						ta * la + Ma * ha;
					N !== I && (I[12] = N[12], I[13] = N[13], I[14] = N[14], I[15] = N[15]);
					return I
				}

				function t(I, N, ea) {
					const pa = Math.sin(ea);
					ea = Math.cos(ea);
					const xa = N[4],
						S = N[5],
						ba = N[6],
						la = N[7],
						ha = N[8],
						P = N[9],
						ca = N[10],
						ka = N[11];
					N !== I && (I[0] = N[0], I[1] = N[1], I[2] = N[2], I[3] = N[3], I[12] = N[12], I[13] = N[13], I[14] = N[14], I[15] = N[15]);
					I[4] = xa * ea + ha * pa;
					I[5] = S * ea + P * pa;
					I[6] = ba * ea + ca * pa;
					I[7] = la * ea + ka * pa;
					I[8] = ha * ea - xa * pa;
					I[9] = P * ea - S * pa;
					I[10] = ca * ea - ba * pa;
					I[11] = ka * ea - la * pa;
					return I
				}

				function h(I, N, ea) {
					const pa = Math.sin(ea);
					ea = Math.cos(ea);
					const xa = N[0],
						S = N[1],
						ba = N[2],
						la = N[3],
						ha = N[8],
						P = N[9],
						ca = N[10],
						ka = N[11];
					N !== I && (I[4] = N[4], I[5] = N[5], I[6] = N[6], I[7] = N[7], I[12] = N[12], I[13] = N[13], I[14] = N[14], I[15] = N[15]);
					I[0] = xa * ea - ha * pa;
					I[1] = S * ea - P * pa;
					I[2] = ba * ea - ca * pa;
					I[3] = la * ea - ka * pa;
					I[8] = xa * pa + ha * ea;
					I[9] = S * pa + P * ea;
					I[10] = ba * pa + ca * ea;
					I[11] = la * pa + ka * ea;
					return I
				}

				function q(I, N, ea) {
					const pa = Math.sin(ea);
					ea = Math.cos(ea);
					const xa = N[0],
						S = N[1],
						ba = N[2],
						la = N[3],
						ha = N[4],
						P = N[5],
						ca = N[6],
						ka = N[7];
					N !== I && (I[8] = N[8], I[9] = N[9], I[10] = N[10], I[11] = N[11], I[12] = N[12], I[13] =
						N[13], I[14] = N[14], I[15] = N[15]);
					I[0] = xa * ea + ha * pa;
					I[1] = S * ea + P * pa;
					I[2] = ba * ea + ca * pa;
					I[3] = la * ea + ka * pa;
					I[4] = ha * ea - xa * pa;
					I[5] = P * ea - S * pa;
					I[6] = ca * ea - ba * pa;
					I[7] = ka * ea - la * pa;
					return I
				}

				function u(I, N) {
					I[0] = 1;
					I[1] = 0;
					I[2] = 0;
					I[3] = 0;
					I[4] = 0;
					I[5] = 1;
					I[6] = 0;
					I[7] = 0;
					I[8] = 0;
					I[9] = 0;
					I[10] = 1;
					I[11] = 0;
					I[12] = N[0];
					I[13] = N[1];
					I[14] = N[2];
					I[15] = 1;
					return I
				}

				function x(I, N) {
					I[0] = N[0];
					I[1] = 0;
					I[2] = 0;
					I[3] = 0;
					I[4] = 0;
					I[5] = N[1];
					I[6] = 0;
					I[7] = 0;
					I[8] = 0;
					I[9] = 0;
					I[10] = N[2];
					I[11] = 0;
					I[12] = 0;
					I[13] = 0;
					I[14] = 0;
					I[15] = 1;
					return I
				}

				function y(I, N, ea) {
					if (0 ===
						N) return k(I);
					let pa = ea[0],
						xa = ea[1];
					ea = ea[2];
					let S = Math.sqrt(pa * pa + xa * xa + ea * ea),
						ba = void 0,
						la = void 0,
						ha = void 0;
					if (S < c.getEpsilon()) return null;
					S = 1 / S;
					pa *= S;
					xa *= S;
					ea *= S;
					ba = Math.sin(N);
					la = Math.cos(N);
					ha = 1 - la;
					I[0] = pa * pa * ha + la;
					I[1] = xa * pa * ha + ea * ba;
					I[2] = ea * pa * ha - xa * ba;
					I[3] = 0;
					I[4] = pa * xa * ha - ea * ba;
					I[5] = xa * xa * ha + la;
					I[6] = ea * xa * ha + pa * ba;
					I[7] = 0;
					I[8] = pa * ea * ha + xa * ba;
					I[9] = xa * ea * ha - pa * ba;
					I[10] = ea * ea * ha + la;
					I[11] = 0;
					I[12] = 0;
					I[13] = 0;
					I[14] = 0;
					I[15] = 1;
					return I
				}

				function w(I, N) {
					const ea = Math.sin(N);
					N = Math.cos(N);
					I[0] = 1;
					I[1] =
						0;
					I[2] = 0;
					I[3] = 0;
					I[4] = 0;
					I[5] = N;
					I[6] = ea;
					I[7] = 0;
					I[8] = 0;
					I[9] = -ea;
					I[10] = N;
					I[11] = 0;
					I[12] = 0;
					I[13] = 0;
					I[14] = 0;
					I[15] = 1;
					return I
				}

				function A(I, N) {
					const ea = Math.sin(N);
					N = Math.cos(N);
					I[0] = N;
					I[1] = 0;
					I[2] = -ea;
					I[3] = 0;
					I[4] = 0;
					I[5] = 1;
					I[6] = 0;
					I[7] = 0;
					I[8] = ea;
					I[9] = 0;
					I[10] = N;
					I[11] = 0;
					I[12] = 0;
					I[13] = 0;
					I[14] = 0;
					I[15] = 1;
					return I
				}

				function B(I, N) {
					const ea = Math.sin(N);
					N = Math.cos(N);
					I[0] = N;
					I[1] = ea;
					I[2] = 0;
					I[3] = 0;
					I[4] = -ea;
					I[5] = N;
					I[6] = 0;
					I[7] = 0;
					I[8] = 0;
					I[9] = 0;
					I[10] = 1;
					I[11] = 0;
					I[12] = 0;
					I[13] = 0;
					I[14] = 0;
					I[15] = 1;
					return I
				}

				function E(I, N, ea) {
					var pa =
						N[0],
						xa = N[1],
						S = N[2],
						ba = N[3],
						la = pa + pa,
						ha = xa + xa;
					const P = S + S;
					N = pa * la;
					const ca = pa * ha;
					pa *= P;
					const ka = xa * ha;
					xa *= P;
					S *= P;
					la *= ba;
					ha *= ba;
					ba *= P;
					I[0] = 1 - (ka + S);
					I[1] = ca + ba;
					I[2] = pa - ha;
					I[3] = 0;
					I[4] = ca - ba;
					I[5] = 1 - (N + S);
					I[6] = xa + la;
					I[7] = 0;
					I[8] = pa + ha;
					I[9] = xa - la;
					I[10] = 1 - (N + ka);
					I[11] = 0;
					I[12] = ea[0];
					I[13] = ea[1];
					I[14] = ea[2];
					I[15] = 1;
					return I
				}

				function z(I, N) {
					const ea = sa,
						pa = -N[0],
						xa = -N[1],
						S = -N[2],
						ba = N[3],
						la = N[4],
						ha = N[5],
						P = N[6],
						ca = N[7],
						ka = pa * pa + xa * xa + S * S + ba * ba;
					0 < ka ? (ea[0] = 2 * (la * ba + ca * pa + ha * S - P * xa) / ka, ea[1] = 2 * (ha * ba + ca * xa + P * pa -
						la * S) / ka, ea[2] = 2 * (P * ba + ca * S + la * xa - ha * pa) / ka) : (ea[0] = 2 * (la * ba + ca * pa + ha * S - P * xa), ea[1] = 2 * (ha * ba + ca * xa + P * pa - la * S), ea[2] = 2 * (P * ba + ca * S + la * xa - ha * pa));
					E(I, N, ea);
					return I
				}

				function C(I, N) {
					I[0] = N[12];
					I[1] = N[13];
					I[2] = N[14];
					return I
				}

				function D(I, N) {
					const ea = N[0],
						pa = N[1],
						xa = N[2],
						S = N[4],
						ba = N[5],
						la = N[6],
						ha = N[8],
						P = N[9];
					N = N[10];
					I[0] = Math.sqrt(ea * ea + pa * pa + xa * xa);
					I[1] = Math.sqrt(S * S + ba * ba + la * la);
					I[2] = Math.sqrt(ha * ha + P * P + N * N);
					return I
				}

				function J(I, N) {
					const ea = N[0] + N[5] + N[10];
					let pa = 0;
					0 < ea ? (pa = 2 * Math.sqrt(ea + 1), I[3] = .25 *
						pa, I[0] = (N[6] - N[9]) / pa, I[1] = (N[8] - N[2]) / pa, I[2] = (N[1] - N[4]) / pa) : N[0] > N[5] && N[0] > N[10] ? (pa = 2 * Math.sqrt(1 + N[0] - N[5] - N[10]), I[3] = (N[6] - N[9]) / pa, I[0] = .25 * pa, I[1] = (N[1] + N[4]) / pa, I[2] = (N[8] + N[2]) / pa) : N[5] > N[10] ? (pa = 2 * Math.sqrt(1 + N[5] - N[0] - N[10]), I[3] = (N[8] - N[2]) / pa, I[0] = (N[1] + N[4]) / pa, I[1] = .25 * pa, I[2] = (N[6] + N[9]) / pa) : (pa = 2 * Math.sqrt(1 + N[10] - N[0] - N[5]), I[3] = (N[1] - N[4]) / pa, I[0] = (N[8] + N[2]) / pa, I[1] = (N[6] + N[9]) / pa, I[2] = .25 * pa);
					return I
				}

				function K(I, N, ea, pa) {
					var xa = N[0],
						S = N[1],
						ba = N[2],
						la = N[3],
						ha = xa + xa,
						P = S + S,
						ca = ba + ba;
					N = xa * ha;
					const ka = xa * P;
					xa *= ca;
					const va = S * P;
					S *= ca;
					ba *= ca;
					ha *= la;
					P *= la;
					la *= ca;
					ca = pa[0];
					const Ca = pa[1];
					pa = pa[2];
					I[0] = (1 - (va + ba)) * ca;
					I[1] = (ka + la) * ca;
					I[2] = (xa - P) * ca;
					I[3] = 0;
					I[4] = (ka - la) * Ca;
					I[5] = (1 - (N + ba)) * Ca;
					I[6] = (S + ha) * Ca;
					I[7] = 0;
					I[8] = (xa + P) * pa;
					I[9] = (S - ha) * pa;
					I[10] = (1 - (N + va)) * pa;
					I[11] = 0;
					I[12] = ea[0];
					I[13] = ea[1];
					I[14] = ea[2];
					I[15] = 1;
					return I
				}

				function H(I, N, ea, pa, xa) {
					var S = N[0],
						ba = N[1],
						la = N[2],
						ha = N[3],
						P = S + S,
						ca = ba + ba,
						ka = la + la;
					N = S * P;
					var va = S * ca,
						Ca = S * ka;
					S = ba * ca;
					ba *= ka;
					var ma = la * ka;
					la = ha * P;
					ca *= ha;
					const Q =
						ha * ka;
					var aa = pa[0],
						ta = pa[1];
					ka = pa[2];
					pa = xa[0];
					ha = xa[1];
					xa = xa[2];
					P = (1 - (S + ma)) * aa;
					const Da = (va + Q) * aa;
					aa *= Ca - ca;
					va = (va - Q) * ta;
					ma = (1 - (N + ma)) * ta;
					ta *= ba + la;
					Ca = (Ca + ca) * ka;
					ba = (ba - la) * ka;
					N = (1 - (N + S)) * ka;
					I[0] = P;
					I[1] = Da;
					I[2] = aa;
					I[3] = 0;
					I[4] = va;
					I[5] = ma;
					I[6] = ta;
					I[7] = 0;
					I[8] = Ca;
					I[9] = ba;
					I[10] = N;
					I[11] = 0;
					I[12] = ea[0] + pa - (P * pa + va * ha + Ca * xa);
					I[13] = ea[1] + ha - (Da * pa + ma * ha + ba * xa);
					I[14] = ea[2] + xa - (aa * pa + ta * ha + N * xa);
					I[15] = 1;
					return I
				}

				function G(I, N) {
					var ea = N[0],
						pa = N[1],
						xa = N[2];
					N = N[3];
					var S = ea + ea,
						ba = pa + pa;
					const la = xa + xa;
					ea *= S;
					const ha =
						pa * S;
					pa *= ba;
					const P = xa * S,
						ca = xa * ba;
					xa *= la;
					S *= N;
					ba *= N;
					N *= la;
					I[0] = 1 - pa - xa;
					I[1] = ha + N;
					I[2] = P - ba;
					I[3] = 0;
					I[4] = ha - N;
					I[5] = 1 - ea - xa;
					I[6] = ca + S;
					I[7] = 0;
					I[8] = P + ba;
					I[9] = ca - S;
					I[10] = 1 - ea - pa;
					I[11] = 0;
					I[12] = 0;
					I[13] = 0;
					I[14] = 0;
					I[15] = 1;
					return I
				}

				function F(I, N, ea, pa, xa, S, ba) {
					const la = 1 / (ea - N),
						ha = 1 / (xa - pa),
						P = 1 / (S - ba);
					I[0] = 2 * S * la;
					I[1] = 0;
					I[2] = 0;
					I[3] = 0;
					I[4] = 0;
					I[5] = 2 * S * ha;
					I[6] = 0;
					I[7] = 0;
					I[8] = (ea + N) * la;
					I[9] = (xa + pa) * ha;
					I[10] = (ba + S) * P;
					I[11] = -1;
					I[12] = 0;
					I[13] = 0;
					I[14] = ba * S * 2 * P;
					I[15] = 0;
					return I
				}

				function L(I, N, ea, pa, xa) {
					N = 1 / Math.tan(N /
						2);
					let S = void 0;
					I[0] = N / ea;
					I[1] = 0;
					I[2] = 0;
					I[3] = 0;
					I[4] = 0;
					I[5] = N;
					I[6] = 0;
					I[7] = 0;
					I[8] = 0;
					I[9] = 0;
					I[11] = -1;
					I[12] = 0;
					I[13] = 0;
					I[15] = 0;
					null != xa && Infinity !== xa ? (S = 1 / (pa - xa), I[10] = (xa + pa) * S, I[14] = 2 * xa * pa * S) : (I[10] = -1, I[14] = -2 * pa);
					return I
				}

				function R(I, N, ea, pa) {
					const xa = Math.tan(N.upDegrees * Math.PI / 180),
						S = Math.tan(N.downDegrees * Math.PI / 180),
						ba = Math.tan(N.leftDegrees * Math.PI / 180);
					N = Math.tan(N.rightDegrees * Math.PI / 180);
					const la = 2 / (ba + N),
						ha = 2 / (xa + S);
					I[0] = la;
					I[1] = 0;
					I[2] = 0;
					I[3] = 0;
					I[4] = 0;
					I[5] = ha;
					I[6] = 0;
					I[7] = 0;
					I[8] = -((ba -
						N) * la * .5);
					I[9] = (xa - S) * ha * .5;
					I[10] = pa / (ea - pa);
					I[11] = -1;
					I[12] = 0;
					I[13] = 0;
					I[14] = pa * ea / (ea - pa);
					I[15] = 0;
					return I
				}

				function V(I, N, ea, pa, xa, S, ba) {
					const la = 1 / (N - ea),
						ha = 1 / (pa - xa),
						P = 1 / (S - ba);
					I[0] = -2 * la;
					I[1] = 0;
					I[2] = 0;
					I[3] = 0;
					I[4] = 0;
					I[5] = -2 * ha;
					I[6] = 0;
					I[7] = 0;
					I[8] = 0;
					I[9] = 0;
					I[10] = 2 * P;
					I[11] = 0;
					I[12] = (N + ea) * la;
					I[13] = (xa + pa) * ha;
					I[14] = (ba + S) * P;
					I[15] = 1;
					return I
				}

				function U(I, N, ea, pa) {
					var xa = void 0;
					let S = void 0;
					var ba = void 0,
						la = void 0;
					let ha = void 0,
						P = void 0;
					var ca = void 0,
						ka = void 0;
					let va = void 0,
						Ca = void 0;
					const ma = N[0],
						Q = N[1];
					N = N[2];
					ba = pa[0];
					la = pa[1];
					pa = pa[2];
					ca = ea[0];
					ka = ea[1];
					ea = ea[2];
					xa = c.getEpsilon();
					if (Math.abs(ma - ca) < xa && Math.abs(Q - ka) < xa && Math.abs(N - ea) < xa) return k(I);
					ca = ma - ca;
					ka = Q - ka;
					va = N - ea;
					Ca = 1 / Math.sqrt(ca * ca + ka * ka + va * va);
					ca *= Ca;
					ka *= Ca;
					va *= Ca;
					xa = la * va - pa * ka;
					S = pa * ca - ba * va;
					ba = ba * ka - la * ca;
					(Ca = Math.sqrt(xa * xa + S * S + ba * ba)) ? (Ca = 1 / Ca, xa *= Ca, S *= Ca, ba *= Ca) : ba = S = xa = 0;
					la = ka * ba - va * S;
					ha = va * xa - ca * ba;
					P = ca * S - ka * xa;
					(Ca = Math.sqrt(la * la + ha * ha + P * P)) ? (Ca = 1 / Ca, la *= Ca, ha *= Ca, P *= Ca) : P = ha = la = 0;
					I[0] = xa;
					I[1] = la;
					I[2] = ca;
					I[3] = 0;
					I[4] = S;
					I[5] =
						ha;
					I[6] = ka;
					I[7] = 0;
					I[8] = ba;
					I[9] = P;
					I[10] = va;
					I[11] = 0;
					I[12] = -(xa * ma + S * Q + ba * N);
					I[13] = -(la * ma + ha * Q + P * N);
					I[14] = -(ca * ma + ka * Q + va * N);
					I[15] = 1;
					return I
				}

				function W(I, N, ea, pa) {
					const xa = N[0],
						S = N[1];
					N = N[2];
					var ba = pa[0];
					const la = pa[1];
					var ha = pa[2];
					pa = xa - ea[0];
					let P = S - ea[1];
					ea = N - ea[2];
					let ca = pa * pa + P * P + ea * ea;
					0 < ca && (ca = 1 / Math.sqrt(ca), pa *= ca, P *= ca, ea *= ca);
					let ka = la * ea - ha * P;
					ha = ha * pa - ba * ea;
					ba = ba * P - la * pa;
					ca = ka * ka + ha * ha + ba * ba;
					0 < ca && (ca = 1 / Math.sqrt(ca), ka *= ca, ha *= ca, ba *= ca);
					I[0] = ka;
					I[1] = ha;
					I[2] = ba;
					I[3] = 0;
					I[4] = P * ba - ea * ha;
					I[5] = ea * ka - pa * ba;
					I[6] = pa * ha - P * ka;
					I[7] = 0;
					I[8] = pa;
					I[9] = P;
					I[10] = ea;
					I[11] = 0;
					I[12] = xa;
					I[13] = S;
					I[14] = N;
					I[15] = 1;
					return I
				}

				function M(I) {
					return "mat4(" + I[0] + ", " + I[1] + ", " + I[2] + ", " + I[3] + ", " + I[4] + ", " + I[5] + ", " + I[6] + ", " + I[7] + ", " + I[8] + ", " + I[9] + ", " + I[10] + ", " + I[11] + ", " + I[12] + ", " + I[13] + ", " + I[14] + ", " + I[15] + ")"
				}

				function T(I) {
					return Math.sqrt(I[0] ** 2 + I[1] ** 2 + I[2] ** 2 + I[3] ** 2 + I[4] ** 2 + I[5] ** 2 + I[6] ** 2 + I[7] ** 2 + I[8] ** 2 + I[9] ** 2 + I[10] ** 2 + I[11] ** 2 + I[12] ** 2 + I[13] ** 2 + I[14] ** 2 + I[15] ** 2)
				}

				function Z(I, N, ea) {
					I[0] = N[0] +
						ea[0];
					I[1] = N[1] + ea[1];
					I[2] = N[2] + ea[2];
					I[3] = N[3] + ea[3];
					I[4] = N[4] + ea[4];
					I[5] = N[5] + ea[5];
					I[6] = N[6] + ea[6];
					I[7] = N[7] + ea[7];
					I[8] = N[8] + ea[8];
					I[9] = N[9] + ea[9];
					I[10] = N[10] + ea[10];
					I[11] = N[11] + ea[11];
					I[12] = N[12] + ea[12];
					I[13] = N[13] + ea[13];
					I[14] = N[14] + ea[14];
					I[15] = N[15] + ea[15];
					return I
				}

				function oa(I, N, ea) {
					I[0] = N[0] - ea[0];
					I[1] = N[1] - ea[1];
					I[2] = N[2] - ea[2];
					I[3] = N[3] - ea[3];
					I[4] = N[4] - ea[4];
					I[5] = N[5] - ea[5];
					I[6] = N[6] - ea[6];
					I[7] = N[7] - ea[7];
					I[8] = N[8] - ea[8];
					I[9] = N[9] - ea[9];
					I[10] = N[10] - ea[10];
					I[11] = N[11] - ea[11];
					I[12] = N[12] -
						ea[12];
					I[13] = N[13] - ea[13];
					I[14] = N[14] - ea[14];
					I[15] = N[15] - ea[15];
					return I
				}

				function qa(I, N, ea) {
					I[0] = N[0] * ea;
					I[1] = N[1] * ea;
					I[2] = N[2] * ea;
					I[3] = N[3] * ea;
					I[4] = N[4] * ea;
					I[5] = N[5] * ea;
					I[6] = N[6] * ea;
					I[7] = N[7] * ea;
					I[8] = N[8] * ea;
					I[9] = N[9] * ea;
					I[10] = N[10] * ea;
					I[11] = N[11] * ea;
					I[12] = N[12] * ea;
					I[13] = N[13] * ea;
					I[14] = N[14] * ea;
					I[15] = N[15] * ea;
					return I
				}

				function Aa(I, N, ea, pa) {
					I[0] = N[0] + ea[0] * pa;
					I[1] = N[1] + ea[1] * pa;
					I[2] = N[2] + ea[2] * pa;
					I[3] = N[3] + ea[3] * pa;
					I[4] = N[4] + ea[4] * pa;
					I[5] = N[5] + ea[5] * pa;
					I[6] = N[6] + ea[6] * pa;
					I[7] = N[7] + ea[7] * pa;
					I[8] =
						N[8] + ea[8] * pa;
					I[9] = N[9] + ea[9] * pa;
					I[10] = N[10] + ea[10] * pa;
					I[11] = N[11] + ea[11] * pa;
					I[12] = N[12] + ea[12] * pa;
					I[13] = N[13] + ea[13] * pa;
					I[14] = N[14] + ea[14] * pa;
					I[15] = N[15] + ea[15] * pa;
					return I
				}

				function Ka(I, N) {
					return I[0] === N[0] && I[1] === N[1] && I[2] === N[2] && I[3] === N[3] && I[4] === N[4] && I[5] === N[5] && I[6] === N[6] && I[7] === N[7] && I[8] === N[8] && I[9] === N[9] && I[10] === N[10] && I[11] === N[11] && I[12] === N[12] && I[13] === N[13] && I[14] === N[14] && I[15] === N[15]
				}

				function da(I, N) {
					if (I === N) return !0;
					const ea = I[0],
						pa = I[1],
						xa = I[2],
						S = I[3],
						ba = I[4],
						la = I[5],
						ha = I[6],
						P = I[7],
						ca = I[8],
						ka = I[9],
						va = I[10],
						Ca = I[11],
						ma = I[12],
						Q = I[13],
						aa = I[14];
					I = I[15];
					const ta = N[0],
						Da = N[1],
						Ga = N[2],
						Na = N[3],
						Ma = N[4],
						Ta = N[5],
						Ra = N[6],
						Wa = N[7],
						Xa = N[8],
						bb = N[9],
						$a = N[10],
						Ya = N[11],
						ab = N[12],
						Qa = N[13],
						Ba = N[14];
					N = N[15];
					const O = c.getEpsilon();
					return Math.abs(ea - ta) <= O * Math.max(1, Math.abs(ea), Math.abs(ta)) && Math.abs(pa - Da) <= O * Math.max(1, Math.abs(pa), Math.abs(Da)) && Math.abs(xa - Ga) <= O * Math.max(1, Math.abs(xa), Math.abs(Ga)) && Math.abs(S - Na) <= O * Math.max(1, Math.abs(S), Math.abs(Na)) && Math.abs(ba - Ma) <= O *
						Math.max(1, Math.abs(ba), Math.abs(Ma)) && Math.abs(la - Ta) <= O * Math.max(1, Math.abs(la), Math.abs(Ta)) && Math.abs(ha - Ra) <= O * Math.max(1, Math.abs(ha), Math.abs(Ra)) && Math.abs(P - Wa) <= O * Math.max(1, Math.abs(P), Math.abs(Wa)) && Math.abs(ca - Xa) <= O * Math.max(1, Math.abs(ca), Math.abs(Xa)) && Math.abs(ka - bb) <= O * Math.max(1, Math.abs(ka), Math.abs(bb)) && Math.abs(va - $a) <= O * Math.max(1, Math.abs(va), Math.abs($a)) && Math.abs(Ca - Ya) <= O * Math.max(1, Math.abs(Ca), Math.abs(Ya)) && Math.abs(ma - ab) <= O * Math.max(1, Math.abs(ma), Math.abs(ab)) &&
						Math.abs(Q - Qa) <= O * Math.max(1, Math.abs(Q), Math.abs(Qa)) && Math.abs(aa - Ba) <= O * Math.max(1, Math.abs(aa), Math.abs(Ba)) && Math.abs(I - N) <= O * Math.max(1, Math.abs(I), Math.abs(N))
				}

				function ja(I) {
					const N = c.getEpsilon(),
						ea = I[0],
						pa = I[1],
						xa = I[2],
						S = I[4],
						ba = I[5],
						la = I[6],
						ha = I[8],
						P = I[9];
					I = I[10];
					return Math.abs(1 - (ea * ea + S * S + ha * ha)) <= N && Math.abs(1 - (pa * pa + ba * ba + P * P)) <= N && Math.abs(1 - (xa * xa + la * la + I * I)) <= N
				}
				const sa = b.create();
				b = Object.freeze(Object.defineProperty({
					__proto__: null,
					copy: e,
					set: d,
					identity: k,
					transpose: v,
					invert: m,
					adjoint: f,
					determinant: g,
					multiply: l,
					translate: r,
					scale: p,
					rotate: n,
					rotateX: t,
					rotateY: h,
					rotateZ: q,
					fromTranslation: u,
					fromScaling: x,
					fromRotation: y,
					fromXRotation: w,
					fromYRotation: A,
					fromZRotation: B,
					fromRotationTranslation: E,
					fromQuat2: z,
					getTranslation: C,
					getScaling: D,
					getRotation: J,
					fromRotationTranslationScale: K,
					fromRotationTranslationScaleOrigin: H,
					fromQuat: G,
					frustum: F,
					perspective: L,
					perspectiveFromFieldOfView: R,
					ortho: V,
					lookAt: U,
					targetTo: W,
					str: M,
					frob: T,
					add: Z,
					subtract: oa,
					multiplyScalar: qa,
					multiplyScalarAndAdd: Aa,
					exactEquals: Ka,
					equals: da,
					isOrthoNormal: ja,
					mul: l,
					sub: oa
				}, Symbol.toStringTag, {
					value: "Module"
				}));
				a.add = Z;
				a.adjoint = f;
				a.copy = e;
				a.determinant = g;
				a.equals = da;
				a.exactEquals = Ka;
				a.frob = T;
				a.fromQuat = G;
				a.fromQuat2 = z;
				a.fromRotation = y;
				a.fromRotationTranslation = E;
				a.fromRotationTranslationScale = K;
				a.fromRotationTranslationScaleOrigin = H;
				a.fromScaling = x;
				a.fromTranslation = u;
				a.fromXRotation = w;
				a.fromYRotation = A;
				a.fromZRotation = B;
				a.frustum = F;
				a.getRotation = J;
				a.getScaling = D;
				a.getTranslation = C;
				a.identity = k;
				a.invert = m;
				a.isOrthoNormal =
					ja;
				a.lookAt = U;
				a.mat4 = b;
				a.mul = l;
				a.multiply = l;
				a.multiplyScalar = qa;
				a.multiplyScalarAndAdd = Aa;
				a.ortho = V;
				a.perspective = L;
				a.perspectiveFromFieldOfView = R;
				a.rotate = n;
				a.rotateX = t;
				a.rotateY = h;
				a.rotateZ = q;
				a.scale = p;
				a.set = d;
				a.str = M;
				a.sub = oa;
				a.subtract = oa;
				a.targetTo = W;
				a.translate = r;
				a.transpose = v
			})
		},
		"esri/chunks/pe": function() {
			define(["require", "exports", "./_rollupPluginBabelHelpers", "../assets", "../core/has"], function(a, b, c, e, d) {
				function k() {
					return !!b._pe
				}

				function v() {
					return !!d("esri-wasm")
				}

				function m() {
					return n ?
						n : n = (new Promise((h, q) => a(["./pe-wasm"], h, q)))
						.then(h => h.peWasm)
						.then(({
							default: h
						}) => h({
							locateFile: q => e.getAssetUrl(`esri/geometry/support/${q}`)
						}))
						.then(h => {
							f(h)
						})
				}

				function f(h) {
					function q(y, w, A) {
						y[w] = A(y[w])
					}
					b._pe = h;
					b.PeDefs.init();
					b.PeGTlistExtended.init();
					b.PeNotationMgrs.init();
					b.PeNotationUtm.init();
					b.PePCSInfo.init();
					b.PeGCSExtent = function(y) {
						function w() {
							return y.apply(this, arguments) || this
						}
						c._inheritsLoose(w, y);
						w.prototype.destroy = function() {
							b._pe.destroy(this)
						};
						return w
					}(b._pe.PeGCSExtent);
					h = [b._pe.PeDatum, b._pe.PeGeogcs, b._pe.PeGeogtran, b._pe.PeObject, b._pe.PeParameter, b._pe.PePrimem, b._pe.PeProjcs, b._pe.PeSpheroid, b._pe.PeUnit];
					for (var u of h) q(u.prototype, "getName", y => function() {
						return y.call(this, Array(b.PeDefs.PE_NAME_MAX))
					});
					for (const y of [b._pe.PeGeogtran, b._pe.PeProjcs]) q(y.prototype, "getParameters", w => function() {
						const A = Array(b.PeDefs.PE_PARM_MAX);
						let B = w.call(this);
						for (let E = 0; E < A.length; E++) {
							const z = b._pe.getValue(B, "*");
							A[E] = z ? b._pe.wrapPointer(z, b._pe.PeParameter) : null;
							B += Int32Array.BYTES_PER_ELEMENT
						}
						return A
					});
					q(b._pe.PeHorizon.prototype, "getCoord", y => function() {
						const w = this.getSize();
						if (!w) return null;
						const A = [],
							B = y.call(this);
						p(A, w, B);
						return A
					});
					q(b._pe.PeGTlistExtendedEntry.prototype, "getEntries", y => {
						const w = b._pe._pe_getPeGTlistExtendedGTsSize();
						return function() {
							let A = null;
							var B = y.call(this);
							if (!b._pe.compare(B, b._pe.NULL)) {
								A = [B];
								const E = this.getSteps();
								if (1 < E) {
									B = b._pe.getPointer(B);
									for (let z = 1; z < E; z++) A.push(b._pe.wrapPointer(B + w * z, b._pe.PeGTlistExtendedGTs))
								}
							}
							return A
						}
					});
					const x = b._pe._pe_getPeHorizonSize();
					u = y => function() {
						let w = this._cache;
						w || (this._cache = w = new Map);
						if (w.has(y)) return w.get(y);
						let A = null;
						var B = y.call(this);
						if (!b._pe.compare(B, b._pe.NULL)) {
							A = [B];
							const E = B.getNump();
							if (1 < E) {
								B = b._pe.getPointer(B);
								for (let z = 1; z < E; z++) A.push(b._pe.wrapPointer(B + x * z, b._pe.PeHorizon))
							}
						}
						w.set(y, A);
						return A
					};
					q(b._pe.PeProjcs.prototype, "horizonGcsGenerate", u);
					q(b._pe.PeProjcs.prototype, "horizonPcsGenerate", u);
					b._pe.PeObject.prototype.toString = function(y = b.PeDefs.PE_STR_OPTS_NONE) {
						b._pe.ensureCache.prepare();
						const w = b._pe.getPointer(this),
							A = b._pe.ensureInt8(Array(b.PeDefs.PE_BUFFER_MAX));
						return b._pe.UTF8ToString(b._pe._pe_object_to_string_ext(w, y, A))
					}
				}

				function g(h) {
					if (h) {
						var q = b._pe.getClass(h);
						q && (q = b._pe.getCache(q)) && (h = b._pe.getPointer(h)) && delete q[h]
					}
				}

				function l(h, q) {
					const u = [];
					q = Array(q);
					for (let x = 0; x < h; x++) u.push(b._pe.ensureInt8(q));
					return u
				}

				function r(h) {
					let q;
					Array.isArray(h[0]) ? (q = [], h.forEach(u => {
						q.push(u[0], u[1])
					})) : q = h;
					return q
				}

				function p(h, q, u, x = !1) {
					if (x)
						for (x = 0; x < 2 * q; x++) h[x] = b._pe.getValue(u +
							x * Float64Array.BYTES_PER_ELEMENT, "double");
					else {
						x = 0 === h.length;
						for (let y = 0; y < q; y++) x && (h[y] = Array(2)), h[y][0] = b._pe.getValue(u, "double"), h[y][1] = b._pe.getValue(u + Float64Array.BYTES_PER_ELEMENT, "double"), u += 2 * Float64Array.BYTES_PER_ELEMENT
					}
				}
				let n;
				b._pe = null;
				b.PeCSTransformations = void 0;
				(function(h) {
					function q(y, w, A) {
						b._pe.ensureCache.prepare();
						var B = r(A);
						const E = A === B;
						B = b._pe.ensureFloat64(B);
						(y = b._pe._pe_geog_to_proj(b._pe.getPointer(y), w, B)) && p(A, w, B, E);
						return y
					}

					function u(y, w, A) {
						return x(y, w, A,
							0)
					}

					function x(y, w, A, B) {
						b._pe.ensureCache.prepare();
						var E = r(A);
						const z = A === E;
						E = b._pe.ensureFloat64(E);
						(y = b._pe._pe_proj_to_geog_center(b._pe.getPointer(y), w, E, B)) && p(A, w, E, z);
						return y
					}
					h.geogToProj = q;
					h.projGeog = function(y, w, A, B) {
						switch (B) {
							case b.PeDefs.PE_TRANSFORM_P_TO_G:
								return u(y, w, A);
							case b.PeDefs.PE_TRANSFORM_G_TO_P:
								return q(y, w, A)
						}
						return 0
					};
					h.projToGeog = u;
					h.projToGeogCenter = x
				})(b.PeCSTransformations || (b.PeCSTransformations = {}));
				b.PeDefs = void 0;
				(function(h) {
					h.init = function() {
						h.PE_BUFFER_MAX = b._pe.PeDefs.prototype.PE_BUFFER_MAX;
						h.PE_NAME_MAX = b._pe.PeDefs.prototype.PE_NAME_MAX;
						h.PE_MGRS_MAX = b._pe.PeDefs.prototype.PE_MGRS_MAX;
						h.PE_USNG_MAX = b._pe.PeDefs.prototype.PE_USNG_MAX;
						h.PE_DD_MAX = b._pe.PeDefs.prototype.PE_DD_MAX;
						h.PE_DDM_MAX = b._pe.PeDefs.prototype.PE_DDM_MAX;
						h.PE_DMS_MAX = b._pe.PeDefs.prototype.PE_DMS_MAX;
						h.PE_UTM_MAX = b._pe.PeDefs.prototype.PE_UTM_MAX;
						h.PE_PARM_MAX = b._pe.PeDefs.prototype.PE_PARM_MAX;
						h.PE_TYPE_NONE = b._pe.PeDefs.prototype.PE_TYPE_NONE;
						h.PE_TYPE_GEOGCS = b._pe.PeDefs.prototype.PE_TYPE_GEOGCS;
						h.PE_TYPE_PROJCS =
							b._pe.PeDefs.prototype.PE_TYPE_PROJCS;
						h.PE_TYPE_GEOGTRAN = b._pe.PeDefs.prototype.PE_TYPE_GEOGTRAN;
						h.PE_TYPE_COORDSYS = b._pe.PeDefs.prototype.PE_TYPE_COORDSYS;
						h.PE_TYPE_UNIT = b._pe.PeDefs.prototype.PE_TYPE_UNIT;
						h.PE_TYPE_LINUNIT = b._pe.PeDefs.prototype.PE_TYPE_LINUNIT;
						h.PE_STR_OPTS_NONE = b._pe.PeDefs.prototype.PE_STR_OPTS_NONE;
						h.PE_STR_AUTH_NONE = b._pe.PeDefs.prototype.PE_STR_AUTH_NONE;
						h.PE_STR_AUTH_TOP = b._pe.PeDefs.prototype.PE_STR_AUTH_TOP;
						h.PE_STR_NAME_CANON = b._pe.PeDefs.prototype.PE_STR_NAME_CANON;
						h.PE_PARM_X0 =
							b._pe.PeDefs.prototype.PE_PARM_X0;
						h.PE_PARM_ND = b._pe.PeDefs.prototype.PE_PARM_ND;
						h.PE_TRANSFORM_1_TO_2 = b._pe.PeDefs.prototype.PE_TRANSFORM_1_TO_2;
						h.PE_TRANSFORM_2_TO_1 = b._pe.PeDefs.prototype.PE_TRANSFORM_2_TO_1;
						h.PE_TRANSFORM_P_TO_G = b._pe.PeDefs.prototype.PE_TRANSFORM_P_TO_G;
						h.PE_TRANSFORM_G_TO_P = b._pe.PeDefs.prototype.PE_TRANSFORM_G_TO_P;
						h.PE_HORIZON_RECT = b._pe.PeDefs.prototype.PE_HORIZON_RECT;
						h.PE_HORIZON_POLY = b._pe.PeDefs.prototype.PE_HORIZON_POLY;
						h.PE_HORIZON_LINE = b._pe.PeDefs.prototype.PE_HORIZON_LINE;
						h.PE_HORIZON_DELTA = b._pe.PeDefs.prototype.PE_HORIZON_DELTA
					}
				})(b.PeDefs || (b.PeDefs = {}));
				b.PeFactory = void 0;
				(function(h) {
					function q(w, A) {
						let B = null,
							E = u[w];
						E || (E = {}, u[w] = E);
						E.hasOwnProperty(String(A)) ? B = E[A] : (w = b._pe.PeFactory.prototype.factoryByType(w, A), b._pe.compare(w, b._pe.NULL) || (B = w, E[A] = B));
						return B = y(B)
					}
					const u = {},
						x = {},
						y = w => {
							if (w) {
								const A = w.getType();
								switch (A) {
									case b.PeDefs.PE_TYPE_GEOGCS:
										w = b._pe.castObject(w, b._pe.PeGeogcs);
										break;
									case b.PeDefs.PE_TYPE_PROJCS:
										w = b._pe.castObject(w, b._pe.PeProjcs);
										break;
									case b.PeDefs.PE_TYPE_GEOGTRAN:
										w = b._pe.castObject(w, b._pe.PeGeogtran);
										break;
									default:
										A & b.PeDefs.PE_TYPE_UNIT && (w = b._pe.castObject(w, b._pe.PeUnit))
								}
							}
							return w
						};
					h.initialize = function() {
						b._pe.PeFactory.prototype.initialize(null)
					};
					h.coordsys = function(w) {
						return q(b.PeDefs.PE_TYPE_COORDSYS, w)
					};
					h.factoryByType = q;
					h.fromString = function(w, A) {
						let B = null,
							E = x[w];
						E || (E = {}, x[w] = E);
						E.hasOwnProperty(A) ? B = E[A] : (w = b._pe.PeFactory.prototype.fromString(w, A), b._pe.compare(w, b._pe.NULL) || (B = w, E[A] = B));
						return B = y(B)
					};
					h.geogcs = function(w) {
						return q(b.PeDefs.PE_TYPE_GEOGCS, w)
					};
					h.geogtran = function(w) {
						return q(b.PeDefs.PE_TYPE_GEOGTRAN, w)
					};
					h.getCode = function(w) {
						return b._pe.PeFactory.prototype.getCode(w)
					};
					h.projcs = function(w) {
						return q(b.PeDefs.PE_TYPE_PROJCS, w)
					};
					h.unit = function(w) {
						return q(b.PeDefs.PE_TYPE_UNIT, w)
					}
				})(b.PeFactory || (b.PeFactory = {}));
				b.PeGCSExtent = null;
				b.PeGTlistExtended = void 0;
				(function(h) {
					let q;
					h.init = function() {
						h.PE_GTLIST_OPTS_COMMON = b._pe.PeGTlistExtended.prototype.PE_GTLIST_OPTS_COMMON;
						q = b._pe._pe_getPeGTlistExtendedEntrySize()
					};
					h.getGTlist = function(u, x, y, w, A, B) {
						let E = null;
						const z = new b._pe.PeInteger(B);
						try {
							const C = b._pe.PeGTlistExtended.prototype.getGTlist(u, x, y, w, A, z);
							if (B = z.val)
								if (E = [C], 1 < B) {
									const D = b._pe.getPointer(C);
									for (u = 1; u < B; u++) E.push(b._pe.wrapPointer(D + q * u, b._pe.PeGTlistExtendedEntry))
								}
						} finally {
							b._pe.destroy(z)
						}
						return E
					}
				})(b.PeGTlistExtended || (b.PeGTlistExtended = {}));
				b.PeGTlistExtendedEntry = void 0;
				(function(h) {
					h.destroy = function(q) {
						if (q && q.length) {
							for (const u of q) g(u), u.getEntries()
								.forEach(x => {
									g(x);
									x = x.getGeogtran();
									g(x);
									x.getParameters()
										.forEach(g);
									[x.getGeogcs1(), x.getGeogcs2()].forEach(y => {
										g(y);
										const w = y.getDatum();
										g(w);
										g(w.getSpheroid());
										g(y.getPrimem());
										g(y.getUnit())
									})
								});
							b._pe.PeGTlistExtendedEntry.prototype.Delete(q[0])
						}
					}
				})(b.PeGTlistExtendedEntry || (b.PeGTlistExtendedEntry = {}));
				b.PeGTTransformations = void 0;
				(function(h) {
					h.geogToGeog = function(q, u, x, y, w) {
						b._pe.ensureCache.prepare();
						var A = r(x);
						const B = x === A;
						A = b._pe.ensureFloat64(A);
						let E = 0;
						y && (E = b._pe.ensureFloat64(y));
						(q = b._pe._pe_geog_to_geog(b._pe.getPointer(q),
							u, A, E, w)) && p(x, u, A, B);
						return q
					}
				})(b.PeGTTransformations || (b.PeGTTransformations = {}));
				b.PeNotationDms = void 0;
				(function(h) {
					const q = (x, y, w, A, B, E) => {
							b._pe.ensureCache.prepare();
							switch (x) {
								case "dd":
									var z = b._pe._pe_geog_to_dd;
									var C = b.PeDefs.PE_DD_MAX;
									break;
								case "ddm":
									z = b._pe._pe_geog_to_ddm;
									C = b.PeDefs.PE_DDM_MAX;
									break;
								case "dms":
									z = b._pe._pe_geog_to_dms, C = b.PeDefs.PE_DMS_MAX
							}
							x = 0;
							y && (x = b._pe.getPointer(y));
							y = r(A);
							y = b._pe.ensureFloat64(y);
							C = l(w, C);
							A = b._pe.ensureInt32(C);
							if (B = z(x, w, y, B, A))
								for (z = 0; z < w; z++) E[z] =
									b._pe.UTF8ToString(C[z]);
							return B
						},
						u = (x, y, w, A, B) => {
							b._pe.ensureCache.prepare();
							switch (x) {
								case "dd":
									var E = b._pe._pe_dd_to_geog;
									break;
								case "ddm":
									E = b._pe._pe_ddm_to_geog;
									break;
								case "dms":
									E = b._pe._pe_dms_to_geog
							}
							x = 0;
							y && (x = b._pe.getPointer(y));
							y = A.map(z => b._pe.ensureString(z));
							A = b._pe.ensureInt32(y);
							y = b._pe.ensureFloat64(Array(2 * w));
							(E = E(x, w, A, y)) && p(B, w, y);
							return E
						};
					h.geogToDms = function(x, y, w, A, B) {
						return q("dms", x, y, w, A, B)
					};
					h.dmsToGeog = function(x, y, w, A) {
						return u("dms", x, y, w, A)
					};
					h.geogToDdm = function(x,
						y, w, A, B) {
						return q("ddm", x, y, w, A, B)
					};
					h.ddmToGeog = function(x, y, w, A) {
						return u("ddm", x, y, w, A)
					};
					h.geogToDd = function(x, y, w, A, B) {
						return q("dd", x, y, w, A, B)
					};
					h.ddToGeog = function(x, y, w, A) {
						return u("dd", x, y, w, A)
					}
				})(b.PeNotationDms || (b.PeNotationDms = {}));
				b.PeNotationMgrs = void 0;
				(function(h) {
					h.init = function() {
						h.PE_MGRS_STYLE_NEW = b._pe.PeNotationMgrs.prototype.PE_MGRS_STYLE_NEW;
						h.PE_MGRS_STYLE_OLD = b._pe.PeNotationMgrs.prototype.PE_MGRS_STYLE_OLD;
						h.PE_MGRS_STYLE_AUTO = b._pe.PeNotationMgrs.prototype.PE_MGRS_STYLE_AUTO;
						h.PE_MGRS_180_ZONE_1_PLUS = b._pe.PeNotationMgrs.prototype.PE_MGRS_180_ZONE_1_PLUS;
						h.PE_MGRS_ADD_SPACES = b._pe.PeNotationMgrs.prototype.PE_MGRS_ADD_SPACES
					};
					h.geogToMgrsExtended = function(q, u, x, y, w, A, B) {
						b._pe.ensureCache.prepare();
						let E = 0;
						q && (E = b._pe.getPointer(q));
						q = r(x);
						x = b._pe.ensureFloat64(q);
						q = l(u, b.PeDefs.PE_MGRS_MAX);
						const z = b._pe.ensureInt32(q);
						if (y = b._pe._pe_geog_to_mgrs_extended(E, u, x, y, w, A, z))
							for (w = 0; w < u; w++) B[w] = b._pe.UTF8ToString(q[w]);
						return y
					};
					h.mgrsToGeogExtended = function(q, u, x, y, w) {
						b._pe.ensureCache.prepare();
						let A = 0;
						q && (A = b._pe.getPointer(q));
						q = x.map(B => b._pe.ensureString(B));
						x = b._pe.ensureInt32(q);
						q = b._pe.ensureFloat64(Array(2 * u));
						(y = b._pe._pe_mgrs_to_geog_extended(A, u, x, y, q)) && p(w, u, q);
						return y
					}
				})(b.PeNotationMgrs || (b.PeNotationMgrs = {}));
				b.PeNotationUsng = void 0;
				(function(h) {
					h.geogToUsng = function(q, u, x, y, w, A, B) {
						b._pe.ensureCache.prepare();
						let E = 0;
						q && (E = b._pe.getPointer(q));
						q = r(x);
						x = b._pe.ensureFloat64(q);
						q = l(u, b.PeDefs.PE_MGRS_MAX);
						const z = b._pe.ensureInt32(q);
						if (y = b._pe._pe_geog_to_usng(E, u, x, y, w, A,
							z))
							for (w = 0; w < u; w++) B[w] = b._pe.UTF8ToString(q[w]);
						return y
					};
					h.usngToGeog = function(q, u, x, y) {
						b._pe.ensureCache.prepare();
						var w = 0;
						q && (w = b._pe.getPointer(q));
						q = x.map(A => b._pe.ensureString(A));
						x = b._pe.ensureInt32(q);
						q = b._pe.ensureFloat64(Array(2 * u));
						(w = b._pe._pe_usng_to_geog(w, u, x, q)) && p(y, u, q);
						return w
					}
				})(b.PeNotationUsng || (b.PeNotationUsng = {}));
				b.PeNotationUtm = void 0;
				(function(h) {
					h.init = function() {
						h.PE_UTM_OPTS_NONE = b._pe.PeNotationUtm.prototype.PE_UTM_OPTS_NONE;
						h.PE_UTM_OPTS_ADD_SPACES = b._pe.PeNotationUtm.prototype.PE_UTM_OPTS_ADD_SPACES;
						h.PE_UTM_OPTS_NS = b._pe.PeNotationUtm.prototype.PE_UTM_OPTS_NS
					};
					h.geogToUtm = function(q, u, x, y, w) {
						b._pe.ensureCache.prepare();
						var A = 0;
						q && (A = b._pe.getPointer(q));
						q = r(x);
						x = b._pe.ensureFloat64(q);
						q = l(u, b.PeDefs.PE_UTM_MAX);
						const B = b._pe.ensureInt32(q);
						if (y = b._pe._pe_geog_to_utm(A, u, x, y, B))
							for (A = 0; A < u; A++) w[A] = b._pe.UTF8ToString(q[A]);
						return y
					};
					h.utmToGeog = function(q, u, x, y, w) {
						b._pe.ensureCache.prepare();
						let A = 0;
						q && (A = b._pe.getPointer(q));
						q = x.map(B => b._pe.ensureString(B));
						x = b._pe.ensureInt32(q);
						q = b._pe.ensureFloat64(Array(2 *
							u));
						(y = b._pe._pe_utm_to_geog(A, u, x, y, q)) && p(w, u, q);
						return y
					}
				})(b.PeNotationUtm || (b.PeNotationUtm = {}));
				b.PePCSInfo = void 0;
				(function(h) {
					const q = new Map;
					h.init = function() {
						h.PE_PCSINFO_OPTION_NONE = b._pe.PePCSInfo.prototype.PE_PCSINFO_OPTION_NONE;
						h.PE_PCSINFO_OPTION_DOMAIN = b._pe.PePCSInfo.prototype.PE_PCSINFO_OPTION_DOMAIN;
						h.PE_POLE_OUTSIDE_BOUNDARY = b._pe.PePCSInfo.prototype.PE_POLE_OUTSIDE_BOUNDARY;
						h.PE_POLE_POINT = b._pe.PePCSInfo.prototype.PE_POLE_POINT
					};
					h.generate = function(u, x = h.PE_PCSINFO_OPTION_DOMAIN) {
						let y =
							null,
							w = null;
						q.has(u) && (w = q.get(u), w[x] && (y = w[x]));
						y || (y = b._pe.PePCSInfo.prototype.generate(u, x), w || (w = [], q.set(u, w)), w[x] = y);
						return y
					}
				})(b.PePCSInfo || (b.PePCSInfo = {}));
				b.PeVersion = void 0;
				(function(h) {
					h.versionString = function() {
						return b._pe.PeVersion.prototype.version_string()
					}
				})(b.PeVersion || (b.PeVersion = {}));
				const t = Object.freeze(Object.defineProperty({
						__proto__: null,
						get _pe() {
							return b._pe
						},
						isLoaded: k,
						isSupported: v,
						load: m,
						get PeCSTransformations() {
							return b.PeCSTransformations
						},
						get PeDefs() {
							return b.PeDefs
						},
						get PeFactory() {
							return b.PeFactory
						},
						get PeGCSExtent() {
							return b.PeGCSExtent
						},
						get PeGTlistExtended() {
							return b.PeGTlistExtended
						},
						get PeGTlistExtendedEntry() {
							return b.PeGTlistExtendedEntry
						},
						get PeGTTransformations() {
							return b.PeGTTransformations
						},
						get PeNotationDms() {
							return b.PeNotationDms
						},
						get PeNotationMgrs() {
							return b.PeNotationMgrs
						},
						get PeNotationUsng() {
							return b.PeNotationUsng
						},
						get PeNotationUtm() {
							return b.PeNotationUtm
						},
						get PePCSInfo() {
							return b.PePCSInfo
						},
						get PeVersion() {
							return b.PeVersion
						},
						_init: f
					},
					Symbol.toStringTag, {
						value: "Module"
					}));
				b._init = f;
				b.isLoaded = k;
				b.isSupported = v;
				b.load = m;
				b.pe = t
			})
		},
		"esri/geometry/support/aaBoundingRect": function() {
			define(["exports", "../../core/has", "../../core/mathUtils", "../../core/maybe", "../Extent"], function(a, b, c, e, d) {
				function k(n = p) {
					return [n[0], n[1], n[2], n[3]]
				}

				function v(n, t) {
					n !== t && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3]);
					return n
				}

				function m(n) {
					return e.isNone(n) || n[0] >= n[2] ? 0 : n[2] - n[0]
				}

				function f(n) {
					return n[1] >= n[3] ? 0 : n[3] - n[1]
				}

				function g(n, t, h) {
					return t >=
						n[0] && h >= n[1] && t <= n[2] && h <= n[3]
				}

				function l(n) {
					return null != n && 4 === n.length
				}
				const r = [Infinity, Infinity, -Infinity, -Infinity],
					p = [0, 0, 0, 0];
				a.NEGATIVE_INFINITY = r;
				a.POSITIVE_INFINITY = [-Infinity, -Infinity, Infinity, Infinity];
				a.UNIT = [0, 0, 1, 1];
				a.ZERO = p;
				a.allFinite = function(n) {
					for (let t = 0; 4 > t; t++)
						if (!isFinite(n[t])) return !1;
					return !0
				};
				a.area = function(n) {
					return m(n) * f(n)
				};
				a.center = function(n, t = [0, 0]) {
					t[0] = (n[0] + n[2]) / 2;
					t[1] = (n[1] + n[3]) / 2;
					return t
				};
				a.clone = function(n) {
					return [n[0], n[1], n[2], n[3]]
				};
				a.contains = function(n,
					t) {
					return t[0] >= n[0] && t[2] <= n[2] && t[1] >= n[1] && t[3] <= n[3]
				};
				a.containsPoint = function(n, t) {
					return g(n, t[0], t[1])
				};
				a.containsPointObject = function(n, t) {
					return g(n, t.x, t.y)
				};
				a.containsPointWithMargin = function(n, t, h) {
					return t[0] >= n[0] - h && t[1] >= n[1] - h && t[0] <= n[2] + h && t[1] <= n[3] + h
				};
				a.containsXY = g;
				a.containsXYWithMargin = function(n, t, h, q) {
					return t >= n[0] - q && h >= n[1] - q && t <= n[2] + q && h <= n[3] + q
				};
				a.copy = v;
				a.create = k;
				a.distance = function(n, t) {
					const h = (n[1] + n[3]) / 2,
						q = Math.max(Math.abs(t[0] - (n[0] + n[2]) / 2) - m(n) / 2, 0);
					n = Math.max(Math.abs(t[1] -
						h) - f(n) / 2, 0);
					return Math.sqrt(q * q + n * n)
				};
				a.empty = function(n) {
					return n ? v(n, r) : k(r)
				};
				a.equals = function(n, t) {
					return l(n) && l(t) ? n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] : n === t
				};
				a.expand = function(n, t, h) {
					if (e.isNone(t)) v(h, n);
					else if ("length" in t)
						if (l(t)) h[0] = Math.min(n[0], t[0]), h[1] = Math.min(n[1], t[1]), h[2] = Math.max(n[2], t[2]), h[3] = Math.max(n[3], t[3]);
						else {
							if (2 === t.length || 3 === t.length) h[0] = Math.min(n[0], t[0]), h[1] = Math.min(n[1], t[1]), h[2] = Math.max(n[2], t[0]), h[3] = Math.max(n[3], t[1])
						}
					else switch (t.type) {
						case "extent":
							h[0] =
								Math.min(n[0], t.xmin);
							h[1] = Math.min(n[1], t.ymin);
							h[2] = Math.max(n[2], t.xmax);
							h[3] = Math.max(n[3], t.ymax);
							break;
						case "point":
							h[0] = Math.min(n[0], t.x), h[1] = Math.min(n[1], t.y), h[2] = Math.max(n[2], t.x), h[3] = Math.max(n[3], t.y)
					}
				};
				a.expandPointInPlace = function(n, t) {
					t[0] < n[0] && (n[0] = t[0]);
					t[0] > n[2] && (n[2] = t[0]);
					t[1] < n[1] && (n[1] = t[1]);
					t[1] > n[3] && (n[3] = t[1])
				};
				a.expandWithNestedArray = function(n, t, h = n) {
					const q = t.length;
					let u = n[0],
						x = n[1],
						y = n[2];
					n = n[3];
					for (let w = 0; w < q; w++) {
						const A = t[w];
						u = Math.min(u, A[0]);
						x = Math.min(x,
							A[1]);
						y = Math.max(y, A[0]);
						n = Math.max(n, A[1])
					}
					h[0] = u;
					h[1] = x;
					h[2] = y;
					h[3] = n;
					return h
				};
				a.fromExtent = function(n, t = k()) {
					t[0] = n.xmin;
					t[1] = n.ymin;
					t[2] = n.xmax;
					t[3] = n.ymax;
					return t
				};
				a.fromValues = function(n, t, h, q, u = k()) {
					u[0] = n;
					u[1] = t;
					u[2] = h;
					u[3] = q;
					return u
				};
				a.height = f;
				a.intersection = function(n, t, h) {
					if (e.isNone(t)) return v(h, n);
					const q = t[0],
						u = t[1],
						x = t[2];
					t = t[3];
					h[0] = c.clamp(n[0], q, x);
					h[1] = c.clamp(n[1], u, t);
					h[2] = c.clamp(n[2], q, x);
					h[3] = c.clamp(n[3], u, t);
					return h
				};
				a.intersects = function(n, t) {
					return Math.max(t[0],
						n[0]) <= Math.min(t[2], n[2]) && Math.max(t[1], n[1]) <= Math.min(t[3], n[3])
				};
				a.intersectsSegment = function(n, t, h) {
					const q = n[0],
						u = n[1],
						x = n[2];
					n = n[3];
					const {
						x: y,
						y: w
					} = t, {
						x: A,
						y: B
					} = h;
					var E = (C, D) => 0 > (B - w) * C + (y - A) * D + (A * w - y * B);
					t = E(q, n);
					h = E(x, n);
					const z = E(x, u);
					E = E(q, u);
					return t === h && h === z && z === E && E === t || y < q && A < q || y > x && A > x || w > n && B > n || w < u && B < u ? !1 : !0
				};
				a.intersectsSphere = function(n, t) {
					const h = t[3];
					var q = Math.abs(t[0] - .5 * (n[0] + n[2]));
					const u = .5 * (n[2] - n[0]);
					if (q > h + u) return !1;
					var x = .5 * (n[3] - n[1]);
					n = Math.abs(t[1] - .5 * (n[1] +
						n[3]));
					if (n > h + x) return !1;
					if (q < u || n < x) return !0;
					q -= u;
					x = n - x;
					return q * q + x * x <= h * h
				};
				a.is = l;
				a.isPoint = function(n) {
					return (0 === m(n) || !isFinite(n[0])) && (0 === f(n) || !isFinite(n[1]))
				};
				a.offset = function(n, t, h, q = n) {
					q[0] = n[0] + t;
					q[1] = n[1] + h;
					q[2] = n[2] + t;
					q[3] = n[3] + h;
					return q
				};
				a.pad = function(n, t, h = n) {
					h[0] = n[0] - t;
					h[1] = n[1] - t;
					h[2] = n[2] + t;
					h[3] = n[3] + t;
					return h
				};
				a.setMax = function(n, t, h = n) {
					h[2] = t[0];
					h[3] = t[1];
					h !== n && (h[0] = n[0], h[1] = n[1]);
					return n
				};
				a.setMin = function(n, t, h = n) {
					h[0] = t[0];
					h[1] = t[1];
					h !== n && (h[2] = n[2], h[3] = n[3]);
					return h
				};
				a.size = function(n, t) {
					t[0] = n[2] - n[0];
					t[1] = n[3] - n[1]
				};
				a.toExtent = function(n, t) {
					return new d({
						xmin: n[0],
						ymin: n[1],
						xmax: n[2],
						ymax: n[3],
						spatialReference: t
					})
				};
				a.width = m;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/geodesicConstants": function() {
			define(["exports", "./Ellipsoid"], function(a, b) {
				const c = Math.PI / 180;
				var e = b.earth.radius;
				const d = b.earth.eccentricitySquared;
				e = {
					a1: e * d,
					a2: e * d * e * d,
					a3: e * d * d / 2,
					a4: e * d * e * d * 2.5,
					a5: e * d + e * d * d /
						2,
					a6: 1 - d
				};
				b = {
					4267: {
						a: 6378206.4,
						f: 1 / 294.9786982
					},
					4269: {
						a: 6378137,
						f: 1 / 298.257222101
					},
					4326: {
						a: b.earth.radius,
						f: b.earth.flattening
					},
					104900: {
						a: 2439700,
						f: 0
					},
					104901: {
						a: 6051E3,
						f: 0
					},
					104902: {
						a: 6051800,
						f: 0
					},
					104903: {
						a: b.moon.radius,
						f: b.moon.flattening
					},
					104904: {
						a: 3393400,
						f: .005207166853303471
					},
					104905: {
						a: b.mars.radius,
						f: b.mars.flattening
					},
					104906: {
						a: 6200,
						f: 0
					},
					104907: {
						a: 11100,
						f: 0
					},
					104908: {
						a: 71492E3,
						f: .06487439154031222
					},
					104909: {
						a: 8200,
						f: 0
					},
					104910: {
						a: 83500,
						f: 0
					},
					104911: {
						a: 1E4,
						f: 0
					},
					104912: {
						a: 2409300,
						f: 0
					},
					104913: {
						a: 15E3,
						f: 0
					},
					104914: {
						a: 4E4,
						f: 0
					},
					104915: {
						a: 1562090,
						f: 0
					},
					104916: {
						a: 2632345,
						f: 0
					},
					104917: {
						a: 85E3,
						f: 0
					},
					104918: {
						a: 1821460,
						f: 0
					},
					104919: {
						a: 5E3,
						f: 0
					},
					104920: {
						a: 12E3,
						f: 0
					},
					104921: {
						a: 3E4,
						f: 3
					},
					104922: {
						a: 18E3,
						f: 0
					},
					104923: {
						a: 14E3,
						f: 0
					},
					104924: {
						a: 49300,
						f: 0
					},
					104925: {
						a: 60268E3,
						f: .09796243445941462
					},
					104926: {
						a: 16E3,
						f: 0
					},
					104927: {
						a: 9500,
						f: 0
					},
					104928: {
						a: 56E4,
						f: 0
					},
					104929: {
						a: 249400,
						f: 0
					},
					104930: {
						a: 59500,
						f: 0
					},
					104931: {
						a: 16E3,
						f: 0
					},
					104932: {
						a: 133E3,
						f: 0
					},
					104933: {
						a: 718E3,
						f: 0
					},
					104934: {
						a: 888E3,
						f: 0
					},
					104935: {
						a: 1986300,
						f: 0
					},
					104936: {
						a: 1E4,
						f: 0
					},
					104937: {
						a: 41900,
						f: 0
					},
					104938: {
						a: 11E4,
						f: 0
					},
					104939: {
						a: 50100,
						f: 0
					},
					104940: {
						a: 764E3,
						f: 0
					},
					104941: {
						a: 11E3,
						f: 0
					},
					104942: {
						a: 529800,
						f: 0
					},
					104943: {
						a: 2575E3,
						f: 0
					},
					104944: {
						a: 25559E3,
						f: .022927344575296365
					},
					104945: {
						a: 578900,
						f: 0
					},
					104946: {
						a: 33E3,
						f: 0
					},
					104947: {
						a: 21E3,
						f: 0
					},
					104948: {
						a: 13E3,
						f: 0
					},
					104949: {
						a: 31E3,
						f: 0
					},
					104950: {
						a: 27E3,
						f: 0
					},
					104951: {
						a: 42E3,
						f: 0
					},
					104952: {
						a: 235800,
						f: 0
					},
					104953: {
						a: 761400,
						f: 0
					},
					104954: {
						a: 15E3,
						f: 0
					},
					104955: {
						a: 54E3,
						f: 0
					},
					104956: {
						a: 77E3,
						f: 0
					},
					104957: {
						a: 27E3,
						f: 0
					},
					104958: {
						a: 788900,
						f: 0
					},
					104959: {
						a: 584700,
						f: 0
					},
					104960: {
						a: 24764E3,
						f: .01708124697141011
					},
					104961: {
						a: 74E3,
						f: 0
					},
					104962: {
						a: 79E3,
						f: 0
					},
					104963: {
						a: 104E3,
						f: .14423076923076922
					},
					104964: {
						a: 29E3,
						f: 0
					},
					104965: {
						a: 17E4,
						f: 0
					},
					104966: {
						a: 208E3,
						f: 0
					},
					104967: {
						a: 4E4,
						f: 0
					},
					104968: {
						a: 1352600,
						f: 0
					},
					104969: {
						a: 1195E3,
						f: 0
					},
					104970: {
						a: 593E3,
						f: 0
					},
					104971: {
						a: b.mars.radius,
						f: 0
					},
					104972: {
						a: 47E4,
						f: 0
					},
					104973: {
						a: 255E3,
						f: 0
					},
					104974: {
						a: 2439400,
						f: 0
					}
				};
				a.WKT_SPHEROID_REGEX = /SPHEROID\[([^\]]+)]/i;
				a.earthEllipsoidConstants = e;
				a.spheroids = b;
				a.toRadians = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/GeographicTransformation": function() {
			define(["./GeographicTransformationStep"], function(a) {
				return function() {
					function b(e) {
						this.steps = [];
						this._cachedProjection = {};
						this._chain = "";
						this._gtlistentry = null;
						if (e && e.steps)
							for (const d of e.steps) d instanceof a ? this.steps.push(d) : this.steps.push(new a({
								wkid: d.wkid,
								wkt: d.wkt,
								isInverse: d.isInverse
							}))
					}
					b.cacheKey = function(e, d) {
						return [void 0 !== e.wkid && null !== e.wkid ? e.wkid.toString() : "-1", void 0 !== e.wkt && null !== e.wkt ? e.wkt.toString() : "", void 0 !==
							d.wkid && null !== d.wkid ? d.wkid.toString() : "-1", void 0 !== d.wkt && null !== d.wkt ? d.wkt.toString() : ""
						].join()
					};
					b.fromGE = function(e) {
						const d = new b;
						let k = "";
						for (const v of e.steps) e = a.fromGE(v), d.steps.push(e), k += e.uid.toString() + ",";
						d._cachedProjection = {};
						d._gtlistentry = null;
						d._chain = k;
						return d
					};
					var c = b.prototype;
					c.getInverse = function() {
						const e = new b;
						e.steps = [];
						for (let d = this.steps.length - 1; 0 <= d; d--) e.steps.push(this.steps[d].getInverse());
						return e
					};
					c.getGTListEntry = function() {
						let e = "";
						for (const d of this.steps) e +=
							d.uid.toString() + ",";
						e !== this._chain && (this._gtlistentry = null, this._cachedProjection = {}, this._chain = e);
						return this._gtlistentry
					};
					c.assignCachedGe = function(e, d, k) {
						this._cachedProjection[b.cacheKey(e, d)] = k
					};
					c.getCachedGeTransformation = function(e, d) {
						let k = "";
						for (const v of this.steps) k += v.uid.toString() + ",";
						k !== this._chain && (this._gtlistentry = null, this._cachedProjection = {}, this._chain = k);
						e = this._cachedProjection[b.cacheKey(e, d)];
						return void 0 === e ? null : e
					};
					return b
				}()
			})
		},
		"esri/geometry/support/GeographicTransformationStep": function() {
			define(["../../chunks/_rollupPluginBabelHelpers"],
				function(a) {
					let b = 0;
					return function() {
						function c(e) {
							this.uid = b++;
							e ? (this._wkt = null != e.wkt ? e.wkt : null, this._wkid = null != e.wkid ? e.wkid : -1, this._isInverse = null != e.isInverse ? !0 === e.isInverse : !1) : (this._wkt = null, this._wkid = -1, this._isInverse = !1)
						}
						c.fromGE = function(e) {
							const d = new c;
							d._wkt = e.wkt;
							d._wkid = e.wkid;
							d._isInverse = e.isInverse;
							return d
						};
						c.prototype.getInverse = function() {
							const e = new c;
							e._wkt = this.wkt;
							e._wkid = this._wkid;
							e._isInverse = !this.isInverse;
							return e
						};
						a._createClass(c, [{
							key: "wkt",
							get: function() {
								return this._wkt
							},
							set: function(e) {
								this._wkt = e;
								this.uid = b++
							}
						}, {
							key: "wkid",
							get: function() {
								return this._wkid
							},
							set: function(e) {
								this._wkid = e;
								this.uid = b++
							}
						}, {
							key: "isInverse",
							get: function() {
								return this._isInverse
							},
							set: function(e) {
								this._isInverse = e;
								this.uid = b++
							}
						}]);
						return c
					}()
				})
		},
		"esri/geometry/support/zscale": function() {
			define(["exports", "../../core/maybe", "../../core/unitUtils", "./spatialReferenceUtils"], function(a, b, c, e) {
				a.getGeometryZScaler = function(d, k, v) {
					if (b.isNone(k) || b.isNone(v) || v.vcsWkid || e.equals(k, v)) return null;
					k = c.getMetersPerVerticalUnitForSR(k);
					v = c.getMetersPerVerticalUnitForSR(v);
					const m = k / v;
					if (1 === m) return null;
					switch (d) {
						case "point":
						case "esriGeometryPoint":
							return f => {
								f && null != f.z && (f.z *= m)
							};
						case "polyline":
						case "esriGeometryPolyline":
							return f => {
								if (f)
									for (const g of f.paths)
										for (const l of g) 2 < l.length && (l[2] *= m)
							};
						case "polygon":
						case "esriGeometryPolygon":
							return f => {
								if (f)
									for (const g of f.rings)
										for (const l of g) 2 < l.length && (l[2] *= m)
							};
						case "multipoint":
						case "esriGeometryMultipoint":
							return f => {
								if (f)
									for (const g of f.points) 2 <
										g.length && (g[2] *= m)
							};
						case "extent":
						case "esriGeometryExtent":
							return f => {
								f && null != f.zmin && null != f.zmax && (f.zmin *= m, f.zmax *= m)
							};
						default:
							return null
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/renderers/support/styleUtils": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../core/asyncUtils", "../../core/promiseUtils", "../../core/Warning"], function(a, b, c, e, d) {
				function k() {
					k = b._asyncToGenerator(function*(v, m, f) {
						var g = v && v.getAtOrigin &&
							v.getAtOrigin("renderer", m.origin);
						g && "unique-value" === g.type && g.styleOrigin && (g = yield c.result(g.populateFromStyle()), e.throwIfAborted(f), !1 === g.ok && (f = g.error, m && m.messages && m.messages.push(new d("renderer:style-reference", `Failed to create unique value renderer from style reference: ${f.message}`, {
							error: f,
							context: m
						})), v.clear("renderer", m ? .origin)))
					});
					return k.apply(this, arguments)
				}
				a.loadStyleRenderer = function(v, m, f) {
					return k.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/requestPresets": function() {
			define(["exports", "../chunks/_rollupPluginBabelHelpers", "../request"], function(a, b, c) {
				function e() {
					e = b._asyncToGenerator(function*(d) {
						({
							data: d
						} = yield c(d, {
							responseType: "json",
							query: {
								f: "json"
							}
						}));
						return d
					});
					return e.apply(this, arguments)
				}
				a.requestArcGISServiceJSON = function(d) {
					return e.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/FeatureLayer": function() {
			define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../PopupTemplate ../renderers/ClassBreaksRenderer ../renderers/DictionaryRenderer ../renderers/DotDensityRenderer ../renderers/HeatmapRenderer ../renderers/PieChartRenderer ../renderers/Renderer ../renderers/SimpleRenderer ../renderers/UniqueValueRenderer ../renderers/support/jsonUtils ../renderers/support/types ../request ../symbols ../core/Clonable ../core/Collection ../core/Error ../core/Handles ../core/lang ../core/Logger ../core/maybe ../core/MultiOriginJSONSupport ../core/object ../core/promiseUtils ../core/sql ../core/urlUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/accessorSupport/extensions/serializableProperty/reader ../form/FormTemplate ../geometry/SpatialReference ./Layer ./graphics/sources/MemorySource ./mixins/APIKeyMixin ./mixins/ArcGISService ./mixins/BlendLayer ./mixins/CustomParametersMixin ./mixins/EditBusLayer ./mixins/FeatureEffectLayer ./mixins/FeatureLayerBase ./mixins/FeatureReductionLayer ./mixins/OperationalLayer ./mixins/OrderedLayer ./mixins/PortalLayer ./mixins/PublishableLayer ./mixins/RefreshableLayer ./mixins/ScaleRangeLayer ./mixins/TemporalLayer ./support/arcgisLayerUrl ./support/commonProperties ./support/featureLayerUtils ./support/FeatureTemplate ./support/FeatureType ./support/fieldProperties ./support/fieldUtils ./support/LabelClass ./support/labelingInfo ./support/TimeInfo ./support/versionUtils ./support/source/DataLayerSource ../renderers/support/styleUtils ../rest/support/FeatureSet ../rest/support/Query ../rest/support/TopFeaturesQuery ../support/popupUtils ../webdoc/support/opacityUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D, J, K, H, G, F, L, R, V, U, W, M, T, Z, oa, qa, Aa, Ka, da, ja, sa, I, N, ea, pa, xa, S, ba, la, ha, P, ca, ka, va, Ca, ma, Q, aa, ta, Da, Ga, Na, Ma, Ta, Ra) {
					function Wa(Ya, ab) {
						return new x("layer:unsupported", `Layer (${Ya.title}, ${Ya.id}) of type '${Ya.declaredClass}' ${ab}`, {
							layer: Ya
						})
					}

					function Xa(Ya, ab, Qa) {
						Ya = !!Qa ? .writeLayerSchema;
						return {
							enabled: Ya,
							ignoreOrigin: Ya
						}
					}
					const bb = A.getLogger("esri.layers.FeatureLayer");
					d = ka.defineFieldProperties();
					q = function(Ya) {
						function ab(...Ba) {
							Ba =
								Ya.call(this, ...Ba) || this;
							Ba._handles = new y;
							Ba.charts = null;
							Ba.copyright = null;
							Ba.displayField = null;
							Ba.dynamicDataSource = null;
							Ba.fields = null;
							Ba.fieldsIndex = null;
							Ba.formTemplate = null;
							Ba.fullExtent = null;
							Ba.geometryType = null;
							Ba.hasM = void 0;
							Ba.hasZ = void 0;
							Ba.infoFor3D = null;
							Ba.isTable = !1;
							Ba.labelsVisible = !0;
							Ba.labelingInfo = null;
							Ba.legendEnabled = !0;
							Ba.objectIdField = null;
							Ba.outFields = null;
							Ba.path = null;
							Ba.popupEnabled = !0;
							Ba.popupTemplate = null;
							Ba.screenSizePerspectiveEnabled = !0;
							Ba.spatialReference = U.WGS84;
							Ba.subtypeCode =
								null;
							Ba.templates = null;
							Ba.timeInfo = null;
							Ba.title = null;
							Ba.sublayerTitleMode = "item-title";
							Ba.type = "feature";
							Ba.typeIdField = null;
							Ba.types = null;
							Ba.visible = !0;
							return Ba
						}
						b._inheritsLoose(ab, Ya);
						var Qa = ab.prototype;
						Qa.destroy = function() {
							this.source ? .destroy();
							this._handles = B.destroyMaybe(this._handles)
						};
						Qa.normalizeCtorArgs = function(Ba, O) {
							return "string" === typeof Ba ? {
								url: Ba,
								...O
							} : Ba
						};
						Qa.load = function(Ba) {
							var O = this;
							const Y = B.isSome(Ba) ? Ba.signal : null;
							if (this.portalItem ? .loaded && this.source) return this.addResolvingPromise(this.createGraphicsSource(Y)
								.then(za =>
									this.initLayerProperties(za))), Promise.resolve(this);
							const ya = this.loadFromPortal({
									supportedTypes: ["Feature Service", "Feature Collection"]
								}, Ba)
								.catch(C.throwIfAbortError)
								.then(b._asyncToGenerator(function*() {
									if (O.url && null == O.layerId && /FeatureServer|MapServer\/*$/i.test(O.url)) {
										const za = yield O._fetchFirstLayerId(Y);
										null != za && (O.layerId = za)
									}
									if (!O.url && !O._hasMemorySource()) throw new x("feature-layer:missing-url-or-source", "Feature layer must be created with either a url or a source");
									return O.initLayerProperties(yield O.createGraphicsSource(Y))
								}))
								.then(() =>
									this.finishLoadEditablePortalLayer(Ba));
							this.addResolvingPromise(ya);
							return Promise.resolve(this)
						};
						Qa.readCapabilities = function(Ba, O) {
							O = O.layerDefinition || O;
							return ha.getFeatureLayerCapabilities(Ba, O, this.url)
						};
						Qa.readEditingEnabled = function(Ba, O) {
							return this._readEditingEnabled(O, !1)
						};
						Qa.readEditingEnabledFromWebMap = function(Ba, O, Y) {
							return this._readEditingEnabled(O, !0, Y)
						};
						Qa.writeEditingEnabled = function(Ba, O) {
							this._writeEditingEnabled(Ba, O, !1)
						};
						Qa.writeEditingEnabledToWebMap = function(Ba, O, Y, ya) {
							this._writeEditingEnabled(Ba,
								O, !0, ya)
						};
						Qa.readIsTable = function(Ba, O) {
							O = O ? .layerDefinition ? ? O;
							return "Table" === O.type || !O.geometryType
						};
						Qa.writeIsTable = function(Ba, O, Y, ya) {
							ya ? .writeLayerSchema && z.setDeepValue(Y, Ba ? "Table" : "Feature Layer", O)
						};
						Qa.readGlobalIdField = function(Ba, O) {
							return ha.readGlobalIdField(O.layerDefinition || O)
						};
						Qa.readObjectIdField = function(Ba, O) {
							return ha.readObjectIdField(O.layerDefinition || O)
						};
						Qa.readRenderer = function(Ba, O, Y) {
							O = O.layerDefinition || O;
							if (Ba = O.drawingInfo ? .renderer) return (Ba = p.read(Ba, O, Y) ? ? void 0) ||
								bb.error("Failed to create renderer", {
									rendererDefinition: O.drawingInfo.renderer,
									layer: this,
									context: Y
								}), Ba;
							if (O.defaultSymbol) return O.types && O.types.length ? new r({
								defaultSymbol: $a(O.defaultSymbol, O, Y),
								field: O.typeIdField,
								uniqueValueInfos: O.types.map(ya => ({
									id: ya.id,
									symbol: $a(ya.symbol, ya, Y)
								}))
							}) : new l({
								symbol: $a(O.defaultSymbol, O, Y)
							})
						};
						Qa.castSource = function(Ba) {
							return Ba ? Array.isArray(Ba) || Ba instanceof u ? new M.MemorySource({
								layer: this,
								items: Ba
							}) : Ba : null
						};
						Qa.readSource = function(Ba, O) {
							Ba = Ga.fromJSON(O.featureSet);
							return new M.MemorySource({
								layer: this,
								items: Ba ? .features ? ? []
							})
						};
						Qa.readTemplates = function(Ba, O) {
							var Y = O.editFieldsInfo;
							O = Y && Y.creatorField;
							Y = Y && Y.editorField;
							Ba = Ba && Ba.map(ya => P.fromJSON(ya));
							this._fixTemplates(Ba, O);
							this._fixTemplates(Ba, Y);
							return Ba
						};
						Qa.readTitle = function(Ba, O) {
							Ba = O.layerDefinition ? .name ? ? O.name;
							O = O.title || O.layerDefinition && O.layerDefinition.title;
							if (Ba) {
								O = this.portalItem && this.portalItem.title;
								if ("item-title" === this.sublayerTitleMode) return this.url ? ba.titleFromUrlAndName(this.url,
									Ba) : Ba;
								if (!Ba && this.url) {
									const Y = ba.parse(this.url);
									B.isSome(Y) && (Ba = Y.title)
								}
								if (!Ba) return;
								"item-title-and-service-name" === this.sublayerTitleMode && O && O !== Ba && (Ba = O + " - " + Ba);
								return ba.cleanTitle(Ba)
							}
							if ("item-title" === this.sublayerTitleMode && O) return O
						};
						Qa.readTitleFromWebMap = function(Ba, O) {
							return O.title || O.layerDefinition && O.layerDefinition.name
						};
						Qa.readTypeIdField = function(Ba, O) {
							O = O.layerDefinition || O;
							let Y = O.typeIdField;
							Y && O.fields && (Y = Y.toLowerCase(), Ba = O.fields.find(ya => ya.name.toLowerCase() ===
								Y)) && (Y = Ba.name);
							return Y
						};
						Qa.readTypes = function(Ba, O) {
							O = O.layerDefinition || O;
							Ba = O.types;
							const Y = (O = O.editFieldsInfo) && O.creatorField,
								ya = O && O.editorField;
							return Ba && Ba.map(za => {
								za = ca.fromJSON(za);
								this._fixTemplates(za.templates, Y);
								this._fixTemplates(za.templates, ya);
								return za
							})
						};
						Qa.readVisible = function(Ba, O) {
							if (O.layerDefinition && null != O.layerDefinition.defaultVisibility) return !!O.layerDefinition.defaultVisibility;
							if (null != O.visibility) return !!O.visibility
						};
						Qa.addAttachment = function() {
							var Ba = b._asyncToGenerator(function*(O,
								Y) {
								return ha.addAttachment(this, O, Y, "FeatureLayer")
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.updateAttachment = function() {
							var Ba = b._asyncToGenerator(function*(O, Y, ya) {
								return ha.updateAttachment(this, O, Y, ya, "FeatureLayer")
							});
							return function(O, Y, ya) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.applyEdits = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								return ha.applyEdits(this, O, Y)
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.on = function(Ba, O) {
							return Ya.prototype.on.call(this,
								Ba, O)
						};
						Qa.createPopupTemplate = function(Ba) {
							return Ta.createPopupTemplate(this, Ba)
						};
						Qa.createGraphicsSource = function() {
							var Ba = b._asyncToGenerator(function*(O) {
								if (this._hasMemorySource() && this.source) return this.source.load({
									signal: O
								});
								const {
									default: Y
								} = yield C.whenOrAbort(new Promise((ya, za) => a(["./graphics/sources/FeatureLayerSource"], fa => ya(Object.freeze(Object.defineProperty({
									__proto__: null,
									default: fa
								}, Symbol.toStringTag, {
									value: "Module"
								}))), za)), O);
								return (new Y({
										layer: this
									}))
									.load({
										signal: O
									})
							});
							return function(O) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.createQuery = function() {
							const Ba = ha.createQuery(this);
							Ba.dynamicDataSource = this.dynamicDataSource;
							var O = B.isSome(this.subtypeCode) ? `${this.subtypeField} = ${this.subtypeCode}` : null;
							O = D.sqlAnd(this.definitionExpression, O);
							Ba.where = O || "1\x3d1";
							return Ba
						};
						Qa.deleteAttachments = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								return ha.deleteAttachments(this, O, Y, "FeatureLayer")
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.fetchRecomputedExtents =
							function() {
								var Ba = b._asyncToGenerator(function*(O) {
									return ha.fetchRecomputedExtents(this, O, "FeatureLayer")
								});
								return function(O) {
									return Ba.apply(this, arguments)
								}
							}();
						Qa.getFeatureType = function(Ba) {
							const {
								typeIdField: O,
								types: Y
							} = this;
							if (!O || !Ba) return null;
							const ya = Ba.attributes ? Ba.attributes[O] : void 0;
							if (null == ya) return null;
							let za = null;
							Y ? .some(fa => {
								const {
									id: Pa
								} = fa;
								if (null == Pa) return !1;
								Pa.toString() === ya.toString() && (za = fa);
								return !!za
							});
							return za
						};
						Qa.getFieldDomain = function(Ba, O) {
							return (O = this.getFeatureType(O &&
								O.feature)) && (O = O.domains && O.domains[Ba]) && "inherited" !== O.type ? O : this._getLayerDomain(Ba)
						};
						Qa.getField = function(Ba) {
							return this.fieldsIndex.get(Ba)
						};
						Qa.queryAttachments = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								return ha.queryAttachments(this, O, Y, "FeatureLayer")
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryFeatures = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								const ya = yield this.load();
								O = yield ya.source.queryFeatures(Na.from(O) ? ? ya.createQuery(), Y);
								if (O ? .features)
									for (const za of O.features) za.layer =
										za.sourceLayer = ya;
								return O
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryObjectIds = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								return ha.queryObjectIds(this, O, Y, "FeatureLayer")
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryFeatureCount = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								return ha.queryFeatureCount(this, O, Y, "FeatureLayer")
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryExtent = function() {
							var Ba = b._asyncToGenerator(function*(O,
								Y) {
								return ha.queryExtent(this, O, Y, "FeatureLayer")
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryRelatedFeatures = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								return ha.queryRelatedFeatures(this, O, Y, "FeatureLayer")
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryRelatedFeaturesCount = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								return ha.queryRelatedFeaturesCount(this, O, Y, "FeatureLayer")
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryTopFeatures = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								const {
									source: ya,
									capabilities: za
								} = yield this.load();
								if (!ya.queryTopFeatures || !za ? .query ? .supportsTopFeaturesQuery) throw new x("FeatureLayer", "Layer source does not support queryTopFeatures capability");
								O = yield ya.queryTopFeatures(Ma.from(O), Y);
								if (O ? .features)
									for (const fa of O.features) fa.layer = fa.sourceLayer = this;
								return O
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryTopObjectIds = function() {
							var Ba = b._asyncToGenerator(function*(O,
								Y) {
								const {
									source: ya,
									capabilities: za
								} = yield this.load();
								if (!ya.queryTopObjectIds || !za ? .query.supportsTopFeaturesQuery) throw new x("FeatureLayer", "Layer source does not support queryTopObjectIds capability");
								return ya.queryTopObjectIds(Ma.from(O), Y)
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryTopFeaturesExtent = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								const {
									source: ya,
									capabilities: za
								} = yield this.load();
								if (!ya.queryTopExtents || !za ? .query ? .supportsTopFeaturesQuery) throw new x("FeatureLayer",
									"Layer source does not support queryTopExtents capability");
								return ya.queryTopExtents(Ma.from(O), Y)
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.queryTopFeatureCount = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								const {
									source: ya,
									capabilities: za
								} = yield this.load();
								if (!ya.queryTopCount || !za ? .query ? .supportsTopFeaturesQuery) throw new x("FeatureLayer", "Layer source does not support queryFeatureCount capability");
								return ya.queryTopCount(Ma.from(O), Y)
							});
							return function(O, Y) {
								return Ba.apply(this,
									arguments)
							}
						}();
						Qa.read = function(Ba, O) {
							const Y = Ba.featureCollection;
							if (Y) {
								const ya = Y.layers;
								ya && 1 === ya.length && (Ya.prototype.read.call(this, ya[0], O), null != Y.showLegend && Ya.prototype.read.call(this, {
									showLegend: Y.showLegend
								}, O))
							}
							Ya.prototype.read.call(this, Ba, O);
							O && "service" === O.origin && this.revert(["objectIdField", "fields", "timeInfo", "spatialReference"], "service")
						};
						Qa.write = function(Ba, O) {
							O = {
								...O,
								origin: O ? .origin ? ? void 0,
								writeLayerSchema: O ? .writeLayerSchema ? ? this._hasMemorySource()
							};
							const {
								origin: Y,
								layerContainerType: ya,
								messages: za
							} = O;
							if (this.dynamicDataSource) return za ? .push(Wa(this, "using a dynamic data source cannot be written to web scenes, web maps and feature service items")), null;
							if (this.isTable) {
								if ("web-scene" === Y || "web-map" === Y && "tables" !== ya) return za ? .push(Wa(this, "using a table source cannot be written to web scenes and web maps")), null;
								if (this._hasMemorySource()) return za ? .push(Wa(this, "using an in-memory table source cannot be written to web scenes and web maps")), null
							} else if (this.loaded &&
								"web-map" === Y && "tables" === ya) return za ? .push(Wa(this, "using a non-table source cannot be written to tables in web maps")), null;
							return Ya.prototype.write.call(this, Ba, O)
						};
						Qa.clone = function() {
							if (this._hasMemorySource()) throw new x("FeatureLayer", `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);
							return Ya.prototype.clone.call(this)
						};
						Qa.serviceSupportsSpatialReference = function(Ba) {
							return this.loaded ? "memory" === this.source ? .type ? !0 : aa.serviceSupportsSpatialReference(this,
								Ba) : !1
						};
						Qa.save = function() {
							var Ba = b._asyncToGenerator(function*(O) {
								return (yield new Promise((Y, ya) => a(["./save/featureLayerUtils"], Y, ya)))
									.save(this, O)
							});
							return function(O) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.saveAs = function() {
							var Ba = b._asyncToGenerator(function*(O, Y) {
								return (yield new Promise((ya, za) => a(["./save/featureLayerUtils"], ya, za)))
									.saveAs(this, O, Y)
							});
							return function(O, Y) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa._readEditingEnabled = function(Ba, O, Y) {
							let ya = Ba.layerDefinition ? .capabilities;
							if (ya) return this._hasEditingCapability(ya);
							ya = Ba.capabilities;
							if (O && "web-map" === Y ? .origin && !this._hasMemorySource() && ya) return this._hasEditingCapability(ya)
						};
						Qa._hasEditingCapability = function(Ba) {
							return Ba.toLowerCase()
								.split(",")
								.map(O => O.trim())
								.includes("editing")
						};
						Qa._writeEditingEnabled = function(Ba, O, Y, ya) {
							Ba || (Ba = this.capabilities ? .operations ? .supportsSync ? "Query,Sync" : "Query", z.setDeepValue("layerDefinition.capabilities", Ba, O), Y && !ya ? .writeLayerSchema && (O.capabilities = Ba))
						};
						Qa._getLayerDomain =
							function(Ba) {
								return (Ba = this.fieldsIndex.get(Ba)) ? Ba.domain : null
							};
						Qa._fetchFirstLayerId = function(Ba) {
							return t(this.url, {
									query: {
										f: "json",
										...this.customParameters,
										token: this.apiKey
									},
									responseType: "json",
									signal: Ba
								})
								.then(O => {
									if (O = O.data) {
										if (Array.isArray(O.layers) && 0 < O.layers.length) return O.layers[0].id;
										if (Array.isArray(O.tables) && 0 < O.tables.length) return O.tables[0].id
									}
								})
						};
						Qa.initLayerProperties = function() {
							var Ba = b._asyncToGenerator(function*(O) {
								this._set("source", O);
								O.sourceJSON && (this.sourceJSON = O.sourceJSON,
									this.read(O.sourceJSON, {
										origin: "service",
										url: this.parsedUrl
									}));
								this._verifySource();
								this._verifyFields();
								va.fixRendererFields(this.renderer, this.fieldsIndex);
								va.fixTimeInfoFields(this.timeInfo, this.fieldsIndex);
								return Da.loadStyleRenderer(this, {
									origin: "service"
								})
							});
							return function(O) {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.hasDataChanged = function() {
							var Ba = b._asyncToGenerator(function*() {
								return ha.hasDataChanged(this)
							});
							return function() {
								return Ba.apply(this, arguments)
							}
						}();
						Qa.fetchPublishingStatus =
							function() {
								var Ba = b._asyncToGenerator(function*() {
									const O = this.source;
									return O ? .fetchPublishingStatus ? O.fetchPublishingStatus() : "unavailable"
								});
								return function() {
									return Ba.apply(this, arguments)
								}
							}();
						Qa._verifyFields = function() {
							const Ba = this.parsedUrl ? .path ? ? "undefined";
							this.objectIdField || console.log("FeatureLayer: 'objectIdField' property is not defined (url: " + Ba + ")");
							this.isTable || this._hasMemorySource() || -1 !== Ba.search(/\/FeatureServer\//i) || this.fields ? .some(O => "geometry" === O.type) || console.log("FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " +
								Ba + ")")
						};
						Qa._fixTemplates = function(Ba, O) {
							Ba && Ba.forEach(Y => {
								(Y = Y.prototype && Y.prototype.attributes) && O && delete Y[O]
							})
						};
						Qa._verifySource = function() {
							if (this._hasMemorySource()) {
								if (this.url) throw new x("feature-layer:mixed-source-and-url", "FeatureLayer cannot be created with both an in-memory source and a url");
							} else if (!this.url) throw new x("feature-layer:source-or-url-required", "FeatureLayer requires either a url, a valid portal item or a source");
						};
						Qa._initMemorySource = function(Ba) {
							Ba.forEach(O => {
								O.layer = this;
								O.sourceLayer = this
							});
							this._handles.add([Ba.on("after-add", O => {
								O.item.layer = this;
								O.item.sourceLayer = this
							}), Ba.on("after-remove", O => {
								O.item.layer = null;
								O.item.sourceLayer = null
							})], "fl-source")
						};
						Qa._resetMemorySource = function(Ba) {
							Ba.forEach(O => {
								O.layer = null;
								O.sourceLayer = null
							});
							this._handles.remove("fl-source")
						};
						Qa._hasMemorySource = function() {
							return !(this.url || !this.source)
						};
						b._createClass(ab, [{
							key: "createQueryVersion",
							get: function() {
								this.commitProperty("definitionExpression");
								this.commitProperty("dynamicDataSource");
								this.commitProperty("timeExtent");
								this.commitProperty("timeOffset");
								this.commitProperty("geometryType");
								this.commitProperty("gdbVersion");
								this.commitProperty("historicMoment");
								this.commitProperty("returnZ");
								this.commitProperty("capabilities");
								this.commitProperty("returnM");
								return (this._get("createQueryVersion") ? ? 0) + 1
							}
						}, {
							key: "editingEnabled",
							get: function() {
								return this.loaded && !this.capabilities ? .operations.supportsEditing ? !1 : this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this._hasMemorySource() ||
									this.userHasEditingPrivileges
							},
							set: function(Ba) {
								this._overrideIfSome("editingEnabled", Ba)
							}
						}, {
							key: "parsedUrl",
							get: function() {
								const Ba = J.urlToObject(this.url);
								null != Ba && (null != this.dynamicDataSource ? Ba.path = J.join(Ba.path, "dynamicLayer") : null != this.layerId && (Ba.path = J.join(Ba.path, this.layerId.toString())));
								return Ba
							}
						}, {
							key: "defaultPopupTemplate",
							get: function() {
								return this.createPopupTemplate()
							}
						}, {
							key: "renderer",
							set: function(Ba) {
								va.fixRendererFields(Ba, this.fieldsIndex);
								this._set("renderer", Ba)
							}
						}, {
							key: "source",
							set: function(Ba) {
								const O = this._get("source");
								O !== Ba && (O && O instanceof u && this._resetMemorySource(O), Ba && Ba instanceof u && this._initMemorySource(Ba), this._set("source", Ba))
							}
						}]);
						return ab
					}(da.FeatureLayerBase(ja.FeatureReductionLayer(Ka.FeatureEffectLayer(ea.PublishableLayer(Aa.EditBusLayer(oa.BlendLayer(I.OrderedLayer(S.TemporalLayer(xa.ScaleRangeLayer(pa.RefreshableLayer(Z.ArcGISService(sa.OperationalLayer(N.PortalLayer(E.MultiOriginJSONMixin(qa.CustomParametersMixin(T.APIKeyMixin(q.ClonableMixin(W))))))))))))))))));
					c.__decorate([G.reader("service", "capabilities")], q.prototype, "readCapabilities", null);
					c.__decorate([K.property({
						json: {
							origins: {
								"portal-item": {
									write: !0
								},
								"web-map": {
									write: !0
								}
							}
						}
					})], q.prototype, "charts", void 0);
					c.__decorate([K.property({
						readOnly: !0
					})], q.prototype, "createQueryVersion", null);
					c.__decorate([K.property({
						json: {
							read: {
								source: "layerDefinition.copyrightText"
							}
						}
					})], q.prototype, "copyright", void 0);
					c.__decorate([K.property({
							json: {
								read: {
									source: "layerDefinition.displayField"
								}
							}
						})], q.prototype, "displayField",
						void 0);
					c.__decorate([K.property({
						types: h.symbolTypes,
						readOnly: !0
					})], q.prototype, "defaultSymbol", void 0);
					c.__decorate([K.property({
						type: ta.DataLayerSource
					})], q.prototype, "dynamicDataSource", void 0);
					c.__decorate([K.property({
						type: Boolean
					})], q.prototype, "editingEnabled", null);
					c.__decorate([G.reader(["portal-item", "web-scene"], "editingEnabled", ["layerDefinition.capabilities"])], q.prototype, "readEditingEnabled", null);
					c.__decorate([G.reader("web-map", "editingEnabled", ["capabilities", "layerDefinition.capabilities"])],
						q.prototype, "readEditingEnabledFromWebMap", null);
					c.__decorate([L.writer(["portal-item", "web-scene"], "editingEnabled", {
						"layerDefinition.capabilities": {
							type: String
						}
					})], q.prototype, "writeEditingEnabled", null);
					c.__decorate([L.writer("web-map", "editingEnabled", {
						capabilities: {
							type: String
						},
						"layerDefinition.capabilities": {
							type: String
						}
					})], q.prototype, "writeEditingEnabledToWebMap", null);
					c.__decorate([K.property({
						...d.fields,
						json: {
							read: {
								source: "layerDefinition.fields"
							},
							origins: {
								service: {
									name: "fields"
								},
								"web-map": {
									write: {
										target: "layerDefinition.fields",
										overridePolicy: Xa
									}
								}
							}
						}
					})], q.prototype, "fields", void 0);
					c.__decorate([K.property(d.fieldsIndex)], q.prototype, "fieldsIndex", void 0);
					c.__decorate([K.property({
						type: V,
						json: {
							name: "formInfo",
							write: !0,
							origins: {
								"web-scene": {
									read: !1,
									write: !1
								}
							}
						}
					})], q.prototype, "formTemplate", void 0);
					c.__decorate([K.property({
						json: {
							read: {
								source: "layerDefinition.extent"
							}
						}
					})], q.prototype, "fullExtent", void 0);
					c.__decorate([K.property({
						json: {
							origins: {
								"web-map": {
									write: {
										target: "layerDefinition.geometryType",
										overridePolicy: Xa,
										writer(Ya,
											ab, Qa) {
											(Ya = Ya ? ha.geometryTypeKebabDict.toJSON(Ya) : null) && z.setDeepValue(Qa, Ya, ab)
										}
									}
								}
							},
							read: {
								source: "layerDefinition.geometryType",
								reader: ha.geometryTypeKebabDict.read
							}
						}
					})], q.prototype, "geometryType", void 0);
					c.__decorate([K.property({
						json: {
							read: {
								source: "layerDefinition.hasM"
							}
						}
					})], q.prototype, "hasM", void 0);
					c.__decorate([K.property({
						json: {
							read: {
								source: "layerDefinition.hasZ"
							}
						}
					})], q.prototype, "hasZ", void 0);
					c.__decorate([K.property(la.id)], q.prototype, "id", void 0);
					c.__decorate([K.property({
						readOnly: !0,
						json: {
							origins: {
								service: {
									read: !0
								}
							},
							read: !1
						}
					})], q.prototype, "infoFor3D", void 0);
					c.__decorate([K.property({
						json: {
							origins: {
								"web-map": {
									write: {
										target: "layerDefinition.type"
									}
								}
							}
						}
					})], q.prototype, "isTable", void 0);
					c.__decorate([G.reader("service", "isTable", ["type", "geometryType"]), G.reader("isTable", ["layerDefinition.type", "layerDefinition.geometryType"])], q.prototype, "readIsTable", null);
					c.__decorate([L.writer("web-map", "isTable")], q.prototype, "writeIsTable", null);
					c.__decorate([K.property(la.labelsVisible)],
						q.prototype, "labelsVisible", void 0);
					c.__decorate([K.property({
						type: [Ca],
						json: {
							origins: {
								service: {
									read: {
										source: "drawingInfo.labelingInfo",
										reader: ma.reader
									},
									write: {
										target: "drawingInfo.labelingInfo",
										enabled: !1
									}
								}
							},
							read: {
								source: "layerDefinition.drawingInfo.labelingInfo",
								reader: ma.reader
							},
							write: {
								target: "layerDefinition.drawingInfo.labelingInfo"
							}
						}
					})], q.prototype, "labelingInfo", void 0);
					c.__decorate([K.property((() => {
						const Ya = w.clone(la.opacityDrawingInfo);
						Ya.json.origins["portal-item"] = {
							write: {
								target: "layerDefinition.drawingInfo.transparency",
								writer(ab, Qa, Ba) {
									z.setDeepValue(Ba, Ra.opacityToTransparency(ab), Qa)
								}
							}
						};
						return Ya
					})())], q.prototype, "opacity", void 0);
					c.__decorate([K.property(la.legendEnabled)], q.prototype, "legendEnabled", void 0);
					c.__decorate([K.property({
						type: ["show", "hide"],
						json: (() => {
							const Ya = w.clone(la.listMode.json);
							Ya.origins["portal-item"] = {
								read: !1,
								write: !1
							};
							return Ya
						})()
					})], q.prototype, "listMode", void 0);
					c.__decorate([G.reader("globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], q.prototype, "readGlobalIdField",
						null);
					c.__decorate([K.property({
						json: {
							origins: {
								"web-map": {
									write: {
										target: "layerDefinition.objectIdField",
										overridePolicy: Xa
									}
								}
							}
						}
					})], q.prototype, "objectIdField", void 0);
					c.__decorate([G.reader("objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], q.prototype, "readObjectIdField", null);
					c.__decorate([K.property({
						value: "ArcGISFeatureLayer",
						type: ["ArcGISFeatureLayer"]
					})], q.prototype, "operationalLayerType", void 0);
					c.__decorate([K.property(d.outFields)], q.prototype, "outFields", void 0);
					c.__decorate([K.property({
						readOnly: !0
					})], q.prototype, "parsedUrl", null);
					c.__decorate([K.property({
						type: String,
						json: {
							origins: {
								"web-scene": {
									read: !0,
									write: !0
								}
							},
							read: !1
						}
					})], q.prototype, "path", void 0);
					c.__decorate([K.property(la.popupEnabled)], q.prototype, "popupEnabled", void 0);
					c.__decorate([K.property({
						type: e,
						json: {
							name: "popupInfo",
							write: !0
						}
					})], q.prototype, "popupTemplate", void 0);
					c.__decorate([K.property({
						readOnly: !0
					})], q.prototype, "defaultPopupTemplate", null);
					c.__decorate([K.property({
						types: n.rendererTypes,
						json: {
							origins: {
								service: {
									write: {
										target: "drawingInfo.renderer",
										enabled: !1
									}
								},
								"web-scene": {
									types: n.webSceneRendererTypes,
									name: "layerDefinition.drawingInfo.renderer",
									write: {
										overridePolicy(Ya, ab, Qa) {
											return {
												ignoreOrigin: Qa ? .writeLayerSchema
											}
										}
									}
								}
							},
							write: {
								target: "layerDefinition.drawingInfo.renderer",
								overridePolicy(Ya, ab, Qa) {
									return {
										ignoreOrigin: Qa ? .writeLayerSchema
									}
								}
							}
						}
					})], q.prototype, "renderer", null);
					c.__decorate([G.reader("service", "renderer", ["drawingInfo.renderer", "defaultSymbol"]), G.reader("renderer", ["layerDefinition.drawingInfo.renderer",
						"layerDefinition.defaultSymbol"
					])], q.prototype, "readRenderer", null);
					c.__decorate([K.property((() => {
						const Ya = w.clone(la.screenSizePerspectiveEnabled);
						Ya.json.origins["portal-item"] = {
							read: !1,
							write: !1
						};
						return Ya
					})())], q.prototype, "screenSizePerspectiveEnabled", void 0);
					c.__decorate([K.property({
						clonable: !1
					})], q.prototype, "source", null);
					c.__decorate([H.cast("source")], q.prototype, "castSource", null);
					c.__decorate([G.reader("portal-item", "source", ["featureSet"]), G.reader("web-map", "source", ["featureSet"])],
						q.prototype, "readSource", null);
					c.__decorate([K.property({
						json: {
							read: {
								source: "layerDefinition.extent.spatialReference"
							}
						}
					})], q.prototype, "spatialReference", void 0);
					c.__decorate([K.property({
						type: Number
					})], q.prototype, "subtypeCode", void 0);
					c.__decorate([K.property({
						type: [P]
					})], q.prototype, "templates", void 0);
					c.__decorate([G.reader("templates", ["editFieldsInfo", "creatorField", "editorField", "templates"])], q.prototype, "readTemplates", null);
					c.__decorate([K.property({
						type: Q
					})], q.prototype, "timeInfo", void 0);
					c.__decorate([K.property()], q.prototype, "title", void 0);
					c.__decorate([G.reader("service", "title", ["name"]), G.reader("portal-item", "title", ["layerDefinition.title", "layerDefinition.name", "title"])], q.prototype, "readTitle", null);
					c.__decorate([G.reader("web-map", "title", ["layerDefinition.name", "title"])], q.prototype, "readTitleFromWebMap", null);
					c.__decorate([K.property({
						type: String
					})], q.prototype, "sublayerTitleMode", void 0);
					c.__decorate([K.property({
						json: {
							read: !1
						}
					})], q.prototype, "type", void 0);
					c.__decorate([K.property({
							type: String
						})],
						q.prototype, "typeIdField", void 0);
					c.__decorate([G.reader("service", "typeIdField"), G.reader("typeIdField", ["layerDefinition.typeIdField"])], q.prototype, "readTypeIdField", null);
					c.__decorate([K.property({
						type: [ca]
					})], q.prototype, "types", void 0);
					c.__decorate([G.reader("service", "types", ["types"]), G.reader("types", ["layerDefinition.types"])], q.prototype, "readTypes", null);
					c.__decorate([K.property({
							type: Boolean,
							json: {
								origins: {
									"portal-item": {
										write: {
											target: "layerDefinition.defaultVisibility"
										}
									}
								}
							}
						})], q.prototype,
						"visible", void 0);
					c.__decorate([G.reader("portal-item", "visible", ["visibility", "layerDefinition.defaultVisibility"])], q.prototype, "readVisible", null);
					q = c.__decorate([F.subclass("esri.layers.FeatureLayer")], q);
					const $a = R.createTypeReader({
						types: h.symbolTypesRenderer
					});
					return q
				})
		},
		"esri/PopupTemplate": function() {
			define("./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./core/Clonable ./core/Collection ./core/JSONSupport ./core/lang ./core/Logger ./core/promiseUtils ./core/accessorSupport/decorators/property ./core/accessorSupport/decorators/cast ./core/accessorSupport/decorators/reader ./core/accessorSupport/decorators/subclass ./core/accessorSupport/decorators/writer ./core/accessorSupport/ensureType ./layers/support/fieldUtils ./popup/content ./popup/ExpressionInfo ./popup/FieldInfo ./popup/LayerOptions ./popup/RelatedRecordsInfo ./popup/content/support/mediaInfoTypes ./support/actions/ActionBase ./support/actions/ActionButton ./support/actions/ActionToggle ./popup/content/MediaContent ./popup/content/TextContent ./popup/content/AttachmentsContent ./popup/content/FieldsContent ./popup/content/ExpressionContent ./popup/content/RelationshipContent ./popup/content/Content ./popup/content/CustomContent".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D, J, K, H, G, F) {
					const L = v.getLogger("esri.PopupTemplate");
					v = e.ofType({
						key: "type",
						defaultKeyValue: "button",
						base: A,
						typeMap: {
							button: B,
							toggle: E
						}
					});
					const R = {
							base: G,
							key: "type",
							typeMap: {
								media: z,
								custom: F,
								text: C,
								attachments: D,
								fields: J,
								expression: K,
								relationship: H
							}
						},
						V = "attachments fields media text expression relationship".split(" ");
					c = function(U) {
						function W() {
							var T = U.apply(this, arguments) || this;
							T.actions = null;
							T.content = "";
							T.expressionInfos = null;
							T.fieldInfos =
								null;
							T.layerOptions = null;
							T.lastEditInfoEnabled = !0;
							T.outFields = null;
							T.overwriteActions = !1;
							T.returnGeometry = !1;
							T.title = "";
							return T
						}
						a._inheritsLoose(W, U);
						var M = W.prototype;
						M.castContent = function(T) {
							if (Array.isArray(T)) return T.map(Z => n.ensureOneOfType(R, Z));
							if ("string" === typeof T || "function" === typeof T || T instanceof HTMLElement || m.isPromiseLike(T)) return T;
							L.error("content error", "unsupported content value", {
								value: T
							});
							return null
						};
						M.readContent = function(T, Z) {
							({
								popupElements: T
							} = Z);
							return Array.isArray(T) &&
								0 < T.length ? this._readPopupInfoElements(Z.description, Z.mediaInfos, T) : this._readPopupInfo(Z)
						};
						M.writeContent = function(T, Z, oa, qa) {
							"string" === typeof T ? Z.description = T : Array.isArray(T) && (Z.popupElements = T.filter(Aa => V.includes(Aa.type))
								.map(Aa => Aa && Aa.toJSON(qa)), Z.popupElements.forEach(Aa => {
									"attachments" === Aa.type ? this._writeAttachmentContent(Z) : "media" === Aa.type ? this._writeMediaContent(Aa, Z) : "text" === Aa.type ? this._writeTextContent(Aa, Z) : "relationship" === Aa.type && this._writeRelationshipContent(Aa, Z)
								}))
						};
						M.writeFieldInfos = function(T, Z, oa, qa) {
							({
								content: oa
							} = this);
							oa = Array.isArray(oa) ? oa : null;
							if (T) {
								const Aa = oa ? oa.filter(da => "fields" === da.type) : [],
									Ka = Aa.length && Aa.every(da => da.fieldInfos ? .length);
								Z.fieldInfos = T.filter(Boolean)
									.map(da => {
										da = da.toJSON(qa);
										Ka && (da.visible = !1);
										return da
									})
							}
							if (oa)
								for (const Aa of oa) "fields" === Aa.type && this._writeFieldsContent(Aa, Z)
						};
						M.writeLayerOptions = function(T, Z, oa, qa) {
							Z[oa] = !T || null === T.showNoDataRecords && null === T.returnTopmostRaster ? null : T.toJSON(qa)
						};
						M.writeTitle = function(T,
							Z) {
							Z.title = T || ""
						};
						M.collectRequiredFields = function() {
							var T = a._asyncToGenerator(function*(Z, oa) {
								const qa = this.expressionInfos || [];
								yield this._collectExpressionInfoFields(Z, oa, [...qa, ...this._getContentExpressionInfos(this.content, qa)]);
								t.collectFields(Z, oa, [...(this.outFields || []), ...this._getActionsFields(this.actions), ...this._getTitleFields(this.title), ...this._getContentFields(this.content)])
							});
							return function(Z, oa) {
								return T.apply(this, arguments)
							}
						}();
						M.getRequiredFields = function() {
							var T = a._asyncToGenerator(function*(Z) {
								const oa =
									new Set;
								yield this.collectRequiredFields(oa, Z);
								return [...oa].sort()
							});
							return function(Z) {
								return T.apply(this, arguments)
							}
						}();
						M._writeFieldsContent = function(T, Z) {
							Array.isArray(T.fieldInfos) && T.fieldInfos.length && (T = k.clone(T.fieldInfos), Array.isArray(Z.fieldInfos) ? T.forEach(oa => {
								const qa = Z.fieldInfos.find(Aa => Aa.fieldName.toLowerCase() === oa.fieldName.toLowerCase());
								qa ? qa.visible = !0 : Z.fieldInfos.push(oa)
							}) : Z.fieldInfos = T)
						};
						M._writeAttachmentContent = function(T) {
							T.showAttachments || (T.showAttachments = !0)
						};
						M._writeRelationshipContent = function(T, Z) {
							var oa = T.orderByFields ? .map(qa => this._toFieldOrderJSON(qa, T.relationshipId)) || [];
							oa = [...(Z.relatedRecordsInfo ? .orderByFields || []), ...oa];
							Z.relatedRecordsInfo = {
								showRelatedRecords: !0,
								...(oa ? .length && {
									orderByFields: oa
								})
							}
						};
						M._writeTextContent = function(T, Z) {
							!Z.description && T.text && (Z.description = T.text)
						};
						M._writeMediaContent = function(T, Z) {
							Array.isArray(T.mediaInfos) && T.mediaInfos.length && (T = k.clone(T.mediaInfos), Array.isArray(Z.mediaInfos) ? Z.mediaInfos = [...Z.mediaInfos,
								...T
							] : Z.mediaInfos = T)
						};
						M._readPopupInfoElements = function(T, Z, oa) {
							var qa = !1,
								Aa = !1;
							return oa.map(Ka => {
									if ("media" === Ka.type) return Ka.mediaInfos || !Z || Aa || (Ka.mediaInfos = Z, Aa = !0), z.fromJSON(Ka);
									if ("text" === Ka.type) return Ka.text || !T || qa || (Ka.text = T, qa = !0), C.fromJSON(Ka);
									if ("attachments" === Ka.type) return D.fromJSON(Ka);
									if ("fields" === Ka.type) return J.fromJSON(Ka);
									if ("expression" === Ka.type) return K.fromJSON(Ka);
									if ("relationship" === Ka.type) return H.fromJSON(Ka)
								})
								.filter(Boolean)
						};
						M._toRelationshipContent =
							function(T) {
								const {
									field: Z,
									order: oa
								} = T;
								if (!Z ? .startsWith("relationships/")) return null;
								var qa = Z.replace("relationships/", "")
									.split("/");
								if (2 !== qa.length) return null;
								T = parseInt(qa[0], 10);
								qa = qa[1];
								return "number" === typeof T && qa ? H.fromJSON({
									relationshipId: T,
									orderByFields: [{
										field: qa,
										order: oa
									}]
								}) : null
							};
						M._toFieldOrderJSON = function(T, Z) {
							const {
								order: oa,
								field: qa
							} = T;
							return {
								field: `${"relationships/"}${Z}/${qa}`,
								order: oa
							}
						};
						M._readPopupInfo = function({
							description: T,
							mediaInfos: Z,
							showAttachments: oa,
							relatedRecordsInfo: qa = {
								showRelatedRecords: !1
							}
						}) {
							const Aa = [];
							T ? Aa.push(new C({
								text: T
							})) : Aa.push(new J);
							Array.isArray(Z) && Z.length && Aa.push(z.fromJSON({
								mediaInfos: Z
							}));
							oa && Aa.push(D.fromJSON({
								displayType: "auto"
							}));
							const {
								showRelatedRecords: Ka,
								orderByFields: da
							} = qa;
							Ka && da ? .length && da.forEach(ja => {
								(ja = this._toRelationshipContent(ja)) && Aa.push(ja)
							});
							return Aa.length ? Aa : T
						};
						M._getContentElementFields = function(T) {
							var Z = T ? .type;
							return "attachments" === Z ? [...this._extractFieldNames(T.title), ...this._extractFieldNames(T.description)] :
								"custom" === Z ? T.outFields || [] : "fields" === Z ? [...this._extractFieldNames(T.title), ...this._extractFieldNames(T.description), ...this._getFieldInfoFields(T.fieldInfos ? ? this.fieldInfos)] : "media" === Z ? (Z = T.mediaInfos || [], [...this._extractFieldNames(T.title), ...this._extractFieldNames(T.description), ...Z.reduce((oa, qa) => [...oa, ...this._getMediaInfoFields(qa)], [])]) : "text" === Z ? this._extractFieldNames(T.text) : []
						};
						M._getMediaInfoFields = function(T) {
							const {
								caption: Z,
								title: oa,
								value: qa
							} = T, {
								fields: Aa,
								normalizeField: Ka,
								tooltipField: da,
								sourceURL: ja,
								linkURL: sa
							} = qa || {};
							T = [...this._extractFieldNames(oa), ...this._extractFieldNames(Z), ...this._extractFieldNames(ja), ...this._extractFieldNames(sa), ...(Aa ? ? [])];
							Ka && T.push(Ka);
							da && T.push(da);
							return T
						};
						M._getContentExpressionInfos = function(T, Z) {
							return Array.isArray(T) ? T.reduce((oa, qa) => [...oa, ...("expression" === qa.type && qa.expressionInfo ? [qa.expressionInfo] : [])], Z) : []
						};
						M._getContentFields = function(T) {
							return "string" === typeof T ? this._extractFieldNames(T) : Array.isArray(T) ? T.reduce((Z,
								oa) => [...Z, ...this._getContentElementFields(oa)], []) : []
						};
						M._collectExpressionInfoFields = function() {
							var T = a._asyncToGenerator(function*(Z, oa, qa) {
								qa && (yield Promise.all(qa.map(Aa => t.collectArcadeFieldNames(Z, oa, Aa.expression))))
							});
							return function(Z, oa, qa) {
								return T.apply(this, arguments)
							}
						}();
						M._getFieldInfoFields = function(T) {
							return T ? T.filter(Z => "undefined" === typeof Z.visible ? !0 : !!Z.visible)
								.map(Z => Z.fieldName)
								.filter(Z => !Z.startsWith("relationships/") && !Z.startsWith("expression/")) : []
						};
						M._getActionsFields =
							function(T) {
								return T ? T.toArray()
									.reduce((Z, oa) => [...Z, ...this._getActionFields(oa)], []) : []
							};
						M._getActionFields = function(T) {
							const {
								className: Z,
								title: oa,
								type: qa
							} = T;
							T = "button" === qa || "toggle" === qa ? T.image : "";
							return [...this._extractFieldNames(oa), ...this._extractFieldNames(Z), ...this._extractFieldNames(T)]
						};
						M._getTitleFields = function(T) {
							return "string" === typeof T ? this._extractFieldNames(T) : []
						};
						M._extractFieldNames = function(T) {
							if (!T || "string" !== typeof T) return [];
							T = T.match(/{[^}]*}/g);
							if (!T) return [];
							const Z =
								/\{(\w+):.+\}/;
							return (T = T.filter(oa => !(0 === oa.indexOf("{relationships/") || 0 === oa.indexOf("{expression/")))
								.map(oa => oa.replace(Z, "{$1}"))) ? T.map(oa => oa.slice(1, -1)) : []
						};
						return W
					}(c.ClonableMixin(d.JSONSupport));
					b.__decorate([f.property({
						type: v
					})], c.prototype, "actions", void 0);
					b.__decorate([f.property()], c.prototype, "content", void 0);
					b.__decorate([g.cast("content")], c.prototype, "castContent", null);
					b.__decorate([l.reader("content", "description fieldInfos popupElements mediaInfos showAttachments relatedRecordsInfo".split(" "))],
						c.prototype, "readContent", null);
					b.__decorate([p.writer("content", {
						popupElements: {
							type: e.ofType(h.persistableTypes)
						},
						showAttachments: {
							type: Boolean
						},
						mediaInfos: {
							type: e.ofType(w.types)
						},
						description: {
							type: String
						},
						relatedRecordsInfo: {
							type: y
						}
					})], c.prototype, "writeContent", null);
					b.__decorate([f.property({
						type: [q],
						json: {
							write: !0
						}
					})], c.prototype, "expressionInfos", void 0);
					b.__decorate([f.property({
						type: [u]
					})], c.prototype, "fieldInfos", void 0);
					b.__decorate([p.writer("fieldInfos")], c.prototype, "writeFieldInfos",
						null);
					b.__decorate([f.property({
						type: x
					})], c.prototype, "layerOptions", void 0);
					b.__decorate([p.writer("layerOptions")], c.prototype, "writeLayerOptions", null);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							read: {
								source: "showLastEditInfo"
							},
							write: {
								target: "showLastEditInfo"
							},
							default: !0
						}
					})], c.prototype, "lastEditInfoEnabled", void 0);
					b.__decorate([f.property()], c.prototype, "outFields", void 0);
					b.__decorate([f.property()], c.prototype, "overwriteActions", void 0);
					b.__decorate([f.property()], c.prototype, "returnGeometry",
						void 0);
					b.__decorate([f.property({
						json: {
							type: String
						}
					})], c.prototype, "title", void 0);
					b.__decorate([p.writer("title")], c.prototype, "writeTitle", null);
					return c = b.__decorate([r.subclass("esri.PopupTemplate")], c)
				})
		},
		"esri/popup/content": function() {
			define("exports ./content/AttachmentsContent ./content/Content ./content/CustomContent ./content/ExpressionContent ./content/FieldsContent ./content/MediaContent ./content/RelationshipContent ./content/TextContent".split(" "), function(a, b, c, e, d, k, v, m, f) {
				const g = {
					base: null,
					key: "type",
					typeMap: {
						attachment: b,
						media: v,
						text: f,
						expression: d,
						field: k,
						relationship: m
					}
				};
				a.AttachmentsContent = b;
				a.BaseContent = c;
				a.CustomContent = e;
				a.ExpressionContent = d;
				a.FieldsContent = k;
				a.MediaContent = v;
				a.RelationshipContent = m;
				a.TextContent = f;
				a.isContent = function(l) {
					return l instanceof c
				};
				a.persistableTypes = g;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/popup/content/AttachmentsContent": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Content".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.description = null;
							l.displayType = "auto";
							l.title = null;
							l.type = "attachments";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								description: this.description,
								displayType: this.displayType,
								title: this.title
							})
						};
						return g
					}(v);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "description", void 0);
					b.__decorate([c.property({
							type: ["auto", "preview", "list"],
							json: {
								write: !0
							}
						})], e.prototype,
						"displayType", void 0);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "title", void 0);
					b.__decorate([c.property({
						type: ["attachments"],
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = m = b.__decorate([k.subclass("esri.popup.content.AttachmentsContent")], e)
				})
		},
		"esri/popup/content/Content": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f(g) {
							g = m.call(this, g) || this;
							g.type = null;
							return g
						}
						a._inheritsLoose(f, m);
						return f
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: "attachments custom fields media text expression relationship".split(" "),
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], c.prototype, "type", void 0);
					return c = b.__decorate([v.subclass("esri.popup.content.Content")], c)
				})
		},
		"esri/popup/content/CustomContent": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Content".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					d = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.creator = null;
							l.destroyer = null;
							l.outFields = null;
							l.type = "custom";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								creator: this.creator,
								destroyer: this.destroyer,
								outFields: Array.isArray(this.outFields) ? c.clone(this.outFields) : null
							})
						};
						return g
					}(v);
					b.__decorate([e.property()], d.prototype, "creator", void 0);
					b.__decorate([e.property()], d.prototype, "destroyer", void 0);
					b.__decorate([e.property()], d.prototype,
						"outFields", void 0);
					b.__decorate([e.property({
						type: ["custom"],
						readOnly: !0
					})], d.prototype, "type", void 0);
					return d = m = b.__decorate([k.subclass("esri.popup.content.CustomContent")], d)
				})
		},
		"esri/popup/content/ExpressionContent": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../ElementExpressionInfo ./Content".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					e = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.expressionInfo = null;
							r.type = "expression";
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								expressionInfo: this.expressionInfo ? .clone()
							})
						};
						return l
					}(m);
					b.__decorate([c.property({
						type: v,
						json: {
							write: !0
						}
					})], e.prototype, "expressionInfo", void 0);
					b.__decorate([c.property({
						type: ["expression"],
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = f = b.__decorate([k.subclass("esri.popup.content.ExpressionContent")],
						e)
				})
		},
		"esri/popup/ElementExpressionInfo": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v) {
				var m;
				c = m = function(f) {
					function g(l) {
						l = f.call(this, l) || this;
						l.title = null;
						l.expression = null;
						l.returnType = "dictionary";
						return l
					}
					a._inheritsLoose(g, f);
					g.prototype.clone = function() {
						return new m({
							title: this.title,
							expression: this.expression
						})
					};
					return g
				}(c.JSONSupport);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "title", void 0);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "expression", void 0);
				b.__decorate([e.property({
					type: ["dictionary"],
					readOnly: !0,
					json: {
						read: !1,
						write: !0
					}
				})], c.prototype, "returnType", void 0);
				return c = m = b.__decorate([v.subclass("esri.popup.ElementExpressionInfo")], c)
			})
		},
		"esri/popup/content/FieldsContent": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../FieldInfo ./Content".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					d = g = function(l) {
						function r(n) {
							n = l.call(this, n) || this;
							n.attributes = null;
							n.description = null;
							n.fieldInfos = null;
							n.title = null;
							n.type = "fields";
							return n
						}
						a._inheritsLoose(r, l);
						var p = r.prototype;
						p.writeFieldInfos = function(n, t) {
							t.fieldInfos = n && n.map(h => h.toJSON())
						};
						p.clone = function() {
							return new g(c.clone({
								attributes: this.attributes,
								description: this.description,
								fieldInfos: this.fieldInfos,
								title: this.title
							}))
						};
						return r
					}(f);
					b.__decorate([e.property({
							type: Object,
							json: {
								write: !0
							}
						})],
						d.prototype, "attributes", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], d.prototype, "description", void 0);
					b.__decorate([e.property({
						type: [m]
					})], d.prototype, "fieldInfos", void 0);
					b.__decorate([v.writer("fieldInfos")], d.prototype, "writeFieldInfos", null);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], d.prototype, "title", void 0);
					b.__decorate([e.property({
						type: ["fields"],
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], d.prototype, "type", void 0);
					return d = g = b.__decorate([k.subclass("esri.popup.content.FieldsContent")],
						d)
				})
		},
		"esri/popup/FieldInfo": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/jsonMap ../core/JSONSupport ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./support/FieldInfoFormat".split(" "), function(a, b, c, e, d, k, v, m, f, g) {
				var l;
				e = l = function(r) {
					function p(n) {
						n = r.call(this, n) || this;
						n.fieldName = null;
						n.format = null;
						n.isEditable = !1;
						n.label =
							null;
						n.stringFieldOption = "text-box";
						n.statisticType = null;
						n.tooltip = null;
						n.visible = !0;
						return n
					}
					a._inheritsLoose(p, r);
					p.prototype.clone = function() {
						return new l({
							fieldName: this.fieldName,
							format: this.format ? d.clone(this.format) : null,
							isEditable: this.isEditable,
							label: this.label,
							stringFieldOption: this.stringFieldOption,
							statisticType: this.statisticType,
							tooltip: this.tooltip,
							visible: this.visible
						})
					};
					return p
				}(e.JSONSupport);
				b.__decorate([k.property({
					type: String,
					json: {
						write: !0
					}
				})], e.prototype, "fieldName", void 0);
				b.__decorate([k.property({
					type: g,
					json: {
						write: !0
					}
				})], e.prototype, "format", void 0);
				b.__decorate([k.property({
					type: Boolean,
					json: {
						write: !0,
						default: !1
					}
				})], e.prototype, "isEditable", void 0);
				b.__decorate([k.property({
					type: String,
					json: {
						write: !0
					}
				})], e.prototype, "label", void 0);
				b.__decorate([m.enumeration(new c.JSONMap({
					richtext: "rich-text",
					textarea: "text-area",
					textbox: "text-box"
				}), {
					default: "text-box"
				})], e.prototype, "stringFieldOption", void 0);
				b.__decorate([k.property({
					type: "count sum min max avg stddev var".split(" "),
					json: {
						write: !0
					}
				})], e.prototype, "statisticType", void 0);
				b.__decorate([k.property({
					type: String,
					json: {
						write: !0
					}
				})], e.prototype, "tooltip", void 0);
				b.__decorate([k.property({
					type: Boolean,
					json: {
						write: !0
					}
				})], e.prototype, "visible", void 0);
				return e = l = b.__decorate([f.subclass("esri.popup.FieldInfo")], e)
			})
		},
		"esri/popup/support/FieldInfoFormat": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/date ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ../../intl/date ../../intl/number".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					e = r = function(p) {
						function n(h) {
							h = p.call(this, h) || this;
							h.dateFormat = null;
							h.dateTimeFormatOptions = null;
							h.digitSeparator = !1;
							h.places = null;
							return h
						}
						a._inheritsLoose(n, p);
						var t = n.prototype;
						t.clone = function() {
							return new r({
								dateFormat: this.dateFormat,
								digitSeparator: this.digitSeparator,
								places: this.places
							})
						};
						t.format = function(h) {
							return this.dateFormat ? g.formatDate(h, {
								...g.convertDateFormatToIntlOptions(this.dateFormat),
								...this.dateTimeFormatOptions
							}) : l.formatNumber(h, l.convertNumberFormatToIntlOptions(this))
						};
						t.formatRasterPixelValue = function(h) {
							if (h.includes("-")) return h;
							let q;
							return h.trim()
								.includes(",") ? (q = ",", this._formatDelimitedString(h, q, q + " ", this)) : h.trim()
								.includes(";") ? (q = ";", this._formatDelimitedString(h, q, q + " ", this)) : h.trim()
								.includes(" ") ? this._formatDelimitedString(h, " ", " ", this) : this.format(Number(h))
						};
						t._formatDelimitedString = function(h, q, u, x) {
							return h && q && u && x ? h.trim()
								.split(q)
								.map(y => this.format(Number(y)))
								.join(u) : h
						};
						return n
					}(e.JSONSupport);
					b.__decorate([m.enumeration(c.dictionary)],
						e.prototype, "dateFormat", void 0);
					b.__decorate([d.property({
						type: Object,
						json: {
							read: !1
						}
					})], e.prototype, "dateTimeFormatOptions", void 0);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], e.prototype, "digitSeparator", void 0);
					b.__decorate([d.property({
						type: v.Integer,
						json: {
							write: !0
						}
					})], e.prototype, "places", void 0);
					return e = r = b.__decorate([f.subclass("esri.popup.support.FieldInfoFormat")], e)
				})
		},
		"esri/core/date": function() {
			define(["exports", "./jsonMap"], function(a, b) {
				const c = {
					"short-date": "(datePattern: 'M/d/y', selector: 'date')",
					"short-date-short-time": "(datePattern: 'M/d/y', timePattern: 'h:mm a', selector: 'date and time')",
					"short-date-short-time-24": "(datePattern: 'M/d/y', timePattern: 'H:mm', selector: 'date and time')",
					"short-date-long-time": "(datePattern: 'M/d/y', timePattern: 'h:mm:ss a', selector: 'date and time')",
					"short-date-long-time-24": "(datePattern: 'M/d/y', timePattern: 'H:mm:ss', selector: 'date and time')",
					"short-date-le": "(datePattern: 'd/M/y', selector: 'date')",
					"short-date-le-short-time": "(datePattern: 'd/M/y', timePattern: 'h:mm a', selector: 'date and time')",
					"short-date-le-short-time-24": "(datePattern: 'd/M/y', timePattern: 'H:mm', selector: 'date and time')",
					"short-date-le-long-time": "(datePattern: 'd/M/y', timePattern: 'h:mm:ss a', selector: 'date and time')",
					"short-date-le-long-time-24": "(datePattern: 'd/M/y', timePattern: 'H:mm:ss', selector: 'date and time')",
					"long-month-day-year": "(datePattern: 'MMMM d, y', selector: 'date')",
					"long-month-day-year-short-time": "(datePattern: 'MMMM d, y', timePattern: 'h:mm a', selector: 'date and time')",
					"long-month-day-year-short-time-24": "(datePattern: 'MMMM d, y', timePattern: 'H:mm', selector: 'date and time')",
					"long-month-day-year-long-time": "(datePattern: 'MMMM d, y', timePattern: 'h:mm:ss a', selector: 'date and time')",
					"long-month-day-year-long-time-24": "(datePattern: 'MMMM d, y', timePattern: 'H:mm:ss', selector: 'date and time')",
					"day-short-month-year": "(datePattern: 'd MMM y', selector: 'date')",
					"day-short-month-year-short-time": "(datePattern: 'd MMM y', timePattern: 'h:mm a', selector: 'date and time')",
					"day-short-month-year-short-time-24": "(datePattern: 'd MMM y', timePattern: 'H:mm', selector: 'date and time')",
					"day-short-month-year-long-time": "(datePattern: 'd MMM y', timePattern: 'h:mm:ss a', selector: 'date and time')",
					"day-short-month-year-long-time-24": "(datePattern: 'd MMM y', timePattern: 'H:mm:ss', selector: 'date and time')",
					"long-date": "(datePattern: 'EEEE, MMMM d, y', selector: 'date')",
					"long-date-short-time": "(datePattern: 'EEEE, MMMM d, y', timePattern: 'h:mm a', selector: 'date and time')",
					"long-date-short-time-24": "(datePattern: 'EEEE, MMMM d, y', timePattern: 'H:mm', selector: 'date and time')",
					"long-date-long-time": "(datePattern: 'EEEE, MMMM d, y', timePattern: 'h:mm:ss a', selector: 'date and time')",
					"long-date-long-time-24": "(datePattern: 'EEEE, MMMM d, y', timePattern: 'H:mm:ss', selector: 'date and time')",
					"long-month-year": "(datePattern: 'MMMM y', selector: 'date')",
					"short-month-year": "(datePattern: 'MMM y', selector: 'date')",
					year: "(datePattern: 'y', selector: 'date')"
				};
				b = b.strict()({
					shortDate: "short-date",
					shortDateShortTime: "short-date-short-time",
					shortDateShortTime24: "short-date-short-time-24",
					shortDateLongTime: "short-date-long-time",
					shortDateLongTime24: "short-date-long-time-24",
					shortDateLE: "short-date-le",
					shortDateLEShortTime: "short-date-le-short-time",
					shortDateLEShortTime24: "short-date-le-short-time-24",
					shortDateLELongTime: "short-date-le-long-time",
					shortDateLELongTime24: "short-date-le-long-time-24",
					longMonthDayYear: "long-month-day-year",
					longMonthDayYearShortTime: "long-month-day-year-short-time",
					longMonthDayYearShortTime24: "long-month-day-year-short-time-24",
					longMonthDayYearLongTime: "long-month-day-year-long-time",
					longMonthDayYearLongTime24: "long-month-day-year-long-time-24",
					dayShortMonthYear: "day-short-month-year",
					dayShortMonthYearShortTime: "day-short-month-year-short-time",
					dayShortMonthYearShortTime24: "day-short-month-year-short-time-24",
					dayShortMonthYearLongTime: "day-short-month-year-long-time",
					dayShortMonthYearLongTime24: "day-short-month-year-long-time-24",
					longDate: "long-date",
					longDateShortTime: "long-date-short-time",
					longDateShortTime24: "long-date-short-time-24",
					longDateLongTime: "long-date-long-time",
					longDateLongTime24: "long-date-long-time-24",
					longMonthYear: "long-month-year",
					shortMonthYear: "short-month-year",
					year: "year"
				});
				const e = b.toJSON.bind(b),
					d = b.fromJSON.bind(b);
				a.dictionary = b;
				a.formats = c;
				a.fromJSON = d;
				a.getFormat = function(k) {
					return c[k]
				};
				a.toJSON = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/intl/date": function() {
			define(["exports", "../core/jsonMap", "./locale"], function(a, b, c) {
				function e(t) {
					t = t || n;
					var h = p.get(t);
					h || (h = c.getLocale(), h = r[c.getLocale()] || h, h = new Intl.DateTimeFormat(h,
						t), p.set(t, h));
					return h
				}
				var d = {
						year: "numeric",
						month: "numeric",
						day: "numeric"
					},
					k = {
						year: "numeric",
						month: "long",
						day: "numeric"
					},
					v = {
						year: "numeric",
						month: "short",
						day: "numeric"
					};
				const m = {
						year: "numeric",
						month: "long",
						weekday: "long",
						day: "numeric"
					},
					f = {
						hour: "numeric",
						minute: "numeric"
					},
					g = {
						...f,
						second: "numeric"
					},
					l = {
						"short-date": d,
						"short-date-short-time": {
							...d,
							...f
						},
						"short-date-short-time-24": {
							...d,
							...f,
							hour12: !1
						},
						"short-date-long-time": {
							...d,
							...g
						},
						"short-date-long-time-24": {
							...d,
							...g,
							hour12: !1
						},
						"short-date-le": d,
						"short-date-le-short-time": {
							...d,
							...f
						},
						"short-date-le-short-time-24": {
							...d,
							...f,
							hour12: !1
						},
						"short-date-le-long-time": {
							...d,
							...g
						},
						"short-date-le-long-time-24": {
							...d,
							...g,
							hour12: !1
						},
						"long-month-day-year": k,
						"long-month-day-year-short-time": {
							...k,
							...f
						},
						"long-month-day-year-short-time-24": {
							...k,
							...f,
							hour12: !1
						},
						"long-month-day-year-long-time": {
							...k,
							...g
						},
						"long-month-day-year-long-time-24": {
							...k,
							...g,
							hour12: !1
						},
						"day-short-month-year": v,
						"day-short-month-year-short-time": {
							...v,
							...f
						},
						"day-short-month-year-short-time-24": {
							...v,
							...f,
							hour12: !1
						},
						"day-short-month-year-long-time": {
							...v,
							...g
						},
						"day-short-month-year-long-time-24": {
							...v,
							...g,
							hour12: !1
						},
						"long-date": m,
						"long-date-short-time": {
							...m,
							...f
						},
						"long-date-short-time-24": {
							...m,
							...f,
							hour12: !1
						},
						"long-date-long-time": {
							...m,
							...g
						},
						"long-date-long-time-24": {
							...m,
							...g,
							hour12: !1
						},
						"long-month-year": {
							month: "long",
							year: "numeric"
						},
						"short-month-year": {
							month: "short",
							year: "numeric"
						},
						year: {
							year: "numeric"
						},
						"short-time": f,
						"long-time": g
					};
				b = b.strict()({
					shortDate: "short-date",
					shortDateShortTime: "short-date-short-time",
					shortDateShortTime24: "short-date-short-time-24",
					shortDateLongTime: "short-date-long-time",
					shortDateLongTime24: "short-date-long-time-24",
					shortDateLE: "short-date-le",
					shortDateLEShortTime: "short-date-le-short-time",
					shortDateLEShortTime24: "short-date-le-short-time-24",
					shortDateLELongTime: "short-date-le-long-time",
					shortDateLELongTime24: "short-date-le-long-time-24",
					longMonthDayYear: "long-month-day-year",
					longMonthDayYearShortTime: "long-month-day-year-short-time",
					longMonthDayYearShortTime24: "long-month-day-year-short-time-24",
					longMonthDayYearLongTime: "long-month-day-year-long-time",
					longMonthDayYearLongTime24: "long-month-day-year-long-time-24",
					dayShortMonthYear: "day-short-month-year",
					dayShortMonthYearShortTime: "day-short-month-year-short-time",
					dayShortMonthYearShortTime24: "day-short-month-year-short-time-24",
					dayShortMonthYearLongTime: "day-short-month-year-long-time",
					dayShortMonthYearLongTime24: "day-short-month-year-long-time-24",
					longDate: "long-date",
					longDateShortTime: "long-date-short-time",
					longDateShortTime24: "long-date-short-time-24",
					longDateLongTime: "long-date-long-time",
					longDateLongTime24: "long-date-long-time-24",
					longMonthYear: "long-month-year",
					shortMonthYear: "short-month-year",
					year: "year"
				});
				d = b.apiValues;
				k = b.toJSON.bind(b);
				v = b.fromJSON.bind(b);
				const r = {
					ar: "ar-u-nu-latn-ca-gregory"
				};
				let p = new WeakMap,
					n = l["short-date-short-time"];
				c.beforeLocaleChange(() => {
					p = new WeakMap;
					n = l["short-date-short-time"]
				});
				a.convertDateFormatToIntlOptions = function(t) {
					return t ? l[t] : null
				};
				a.dateFormats = d;
				a.dictionary = b;
				a.formatDate = function(t, h) {
					return e(h)
						.format(t)
				};
				a.fromJSON = v;
				a.getDateTimeFormatter = e;
				a.toJSON = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/intl/number": function() {
			define(["exports", "../core/maybe", "./locale"], function(a, b, c) {
				function e(m) {
					const f = m || v;
					if (!k.has(f)) {
						var g = c.getLocale();
						g = d[c.getLocale()] || g;
						k.set(f, new Intl.NumberFormat(g, m))
					}
					return b.assumeNonNull(k.get(f))
				}
				const d = {
					ar: "ar-u-nu-latn"
				};
				let k = new WeakMap,
					v = {};
				c.beforeLocaleChange(() => {
					k = new WeakMap;
					v = {}
				});
				a.convertNumberFormatToIntlOptions =
					function(m = {}) {
						const f = {};
						null != m.digitSeparator && (f.useGrouping = m.digitSeparator);
						null != m.places && (f.minimumFractionDigits = f.maximumFractionDigits = m.places);
						return f
					};
				a.formatNumber = function(m, f) {
					-0 === m && (m = 0);
					return e(f)
						.format(m)
				};
				a.getFormatter = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/popup/content/MediaContent": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./BarChartMediaInfo ./ColumnChartMediaInfo ./Content ./ImageMediaInfo ./LineChartMediaInfo ./PieChartMediaInfo ./support/mediaInfoTypes".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					var h;
					d = h = function(q) {
						function u(y) {
							y = q.call(this, y) || this;
							y.activeMediaInfoIndex = null;
							y.attributes = null;
							y.description = null;
							y.mediaInfos = null;
							y.title = null;
							y.type = "media";
							return y
						}
						a._inheritsLoose(u, q);
						var x = u.prototype;
						x.readMediaInfos = function(y) {
							return y && y.map(w => {
									if ("image" === w.type) return r.fromJSON(w);
									if ("barchart" === w.type) return f.fromJSON(w);
									if ("columnchart" === w.type) return g.fromJSON(w);
									if ("linechart" === w.type) return p.fromJSON(w);
									if ("piechart" ===
										w.type) return n.fromJSON(w)
								})
								.filter(Boolean)
						};
						x.writeMediaInfos = function(y, w) {
							w.mediaInfos = y && y.map(A => A.toJSON())
						};
						x.clone = function() {
							return new h(c.clone({
								activeMediaInfoIndex: this.activeMediaInfoIndex,
								attributes: this.attributes,
								description: this.description,
								mediaInfos: this.mediaInfos,
								title: this.title
							}))
						};
						return u
					}(l);
					b.__decorate([e.property()], d.prototype, "activeMediaInfoIndex", void 0);
					b.__decorate([e.property({
						type: Object,
						json: {
							write: !0
						}
					})], d.prototype, "attributes", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], d.prototype, "description", void 0);
					b.__decorate([e.property({
						types: [t.types]
					})], d.prototype, "mediaInfos", void 0);
					b.__decorate([k.reader("mediaInfos")], d.prototype, "readMediaInfos", null);
					b.__decorate([m.writer("mediaInfos")], d.prototype, "writeMediaInfos", null);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], d.prototype, "title", void 0);
					b.__decorate([e.property({
						type: ["media"],
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], d.prototype, "type", void 0);
					return d = h = b.__decorate([v.subclass("esri.popup.content.MediaContent")],
						d)
				})
		},
		"esri/popup/content/BarChartMediaInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./mixins/ChartMediaInfo ./support/chartMediaInfoUtils".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				e = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.type = "bar-chart";
						return r
					}
					a._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							altText: this.altText,
							title: this.title,
							caption: this.caption,
							value: this.value ? this.value.clone() : null
						})
					};
					return l
				}(v);
				b.__decorate([c.property({
					type: ["bar-chart"],
					readOnly: !0,
					json: {
						type: ["barchart"],
						read: !1,
						write: m.chartTypeKebabDict.write
					}
				})], e.prototype, "type", void 0);
				return e = f = b.__decorate([k.subclass("esri.popup.content.BarChartMediaInfo")], e)
			})
		},
		"esri/popup/content/mixins/ChartMediaInfo": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./MediaInfo ../support/ChartMediaInfoValue".split(" "),
				function(a, b, c, e, d, k, v, m) {
					e = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.type = null;
							l.value = null;
							return l
						}
						a._inheritsLoose(g, f);
						return g
					}(v);
					b.__decorate([c.property({
						type: ["bar-chart", "column-chart", "line-chart", "pie-chart"],
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					b.__decorate([c.property({
						type: m,
						json: {
							write: !0
						}
					})], e.prototype, "value", void 0);
					return e = b.__decorate([k.subclass("esri.popup.content.mixins.ChartMediaInfo")], e)
				})
		},
		"esri/popup/content/mixins/MediaInfo": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f(g) {
							g = m.call(this, g) || this;
							g.altText = null;
							g.caption = "";
							g.title = "";
							g.type = null;
							return g
						}
						a._inheritsLoose(f, m);
						return f
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "altText", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "caption", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "title", void 0);
					b.__decorate([e.property({
						type: ["image", "bar-chart", "column-chart",
							"line-chart", "pie-chart"
						],
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], c.prototype, "type", void 0);
					return c = b.__decorate([v.subclass("esri.popup.content.mixins.MediaInfo")], c)
				})
		},
		"esri/popup/content/support/ChartMediaInfoValue": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/lang ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./ChartMediaInfoValueSeries".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					c = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.fields = [];
							r.normalizeField = null;
							r.series = [];
							r.tooltipField = null;
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								fields: e.clone(this.fields),
								normalizeField: this.normalizeField,
								tooltipField: this.tooltipField
							})
						};
						return l
					}(c.JSONSupport);
					b.__decorate([d.property({
						type: [String],
						json: {
							write: !0
						}
					})], c.prototype, "fields", void 0);
					b.__decorate([d.property({
							type: String,
							json: {
								write: !0
							}
						})], c.prototype,
						"normalizeField", void 0);
					b.__decorate([d.property({
						type: [m],
						json: {
							read: !1
						}
					})], c.prototype, "series", void 0);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "tooltipField", void 0);
					return c = f = b.__decorate([v.subclass("esri.popup.content.support.ChartMediaInfoValue")], c)
				})
		},
		"esri/popup/content/support/ChartMediaInfoValueSeries": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					c = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.fieldName = null;
							l.tooltip = null;
							l.value = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								fieldName: this.fieldName,
								tooltip: this.tooltip,
								value: this.value
							})
						};
						return g
					}(c);
					b.__decorate([e.property()], c.prototype, "fieldName", void 0);
					b.__decorate([e.property()], c.prototype, "tooltip", void 0);
					b.__decorate([e.property()], c.prototype, "value", void 0);
					return c = m = b.__decorate([v.subclass("esri.popup.content.support.ChartMediaInfoValueSeries")],
						c)
				})
		},
		"esri/popup/content/support/chartMediaInfoUtils": function() {
			define(["exports", "../../../core/jsonMap"], function(a, b) {
				b = b.strict()({
					barchart: "bar-chart",
					columnchart: "column-chart",
					linechart: "line-chart",
					piechart: "pie-chart"
				});
				a.chartTypeKebabDict = b;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/popup/content/ColumnChartMediaInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./mixins/ChartMediaInfo ./support/chartMediaInfoUtils".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					e = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.type = "column-chart";
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								altText: this.altText,
								title: this.title,
								caption: this.caption,
								value: this.value ? this.value.clone() : null
							})
						};
						return l
					}(v);
					b.__decorate([c.property({
						type: ["column-chart"],
						readOnly: !0,
						json: {
							type: ["columnchart"],
							read: !1,
							write: m.chartTypeKebabDict.write
						}
					})], e.prototype, "type", void 0);
					return e = f = b.__decorate([k.subclass("esri.popup.content.ColumnChartMediaInfo")],
						e)
				})
		},
		"esri/popup/content/ImageMediaInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./mixins/MediaInfo ./support/ImageMediaInfoValue".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				e = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.refreshInterval = null;
						r.type = "image";
						r.value = null;
						return r
					}
					a._inheritsLoose(l,
						g);
					l.prototype.clone = function() {
						return new f({
							altText: this.altText,
							title: this.title,
							caption: this.caption,
							refreshInterval: this.refreshInterval,
							value: this.value ? this.value.clone() : null
						})
					};
					return l
				}(v);
				b.__decorate([c.property({
					type: Number,
					json: {
						write: !0
					}
				})], e.prototype, "refreshInterval", void 0);
				b.__decorate([c.property({
					type: ["image"],
					readOnly: !0,
					json: {
						read: !1,
						write: !0
					}
				})], e.prototype, "type", void 0);
				b.__decorate([c.property({
					type: m,
					json: {
						write: !0
					}
				})], e.prototype, "value", void 0);
				return e = f = b.__decorate([k.subclass("esri.popup.content.ImageMediaInfo")],
					e)
			})
		},
		"esri/popup/content/support/ImageMediaInfoValue": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v) {
				var m;
				c = m = function(f) {
					function g(l) {
						l = f.call(this, l) || this;
						l.linkURL = null;
						l.sourceURL = null;
						return l
					}
					a._inheritsLoose(g, f);
					g.prototype.clone =
						function() {
							return new m({
								linkURL: this.linkURL,
								sourceURL: this.sourceURL
							})
						};
					return g
				}(c.JSONSupport);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "linkURL", void 0);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "sourceURL", void 0);
				return c = m = b.__decorate([v.subclass("esri.popup.content.support.ImageMediaInfoValue")], c)
			})
		},
		"esri/popup/content/LineChartMediaInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./mixins/ChartMediaInfo ./support/chartMediaInfoUtils".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					e = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.type = "line-chart";
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								altText: this.altText,
								title: this.title,
								caption: this.caption,
								value: this.value ? this.value.clone() : null
							})
						};
						return l
					}(v);
					b.__decorate([c.property({
						type: ["line-chart"],
						readOnly: !0,
						json: {
							type: ["linechart"],
							read: !1,
							write: m.chartTypeKebabDict.write
						}
					})], e.prototype, "type", void 0);
					return e = f = b.__decorate([k.subclass("esri.popup.content.LineChartMediaInfo")],
						e)
				})
		},
		"esri/popup/content/PieChartMediaInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./mixins/ChartMediaInfo ./support/chartMediaInfoUtils".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				e = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.type = "pie-chart";
						return r
					}
					a._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							altText: this.altText,
							title: this.title,
							caption: this.caption,
							value: this.value ? this.value.clone() : null
						})
					};
					return l
				}(v);
				b.__decorate([c.property({
					type: ["pie-chart"],
					readOnly: !0,
					json: {
						type: ["piechart"],
						read: !1,
						write: m.chartTypeKebabDict.write
					}
				})], e.prototype, "type", void 0);
				return e = f = b.__decorate([k.subclass("esri.popup.content.PieChartMediaInfo")], e)
			})
		},
		"esri/popup/content/support/mediaInfoTypes": function() {
			define("exports ../BarChartMediaInfo ../ColumnChartMediaInfo ../ImageMediaInfo ../LineChartMediaInfo ../PieChartMediaInfo ../mixins/MediaInfo".split(" "),
				function(a, b, c, e, d, k, v) {
					a.types = {
						base: v,
						key: "type",
						defaultKeyValue: "image",
						typeMap: {
							"bar-chart": b,
							"column-chart": c,
							"line-chart": d,
							"pie-chart": k,
							image: e
						}
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/popup/content/RelationshipContent": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Content ../support/RelatedRecordsInfoFieldOrder".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					c = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.description = null;
							r.displayCount = null;
							r.displayType = "list";
							r.orderByFields = null;
							r.relationshipId = null;
							r.title = null;
							r.type = "relationship";
							return r
						}
						a._inheritsLoose(l, g);
						return l
					}(c.ClonableMixin(m));
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "description", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							type: k.Integer,
							write: !0
						}
					})], c.prototype, "displayCount", void 0);
					b.__decorate([e.property({
						type: ["list"],
						json: {
							write: !0
						}
					})], c.prototype, "displayType", void 0);
					b.__decorate([e.property({
						type: [f],
						json: {
							write: !0
						}
					})], c.prototype, "orderByFields", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							type: k.Integer,
							write: !0
						}
					})], c.prototype, "relationshipId", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "title", void 0);
					b.__decorate([e.property({
						type: ["relationship"],
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], c.prototype, "type", void 0);
					return c = b.__decorate([v.subclass("esri.popup.content.RelationshipContent")],
						c)
				})
		},
		"esri/popup/support/RelatedRecordsInfoFieldOrder": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v) {
				var m;
				c = m = function(f) {
					function g(l) {
						l = f.call(this, l) || this;
						l.field = null;
						l.order = null;
						return l
					}
					a._inheritsLoose(g, f);
					g.prototype.clone = function() {
						return new m({
							field: this.field,
							order: this.order
						})
					};
					return g
				}(c.JSONSupport);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "field", void 0);
				b.__decorate([e.property({
					type: ["asc", "desc"],
					json: {
						write: !0
					}
				})], c.prototype, "order", void 0);
				return c = m = b.__decorate([v.subclass("esri.popup.support.RelatedRecordsInfoFieldOrder")], c)
			})
		},
		"esri/popup/content/TextContent": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Content".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.text = null;
							l.type = "text";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								text: this.text
							})
						};
						return g
					}(v);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "text", void 0);
					b.__decorate([c.property({
						type: ["text"],
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = m = b.__decorate([k.subclass("esri.popup.content.TextContent")], e)
				})
		},
		"esri/popup/ExpressionInfo": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					c = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.name = null;
							l.title = null;
							l.expression = null;
							l.returnType = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								name: this.name,
								title: this.title,
								expression: this.expression,
								returnType: this.returnType
							})
						};
						return g
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "name", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "title", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "expression", void 0);
					b.__decorate([e.property({
						type: ["string", "number"],
						json: {
							write: !0
						}
					})], c.prototype, "returnType", void 0);
					return c = m = b.__decorate([v.subclass("esri.popup.ExpressionInfo")], c)
				})
		},
		"esri/popup/LayerOptions": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					c = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.returnTopmostRaster = null;
							l.showNoDataRecords = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								showNoDataRecords: this.showNoDataRecords,
								returnTopmostRaster: this.returnTopmostRaster
							})
						};
						return g
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], c.prototype, "returnTopmostRaster", void 0);
					b.__decorate([e.property({
							type: Boolean,
							json: {
								write: !0
							}
						})], c.prototype, "showNoDataRecords",
						void 0);
					return c = m = b.__decorate([v.subclass("esri.popup.LayerOptions")], c)
				})
		},
		"esri/popup/RelatedRecordsInfo": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./support/RelatedRecordsInfoFieldOrder".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				c = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.showRelatedRecords = null;
						r.orderByFields = null;
						return r
					}
					a._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							showRelatedRecords: this.showRelatedRecords,
							orderByFields: this.orderByFields ? e.clone(this.orderByFields) : null
						})
					};
					return l
				}(c.JSONSupport);
				b.__decorate([d.property({
					type: Boolean,
					json: {
						write: !0
					}
				})], c.prototype, "showRelatedRecords", void 0);
				b.__decorate([d.property({
					type: [m],
					json: {
						write: !0
					}
				})], c.prototype, "orderByFields", void 0);
				return c = f = b.__decorate([v.subclass("esri.popup.RelatedRecordsInfo")], c)
			})
		},
		"esri/support/actions/ActionBase": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/Identifiable ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					c = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.active = !1;
							r.className = null;
							r.disabled = !1;
							r.id = null;
							r.indicator = !1;
							r.title = null;
							r.type = null;
							r.visible = !0;
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								active: this.active,
								className: this.className,
								disabled: this.disabled,
								id: this.id,
								indicator: this.indicator,
								title: this.title,
								visible: this.visible
							})
						};
						return l
					}(e.IdentifiableMixin(c));
					b.__decorate([d.property()], c.prototype, "active", void 0);
					b.__decorate([d.property()],
						c.prototype, "className", void 0);
					b.__decorate([d.property()], c.prototype, "disabled", void 0);
					b.__decorate([d.property()], c.prototype, "id", void 0);
					b.__decorate([d.property()], c.prototype, "indicator", void 0);
					b.__decorate([d.property()], c.prototype, "title", void 0);
					b.__decorate([d.property()], c.prototype, "type", void 0);
					b.__decorate([d.property()], c.prototype, "visible", void 0);
					return c = f = b.__decorate([m.subclass("esri.support.actions.ActionBase")], c)
				})
		},
		"esri/support/actions/ActionButton": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./ActionBase".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.image = null;
							l.type = "button";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								active: this.active,
								className: this.className,
								disabled: this.disabled,
								id: this.id,
								indicator: this.indicator,
								title: this.title,
								visible: this.visible,
								image: this.image
							})
						};
						return g
					}(v);
					b.__decorate([c.property()], e.prototype, "image", void 0);
					return e = m = b.__decorate([k.subclass("esri.support.Action.ActionButton")], e)
				})
		},
		"esri/support/actions/ActionToggle": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./ActionBase".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.image = null;
							l.type = "toggle";
							l.value = !1;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								active: this.active,
								className: this.className,
								disabled: this.disabled,
								id: this.id,
								indicator: this.indicator,
								title: this.title,
								visible: this.visible,
								image: this.image,
								value: this.value
							})
						};
						return g
					}(v);
					b.__decorate([c.property()], e.prototype, "image", void 0);
					b.__decorate([c.property()], e.prototype, "value", void 0);
					return e =
						m = b.__decorate([k.subclass("esri.support.Action.ActionToggle")], e)
				})
		},
		"esri/renderers/ClassBreaksRenderer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../symbols ../core/jsonMap ../core/lang ../core/Logger ../core/maybe ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/accessorSupport/ensureType ../layers/support/fieldUtils ./Renderer ./mixins/VisualVariablesMixin ./support/ClassBreakInfo ./support/commonProperties ./support/LegendOptions ../support/arcadeOnDemand".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w) {
					var A;
					e = new e.JSONMap({
						esriNormalizeByLog: "log",
						esriNormalizeByPercentOfTotal: "percent-of-total",
						esriNormalizeByField: "field"
					});
					const B = n.ensureType(u);
					h = A = function(E) {
						function z(D) {
							D = E.call(this, D) || this;
							D._compiledValueExpression = {
								valueExpression: null,
								compiledFunction: null
							};
							D.backgroundFillSymbol = null;
							D.classBreakInfos = null;
							D.defaultLabel = null;
							D.defaultSymbol = null;
							D.field = null;
							D.isMaxInclusive = !0;
							D.legendOptions = null;
							D.normalizationField = null;
							D.normalizationTotal = null;
							D.type = "class-breaks";
							D.valueExpression = null;
							D.valueExpressionTitle = null;
							D._set("classBreakInfos", []);
							return D
						}
						a._inheritsLoose(z, E);
						var C = z.prototype;
						C.readClassBreakInfos = function(D, J, K) {
							if (Array.isArray(D)) {
								var H = J.minValue;
								return D.map(G => {
									const F = new u;
									F.read(G, K);
									null == F.minValue && (F.minValue = H);
									null == F.maxValue && (F.maxValue = F.minValue);
									H = F.maxValue;
									return F
								})
							}
						};
						C.writeClassBreakInfos = function(D, J, K, H) {
							D = D.map(G => G.write({}, H));
							this._areClassBreaksConsecutive() && D.forEach(G =>
								delete G.classMinValue);
							J[K] = D
						};
						C.castField = function(D) {
							return null == D ? D : "function" === typeof D ? (k.getLogger(this.declaredClass)
								.error(".field: field must be a string value"), null) : n.ensureString(D)
						};
						C.addClassBreakInfo = function(D, J, K) {
							let H = null;
							H = "number" === typeof D ? new u({
								minValue: D,
								maxValue: J,
								symbol: c.ensureType(K)
							}) : B(d.clone(D));
							this.classBreakInfos.push(H);
							1 === this.classBreakInfos.length && this.notifyChange("minValue")
						};
						C.removeClassBreakInfo = function(D, J) {
							const K = this.classBreakInfos.length;
							for (let H = 0; H < K; H++) {
								const G = [this.classBreakInfos[H].minValue, this.classBreakInfos[H].maxValue];
								if (G[0] === D && G[1] === J) {
									this.classBreakInfos.splice(H, 1);
									break
								}
							}
						};
						C.getBreakIndex = function(D, J) {
							this.valueExpression && (v.isNone(J) || v.isNone(J.arcade)) && k.getLogger(this.declaredClass)
								.warn("");
							return this.valueExpression ? this._getBreakIndexForExpression(D, J) : this._getBreakIndexForField(D)
						};
						C.getClassBreakInfo = function() {
							var D = a._asyncToGenerator(function*(J, K) {
								let H = K;
								this.valueExpression && (v.isNone(K) ||
									v.isNone(K.arcade)) && (H = {
									...H,
									arcade: yield w.loadArcade()
								});
								J = this.getBreakIndex(J, H);
								return -1 !== J ? this.classBreakInfos[J] : null
							});
							return function(J, K) {
								return D.apply(this, arguments)
							}
						}();
						C.getSymbol = function(D, J) {
							if (this.valueExpression && (v.isNone(J) || v.isNone(J.arcade))) k.getLogger(this.declaredClass)
								.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
							else return D = this.getBreakIndex(D, J), -1 < D ? this.classBreakInfos[D].symbol : this.defaultSymbol
						};
						C.getSymbolAsync = function() {
							var D =
								a._asyncToGenerator(function*(J, K) {
									let H = K;
									if (this.valueExpression && (v.isNone(K) || v.isNone(K.arcade))) {
										K = yield w.loadArcade();
										const {
											arcadeUtils: G
										} = K;
										G.hasGeometryOperations(this.valueExpression) && (yield G.enableGeometryOperations());
										H = {
											...H,
											arcade: K
										}
									}
									J = this.getBreakIndex(J, H);
									return -1 < J ? this.classBreakInfos[J].symbol : this.defaultSymbol
								});
							return function(J, K) {
								return D.apply(this, arguments)
							}
						}();
						C.getSymbols = function() {
							const D = [];
							this.classBreakInfos.forEach(J => {
								J.symbol && D.push(J.symbol)
							});
							this.defaultSymbol &&
								D.push(this.defaultSymbol);
							return D
						};
						C.getAttributeHash = function() {
							return this.visualVariables && this.visualVariables.reduce((D, J) => D + J.getAttributeHash(), "")
						};
						C.getMeshHash = function() {
							const D = JSON.stringify(this.backgroundFillSymbol),
								J = JSON.stringify(this.defaultSymbol),
								K = `${this.normalizationField}.${this.normalizationType}.${this.normalizationTotal}`,
								H = this.classBreakInfos.reduce((G, F) => G + F.getMeshHash(), "");
							return `${D}.${J}.${H}.${K}.${this.field}.${this.valueExpression}`
						};
						C.clone = function() {
							return new A({
								field: this.field,
								backgroundFillSymbol: this.backgroundFillSymbol && this.backgroundFillSymbol.clone(),
								defaultLabel: this.defaultLabel,
								defaultSymbol: this.defaultSymbol && this.defaultSymbol.clone(),
								valueExpression: this.valueExpression,
								valueExpressionTitle: this.valueExpressionTitle,
								classBreakInfos: d.clone(this.classBreakInfos),
								isMaxInclusive: this.isMaxInclusive,
								normalizationField: this.normalizationField,
								normalizationTotal: this.normalizationTotal,
								normalizationType: this.normalizationType,
								visualVariables: d.clone(this.visualVariables),
								legendOptions: d.clone(this.legendOptions),
								authoringInfo: this.authoringInfo && this.authoringInfo.clone()
							})
						};
						C.collectRequiredFields = function() {
							var D = a._asyncToGenerator(function*(J, K) {
								J = [this.collectVVRequiredFields(J, K), this.collectSymbolFields(J, K)];
								yield Promise.all(J)
							});
							return function(J, K) {
								return D.apply(this, arguments)
							}
						}();
						C.collectSymbolFields = function() {
							var D = a._asyncToGenerator(function*(J, K) {
								const H = [...this.getSymbols()
									.map(G => G.collectRequiredFields(J, K)), t.collectArcadeFieldNames(J, K, this.valueExpression)
								];
								t.collectField(J, K, this.field);
								t.collectField(J, K, this.normalizationField);
								yield Promise.all(H)
							});
							return function(J, K) {
								return D.apply(this, arguments)
							}
						}();
						C._getBreakIndexForExpression = function(D, J) {
							const {
								viewingMode: K,
								scale: H,
								spatialReference: G,
								arcade: F
							} = v.unwrapOr(J, {});
							({
								valueExpression: J
							} = this);
							var L = this._compiledValueExpression.valueExpression === J ? this._compiledValueExpression.compiledFunction : null;
							const R = v.unwrap(F)
								.arcadeUtils;
							L || (L = R.createSyntaxTree(J), L = R.createFunction(L), this._compiledValueExpression.compiledFunction =
								L);
							this._compiledValueExpression.valueExpression = J;
							D = R.executeFunction(L, R.createExecContext(D, R.getViewInfo({
								viewingMode: K,
								scale: H,
								spatialReference: G
							})));
							return this._getBreakIndexfromInfos(D)
						};
						C._getBreakIndexForField = function(D) {
							var J = D.attributes;
							D = this.normalizationType;
							let K = parseFloat(J[this.field]);
							if (D) {
								const H = this.normalizationTotal;
								J = parseFloat(this.normalizationField ? J[this.normalizationField] : void 0);
								if ("log" === D) K = Math.log(K) * Math.LOG10E;
								else if ("percent-of-total" === D && null != H && !isNaN(H)) K =
									K / H * 100;
								else if ("field" === D && !isNaN(J)) {
									if (isNaN(K) || isNaN(J)) return -1;
									K /= J
								}
							}
							return this._getBreakIndexfromInfos(K)
						};
						C._getBreakIndexfromInfos = function(D) {
							const J = this.isMaxInclusive;
							if (null != D && "number" === typeof D && !isNaN(D))
								for (let K = 0; K < this.classBreakInfos.length; K++) {
									const H = [this.classBreakInfos[K].minValue, this.classBreakInfos[K].maxValue];
									if (H[0] <= D && (J ? D <= H[1] : D < H[1])) return K
								}
							return -1
						};
						C._areClassBreaksConsecutive = function() {
							const D = this.classBreakInfos,
								J = D.length;
							for (let K = 1; K < J; K++)
								if (D[K -
									1].maxValue !== D[K].minValue) return !1;
							return !0
						};
						a._createClass(z, [{
							key: "minValue",
							get: function() {
								return this.classBreakInfos && this.classBreakInfos[0] && this.classBreakInfos[0].minValue || 0
							}
						}, {
							key: "normalizationType",
							get: function() {
								let D = this._get("normalizationType");
								const J = !!this.normalizationField,
									K = null != this.normalizationTotal;
								if (J || K) D = J && "field" || K && "percent-of-total" || null, J && K && k.getLogger(this.declaredClass)
									.warn("warning: both normalizationField and normalizationTotal are set!");
								else if ("field" ===
									D || "percent-of-total" === D) D = null;
								return D
							},
							set: function(D) {
								this._set("normalizationType", D)
							}
						}, {
							key: "arcadeRequired",
							get: function() {
								return this.arcadeRequiredForVisualVariables || !!this.valueExpression
							}
						}]);
						return z
					}(q.VisualVariablesMixin(h));
					b.__decorate([m.property(x.rendererBackgroundFillSymbolProperty)], h.prototype, "backgroundFillSymbol", void 0);
					b.__decorate([m.property({
						type: [u]
					})], h.prototype, "classBreakInfos", void 0);
					b.__decorate([l.reader("classBreakInfos")], h.prototype, "readClassBreakInfos",
						null);
					b.__decorate([p.writer("classBreakInfos")], h.prototype, "writeClassBreakInfos", null);
					b.__decorate([m.property({
						type: String,
						json: {
							write: !0
						}
					})], h.prototype, "defaultLabel", void 0);
					b.__decorate([m.property(x.rendererSymbolProperty)], h.prototype, "defaultSymbol", void 0);
					b.__decorate([m.property({
						type: String,
						json: {
							write: !0
						}
					})], h.prototype, "field", void 0);
					b.__decorate([f.cast("field")], h.prototype, "castField", null);
					b.__decorate([m.property({
						type: Boolean
					})], h.prototype, "isMaxInclusive", void 0);
					b.__decorate([m.property({
						type: y.LegendOptions,
						json: {
							write: !0
						}
					})], h.prototype, "legendOptions", void 0);
					b.__decorate([m.property({
						type: Number,
						readOnly: !0,
						value: null,
						json: {
							read: !1,
							write: {
								overridePolicy() {
									return 0 !== this.classBreakInfos.length && this._areClassBreaksConsecutive() ? {
										enabled: !0
									} : {
										enabled: !1
									}
								}
							}
						}
					})], h.prototype, "minValue", null);
					b.__decorate([m.property({
						type: String,
						json: {
							write: !0
						}
					})], h.prototype, "normalizationField", void 0);
					b.__decorate([m.property({
							type: Number,
							cast: E => n.ensureNumber(E),
							json: {
								write: !0
							}
						})], h.prototype, "normalizationTotal",
						void 0);
					b.__decorate([m.property({
						type: e.apiValues,
						value: null,
						json: {
							type: e.jsonValues,
							read: e.read,
							write: e.write
						}
					})], h.prototype, "normalizationType", null);
					b.__decorate([g.enumeration({
						classBreaks: "class-breaks"
					})], h.prototype, "type", void 0);
					b.__decorate([m.property({
						type: String,
						json: {
							write: !0
						}
					})], h.prototype, "valueExpression", void 0);
					b.__decorate([m.property({
						type: String,
						json: {
							write: !0
						}
					})], h.prototype, "valueExpressionTitle", void 0);
					return h = A = b.__decorate([r.subclass("esri.renderers.ClassBreaksRenderer")],
						h)
				})
		},
		"esri/symbols": function() {
			define("exports ./core/accessorSupport/ensureType ./core/accessorSupport/extensions/serializableProperty/reader ./symbols/CIMSymbol ./symbols/ExtrudeSymbol3DLayer ./symbols/FillSymbol ./symbols/FillSymbol3DLayer ./symbols/Font ./symbols/IconSymbol3DLayer ./symbols/LabelSymbol3D ./symbols/LineSymbol3D ./symbols/LineSymbol3DLayer ./symbols/MarkerSymbol ./symbols/MeshSymbol3D ./symbols/ObjectSymbol3DLayer ./symbols/PathSymbol3DLayer ./symbols/PictureFillSymbol ./symbols/PictureMarkerSymbol ./symbols/PointSymbol3D ./symbols/PolygonSymbol3D ./symbols/SimpleFillSymbol ./symbols/SimpleLineSymbol ./symbols/SimpleMarkerSymbol ./symbols/Symbol ./symbols/Symbol3D ./symbols/Symbol3DLayer ./symbols/TextSymbol ./symbols/TextSymbol3DLayer ./symbols/WaterSymbol3DLayer ./symbols/WebStyleSymbol ./symbols/callouts/LineCallout3D ./chunks/LineCallout3DBorder".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D, J, K, H, G, F) {
					const L = {
							base: E,
							key: "type",
							typeMap: {
								"simple-fill": w,
								"picture-fill": q,
								"picture-marker": u,
								"simple-line": A,
								"simple-marker": B,
								text: D,
								"label-3d": g,
								"line-3d": l,
								"mesh-3d": n,
								"point-3d": x,
								"polygon-3d": y,
								"web-style": H,
								cim: e
							},
							errorContext: "symbol"
						},
						R = {
							base: E,
							key: "type",
							typeMap: {
								"picture-marker": u,
								"simple-marker": B,
								text: D,
								"web-style": H,
								cim: e
							},
							errorContext: "symbol"
						};
					c = c.createTypeReader({
						types: L
					});
					const V = {
							base: E,
							key: "type",
							typeMap: {
								"simple-fill": w,
								"picture-fill": q,
								"picture-marker": u,
								"simple-line": A,
								"simple-marker": B,
								text: D,
								"line-3d": l,
								"mesh-3d": n,
								"point-3d": x,
								"polygon-3d": y,
								"web-style": H,
								cim: e
							},
							errorContext: "symbol"
						},
						U = {
							base: E,
							key: "type",
							typeMap: {
								text: D,
								"label-3d": g
							},
							errorContext: "symbol"
						},
						W = {
							base: E,
							key: "type",
							typeMap: {
								"label-3d": g,
								"line-3d": l,
								"mesh-3d": n,
								"point-3d": x,
								"polygon-3d": y,
								"web-style": H
							},
							errorContext: "symbol"
						},
						M = {
							base: E,
							key: "type",
							typeMap: {
								"line-3d": l,
								"mesh-3d": n,
								"point-3d": x,
								"polygon-3d": y,
								"web-style": H,
								cim: e
							},
							errorContext: "symbol"
						},
						T = {
							base: E,
							key: "type",
							typeMap: {
								"label-3d": g
							},
							errorContext: "symbol"
						};
					b = b.ensureOneOfType(L);
					a.CIMSymbol = e;
					a.ExtrudeSymbol3DLayer = d;
					a.BaseFillSymbol = k;
					a.FillSymbol3DLayer = v;
					a.Font = m;
					a.IconSymbol3DLayer = f;
					a.LabelSymbol3D = g;
					a.LineSymbol3D = l;
					a.LineSymbol3DLayer = r;
					a.BaseMarkerSymbol = p;
					a.MeshSymbol3D = n;
					a.ObjectSymbol3DLayer = t;
					a.PathSymbol3DLayer = h;
					a.PictureFillSymbol = q;
					a.PictureMarkerSymbol = u;
					a.PointSymbol3D = x;
					a.PolygonSymbol3D = y;
					a.SimpleFillSymbol = w;
					a.SimpleLineSymbol = A;
					a.SimpleMarkerSymbol = B;
					a.BaseSymbol =
						E;
					a.BaseSymbol3D = z;
					a.BaseSymbol3DLayer = C;
					a.TextSymbol = D;
					a.TextSymbol3DLayer = J;
					a.WaterSymbol3DLayer = K;
					a.WebStyleSymbol = H;
					a.LineCallout3D = G;
					a.LineCallout3DBorder = F.LineCallout3DBorder;
					a.ensureType = b;
					a.isSymbol = function(Z) {
						return Z instanceof E
					};
					a.isSymbol2D = function(Z) {
						if (!Z) return !1;
						switch (Z.type) {
							case "picture-fill":
							case "picture-marker":
							case "simple-fill":
							case "simple-line":
							case "simple-marker":
							case "text":
							case "cim":
								return !0;
							default:
								return !1
						}
					};
					a.isSymbol3D = function(Z) {
						if (!Z) return !1;
						switch (Z.type) {
							case "label-3d":
							case "line-3d":
							case "mesh-3d":
							case "point-3d":
							case "polygon-3d":
								return !0;
							default:
								return !1
						}
					};
					a.readSymbol = c;
					a.symbolTypes = L;
					a.symbolTypes3D = W;
					a.symbolTypesCluster = R;
					a.symbolTypesLabel = U;
					a.symbolTypesLabel3D = T;
					a.symbolTypesRenderer = V;
					a.symbolTypesRenderer3D = M;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/CIMSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/string ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../layers/support/fieldUtils ./Symbol".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					k = p = function(n) {
						function t(q) {
							q = n.call(this, q) || this;
							q.data = null;
							q.type = "cim";
							return q
						}
						a._inheritsLoose(t, n);
						var h = t.prototype;
						h.readData = function(q, u) {
							return u
						};
						h.writeData = function(q, u) {
							if (q)
								for (const x in q) u[x] = q[x]
						};
						h.collectRequiredFields = function() {
							var q = a._asyncToGenerator(function*(u, x) {
								if ("CIMSymbolReference" === this.data ? .type) {
									var y = this.data.primitiveOverrides;
									y && (y = y.map(w => l.collectArcadeFieldNames(u, x, w.valueExpressionInfo.expression)), yield Promise.all(y))
								}
							});
							return function(u, x) {
								return q.apply(this, arguments)
							}
						}();
						h.clone = function() {
							return new p({
								data: c.clone(this.data)
							})
						};
						h.hash = function() {
							return e.numericHash(JSON.stringify(this.data))
								.toString()
						};
						return t
					}(r);
					b.__decorate([d.property({
						json: {
							write: !1
						}
					})], k.prototype, "color", void 0);
					b.__decorate([d.property({
						json: {
							write: !0
						}
					})], k.prototype, "data", void 0);
					b.__decorate([m.reader("data", ["symbol"])], k.prototype, "readData", null);
					b.__decorate([g.writer("data", {})], k.prototype, "writeData", null);
					b.__decorate([v.enumeration({
						CIMSymbolReference: "cim"
					}, {
						readOnly: !0
					})], k.prototype, "type", void 0);
					return k = p = b.__decorate([f.subclass("esri.symbols.CIMSymbol")], k)
				})
		},
		"esri/symbols/Symbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../core/jsonMap ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m, f, g) {
				e = new e.JSONMap({
					esriSMS: "simple-marker",
					esriPMS: "picture-marker",
					esriSLS: "simple-line",
					esriSFS: "simple-fill",
					esriPFS: "picture-fill",
					esriTS: "text",
					esriSHD: "shield-label-symbol",
					PointSymbol3D: "point-3d",
					LineSymbol3D: "line-3d",
					PolygonSymbol3D: "polygon-3d",
					WebStyleSymbol: "web-style",
					MeshSymbol3D: "mesh-3d",
					LabelSymbol3D: "label-3d",
					CIMSymbolReference: "cim"
				});
				let l = 0;
				d = function(r) {
					function p(t) {
						t = r.call(this, t) || this;
						t.id = `sym${l++}`;
						t.type = null;
						t.color = new c([0, 0, 0, 1]);
						return t
					}
					a._inheritsLoose(p, r);
					var n = p.prototype;
					n.readColor = function(t) {
						return t &&
							null != t[0] ? [t[0], t[1], t[2], t[3] / 255] : t
					};
					n.collectRequiredFields = function() {
						var t = a._asyncToGenerator(function*(h, q) {});
						return function(h, q) {
							return t.apply(this, arguments)
						}
					}();
					n.hash = function() {
						return JSON.stringify(this.toJSON())
					};
					n.clone = function() {};
					return p
				}(d.JSONSupport);
				b.__decorate([k.property({
					type: e.apiValues,
					readOnly: !0,
					json: {
						read: !1,
						write: {
							ignoreOrigin: !0,
							writer: e.write
						}
					}
				})], d.prototype, "type", void 0);
				b.__decorate([k.property({
					type: c,
					json: {
						write: {
							allowNull: !0
						}
					}
				})], d.prototype, "color", void 0);
				b.__decorate([f.reader("color")], d.prototype, "readColor", null);
				return d = b.__decorate([g.subclass("esri.symbols.Symbol")], d)
			})
		},
		"esri/symbols/ExtrudeSymbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/maybe ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./Symbol3DLayer ./edges/utils ./support/Symbol3DMaterial".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					d = r = function(p) {
						function n(t) {
							t = p.call(this, t) || this;
							t.type = "extrude";
							t.size = 1;
							t.material = null;
							t.castShadows = !0;
							t.edges = null;
							return t
						}
						a._inheritsLoose(n, p);
						n.prototype.clone = function() {
							return new r({
								edges: this.edges && this.edges.clone(),
								enabled: this.enabled,
								material: c.isSome(this.material) ? this.material.clone() : null,
								castShadows: this.castShadows,
								size: this.size
							})
						};
						return n
					}(f);
					b.__decorate([v.enumeration({
						Extrude: "extrude"
					}, {
						readOnly: !0
					})], d.prototype, "type", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: {
								enabled: !0,
								isRequired: !0
							}
						},
						nonNullable: !0
					})], d.prototype, "size", void 0);
					b.__decorate([e.property({
						type: l.Symbol3DMaterial,
						json: {
							write: !0
						}
					})], d.prototype, "material", void 0);
					b.__decorate([e.property({
						type: Boolean,
						nonNullable: !0,
						json: {
							write: !0,
							default: !0
						}
					})], d.prototype, "castShadows", void 0);
					b.__decorate([e.property(g.symbol3dEdgesProperty)], d.prototype, "edges", void 0);
					return d = r = b.__decorate([m.subclass("esri.symbols.ExtrudeSymbol3DLayer")], d)
				})
		},
		"esri/symbols/Symbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer".split(" "),
				function(a, b, c, e, d, k, v, m) {
					c = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.enabled = !0;
							l.type = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.writeEnabled = function(l, r, p) {
							l || (r[p] = l)
						};
						return g
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: Boolean,
						json: {
							read: {
								source: "enable"
							},
							write: {
								target: "enable"
							}
						}
					})], c.prototype, "enabled", void 0);
					b.__decorate([m.writer("enabled")], c.prototype, "writeEnabled", null);
					b.__decorate([e.property({
							type: "icon object line path fill water extrude text".split(" "),
							readOnly: !0
						})],
						c.prototype, "type", void 0);
					return c = b.__decorate([v.subclass("esri.symbols.Symbol3DLayer")], c)
				})
		},
		"esri/symbols/edges/utils": function() {
			define(["exports", "./Edges3D", "./SketchEdges3D", "./SolidEdges3D"], function(a, b, c, e) {
				a.symbol3dEdgesProperty = {
					types: {
						key: "type",
						base: b,
						typeMap: {
							solid: e,
							sketch: c
						}
					},
					json: {
						write: !0
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/edges/Edges3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/JSONSupport ../../core/lang ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../support/materialUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					e = function(l) {
						function r(n) {
							n = l.call(this, n) || this;
							n.color = new c([0, 0, 0, 1]);
							n.extensionLength = 0;
							n.size = k.px2pt(1);
							return n
						}
						a._inheritsLoose(r, l);
						var p = r.prototype;
						p.clone = function() {};
						p.cloneProperties = function() {
							return {
								color: d.clone(this.color),
								size: this.size,
								extensionLength: this.extensionLength
							}
						};
						return r
					}(e.JSONSupport);
					b.__decorate([v.property({
						type: ["solid", "sketch"],
						readOnly: !0,
						json: {
							read: !0,
							write: {
								ignoreOrigin: !0
							}
						}
					})], e.prototype, "type", void 0);
					b.__decorate([v.property(g.colorAndTransparencyProperty)],
						e.prototype, "color", void 0);
					b.__decorate([v.property({
						...g.screenSizeProperty,
						json: {
							write: {
								overridePolicy(l) {
									return {
										enabled: !!l
									}
								}
							}
						}
					})], e.prototype, "extensionLength", void 0);
					b.__decorate([v.property(g.screenSizeProperty)], e.prototype, "size", void 0);
					return e = b.__decorate([f.subclass("esri.symbols.edges.Edges3D")], e)
				})
		},
		"esri/core/screenUtils": function() {
			define(["exports"], function(a) {
				function b(e) {
					return e ? 72 * e / 96 : 0
				}
				const c = /^-?(\d+(\.\d+)?)\s*((px)|(pt))?$/i;
				a.castRenderScreenPointArray = function(e) {
					return e
				};
				a.castRenderScreenPointArray3 = function(e) {
					return e
				};
				a.castScreenPointArray = function(e) {
					return e
				};
				a.createRenderScreenPoint = function(e = 0, d = 0) {
					return {
						x: e,
						y: d
					}
				};
				a.createRenderScreenPointArray = function(e = 0, d = 0) {
					return [e, d]
				};
				a.createRenderScreenPointArray3 = function(e = 0, d = 0, k = 0) {
					return [e, d, k]
				};
				a.createScreenPoint = function(e = 0, d = 0) {
					return {
						x: e,
						y: d
					}
				};
				a.createScreenPointArray = function(e = 0, d = 0) {
					return [e, d]
				};
				a.pt2px = function(e) {
					return e ? e / 72 * 96 : 0
				};
				a.px2pt = b;
				a.screenPointArrayToObject = function(e, d) {
					return d ? (d.x =
						e[0], d.y = e[1], d) : {
						x: e[0],
						y: e[1]
					}
				};
				a.screenPointObjectToArray = function(e, d) {
					return d ? (d[0] = e.x, d[1] = e.y, 2 < d.length && (d[2] = 0), d) : [e.x, e.y]
				};
				a.toPt = function(e) {
					if ("string" === typeof e) {
						var d = e.match(c);
						if (d) {
							var k = Number(d[1]);
							d = d[3] && d[3].toLowerCase();
							e = "-" === e.charAt(0);
							k = "px" === d ? b(k) : k;
							return e ? -k : k
						}
						console.warn("screenUtils.toPt: input not recognized!");
						return null
					}
					return e
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/support/materialUtils": function() {
			define(["exports",
				"../../Color", "../../core/screenUtils", "../../core/accessorSupport/ensureType", "../../webdoc/support/opacityUtils"
			], function(a, b, c, e, d) {
				c = {
					type: Number,
					cast: c.toPt,
					json: {
						write: !0
					}
				};
				a.colorAndTransparencyProperty = {
					type: b,
					json: {
						type: [e.Integer],
						default: null,
						read: {
							source: ["color", "transparency"],
							reader: function(k, v) {
								k = null != v.transparency ? d.transparencyToOpacity(v.transparency) : 1;
								return (v = v.color) && Array.isArray(v) ? new b([v[0] || 0, v[1] || 0, v[2] || 0, k]) : null
							}
						},
						write: {
							target: {
								color: {
									type: [e.Integer]
								},
								transparency: {
									type: e.Integer
								}
							},
							writer: function(k, v) {
								v.color = k.toJSON()
									.slice(0, 3);
								k = d.opacityToTransparency(k.a);
								0 !== k && (v.transparency = k)
							}
						}
					}
				};
				a.screenSizeProperty = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/edges/SketchEdges3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Logger ../../core/accessorSupport/ensureType ../../core/arrayUtils ../../core/Error ../../core/has ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./Edges3D".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					c = l = function(r) {
						function p(n) {
							n = r.call(this, n) || this;
							n.type = "sketch";
							return n
						}
						a._inheritsLoose(p, r);
						p.prototype.clone = function() {
							return new l(this.cloneProperties())
						};
						return p
					}(g);
					b.__decorate([m.enumeration({
						sketch: "sketch"
					}, {
						readOnly: !0
					})], c.prototype, "type", void 0);
					return c = l = b.__decorate([f.subclass("esri.symbols.edges.SketchEdges3D")], c)
				})
		},
		"esri/symbols/edges/SolidEdges3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Logger ../../core/accessorSupport/ensureType ../../core/arrayUtils ../../core/Error ../../core/has ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./Edges3D".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					c = l = function(r) {
						function p(n) {
							n = r.call(this, n) || this;
							n.type = "solid";
							return n
						}
						a._inheritsLoose(p, r);
						p.prototype.clone = function() {
							return new l(this.cloneProperties())
						};
						return p
					}(g);
					b.__decorate([m.enumeration({
						solid: "solid"
					}, {
						readOnly: !0
					})], c.prototype, "type", void 0);
					return c = l = b.__decorate([f.subclass("esri.symbols.support.SolidEdges3D")], c)
				})
		},
		"esri/symbols/support/Symbol3DMaterial": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./materialUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					a.Symbol3DMaterial = l = function(r) {
						function p(n) {
							n = r.call(this, n) || this;
							n.color = null;
							return n
						}
						b._inheritsLoose(p, r);
						p.prototype.clone = function() {
							const n = {
								color: d.isSome(this.color) ? this.color.clone() : null
							};
							return new l(n)
						};
						return p
					}(e.JSONSupport);
					c.__decorate([k.property(g.colorAndTransparencyProperty)], a.Symbol3DMaterial.prototype, "color", void 0);
					a.Symbol3DMaterial = l = c.__decorate([f.subclass("esri.symbols.support.Symbol3DMaterial")], a.Symbol3DMaterial);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/FillSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./SimpleLineSymbol ./Symbol".split(" "), function(a, b, c, e, d, k, v, m) {
				e = function(f) {
					function g(l) {
						l = f.call(this, l) || this;
						l.outline = null;
						l.type = null;
						return l
					}
					a._inheritsLoose(g, f);
					g.prototype.hash =
						function() {
							return `${this.type}.${this.outline&&this.outline.hash()}`
						};
					return g
				}(m);
				b.__decorate([c.property({
					types: {
						key: "type",
						base: null,
						defaultKeyValue: "simple-line",
						typeMap: {
							"simple-line": v
						}
					},
					json: {
						default: null,
						write: !0
					}
				})], e.prototype, "outline", void 0);
				b.__decorate([c.property({
					type: ["simple-fill", "picture-fill"],
					readOnly: !0
				})], e.prototype, "type", void 0);
				return e = b.__decorate([k.subclass("esri.symbols.FillSymbol")], e)
			})
		},
		"esri/symbols/SimpleLineSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/jsonMap ../core/lang ../core/screenUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./LineSymbol ./LineSymbolMarker".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					c = new c.JSONMap({
						esriSLSSolid: "solid",
						esriSLSDash: "dash",
						esriSLSDot: "dot",
						esriSLSDashDot: "dash-dot",
						esriSLSDashDotDot: "long-dash-dot-dot",
						esriSLSNull: "none",
						esriSLSInsideFrame: "inside-frame",
						esriSLSShortDash: "short-dash",
						esriSLSShortDot: "short-dot",
						esriSLSShortDashDot: "short-dash-dot",
						esriSLSShortDashDotDot: "short-dash-dot-dot",
						esriSLSLongDash: "long-dash",
						esriSLSLongDashDot: "long-dash-dot"
					});
					g = r = function(p) {
						function n(...h) {
							h = p.call(this, ...h) || this;
							h.type = "simple-line";
							h.style = "solid";
							h.cap = "round";
							h.join = "round";
							h.marker = null;
							h.miterLimit = 2;
							return h
						}
						a._inheritsLoose(n, p);
						var t = n.prototype;
						t.normalizeCtorArgs = function(h, q, u, x, y, w) {
							if (h && "string" !== typeof h) return h;
							const A = {};
							null != h && (A.style = h);
							null != q && (A.color = q);
							null != u && (A.width = d.toPt(u));
							null != x && (A.cap = x);
							null != y && (A.join = y);
							null != w && (A.miterLimit = d.toPt(w));
							return A
						};
						t.clone = function() {
							return new r({
								color: e.clone(this.color),
								style: this.style,
								width: this.width,
								cap: this.cap,
								join: this.join,
								miterLimit: this.miterLimit,
								marker: this.marker ? .clone()
							})
						};
						t.hash = function() {
							return `${p.prototype.hash.call(this)}.${this.color?.hash()}.${this.style}.${this.cap}.${this.join}.${this.miterLimit}.${this.marker?.hash()}`
						};
						return n
					}(g);
					b.__decorate([m.enumeration({
						esriSLS: "simple-line"
					}, {
						readOnly: !0
					})], g.prototype, "type", void 0);
					b.__decorate([k.property({
						type: c.apiValues,
						json: {
							read: c.read,
							write: c.write
						}
					})], g.prototype, "style", void 0);
					b.__decorate([k.property({
						type: ["butt", "round", "square"],
						json: {
							write: {
								overridePolicy: (p, n, t) =>
									({
										enabled: "round" !== p && (null == t || null == t.origin)
									})
							}
						}
					})], g.prototype, "cap", void 0);
					b.__decorate([k.property({
						type: ["miter", "round", "bevel"],
						json: {
							write: {
								overridePolicy: (p, n, t) => ({
									enabled: "round" !== p && (null == t || null == t.origin)
								})
							}
						}
					})], g.prototype, "join", void 0);
					b.__decorate([k.property({
						types: {
							key: "type",
							base: null,
							defaultKeyValue: "line-marker",
							typeMap: {
								"line-marker": l
							}
						},
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], g.prototype, "marker", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							read: !1,
							write: !1
						}
					})], g.prototype, "miterLimit", void 0);
					return g = r = b.__decorate([f.subclass("esri.symbols.SimpleLineSymbol")], g)
				})
		},
		"esri/symbols/LineSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/screenUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./Symbol".split(" "), function(a, b, c, e, d, k, v, m, f) {
				d = function(g) {
					function l(r) {
						r =
							g.call(this, r) || this;
						r.type = "simple-line";
						r.width = .75;
						return r
					}
					a._inheritsLoose(l, g);
					l.prototype.hash = function() {
						return `${this.type}.${this.width}`
					};
					return l
				}(f);
				b.__decorate([v.enumeration({
					esriSLS: "simple-line"
				}, {
					readOnly: !0
				})], d.prototype, "type", void 0);
				b.__decorate([e.property({
					type: Number,
					cast: c.toPt,
					json: {
						write: !0
					}
				})], d.prototype, "width", void 0);
				return d = b.__decorate([m.subclass("esri.symbols.LineSymbol")], d)
			})
		},
		"esri/symbols/LineSymbolMarker": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../core/JSONSupport ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./support/lineMarkers".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					e = p = function(n) {
						function t(q) {
							q = n.call(this, q) || this;
							q.placement = "begin-end";
							q.type = "line-marker";
							q.style = "arrow";
							return q
						}
						a._inheritsLoose(t, n);
						var h = t.prototype;
						h.writeStyle = function(q, u, x, y) {
							u[x] = "web-map" === y ? .origin ? "arrow" : q
						};
						h.readColor = function(q) {
							return q && null != q[0] ? [q[0], q[1], q[2], q[3] / 255] : q
						};
						h.writeColor = function(q, u, x, y) {
							"web-map" !== y ? .origin && (u[x] = q)
						};
						h.clone = function() {
							return new p({
								color: d.clone(this.color),
								placement: this.placement,
								style: this.style
							})
						};
						h.hash = function() {
							return `${this.placement}.${this.color?.hash()}.${this.style}`
						};
						a._createClass(t, [{
							key: "color",
							set: function(q) {
								this._set("color", q)
							}
						}]);
						return t
					}(e.JSONSupport);
					b.__decorate([k.property({
						type: ["begin", "end", "begin-end"],
						json: {
							write: !0
						}
					})], e.prototype, "placement", void 0);
					b.__decorate([m.enumeration({
						"line-marker": "line-marker"
					}, {
						readOnly: !0
					}), k.property({
						json: {
							origins: {
								"web-map": {
									write: !1
								}
							}
						}
					})], e.prototype, "type", void 0);
					b.__decorate([k.property({
							type: r.lineMarkerStyles
						})], e.prototype,
						"style", void 0);
					b.__decorate([l.writer("style")], e.prototype, "writeStyle", null);
					b.__decorate([k.property({
						type: c,
						value: null,
						json: {
							write: {
								allowNull: !0
							}
						}
					})], e.prototype, "color", null);
					b.__decorate([f.reader("color")], e.prototype, "readColor", null);
					b.__decorate([l.writer("color")], e.prototype, "writeColor", null);
					return e = p = b.__decorate([g.subclass("esri.symbols.LineSymbolMarker")], e)
				})
		},
		"esri/symbols/support/lineMarkers": function() {
			define(["exports"], function(a) {
				a.lineMarkerPlacements = ["begin", "end", "begin-end"];
				a.lineMarkerStyles = "arrow circle square diamond cross x".split(" ");
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/FillSymbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/maybe ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./Symbol3DLayer ./edges/utils ./patterns/LineStylePattern3D ./patterns/StylePattern3D ./patterns/utils ./support/colors ./support/Symbol3DFillMaterial ./support/Symbol3DOutline".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h) {
					var q;
					d = q = function(u) {
						function x(y) {
							y = u.call(this, y) || this;
							y.type = "fill";
							y.material = null;
							y.pattern = null;
							y.castShadows = !0;
							y.outline = null;
							y.edges = null;
							return y
						}
						a._inheritsLoose(x, u);
						x.prototype.clone = function() {
							const y = {
								edges: c.isSome(this.edges) ? this.edges.clone() : null,
								enabled: this.enabled,
								material: c.isSome(this.material) ? this.material.clone() : null,
								pattern: c.isSome(this.pattern) ? this.pattern.clone() : null,
								castShadows: this.castShadows,
								outline: c.isSome(this.outline) ?
									this.outline.clone() : null
							};
							return new q(y)
						};
						x.fromSimpleFillSymbol = function(y) {
							const w = y.outline && y.outline.style && "inside-frame" !== y.outline.style && "solid" !== y.outline.style ? new l({
									style: y.outline.style
								}) : null,
								A = {
									size: y.outline ? .width ? ? 0,
									color: (y.outline ? .color ? ? n.white)
										.clone(),
									pattern: w
								};
							w && y.outline ? .cap && (A.patternCap = y.outline.cap);
							return new q({
								material: new t.Symbol3DFillMaterial({
									color: (y.color ? ? n.transparentWhite)
										.clone()
								}),
								pattern: y.style && "solid" !== y.style ? new r({
									style: y.style
								}) : null,
								outline: A
							})
						};
						return x
					}(f);
					b.__decorate([v.enumeration({
						Fill: "fill"
					}, {
						readOnly: !0
					})], d.prototype, "type", void 0);
					b.__decorate([e.property({
						type: t.Symbol3DFillMaterial,
						json: {
							write: !0
						}
					})], d.prototype, "material", void 0);
					b.__decorate([e.property(p.symbol3dPatternProperty)], d.prototype, "pattern", void 0);
					b.__decorate([e.property({
						type: Boolean,
						nonNullable: !0,
						json: {
							write: !0,
							default: !0
						}
					})], d.prototype, "castShadows", void 0);
					b.__decorate([e.property({
						type: h.Symbol3DOutline,
						json: {
							write: !0
						}
					})], d.prototype, "outline", void 0);
					b.__decorate([e.property(g.symbol3dEdgesProperty)], d.prototype, "edges", void 0);
					return d = q = b.__decorate([m.subclass("esri.symbols.FillSymbol3DLayer")], d)
				})
		},
		"esri/symbols/patterns/LineStylePattern3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./LinePattern3D ./lineStyles".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					c = c.strict()({
						dash: "dash",
						"dash-dot": "dash-dot",
						"dash-dot-dot": "long-dash-dot-dot",
						dot: "dot",
						"long-dash": "long-dash",
						"long-dash-dot": "long-dash-dot",
						null: "none",
						"short-dash": "short-dash",
						"short-dash-dot": "short-dash-dot",
						"short-dash-dot-dot": "short-dash-dot-dot",
						"short-dot": "short-dot",
						solid: "solid"
					});
					f = l = function(r) {
						function p(n) {
							n = r.call(this, n) || this;
							n.type = "style";
							n.style = "solid";
							return n
						}
						a._inheritsLoose(p, r);
						p.prototype.clone = function() {
							return new l({
								style: this.style
							})
						};
						return p
					}(f);
					b.__decorate([e.property({
						type: ["style"]
					})], f.prototype, "type", void 0);
					b.__decorate([v.enumeration(c), e.property({
						type: g.lineStyles
					})], f.prototype, "style", void 0);
					return f = l = b.__decorate([m.subclass("esri.symbols.patterns.LineStylePattern3D")], f)
				})
		},
		"esri/symbols/patterns/LinePattern3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f(g) {
							return m.call(this, g) || this
						}
						a._inheritsLoose(f, m);
						f.prototype.clone = function() {};
						return f
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: ["style"],
						readOnly: !0,
						json: {
							read: !0,
							write: {
								ignoreOrigin: !0
							}
						}
					})], c.prototype, "type", void 0);
					return c = b.__decorate([v.subclass("esri.symbols.patterns.LinePattern3D")], c)
				})
		},
		"esri/symbols/patterns/lineStyles": function() {
			define(["exports"], function(a) {
				a.lineStyles = "dash dash-dot dot long-dash long-dash-dot long-dash-dot-dot none short-dash short-dash-dot short-dash-dot-dot short-dot solid".split(" ");
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/patterns/StylePattern3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Pattern3D ./styles".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				e = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.type = "style";
						r.style =
							"solid";
						return r
					}
					a._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							style: this.style
						})
					};
					return l
				}(v);
				b.__decorate([c.property({
					type: ["style"]
				})], e.prototype, "type", void 0);
				b.__decorate([c.property({
					type: m,
					json: {
						read: !0,
						write: !0
					}
				})], e.prototype, "style", void 0);
				return e = f = b.__decorate([k.subclass("esri.symbols.patterns.StylePattern3D")], e)
			})
		},
		"esri/symbols/patterns/Pattern3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f(g) {
							return m.call(this, g) || this
						}
						a._inheritsLoose(f, m);
						f.prototype.clone = function() {};
						return f
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: ["style"],
						readOnly: !0,
						json: {
							read: !0,
							write: {
								ignoreOrigin: !0
							}
						}
					})], c.prototype, "type", void 0);
					return c = b.__decorate([v.subclass("esri.symbols.patterns.Pattern3D")], c)
				})
		},
		"esri/symbols/patterns/styles": function() {
			define(function() {
				return "backward-diagonal cross diagonal-cross forward-diagonal horizontal none solid vertical".split(" ")
			})
		},
		"esri/symbols/patterns/utils": function() {
			define(["exports", "./LinePattern3D", "./LineStylePattern3D", "./Pattern3D", "./StylePattern3D"], function(a, b, c, e, d) {
				e = {
					types: {
						key: "type",
						base: e,
						typeMap: {
							style: d
						}
					},
					json: {
						write: !0
					}
				};
				a.symbol3dLinePatternProperty = {
					types: {
						key: "type",
						base: b,
						typeMap: {
							style: c
						}
					},
					json: {
						write: !0
					}
				};
				a.symbol3dPatternProperty = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/support/colors": function() {
			define(["exports", "../../Color"],
				function(a, b) {
					const c = new b("white"),
						e = new b("black");
					b = new b([255, 255, 255, 0]);
					a.black = e;
					a.isBlack = function(d) {
						return 0 === d.r && 0 === d.g && 0 === d.b
					};
					a.transparentWhite = b;
					a.white = c;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/Symbol3DFillMaterial": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/maybe ../../core/Logger ../../core/accessorSupport/ensureType ../../core/arrayUtils ../../core/Error ../../core/has ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./Symbol3DMaterial".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					a.Symbol3DFillMaterial = p = function(n) {
						function t(h) {
							h = n.call(this, h) || this;
							h.colorMixMode = null;
							return h
						}
						b._inheritsLoose(t, n);
						t.prototype.clone = function() {
							const h = {
								color: e.isSome(this.color) ? this.color.clone() : null,
								colorMixMode: this.colorMixMode
							};
							return new p(h)
						};
						return t
					}(r.Symbol3DMaterial);
					c.__decorate([g.enumeration({
						multiply: "multiply",
						replace: "replace",
						tint: "tint"
					})], a.Symbol3DFillMaterial.prototype, "colorMixMode", void 0);
					a.Symbol3DFillMaterial = p = c.__decorate([l.subclass("esri.symbols.support.Symbol3DFillMaterial")],
						a.Symbol3DFillMaterial);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/Symbol3DOutline": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/JSONSupport ../../core/maybe ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../patterns/utils ./materialUtils ./symbolLayerUtils3D".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					var t;
					a.Symbol3DOutline = t = function(h) {
						function q(u) {
							u = h.call(this, u) || this;
							u.color = new e([0, 0, 0, 1]);
							u.size = v.px2pt(1);
							u.pattern = null;
							u.patternCap = "butt";
							return u
						}
						b._inheritsLoose(q, h);
						q.prototype.clone = function() {
							const u = {
								color: k.isSome(this.color) ? this.color.clone() : null,
								size: this.size,
								pattern: k.isSome(this.pattern) ? this.pattern.clone() : null,
								patternCap: this.patternCap
							};
							return new t(u)
						};
						return q
					}(d.JSONSupport);
					c.__decorate([m.property(p.colorAndTransparencyProperty)],
						a.Symbol3DOutline.prototype, "color", void 0);
					c.__decorate([m.property(p.screenSizeProperty)], a.Symbol3DOutline.prototype, "size", void 0);
					c.__decorate([m.property(r.symbol3dLinePatternProperty)], a.Symbol3DOutline.prototype, "pattern", void 0);
					c.__decorate([m.property({
						type: n.lineCaps,
						json: {
							default: "butt",
							write: {
								overridePolicy() {
									return {
										enabled: k.isSome(this.pattern)
									}
								}
							}
						}
					})], a.Symbol3DOutline.prototype, "patternCap", void 0);
					a.Symbol3DOutline = t = c.__decorate([l.subclass("esri.symbols.support.Symbol3DOutline")],
						a.Symbol3DOutline);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/symbolLayerUtils3D": function() {
			define(["exports", "../../core/has", "../../chunks/vec3f64", "../../geometry/support/aaBoundingBox"], function(a, b, c, e) {
				const d = e.fromValues(-.5, -.5, -.5, .5, .5, .5),
					k = e.fromValues(-.5, -.5, 0, .5, .5, 1),
					v = e.fromValues(-.5, -.5, 0, .5, .5, .5);
				b = ["butt", "square", "round"];
				e = [...b, "none"];
				a.OBJECT_SYMBOL_LAYER_BOUNDING_BOX_TETRAHEDRON = v;
				a.OBJECT_SYMBOL_LAYER_BOUNDING_BOX_UNIT_CUBE =
					d;
				a.OBJECT_SYMBOL_LAYER_BOUNDING_BOX_UNIT_CYLINDER = k;
				a.lineCaps = b;
				a.lineJoins = ["miter", "bevel", "round"];
				a.objectSymbolLayerPrimitiveBoundingBox = function(m) {
					switch (m) {
						case "sphere":
						case "cube":
						case "diamond":
							return d;
						case "cylinder":
						case "cone":
						case "inverted-cone":
							return k;
						case "tetrahedron":
							return v
					}
				};
				a.objectSymbolLayerSizeWithResourceSize = function(m, {
					isPrimitive: f,
					width: g,
					depth: l,
					height: r
				}) {
					f = f ? 10 : 1;
					if (null == g && null == r && null == l) return [f * m[0], f * m[1], f * m[2]];
					g = c.fromValues(g, l, r);
					let p;
					for (l = 0; 3 >
						l; l++)
						if (r = g[l], null != r) {
							p = r / m[l];
							break
						} for (l = 0; 3 > l; l++) null == g[l] && (g[l] = m[l] * p);
					return g
				};
				a.pathCaps = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/geometry/support/aaBoundingBox": function() {
			define(["exports", "../../core/maybe", "../Extent", "./aaBoundingRect"], function(a, b, c, e) {
				function d(h = n) {
					return [h[0], h[1], h[2], h[3], h[4], h[5]]
				}

				function k(h, q, u, x, y, w, A = d()) {
					A[0] = h;
					A[1] = q;
					A[2] = u;
					A[3] = x;
					A[4] = y;
					A[5] = w;
					return A
				}

				function v(h) {
					return h[0] >= h[3] ? 0 :
						h[3] - h[0]
				}

				function m(h) {
					return h[1] >= h[4] ? 0 : h[4] - h[1]
				}

				function f(h) {
					return h[2] >= h[5] ? 0 : h[5] - h[2]
				}

				function g(h, q) {
					return Math.max(q[0], h[0]) <= Math.min(q[3], h[3]) && Math.max(q[1], h[1]) <= Math.min(q[4], h[4]) && Math.max(q[2], h[2]) <= Math.min(q[5], h[5])
				}

				function l(h, q) {
					h[0] = q[0];
					h[1] = q[1];
					h[2] = q[2];
					h[3] = q[3];
					h[4] = q[4];
					h[5] = q[5];
					return h
				}

				function r(h) {
					return 6 === h.length
				}
				const p = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity],
					n = [0, 0, 0, 0, 0, 0],
					t = d();
				a.NEGATIVE_INFINITY = p;
				a.POSITIVE_INFINITY = [-Infinity,
					-Infinity, -Infinity, Infinity, Infinity, Infinity
				];
				a.ZERO = n;
				a.allFinite = function(h) {
					for (let q = 0; 6 > q; q++)
						if (!isFinite(h[q])) return !1;
					return !0
				};
				a.center = function(h, q = [0, 0, 0]) {
					q[0] = h[0] + v(h) / 2;
					q[1] = h[1] + m(h) / 2;
					q[2] = h[2] + f(h) / 2;
					return q
				};
				a.contains = function(h, q) {
					return q[0] >= h[0] && q[1] >= h[1] && q[2] >= h[2] && q[3] <= h[3] && q[4] <= h[4] && q[5] <= h[5]
				};
				a.containsPoint = function(h, q) {
					return q[0] >= h[0] && q[1] >= h[1] && q[2] >= h[2] && q[0] <= h[3] && q[1] <= h[4] && q[2] <= h[5]
				};
				a.containsPointWithMargin = function(h, q, u) {
					return q[0] >= h[0] -
						u && q[1] >= h[1] - u && q[2] >= h[2] - u && q[0] <= h[3] + u && q[1] <= h[4] + u && q[2] <= h[5] + u
				};
				a.create = d;
				a.depth = m;
				a.diameter = function(h) {
					const q = v(h),
						u = f(h);
					h = m(h);
					return Math.sqrt(q * q + u * u + h * h)
				};
				a.empty = function(h) {
					return h ? l(h, p) : d(p)
				};
				a.equals = function(h, q, u) {
					if (b.isNone(h) || b.isNone(q)) return h === q;
					if (!r(h) || !r(q)) return !1;
					if (u)
						for (let x = 0; x < h.length; x++) {
							if (!u(h[x], q[x])) return !1
						} else
							for (u = 0; u < h.length; u++)
								if (h[u] !== q[u]) return !1;
					return !0
				};
				a.expandWithAABB = function(h, q) {
					h[0] = Math.min(h[0], q[0]);
					h[1] = Math.min(h[1],
						q[1]);
					h[2] = Math.min(h[2], q[2]);
					h[3] = Math.max(h[3], q[3]);
					h[4] = Math.max(h[4], q[4]);
					h[5] = Math.max(h[5], q[5])
				};
				a.expandWithBuffer = function(h, q, u = 0, x = q.length / 3) {
					let y = h[0],
						w = h[1],
						A = h[2],
						B = h[3],
						E = h[4],
						z = h[5];
					for (let C = 0; C < x; C++) y = Math.min(y, q[u + 3 * C]), w = Math.min(w, q[u + 3 * C + 1]), A = Math.min(A, q[u + 3 * C + 2]), B = Math.max(B, q[u + 3 * C]), E = Math.max(E, q[u + 3 * C + 1]), z = Math.max(z, q[u + 3 * C + 2]);
					h[0] = y;
					h[1] = w;
					h[2] = A;
					h[3] = B;
					h[4] = E;
					h[5] = z
				};
				a.expandWithNestedArray = function(h, q, u) {
					const x = q.length;
					let y = h[0],
						w = h[1],
						A = h[2],
						B = h[3],
						E = h[4],
						z = h[5];
					if (u)
						for (u = 0; u < x; u++) {
							var C = q[u];
							y = Math.min(y, C[0]);
							w = Math.min(w, C[1]);
							A = Math.min(A, C[2]);
							B = Math.max(B, C[0]);
							E = Math.max(E, C[1]);
							z = Math.max(z, C[2])
						} else
							for (u = 0; u < x; u++) C = q[u], y = Math.min(y, C[0]), w = Math.min(w, C[1]), B = Math.max(B, C[0]), E = Math.max(E, C[1]);
					h[0] = y;
					h[1] = w;
					h[2] = A;
					h[3] = B;
					h[4] = E;
					h[5] = z
				};
				a.expandWithOffset = function(h, q, u, x) {
					h[0] = Math.min(h[0], h[0] + q);
					h[3] = Math.max(h[3], h[3] + q);
					h[1] = Math.min(h[1], h[1] + u);
					h[4] = Math.max(h[4], h[4] + u);
					h[2] = Math.min(h[2], h[2] + x);
					h[5] = Math.max(h[5], h[5] +
						x)
				};
				a.expandWithRect = function(h, q) {
					h[0] = Math.min(h[0], q[0]);
					h[1] = Math.min(h[1], q[1]);
					h[3] = Math.max(h[3], q[2]);
					h[4] = Math.max(h[4], q[3])
				};
				a.expandWithVec3 = function(h, q) {
					h[0] = Math.min(h[0], q[0]);
					h[1] = Math.min(h[1], q[1]);
					h[2] = Math.min(h[2], q[2]);
					h[3] = Math.max(h[3], q[0]);
					h[4] = Math.max(h[4], q[1]);
					h[5] = Math.max(h[5], q[2])
				};
				a.fromExtent = function(h, q = d()) {
					q[0] = h.xmin;
					q[1] = h.ymin;
					q[2] = h.hasZ ? h.zmin : -Infinity;
					q[3] = h.xmax;
					q[4] = h.ymax;
					q[5] = h.hasZ ? h.zmax : Infinity;
					return q
				};
				a.fromMinMax = function(h, q, u = d()) {
					u[0] =
						h[0];
					u[1] = h[1];
					u[2] = h[2];
					u[3] = q[0];
					u[4] = q[1];
					u[5] = q[2];
					return u
				};
				a.fromRect = function(h, q) {
					h[0] = q[0];
					h[1] = q[1];
					h[2] = Number.NEGATIVE_INFINITY;
					h[3] = q[2];
					h[4] = q[3];
					h[5] = Number.POSITIVE_INFINITY;
					return h
				};
				a.fromValues = k;
				a.getMax = function(h, q) {
					q[0] = h[3];
					q[1] = h[4];
					q[2] = h[5];
					return q
				};
				a.getMin = function(h, q) {
					q[0] = h[0];
					q[1] = h[1];
					q[2] = h[2];
					return q
				};
				a.height = f;
				a.intersects = g;
				a.intersectsClippingArea = function(h, q) {
					return b.isNone(q) ? !0 : g(h, q)
				};
				a.is = r;
				a.isPoint = function(h) {
					return 0 === v(h) && 0 === m(h) && 0 === f(h)
				};
				a.maximumDimension = function(h) {
					return Math.max(v(h), f(h), m(h))
				};
				a.offset = function(h, q, u, x, y = h) {
					y[0] = h[0] + q;
					y[1] = h[1] + u;
					y[2] = h[2] + x;
					y[3] = h[3] + q;
					y[4] = h[4] + u;
					y[5] = h[5] + x;
					return y
				};
				a.scale = function(h, q, u = h) {
					const x = h[0] + v(h) / 2,
						y = h[1] + m(h) / 2,
						w = h[2] + f(h) / 2;
					u[0] = x + (h[0] - x) * q;
					u[1] = y + (h[1] - y) * q;
					u[2] = w + (h[2] - w) * q;
					u[3] = x + (h[3] - x) * q;
					u[4] = y + (h[4] - y) * q;
					u[5] = w + (h[5] - w) * q;
					return u
				};
				a.set = l;
				a.setMax = function(h, q, u = h) {
					u[3] = q[0];
					u[4] = q[1];
					u[5] = q[2];
					u !== h && (u[0] = h[0], u[1] = h[1], u[2] = h[2]);
					return h
				};
				a.setMin = function(h,
					q, u = h) {
					u[0] = q[0];
					u[1] = q[1];
					u[2] = q[2];
					u !== h && (u[3] = h[3], u[4] = h[4], u[5] = h[5]);
					return u
				};
				a.size = function(h, q = [0, 0, 0]) {
					q[0] = v(h);
					q[1] = m(h);
					q[2] = f(h);
					return q
				};
				a.toExtent = function(h, q) {
					return isFinite(h[2]) || isFinite(h[5]) ? new c({
						xmin: h[0],
						xmax: h[3],
						ymin: h[1],
						ymax: h[4],
						zmin: h[2],
						zmax: h[5],
						spatialReference: q
					}) : new c({
						xmin: h[0],
						xmax: h[3],
						ymin: h[1],
						ymax: h[4],
						spatialReference: q
					})
				};
				a.toRect = function(h, q) {
					q || (q = e.create());
					q[0] = h[0];
					q[1] = h[1];
					q[2] = h[3];
					q[3] = h[4];
					return q
				};
				a.width = v;
				a.wrap = function(h, q, u, x, y,
					w) {
					return k(h, q, u, x, y, w, t)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/Font": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/screenUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/subclass ./support/textUtils".split(" "), function(a, b, c, e, d, k, v, m, f) {
				var g;
				c = g = function(l) {
					function r(n) {
						n = l.call(this,
							n) || this;
						n.decoration = "none";
						n.family = "sans-serif";
						n.size = 9;
						n.style = "normal";
						n.weight = "normal";
						return n
					}
					a._inheritsLoose(r, l);
					var p = r.prototype;
					p.castSize = function(n) {
						return e.toPt(n)
					};
					p.clone = function() {
						return new g({
							decoration: this.decoration,
							family: this.family,
							size: this.size,
							style: this.style,
							weight: this.weight
						})
					};
					p.hash = function() {
						return `${this.decoration}.${this.family}.${this.size}.${this.style}.${this.weight}`
					};
					return r
				}(c.JSONSupport);
				b.__decorate([d.property({
					type: f.fontDecorations,
					json: {
						default: "none",
						write: !0
					}
				})], c.prototype, "decoration", void 0);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "family", void 0);
				b.__decorate([d.property({
					type: Number,
					json: {
						write: {
							overridePolicy(l, r, p) {
								return {
									enabled: !p || !p.textSymbol3D
								}
							}
						}
					}
				})], c.prototype, "size", void 0);
				b.__decorate([v.cast("size")], c.prototype, "castSize", null);
				b.__decorate([d.property({
					type: f.fontStyles,
					json: {
						default: "normal",
						write: !0
					}
				})], c.prototype, "style", void 0);
				b.__decorate([d.property({
					type: f.fontWeights,
					json: {
						default: "normal",
						write: !0
					}
				})], c.prototype, "weight", void 0);
				return c = g = b.__decorate([m.subclass("esri.symbols.Font")], c)
			})
		},
		"esri/symbols/support/textUtils": function() {
			define(["exports", "../../core/mathUtils", "../../core/accessorSupport/ensureType"], function(a, b, c) {
				const e = {
						type: Number,
						cast: f => {
							f = c.ensureNumber(f);
							return 0 === f ? 1 : b.clamp(f, .1, 4)
						},
						nonNullable: !0
					},
					d = ["left", "right", "center"],
					k = ["baseline", "top", "middle", "bottom"],
					v = {
						type: d,
						nonNullable: !0
					},
					m = {
						type: k,
						nonNullable: !0
					};
				a.fontDecorations = ["none", "underline",
					"line-through"
				];
				a.fontStyles = ["normal", "italic", "oblique"];
				a.fontWeights = ["normal", "lighter", "bold", "bolder"];
				a.horizontalAlignmentProperty = v;
				a.horizontalAlignments = d;
				a.lineHeightProperty = e;
				a.verticalAlignmentProperty = m;
				a.verticalAlignments = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/IconSymbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Logger ../core/maybe ../core/urlUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./Symbol3DLayer ./support/colors ./support/IconSymbol3DLayerResource ./support/materialUtils ./support/Symbol3DAnchorPosition2D ./support/Symbol3DIconOutline ./support/Symbol3DMaterial".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q) {
					function u(A) {
						const B = "width" in A ? A.width : A.size,
							E = "height" in A ? A.height : A.size,
							z = x(A.xoffset);
						A = x(A.yoffset);
						return (z || A) && B && E ? {
							x: -z / B,
							y: A / E
						} : null
					}

					function x(A) {
						return isFinite(A) ? A : 0
					}
					var y;
					v = y = function(A) {
						function B(E) {
							E = A.call(this, E) || this;
							E.material = null;
							E.resource = null;
							E.type = "icon";
							E.size = 12;
							E.anchor = "center";
							E.anchorPosition = null;
							E.outline = null;
							return E
						}
						a._inheritsLoose(B, A);
						B.prototype.clone = function() {
							return new y({
								anchor: this.anchor,
								anchorPosition: this.anchorPosition &&
									this.anchorPosition.clone(),
								enabled: this.enabled,
								material: e.isSome(this.material) ? this.material.clone() : null,
								outline: e.isSome(this.outline) ? this.outline.clone() : null,
								resource: this.resource && this.resource.clone(),
								size: this.size
							})
						};
						B.fromSimpleMarkerSymbol = function(E) {
							const z = E.color || r.white,
								C = u(E),
								D = E.outline && 0 < E.outline.width ? {
									size: E.outline.width,
									color: (E.outline.color || r.white)
										.clone()
								} : null;
							var J = y,
								K = E.size; {
								E = E.style;
								const H = w[E];
								H ? E = H : (c.getLogger("esri.symbols.IconSymbol3DLayer")
									.warn(`${E} cannot be mapped to Icon symbol. Fallback to "circle"`),
									E = "circle")
							}
							return new J({
								size: K,
								resource: {
									primitive: E
								},
								material: {
									color: z
								},
								outline: D,
								anchor: C ? "relative" : void 0,
								anchorPosition: C
							})
						};
						B.fromPictureMarkerSymbol = function(E) {
							const z = !E.color || r.isBlack(E.color) ? r.white : E.color,
								C = u(E);
							return new y({
								size: E.width <= E.height ? E.height : E.width,
								resource: {
									href: E.url
								},
								material: {
									color: z.clone()
								},
								anchor: C ? "relative" : void 0,
								anchorPosition: C
							})
						};
						B.fromCIMSymbol = function(E) {
							return new y({
								resource: {
									href: d.makeData({
										mediaType: "application/json",
										data: JSON.stringify(E.data)
									})
								}
							})
						};
						return B
					}(l);
					b.__decorate([k.property({
						type: q.Symbol3DMaterial,
						json: {
							write: !0
						}
					})], v.prototype, "material", void 0);
					b.__decorate([k.property({
						type: p.IconSymbol3DLayerResource,
						json: {
							write: !0
						}
					})], v.prototype, "resource", void 0);
					b.__decorate([f.enumeration({
						Icon: "icon"
					}, {
						readOnly: !0
					})], v.prototype, "type", void 0);
					b.__decorate([k.property(n.screenSizeProperty)], v.prototype, "size", void 0);
					b.__decorate([f.enumeration({
						center: "center",
						left: "left",
						right: "right",
						top: "top",
						bottom: "bottom",
						topLeft: "top-left",
						topRight: "top-right",
						bottomLeft: "bottom-left",
						bottomRight: "bottom-right",
						relative: "relative"
					}), k.property({
						json: {
							default: "center"
						}
					})], v.prototype, "anchor", void 0);
					b.__decorate([k.property({
						type: t.Symbol3DAnchorPosition2D,
						json: {
							type: [Number],
							read: {
								reader: A => new t.Symbol3DAnchorPosition2D({
									x: A[0],
									y: A[1]
								})
							},
							write: {
								writer: (A, B) => {
									B.anchorPosition = [A.x, A.y]
								},
								overridePolicy() {
									return {
										enabled: "relative" === this.anchor
									}
								}
							}
						}
					})], v.prototype, "anchorPosition", void 0);
					b.__decorate([k.property({
							type: h.Symbol3DIconOutline,
							json: {
								write: !0
							}
						})],
						v.prototype, "outline", void 0);
					v = y = b.__decorate([g.subclass("esri.symbols.IconSymbol3DLayer")], v);
					const w = {
						circle: "circle",
						cross: "cross",
						diamond: "kite",
						square: "square",
						x: "x",
						triangle: "triangle",
						path: null
					};
					return v
				})
		},
		"esri/symbols/support/IconSymbol3DLayerResource": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/urlUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../chunks/persistableUrlUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					var t;
					e = e.strict()({
						circle: "circle",
						square: "square",
						cross: "cross",
						x: "x",
						kite: "kite",
						triangle: "triangle"
					});
					a.IconSymbol3DLayerResource = t = function(h) {
						function q(x) {
							return h.call(this, x) || this
						}
						b._inheritsLoose(q, h);
						var u = q.prototype;
						u.readHref = function(x, y, w) {
							return x ? n.fromJSON(x, w) : y.dataURI
						};
						u.writeHref = function(x, y, w, A) {
							x && (k.isDataProtocol(x) ? y.dataURI = x : (y.href = n.toJSON(x, A), k.isAbsolute(y.href) && (y.href = k.normalize(y.href))))
						};
						u.clone = function() {
							return new t({
								href: this.href,
								primitive: this.primitive
							})
						};
						return q
					}(d.JSONSupport);
					c.__decorate([v.property({
						type: String,
						json: {
							write: !0,
							read: {
								source: ["href", "dataURI"]
							}
						}
					})], a.IconSymbol3DLayerResource.prototype, "href", void 0);
					c.__decorate([l.reader("href")], a.IconSymbol3DLayerResource.prototype, "readHref", null);
					c.__decorate([p.writer("href", {
						href: {
							type: String
						},
						dataURI: {
							type: String
						}
					})], a.IconSymbol3DLayerResource.prototype, "writeHref", null);
					c.__decorate([g.enumeration(e)], a.IconSymbol3DLayerResource.prototype, "primitive", void 0);
					a.IconSymbol3DLayerResource = t = c.__decorate([r.subclass("esri.symbols.support.IconSymbol3DLayerResource")], a.IconSymbol3DLayerResource);
					a.defaultPrimitive = "circle";
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/Symbol3DAnchorPosition2D": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					a.Symbol3DAnchorPosition2D = f = function(g) {
						function l() {
							var r = g.apply(this, arguments) || this;
							r.x = 0;
							r.y = 0;
							return r
						}
						b._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								x: this.x,
								y: this.y
							})
						};
						return l
					}(e);
					c.__decorate([d.property({
						type: Number
					})], a.Symbol3DAnchorPosition2D.prototype, "x", void 0);
					c.__decorate([d.property({
						type: Number
					})], a.Symbol3DAnchorPosition2D.prototype, "y", void 0);
					a.Symbol3DAnchorPosition2D = f = c.__decorate([m.subclass("esri.symbols.support.Symbol3DAnchorPosition2D")],
						a.Symbol3DAnchorPosition2D);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/Symbol3DIconOutline": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/JSONSupport ../../core/maybe ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./materialUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					a.Symbol3DIconOutline = p = function(n) {
						function t(h) {
							h = n.call(this, h) || this;
							h.color = new e([0, 0, 0, 1]);
							h.size = v.px2pt(1);
							return h
						}
						b._inheritsLoose(t, n);
						t.prototype.clone = function() {
							const h = {
								color: k.isSome(this.color) ? this.color.clone() : null,
								size: this.size
							};
							return new p(h)
						};
						return t
					}(d.JSONSupport);
					c.__decorate([m.property(r.colorAndTransparencyProperty)], a.Symbol3DIconOutline.prototype, "color", void 0);
					c.__decorate([m.property(r.screenSizeProperty)], a.Symbol3DIconOutline.prototype,
						"size", void 0);
					a.Symbol3DIconOutline = p = c.__decorate([l.subclass("esri.symbols.support.Symbol3DIconOutline")], a.Symbol3DIconOutline);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/LabelSymbol3D": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Collection ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./Symbol3D ./TextSymbol3DLayer ./callouts/calloutUtils ./support/Symbol3DVerticalOffset".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					const n = c.ofType({
						base: null,
						key: "type",
						typeMap: {
							text: g
						}
					});
					c = p = function(t) {
						function h(u) {
							u = t.call(this, u) || this;
							u.verticalOffset = null;
							u.callout = null;
							u.styleOrigin = null;
							u.symbolLayers = new n;
							u.type = "label-3d";
							return u
						}
						a._inheritsLoose(h, t);
						var q = h.prototype;
						q.supportsCallout = function() {
							return !0
						};
						q.hasVisibleCallout = function() {
							return l.hasVisibleCallout(this)
						};
						q.hasVisibleVerticalOffset = function() {
							return l.hasVisibleVerticalOffset(this)
						};
						q.clone = function() {
							return new p({
								styleOrigin: e.clone(this.styleOrigin),
								symbolLayers: e.clone(this.symbolLayers),
								thumbnail: e.clone(this.thumbnail),
								callout: e.clone(this.callout),
								verticalOffset: e.clone(this.verticalOffset)
							})
						};
						h.fromTextSymbol = function(u) {
							return new p({
								symbolLayers: [g.fromTextSymbol(u)]
							})
						};
						return h
					}(f);
					b.__decorate([d.property({
						type: r,
						json: {
							write: !0
						}
					})], c.prototype, "verticalOffset", void 0);
					b.__decorate([d.property(l.calloutProperty)], c.prototype, "callout", void 0);
					b.__decorate([d.property({
						json: {
							read: !1,
							write: !1
						}
					})], c.prototype, "styleOrigin", void 0);
					b.__decorate([d.property({
							type: n
						})],
						c.prototype, "symbolLayers", void 0);
					b.__decorate([v.enumeration({
						LabelSymbol3D: "label-3d"
					}, {
						readOnly: !0
					})], c.prototype, "type", void 0);
					return c = p = b.__decorate([m.subclass("esri.symbols.LabelSymbol3D")], c)
				})
		},
		"esri/symbols/Symbol3D": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Collection ../core/collectionUtils ../core/Logger ../core/urlUtils ../core/Warning ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../portal/Portal ../chunks/persistableUrlUtils ./ExtrudeSymbol3DLayer ./FillSymbol3DLayer ./IconSymbol3DLayer ./LineSymbol3DLayer ./ObjectSymbol3DLayer ./PathSymbol3DLayer ./Symbol ./Symbol3DLayer ./TextSymbol3DLayer ./WaterSymbol3DLayer ./support/StyleOrigin ./support/Thumbnail".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D) {
					const J = {
						icon: u,
						object: y,
						line: x,
						path: w,
						fill: q,
						extrude: h,
						text: E,
						water: z
					};
					f = c.ofType({
						base: B,
						key: "type",
						typeMap: J,
						errorContext: "symbol-layer"
					});
					A = function(K) {
						function H(F) {
							F = K.call(this, F) || this;
							F.styleOrigin = null;
							F.thumbnail = null;
							F.type = null;
							const L = F.__accessor__ && F.__accessor__.metadatas && F.__accessor__.metadatas.symbolLayers;
							F._set("symbolLayers", new(L && L.type || c));
							return F
						}
						a._inheritsLoose(H, K);
						var G = H.prototype;
						G.readStyleOrigin =
							function(F, L, R) {
								if (F.styleUrl && F.name) return L = t.fromJSON(F.styleUrl, R), new C({
									styleUrl: L,
									name: F.name
								});
								if (F.styleName && F.name) return new C({
									portal: R && R.portal || n.getDefault(),
									styleName: F.styleName,
									name: F.name
								});
								R && R.messages && R.messages.push(new v("symbol3d:incomplete-style-origin", "Style origin requires either a 'styleUrl' or 'styleName' and a 'name' property", {
									context: R,
									definition: F
								}))
							};
						G.writeStyleOrigin = function(F, L, R, V) {
							F.styleUrl && F.name ? (R = t.toJSON(F.styleUrl, V), k.isAbsolute(R) && (R = k.normalize(R)),
								L.styleOrigin = {
									styleUrl: R,
									name: F.name
								}) : F.styleName && F.name && (F.portal && V && V.portal && !k.hasSamePortal(F.portal.restUrl, V.portal.restUrl) ? V && V.messages && V.messages.push(new v("symbol:cross-portal", "The symbol style origin cannot be persisted because it refers to an item on a different portal than the one being saved to.", {
								symbol: this
							})) : L.styleOrigin = {
								styleName: F.styleName,
								name: F.name
							})
						};
						G.normalizeCtorArgs = function(F) {
							return F instanceof B || F && J[F.type] ? {
									symbolLayers: [F]
								} : Array.isArray(F) ? {
									symbolLayers: F
								} :
								F
						};
						a._createClass(H, [{
							key: "color",
							get: function() {
								return null
							},
							set: function(F) {
								this.constructed && d.getLogger(this.declaredClass)
									.error("Symbol3D does not support colors on the symbol level. Colors may be set on individual symbol layer materials instead.")
							}
						}, {
							key: "symbolLayers",
							set: function(F) {
								e.referenceSetter(F, this._get("symbolLayers"))
							}
						}]);
						return H
					}(A);
					b.__decorate([m.property({
						json: {
							read: !1,
							write: !1
						}
					})], A.prototype, "color", null);
					b.__decorate([m.property({
							type: f,
							nonNullable: !0,
							json: {
								write: !0
							}
						}),
						g.cast(e.castForReferenceSetter)
					], A.prototype, "symbolLayers", null);
					b.__decorate([m.property({
						type: C
					})], A.prototype, "styleOrigin", void 0);
					b.__decorate([l.reader("styleOrigin")], A.prototype, "readStyleOrigin", null);
					b.__decorate([p.writer("styleOrigin", {
						"styleOrigin.styleUrl": {
							type: String
						},
						"styleOrigin.styleName": {
							type: String
						},
						"styleOrigin.name": {
							type: String
						}
					})], A.prototype, "writeStyleOrigin", null);
					b.__decorate([m.property({
						type: D.Thumbnail,
						json: {
							read: !1
						}
					})], A.prototype, "thumbnail", void 0);
					b.__decorate([m.property({
						type: ["point-3d",
							"line-3d", "polygon-3d", "mesh-3d", "label-3d"
						],
						readOnly: !0
					})], A.prototype, "type", void 0);
					return A = b.__decorate([r.subclass("esri.symbols.Symbol3D")], A)
				})
		},
		"esri/symbols/LineSymbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/maybe ../core/screenUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./LineStyleMarker3D ./Symbol3DLayer ./patterns/LineStylePattern3D ./patterns/utils ./support/colors ./support/materialUtils ./support/Symbol3DMaterial ./support/symbolLayerUtils3D".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q) {
					var u;
					k = u = function(x) {
						function y(w) {
							w = x.call(this, w) || this;
							w.material = null;
							w.type = "line";
							w.join = "miter";
							w.cap = "butt";
							w.size = e.px2pt(1);
							w.pattern = null;
							w.marker = null;
							return w
						}
						a._inheritsLoose(y, x);
						y.prototype.clone = function() {
							const w = {
								enabled: this.enabled,
								material: c.isSome(this.material) ? this.material.clone() : null,
								size: this.size,
								join: this.join,
								cap: this.cap,
								pattern: c.isSome(this.pattern) ? this.pattern.clone() : null,
								marker: c.isSome(this.marker) ? this.marker.clone() : null
							};
							return new u(w)
						};
						y.fromSimpleLineSymbol = function(w) {
							w = {
								enabled: !0,
								size: w.width ? ? e.px2pt(1),
								cap: w.cap || "butt",
								join: w.join || "miter",
								pattern: w.style && "inside-frame" !== w.style ? new r({
									style: w.style
								}) : null,
								material: new h.Symbol3DMaterial({
									color: (w.color || n.white)
										.clone()
								}),
								marker: w.marker ? new g({
									placement: w.marker.placement,
									style: w.marker.style,
									color: w.marker.color ? .clone() ? ? null
								}) : null
							};
							return new u(w)
						};
						return y
					}(l);
					b.__decorate([d.property({
							type: h.Symbol3DMaterial,
							json: {
								write: !0
							}
						})], k.prototype,
						"material", void 0);
					b.__decorate([m.enumeration({
						Line: "line"
					}, {
						readOnly: !0
					})], k.prototype, "type", void 0);
					b.__decorate([d.property({
						type: q.lineJoins,
						json: {
							write: !0,
							default: "miter"
						}
					})], k.prototype, "join", void 0);
					b.__decorate([d.property({
						type: q.lineCaps,
						json: {
							write: !0,
							default: "butt"
						}
					})], k.prototype, "cap", void 0);
					b.__decorate([d.property(t.screenSizeProperty)], k.prototype, "size", void 0);
					b.__decorate([d.property(p.symbol3dLinePatternProperty)], k.prototype, "pattern", void 0);
					b.__decorate([d.property({
						types: {
							key: "type",
							base: g,
							typeMap: {
								style: g
							}
						},
						json: {
							write: !0
						}
					})], k.prototype, "marker", void 0);
					return k = u = b.__decorate([f.subclass("esri.symbols.LineSymbol3DLayer")], k)
				})
		},
		"esri/symbols/LineStyleMarker3D": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../core/Clonable ../core/JSONSupport ../core/maybe ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./support/lineMarkers".split(" "), function(a,
				b, c, e, d, k, v, m, f, g, l) {
				e = function(r) {
					function p(n) {
						n = r.call(this, n) || this;
						n.type = "style";
						n.placement = "begin-end";
						n.style = "arrow";
						n.color = null;
						return n
					}
					a._inheritsLoose(p, r);
					p.prototype.equals = function(n) {
						return k.isSome(n) && n.placement === this.placement && n.style === this.style && (k.isNone(this.color) && k.isNone(n.color) || k.isSome(this.color) && k.isSome(n.color) && this.color.toJSON() === n.color.toJSON())
					};
					return p
				}(e.ClonableMixin(d.JSONSupport));
				b.__decorate([v.property({
					type: ["style"],
					readOnly: !0,
					json: {
						read: !0,
						write: {
							ignoreOrigin: !0
						}
					}
				})], e.prototype, "type", void 0);
				b.__decorate([v.property({
					type: l.lineMarkerPlacements,
					json: {
						default: "begin-end",
						write: !0
					}
				})], e.prototype, "placement", void 0);
				b.__decorate([v.property({
					type: l.lineMarkerStyles,
					json: {
						default: "arrow",
						write: !0
					}
				})], e.prototype, "style", void 0);
				b.__decorate([v.property({
					type: c,
					json: {
						type: [f.Integer],
						default: null,
						write: !0
					}
				})], e.prototype, "color", void 0);
				return e = b.__decorate([g.subclass("esri.symbols.LineStyleMarker3D")], e)
			})
		},
		"esri/symbols/ObjectSymbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/maybe ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./Symbol3DLayer ./support/ObjectSymbol3DLayerResource ./support/Symbol3DAnchorPosition3D ./support/Symbol3DMaterial".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					d = p = function(n) {
						function t(h) {
							h = n.call(this, h) || this;
							h.material = null;
							h.castShadows = !0;
							h.resource = null;
							h.type = "object";
							h.width = void 0;
							h.height = void 0;
							h.depth = void 0;
							h.anchor = void 0;
							h.anchorPosition = void 0;
							h.heading = void 0;
							h.tilt = void 0;
							h.roll = void 0;
							return h
						}
						a._inheritsLoose(t, n);
						t.prototype.clone = function() {
							return new p({
								heading: this.heading,
								tilt: this.tilt,
								roll: this.roll,
								anchor: this.anchor,
								anchorPosition: this.anchorPosition && this.anchorPosition.clone(),
								depth: this.depth,
								enabled: this.enabled,
								height: this.height,
								material: c.isSome(this.material) ? this.material.clone() : null,
								castShadows: this.castShadows,
								resource: this.resource && this.resource.clone(),
								width: this.width
							})
						};
						a._createClass(t, [{
							key: "isPrimitive",
							get: function() {
								return !this.resource || "string" !== typeof this.resource.href
							}
						}]);
						return t
					}(f);
					b.__decorate([e.property({
						type: r.Symbol3DMaterial,
						json: {
							write: !0
						}
					})], d.prototype, "material", void 0);
					b.__decorate([e.property({
							type: Boolean,
							nonNullable: !0,
							json: {
								write: !0,
								default: !0
							}
						})],
						d.prototype, "castShadows", void 0);
					b.__decorate([e.property({
						type: g.ObjectSymbol3DLayerResource,
						json: {
							write: !0
						}
					})], d.prototype, "resource", void 0);
					b.__decorate([v.enumeration({
						Object: "object"
					}, {
						readOnly: !0
					})], d.prototype, "type", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], d.prototype, "width", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], d.prototype, "height", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], d.prototype, "depth", void 0);
					b.__decorate([v.enumeration({
						center: "center",
						top: "top",
						bottom: "bottom",
						origin: "origin",
						relative: "relative"
					}), e.property({
						json: {
							default: "origin"
						}
					})], d.prototype, "anchor", void 0);
					b.__decorate([e.property({
						type: l.Symbol3DAnchorPosition3D,
						json: {
							type: [Number],
							read: {
								reader: n => new l.Symbol3DAnchorPosition3D({
									x: n[0],
									y: n[1],
									z: n[2]
								})
							},
							write: {
								writer: (n, t) => {
									t.anchorPosition = [n.x, n.y, n.z]
								},
								overridePolicy() {
									return {
										enabled: "relative" === this.anchor
									}
								}
							}
						}
					})], d.prototype, "anchorPosition", void 0);
					b.__decorate([e.property({
							type: Number,
							json: {
								write: !0
							}
						})], d.prototype,
						"heading", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], d.prototype, "tilt", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], d.prototype, "roll", void 0);
					b.__decorate([e.property({
						readOnly: !0
					})], d.prototype, "isPrimitive", null);
					return d = p = b.__decorate([m.subclass("esri.symbols.ObjectSymbol3DLayer")], d)
				})
		},
		"esri/symbols/support/ObjectSymbol3DLayerResource": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ../../chunks/persistableUrlUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					e = e.strict()({
						sphere: "sphere",
						cylinder: "cylinder",
						cube: "cube",
						cone: "cone",
						diamond: "diamond",
						tetrahedron: "tetrahedron",
						invertedCone: "inverted-cone"
					});
					a.ObjectSymbol3DLayerResource = r = function(p) {
						function n() {
							return p.apply(this, arguments) || this
						}
						b._inheritsLoose(n, p);
						n.prototype.clone = function() {
							return new r({
								href: this.href,
								primitive: this.primitive
							})
						};
						return n
					}(d.JSONSupport);
					c.__decorate([k.property({
							type: String,
							json: {
								read: l.read,
								write: l.write
							}
						})], a.ObjectSymbol3DLayerResource.prototype,
						"href", void 0);
					c.__decorate([f.enumeration(e)], a.ObjectSymbol3DLayerResource.prototype, "primitive", void 0);
					a.ObjectSymbol3DLayerResource = r = c.__decorate([g.subclass("esri.symbols.support.ObjectSymbol3DLayerResource")], a.ObjectSymbol3DLayerResource);
					a.defaultPrimitive = "sphere";
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/Symbol3DAnchorPosition3D": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					a.Symbol3DAnchorPosition3D = f = function(g) {
						function l() {
							var r = g.apply(this, arguments) || this;
							r.x = 0;
							r.y = 0;
							r.z = 0;
							return r
						}
						b._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								x: this.x,
								y: this.y,
								z: this.z
							})
						};
						return l
					}(e);
					c.__decorate([d.property({
						type: Number
					})], a.Symbol3DAnchorPosition3D.prototype, "x", void 0);
					c.__decorate([d.property({
						type: Number
					})], a.Symbol3DAnchorPosition3D.prototype, "y", void 0);
					c.__decorate([d.property({
							type: Number
						})], a.Symbol3DAnchorPosition3D.prototype,
						"z", void 0);
					a.Symbol3DAnchorPosition3D = f = c.__decorate([m.subclass("esri.symbols.support.Symbol3DAnchorPosition3D")], a.Symbol3DAnchorPosition3D);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/PathSymbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/maybe ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ./Symbol3DLayer ./support/Symbol3DMaterial ./support/symbolLayerUtils3D".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					d = p = function(n) {
						function t(q) {
							q = n.call(this, q) || this;
							q.material = null;
							q.castShadows = !0;
							q.type = "path";
							q.profile = "circle";
							q.join = "miter";
							q.cap = "butt";
							q.width = void 0;
							q.height = void 0;
							q.anchor = "center";
							q.profileRotation = "all";
							return q
						}
						a._inheritsLoose(t, n);
						var h = t.prototype;
						h.readWidth = function(q, u) {
							return null != q ? q : null == u.height && null != u.size ? u.size : void 0
						};
						h.readHeight = function(q, u) {
							return null != q ? q : null == u.width && null != u.size ? u.size : void 0
						};
						h.clone = function() {
							return new p({
								enabled: this.enabled,
								material: c.isSome(this.material) ? this.material.clone() : null,
								castShadows: this.castShadows,
								profile: this.profile,
								join: this.join,
								cap: this.cap,
								width: this.width,
								height: this.height,
								profileRotation: this.profileRotation,
								anchor: this.anchor
							})
						};
						return t
					}(g);
					b.__decorate([e.property({
						type: l.Symbol3DMaterial,
						json: {
							write: !0
						}
					})], d.prototype, "material", void 0);
					b.__decorate([e.property({
						type: Boolean,
						nonNullable: !0,
						json: {
							write: !0,
							default: !0
						}
					})], d.prototype, "castShadows", void 0);
					b.__decorate([v.enumeration({
						Path: "path"
					}, {
						readOnly: !0
					})], d.prototype, "type", void 0);
					b.__decorate([e.property({
						type: ["circle", "quad"],
						json: {
							write: !0,
							default: "circle"
						}
					})], d.prototype, "profile", void 0);
					b.__decorate([e.property({
						type: r.lineJoins,
						json: {
							write: !0,
							default: "miter"
						}
					})], d.prototype, "join", void 0);
					b.__decorate([e.property({
						type: r.pathCaps,
						json: {
							write: !0,
							default: "butt"
						}
					})], d.prototype, "cap", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: {
								enabled: !0,
								target: {
									width: {
										type: Number
									},
									size: {
										type: Number
									}
								}
							}
						}
					})], d.prototype, "width", void 0);
					b.__decorate([m.reader("width", ["width", "size", "height"])], d.prototype, "readWidth", null);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], d.prototype, "height", void 0);
					b.__decorate([m.reader("height", ["height", "size", "width"])], d.prototype, "readHeight", null);
					b.__decorate([e.property({
						type: ["center", "bottom", "top"],
						json: {
							write: !0,
							default: "center"
						}
					})], d.prototype, "anchor", void 0);
					b.__decorate([e.property({
						type: ["heading", "all"],
						json: {
							write: !0,
							default: "all"
						}
					})], d.prototype, "profileRotation", void 0);
					return d = p = b.__decorate([f.subclass("esri.symbols.PathSymbol3DLayer")], d)
				})
		},
		"esri/symbols/TextSymbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/maybe ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./Font ./Symbol3DLayer ./support/materialUtils ./support/Symbol3DHalo ./support/Symbol3DMaterial ./support/Symbol3DTextBackground ./support/textUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h) {
					var q;
					k = q = function(u) {
						function x(w) {
							w = u.call(this, w) || this;
							w._userSize = void 0;
							w.halo = null;
							w.horizontalAlignment = "center";
							w.lineHeight = 1;
							w.material = null;
							w.background = null;
							w.text = null;
							w.type = "text";
							w.verticalAlignment = "baseline";
							return w
						}
						a._inheritsLoose(x, u);
						var y = x.prototype;
						y.writeFont = function(w, A, B, E) {
							A.font = w.write({}, {
								...E,
								textSymbol3D: !0
							});
							delete A.font.size
						};
						y.clone = function() {
							const w = new q({
								enabled: this.enabled,
								font: this.font && c.clone(this.font),
								halo: this.halo &&
									c.clone(this.halo),
								horizontalAlignment: this.horizontalAlignment,
								lineHeight: this.lineHeight,
								material: e.isSome(this.material) ? this.material.clone() : null,
								text: this.text,
								verticalAlignment: this.verticalAlignment,
								background: c.clone(this.background)
							});
							w._userSize = this._userSize;
							return w
						};
						x.fromTextSymbol = function(w) {
							var A = q,
								B = e.isSome(w.font) ? w.font.clone() : new g;
							var E = w.haloColor;
							var z = w.haloSize;
							E = E && null != z && 0 < z ? new p.Symbol3DHalo({
								color: c.clone(E),
								size: z
							}) : null;
							return new A({
								font: B,
								halo: E,
								horizontalAlignment: w.horizontalAlignment,
								lineHeight: w.lineHeight,
								material: w.color ? new n.Symbol3DMaterial({
									color: w.color.clone()
								}) : null,
								text: w.text,
								verticalAlignment: w.verticalAlignment,
								background: w.backgroundColor ? new t.Symbol3DTextBackground({
									color: w.backgroundColor.clone()
								}) : null
							})
						};
						a._createClass(x, [{
							key: "font",
							get: function() {
								return this._get("font") || null
							},
							set: function(w) {
								e.isSome(w) && e.isSome(this._userSize) && (w.size = this._userSize);
								this._set("font", w)
							}
						}, {
							key: "size",
							get: function() {
								return e.isSome(this._userSize) ? this._userSize : e.isSome(this.font) &&
									null != this.font.size ? this.font.size : 9
							},
							set: function(w) {
								this._userSize = w;
								e.isSome(this.font) && (this.font.size = this._userSize);
								this.notifyChange("size")
							}
						}]);
						return x
					}(l);
					b.__decorate([d.property({
						type: g,
						json: {
							write: !0
						}
					})], k.prototype, "font", null);
					b.__decorate([f.writer("font")], k.prototype, "writeFont", null);
					b.__decorate([d.property({
						type: p.Symbol3DHalo,
						json: {
							write: !0
						}
					})], k.prototype, "halo", void 0);
					b.__decorate([d.property({
							...h.horizontalAlignmentProperty,
							json: {
								default: "center",
								write: !0
							}
						})], k.prototype,
						"horizontalAlignment", void 0);
					b.__decorate([d.property({
						...h.lineHeightProperty,
						json: {
							default: 1,
							write: !0
						}
					})], k.prototype, "lineHeight", void 0);
					b.__decorate([d.property({
						type: n.Symbol3DMaterial,
						json: {
							write: !0
						}
					})], k.prototype, "material", void 0);
					b.__decorate([d.property({
						type: t.Symbol3DTextBackground,
						json: {
							write: !0
						}
					})], k.prototype, "background", void 0);
					b.__decorate([d.property(r.screenSizeProperty)], k.prototype, "size", null);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "text", void 0);
					b.__decorate([v.enumeration({
						Text: "text"
					}, {
						readOnly: !0
					})], k.prototype, "type", void 0);
					b.__decorate([d.property({
						...h.verticalAlignmentProperty,
						json: {
							default: "baseline",
							write: !0
						}
					})], k.prototype, "verticalAlignment", void 0);
					return k = q = b.__decorate([m.subclass("esri.symbols.TextSymbol3DLayer")], k)
				})
		},
		"esri/symbols/support/Symbol3DHalo": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/JSONSupport ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./materialUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					a.Symbol3DHalo = l = function(r) {
						function p() {
							var n = r.apply(this, arguments) || this;
							n.color = new e([0, 0, 0, 1]);
							n.size = 0;
							return n
						}
						b._inheritsLoose(p, r);
						p.prototype.clone = function() {
							const n = {
								color: k.clone(this.color),
								size: this.size
							};
							return new l(n)
						};
						return p
					}(d.JSONSupport);
					c.__decorate([v.property(g.colorAndTransparencyProperty)], a.Symbol3DHalo.prototype, "color", void 0);
					c.__decorate([v.property(g.screenSizeProperty)], a.Symbol3DHalo.prototype, "size", void 0);
					a.Symbol3DHalo =
						l = c.__decorate([f.subclass("esri.symbols.support.Symbol3DHalo")], a.Symbol3DHalo);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/support/Symbol3DTextBackground": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./materialUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					a.Symbol3DTextBackground = function(l) {
						function r(p) {
							p = l.call(this, p) || this;
							p.color = null;
							return p
						}
						b._inheritsLoose(r, l);
						return r
					}(e.ClonableMixin(d.JSONSupport));
					c.__decorate([k.property(g.colorAndTransparencyProperty)], a.Symbol3DTextBackground.prototype, "color", void 0);
					a.Symbol3DTextBackground = c.__decorate([f.subclass("esri.symbols.support.Symbol3DTextBackground")], a.Symbol3DTextBackground);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/symbols/WaterSymbol3DLayer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./Symbol3DLayer".split(" "), function(a, b, c, e, d, k, v, m, f) {
				var g;
				f = g = function(r) {
					function p(n) {
						n = r.call(this, n) || this;
						n.color = l.clone();
						n.type = "water";
						n.waterbodySize = "medium";
						n.waveDirection = null;
						n.waveStrength =
							"moderate";
						return n
					}
					a._inheritsLoose(p, r);
					p.prototype.clone = function() {
						return new g({
							color: e.clone(this.color),
							waterbodySize: this.waterbodySize,
							waveDirection: this.waveDirection,
							waveStrength: this.waveStrength
						})
					};
					return p
				}(f);
				b.__decorate([d.property({
					type: c,
					nonNullable: !0,
					json: {
						type: [k.Integer],
						write: (r, p, n) => p[n] = r.toArray(c.AlphaMode.UNLESS_OPAQUE),
						default: () => l.clone(),
						defaultEquals: r => r.toCss(!0) === l.toCss(!0)
					}
				})], f.prototype, "color", void 0);
				b.__decorate([v.enumeration({
						Water: "water"
					}, {
						readOnly: !0
					})],
					f.prototype, "type", void 0);
				b.__decorate([d.property({
					type: ["small", "medium", "large"],
					json: {
						write: !0,
						default: "medium"
					}
				})], f.prototype, "waterbodySize", void 0);
				b.__decorate([d.property({
					type: Number,
					json: {
						write: !0,
						default: null
					}
				})], f.prototype, "waveDirection", void 0);
				b.__decorate([d.property({
					type: ["calm", "rippled", "slight", "moderate"],
					json: {
						write: !0,
						default: "moderate"
					}
				})], f.prototype, "waveStrength", void 0);
				f = g = b.__decorate([m.subclass("esri.symbols.WaterSymbol3DLayer")], f);
				const l = new c([0, 119, 190]);
				return f
			})
		},
		"esri/symbols/support/StyleOrigin": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../portal/Portal".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				c = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.name = null;
						r.styleUrl = null;
						r.styleName = null;
						r.portal = null;
						return r
					}
					a._inheritsLoose(l,
						g);
					l.prototype.clone = function() {
						return new f({
							name: this.name,
							styleUrl: this.styleUrl,
							styleName: this.styleName,
							portal: this.portal
						})
					};
					return l
				}(c);
				b.__decorate([e.property({
					type: String
				})], c.prototype, "name", void 0);
				b.__decorate([e.property({
					type: String
				})], c.prototype, "styleUrl", void 0);
				b.__decorate([e.property({
					type: String
				})], c.prototype, "styleName", void 0);
				b.__decorate([e.property({
					type: m
				})], c.prototype, "portal", void 0);
				return c = f = b.__decorate([v.subclass("esri.symbols.support.StyleOrigin")], c)
			})
		},
		"esri/symbols/support/Thumbnail": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				a.Thumbnail = f = function(g) {
					function l() {
						var r = g.apply(this, arguments) || this;
						r.url = "";
						return r
					}
					b._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							url: this.url
						})
					};
					return l
				}(e);
				c.__decorate([d.property({
					type: String
				})], a.Thumbnail.prototype, "url", void 0);
				a.Thumbnail = f = c.__decorate([m.subclass("esri.symbols.support.Thumbnail")], a.Thumbnail);
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/callouts/calloutUtils": function() {
			define(["exports", "../../core/maybe", "./Callout3D", "./LineCallout3D"], function(a, b, c, e) {
				function d(k) {
					if (!k) return !1;
					k = k.verticalOffset;
					return !k || 0 >= k.screenLength || b.isSome(k.maxWorldLength) &&
						0 >= k.maxWorldLength ? !1 : !0
				}
				a.calloutProperty = {
					types: {
						key: "type",
						base: c,
						typeMap: {
							line: e
						}
					},
					json: {
						write: !0
					}
				};
				a.hasCalloutSupport = function(k) {
					return "point-3d" === k.type || "label-3d" === k.type
				};
				a.hasVisibleCallout = function(k) {
					if (!k || !k.supportsCallout || !k.supportsCallout()) return !1;
					const v = k.callout;
					return v && v.visible ? d(k) ? !0 : !1 : !1
				};
				a.hasVisibleVerticalOffset = d;
				a.textSymbolLayerSupportsVerticalOffset = function(k) {
					return "center" === k.horizontalAlignment
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/callouts/Callout3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v) {
				c = function(m) {
					function f(g) {
						g = m.call(this, g) || this;
						g.visible = !0;
						return g
					}
					a._inheritsLoose(f, m);
					f.prototype.clone = function() {};
					return f
				}(c.JSONSupport);
				b.__decorate([e.property({
					type: ["line"],
					readOnly: !0,
					json: {
						read: !1,
						write: {
							ignoreOrigin: !0
						}
					}
				})], c.prototype, "type", void 0);
				b.__decorate([e.property({
					readOnly: !0
				})], c.prototype, "visible", void 0);
				return c = b.__decorate([v.subclass("esri.symbols.callouts.Callout3D")], c)
			})
		},
		"esri/symbols/callouts/LineCallout3D": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/lang ../../core/maybe ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./Callout3D ../../chunks/LineCallout3DBorder ../support/materialUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					var n;
					m = n = function(t) {
						function h(q) {
							q = t.call(this, q) || this;
							q.type = "line";
							q.color = new c([0, 0, 0, 1]);
							q.size = k.px2pt(1);
							q.border = null;
							return q
						}
						a._inheritsLoose(h, t);
						h.prototype.clone = function() {
							return new n({
								color: e.clone(this.color),
								size: this.size,
								border: e.clone(this.border)
							})
						};
						a._createClass(h, [{
							key: "visible",
							get: function() {
								return 0 < this.size && d.isSome(this.color) && 0 < this.color.a
							}
						}]);
						return h
					}(l);
					b.__decorate([f.enumeration({
							line: "line"
						}, {
							readOnly: !0
						})], m.prototype,
						"type", void 0);
					b.__decorate([v.property(p.colorAndTransparencyProperty)], m.prototype, "color", void 0);
					b.__decorate([v.property(p.screenSizeProperty)], m.prototype, "size", void 0);
					b.__decorate([v.property({
						type: r.LineCallout3DBorder$1,
						json: {
							write: !0
						}
					})], m.prototype, "border", void 0);
					b.__decorate([v.property({
						readOnly: !0
					})], m.prototype, "visible", null);
					return m = n = b.__decorate([g.subclass("esri.symbols.callouts.LineCallout3D")], m)
				})
		},
		"esri/chunks/LineCallout3DBorder": function() {
			define("exports ./_rollupPluginBabelHelpers ./tslib.es6 ../Color ../core/JSONSupport ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../symbols/support/materialUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					d = l = function(r) {
						function p() {
							var n = r.apply(this, arguments) || this;
							n.color = new e("white");
							return n
						}
						b._inheritsLoose(p, r);
						p.prototype.clone = function() {
							return new l({
								color: k.clone(this.color)
							})
						};
						return p
					}(d.JSONSupport);
					c.__decorate([v.property(g.colorAndTransparencyProperty)], d.prototype, "color", void 0);
					c = d = l = c.__decorate([f.subclass("esri.symbols.callouts.LineCallout3DBorder")], d);
					v = Object.freeze(Object.defineProperty({
						__proto__: null,
						default: c
					}, Symbol.toStringTag, {
						value: "Module"
					}));
					a.LineCallout3DBorder = v;
					a.LineCallout3DBorder$1 = c
				})
		},
		"esri/symbols/support/Symbol3DVerticalOffset": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./materialUtils".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				c = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.screenLength =
							0;
						r.minWorldLength = 0;
						r.maxWorldLength = null;
						return r
					}
					a._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							screenLength: this.screenLength,
							minWorldLength: this.minWorldLength,
							maxWorldLength: this.maxWorldLength
						})
					};
					return l
				}(c.JSONSupport);
				b.__decorate([e.property(m.screenSizeProperty)], c.prototype, "screenLength", void 0);
				b.__decorate([e.property({
					type: Number,
					nonNullable: !0,
					json: {
						write: !0,
						default: 0
					}
				})], c.prototype, "minWorldLength", void 0);
				b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})],
					c.prototype, "maxWorldLength", void 0);
				return c = f = b.__decorate([v.subclass("esri.symbols.support.Symbol3DVerticalOffset")], c)
			})
		},
		"esri/symbols/LineSymbol3D": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Collection ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./LineSymbol3DLayer ./PathSymbol3DLayer ./Symbol3D".split(" "), function(a,
				b, c, e, d, k, v, m, f, g, l) {
				var r;
				const p = c.ofType({
					base: null,
					key: "type",
					typeMap: {
						line: f,
						path: g
					}
				});
				c = c.ofType({
					base: null,
					key: "type",
					typeMap: {
						line: f,
						path: g
					}
				});
				l = r = function(n) {
					function t(h) {
						h = n.call(this, h) || this;
						h.symbolLayers = new p;
						h.type = "line-3d";
						return h
					}
					a._inheritsLoose(t, n);
					t.prototype.clone = function() {
						return new r({
							styleOrigin: e.clone(this.styleOrigin),
							symbolLayers: e.clone(this.symbolLayers),
							thumbnail: e.clone(this.thumbnail)
						})
					};
					t.fromSimpleLineSymbol = function(h) {
						return new r({
							symbolLayers: [f.fromSimpleLineSymbol(h)]
						})
					};
					return t
				}(l);
				b.__decorate([d.property({
					type: p,
					json: {
						type: c
					}
				})], l.prototype, "symbolLayers", void 0);
				b.__decorate([v.enumeration({
					LineSymbol3D: "line-3d"
				}, {
					readOnly: !0
				})], l.prototype, "type", void 0);
				return l = r = b.__decorate([m.subclass("esri.symbols.LineSymbol3D")], l)
			})
		},
		"esri/symbols/MarkerSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/screenUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./Symbol".split(" "),
				function(a, b, c, e, d, k, v, m) {
					d = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.angle = 0;
							l.type = null;
							l.xoffset = 0;
							l.yoffset = 0;
							l.size = 9;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.hash = function() {
							return `${this.type}.${this.angle}.${this.size}.${this.xoffset}.${this.yoffset}`
						};
						return g
					}(m);
					b.__decorate([e.property({
						type: Number,
						json: {
							read: f => f && -1 * f,
							write: (f, g) => g.angle = f && -1 * f
						}
					})], d.prototype, "angle", void 0);
					b.__decorate([e.property({
							type: ["simple-marker", "picture-marker"],
							readOnly: !0
						})], d.prototype, "type",
						void 0);
					b.__decorate([e.property({
						type: Number,
						cast: c.toPt,
						json: {
							write: !0
						}
					})], d.prototype, "xoffset", void 0);
					b.__decorate([e.property({
						type: Number,
						cast: c.toPt,
						json: {
							write: !0
						}
					})], d.prototype, "yoffset", void 0);
					b.__decorate([e.property({
						type: Number,
						cast: f => "auto" === f ? f : c.toPt(f),
						json: {
							write: !0
						}
					})], d.prototype, "size", void 0);
					return d = b.__decorate([v.subclass("esri.symbols.MarkerSymbol")], d)
				})
		},
		"esri/symbols/MeshSymbol3D": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Collection ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./FillSymbol3DLayer ./Symbol3D".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					const r = c.ofType({
						base: null,
						key: "type",
						typeMap: {
							fill: f
						}
					});
					c = l = function(p) {
						function n(t) {
							t = p.call(this, t) || this;
							t.symbolLayers = new r;
							t.type = "mesh-3d";
							return t
						}
						a._inheritsLoose(n, p);
						n.prototype.clone = function() {
							return new l({
								styleOrigin: e.clone(this.styleOrigin),
								symbolLayers: e.clone(this.symbolLayers),
								thumbnail: e.clone(this.thumbnail)
							})
						};
						n.fromSimpleFillSymbol = function(t) {
							return new l({
								symbolLayers: [f.fromSimpleFillSymbol(t)]
							})
						};
						return n
					}(g);
					b.__decorate([d.property({
							type: r
						})],
						c.prototype, "symbolLayers", void 0);
					b.__decorate([v.enumeration({
						MeshSymbol3D: "mesh-3d"
					}, {
						readOnly: !0
					})], c.prototype, "type", void 0);
					return c = l = b.__decorate([m.subclass("esri.symbols.MeshSymbol3D")], c)
				})
		},
		"esri/symbols/PictureFillSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/screenUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./FillSymbol ./support/urlUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					k = l = function(r) {
						function p(...t) {
							t = r.call(this, ...t) || this;
							t.type = "picture-fill";
							t.url = null;
							t.xscale = 1;
							t.yscale = 1;
							t.width = 12;
							t.height = 12;
							t.xoffset = 0;
							t.yoffset = 0;
							t.source = null;
							return t
						}
						a._inheritsLoose(p, r);
						var n = p.prototype;
						n.normalizeCtorArgs = function(t, h, q, u) {
							if (t && "string" !== typeof t && null == t.imageData) return t;
							const x = {};
							t && (x.url = t);
							h && (x.outline = h);
							null != q && (x.width = e.toPt(q));
							null != u && (x.height = e.toPt(u));
							return x
						};
						n.clone = function() {
							const t = new l({
								color: c.clone(this.color),
								height: this.height,
								outline: this.outline && this.outline.clone(),
								url: this.url,
								width: this.width,
								xoffset: this.xoffset,
								xscale: this.xscale,
								yoffset: this.yoffset,
								yscale: this.yscale
							});
							t._set("source", c.clone(this.source));
							return t
						};
						n.hash = function() {
							return `${r.prototype.hash.call(this)}.${this.color?.hash()}.${this.height}.${this.url}.${this.width}.${this.xoffset}.${this.xscale}.${this.yoffset}.${this.yscale}`
						};
						return p
					}(f);
					b.__decorate([v.enumeration({
							esriPFS: "picture-fill"
						}, {
							readOnly: !0
						})], k.prototype, "type",
						void 0);
					b.__decorate([d.property(g.urlPropertyDefinition)], k.prototype, "url", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "xscale", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "yscale", void 0);
					b.__decorate([d.property({
						type: Number,
						cast: e.toPt,
						json: {
							write: !0
						}
					})], k.prototype, "width", void 0);
					b.__decorate([d.property({
						type: Number,
						cast: e.toPt,
						json: {
							write: !0
						}
					})], k.prototype, "height", void 0);
					b.__decorate([d.property({
						type: Number,
						cast: e.toPt,
						json: {
							write: !0
						}
					})], k.prototype, "xoffset", void 0);
					b.__decorate([d.property({
						type: Number,
						cast: e.toPt,
						json: {
							write: !0
						}
					})], k.prototype, "yoffset", void 0);
					b.__decorate([d.property(g.sourcePropertyDefinition)], k.prototype, "source", void 0);
					return k = l = b.__decorate([m.subclass("esri.symbols.PictureFillSymbol")], k)
				})
		},
		"esri/symbols/support/urlUtils": function() {
			define(["exports", "../../core/urlUtils", "../../chunks/persistableUrlUtils"], function(a, b, c) {
				function e(m, f, g) {
					return f.imageData ? b.makeData({
						mediaType: f.contentType ||
							"image/png",
						isBase64: !0,
						data: f.imageData
					}) : d(f.url, g)
				}

				function d(m, f) {
					return null == f || "service" !== f.origin && "portal-item" !== f.origin || "feature" !== f.layer ? .type && "stream" !== f.layer ? .type || b.isAbsolute(m) || !f ? .layer ? .parsedUrl ? c.fromJSON(m, f) : b.join(f.layer.parsedUrl.path, "images", m)
				}

				function k(m, f, g, l) {
					if (b.isDataProtocol(m)) {
						if (m = b.dataComponents(m)) f.contentType = m.mediaType, f.imageData = m.data, g && g.imageData === f.imageData && g.url && c.write(g.url, f, "url", l)
					} else c.write(m, f, "url", l)
				}
				const v = {
					json: {
						read: {
							source: ["imageData",
								"url"
							],
							reader: e
						},
						write: {
							writer(m, f, g, l) {
								k(m, f, this.source, l)
							}
						}
					}
				};
				a.read = d;
				a.readImageDataOrUrl = e;
				a.sourcePropertyDefinition = {
					readOnly: !0,
					json: {
						read: {
							source: ["imageData", "url"],
							reader(m, f, g) {
								m = {};
								f.imageData && (m.imageData = f.imageData);
								f.contentType && (m.contentType = f.contentType);
								f.url && (m.url = d(f.url, g));
								return m
							}
						}
					}
				};
				a.urlPropertyDefinition = v;
				a.writeImageDataAndUrl = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/PictureMarkerSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/screenUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ./MarkerSymbol ./support/urlUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					k = r = function(p) {
						function n(...h) {
							h = p.call(this, ...h) || this;
							h.color = null;
							h.type = "picture-marker";
							h.url = null;
							h.source = null;
							h.height = 12;
							h.width = 12;
							h.size = null;
							return h
						}
						a._inheritsLoose(n, p);
						var t = n.prototype;
						t.normalizeCtorArgs = function(h, q, u) {
							if (h && "string" !== typeof h && null == h.imageData) return h;
							const x = {};
							h && (x.url = h);
							null != q && (x.width = e.toPt(q));
							null != u && (x.height = e.toPt(u));
							return x
						};
						t.readHeight = function(h, q) {
							return q.size || h
						};
						t.readWidth = function(h, q) {
							return q.size ||
								h
						};
						t.clone = function() {
							const h = new r({
								angle: this.angle,
								height: this.height,
								url: this.url,
								width: this.width,
								xoffset: this.xoffset,
								yoffset: this.yoffset
							});
							h._set("source", c.clone(this.source));
							return h
						};
						t.hash = function() {
							return `${p.prototype.hash.call(this)}.${this.height}.${this.url}.${this.width}`
						};
						return n
					}(g);
					b.__decorate([d.property({
						json: {
							write: !1
						}
					})], k.prototype, "color", void 0);
					b.__decorate([v.enumeration({
						esriPMS: "picture-marker"
					}, {
						readOnly: !0
					})], k.prototype, "type", void 0);
					b.__decorate([d.property(l.urlPropertyDefinition)],
						k.prototype, "url", void 0);
					b.__decorate([d.property(l.sourcePropertyDefinition)], k.prototype, "source", void 0);
					b.__decorate([d.property({
						type: Number,
						cast: e.toPt,
						json: {
							write: !0
						}
					})], k.prototype, "height", void 0);
					b.__decorate([m.reader("height", ["height", "size"])], k.prototype, "readHeight", null);
					b.__decorate([d.property({
						type: Number,
						cast: e.toPt,
						json: {
							write: !0
						}
					})], k.prototype, "width", void 0);
					b.__decorate([d.property({
						json: {
							write: !1
						}
					})], k.prototype, "size", void 0);
					return k = r = b.__decorate([f.subclass("esri.symbols.PictureMarkerSymbol")],
						k)
				})
		},
		"esri/symbols/PointSymbol3D": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Collection ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./IconSymbol3DLayer ./ObjectSymbol3DLayer ./Symbol3D ./TextSymbol3DLayer ./callouts/calloutUtils ./support/Symbol3DVerticalOffset".split(" "), function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
				var t;
				const h =
					c.ofType({
						base: null,
						key: "type",
						typeMap: {
							icon: f,
							object: g,
							text: r
						}
					});
				c = t = function(q) {
					function u(y) {
						y = q.call(this, y) || this;
						y.verticalOffset = null;
						y.callout = null;
						y.symbolLayers = new h;
						y.type = "point-3d";
						return y
					}
					a._inheritsLoose(u, q);
					var x = u.prototype;
					x.supportsCallout = function() {
						if (1 > (this.symbolLayers ? this.symbolLayers.length : 0)) return !1;
						for (const y of this.symbolLayers.items) switch (y.type) {
							case "icon":
							case "text":
							case "object":
								continue;
							default:
								return !1
						}
						return !0
					};
					x.hasVisibleCallout = function() {
						return p.hasVisibleCallout(this)
					};
					x.hasVisibleVerticalOffset = function() {
						return p.hasVisibleVerticalOffset(this)
					};
					x.clone = function() {
						return new t({
							verticalOffset: e.clone(this.verticalOffset),
							callout: e.clone(this.callout),
							styleOrigin: e.clone(this.styleOrigin),
							symbolLayers: e.clone(this.symbolLayers),
							thumbnail: e.clone(this.thumbnail)
						})
					};
					u.fromSimpleMarkerSymbol = function(y) {
						return new t({
							symbolLayers: [f.fromSimpleMarkerSymbol(y)]
						})
					};
					u.fromPictureMarkerSymbol = function(y) {
						return new t({
							symbolLayers: [f.fromPictureMarkerSymbol(y)]
						})
					};
					u.fromCIMSymbol =
						function(y) {
							return "CIMPointSymbol" !== y.data ? .symbol ? .type ? null : y.data.symbol ? .callout ? new t({
								symbolLayers: [f.fromCIMSymbol(y)],
								callout: {
									type: "line",
									size: .5,
									color: [0, 0, 0]
								},
								verticalOffset: {
									screenLength: 40
								}
							}) : new t({
								symbolLayers: [f.fromCIMSymbol(y)]
							})
						};
					u.fromTextSymbol = function(y) {
						return new t({
							symbolLayers: [r.fromTextSymbol(y)]
						})
					};
					return u
				}(l);
				b.__decorate([d.property({
					type: n,
					json: {
						write: !0
					}
				})], c.prototype, "verticalOffset", void 0);
				b.__decorate([d.property(p.calloutProperty)], c.prototype, "callout", void 0);
				b.__decorate([d.property({
					type: h,
					json: {
						origins: {
							"web-scene": {
								write: !0
							}
						}
					}
				})], c.prototype, "symbolLayers", void 0);
				b.__decorate([v.enumeration({
					PointSymbol3D: "point-3d"
				}, {
					readOnly: !0
				})], c.prototype, "type", void 0);
				return c = t = b.__decorate([m.subclass("esri.symbols.PointSymbol3D")], c)
			})
		},
		"esri/symbols/PolygonSymbol3D": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Collection ../core/lang ../core/maybe ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./ExtrudeSymbol3DLayer ./FillSymbol3DLayer ./IconSymbol3DLayer ./LineSymbol3DLayer ./ObjectSymbol3DLayer ./Symbol3D ./TextSymbol3DLayer ./WaterSymbol3DLayer".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q) {
					var u;
					const x = c.ofType({
						base: null,
						key: "type",
						typeMap: {
							extrude: g,
							fill: l,
							icon: r,
							line: p,
							object: n,
							text: h,
							water: q
						}
					});
					c = u = function(y) {
						function w(A) {
							A = y.call(this, A) || this;
							A.symbolLayers = new x;
							A.type = "polygon-3d";
							return A
						}
						a._inheritsLoose(w, y);
						w.prototype.clone = function() {
							return new u({
								styleOrigin: e.clone(this.styleOrigin),
								symbolLayers: e.clone(this.symbolLayers),
								thumbnail: e.clone(this.thumbnail)
							})
						};
						w.fromJSON = function(A) {
							const B = new u;
							B.read(A);
							if (2 === B.symbolLayers.length &&
								"fill" === B.symbolLayers.getItemAt(0)
								.type && "line" === B.symbolLayers.getItemAt(1)
								.type) {
								const E = B.symbolLayers.getItemAt(0),
									z = B.symbolLayers.getItemAt(1);
								!z.enabled || A.symbolLayers && A.symbolLayers[1] && !1 === A.symbolLayers[1].enable || (E.outline = {
									size: z.size,
									color: d.isSome(z.material) ? z.material.color : null
								});
								B.symbolLayers.removeAt(1)
							}
							return B
						};
						w.fromSimpleFillSymbol = function(A) {
							return new u({
								symbolLayers: [l.fromSimpleFillSymbol(A)]
							})
						};
						return w
					}(t);
					b.__decorate([k.property({
							type: x,
							json: {
								write: !0
							}
						})], c.prototype,
						"symbolLayers", void 0);
					b.__decorate([m.enumeration({
						PolygonSymbol3D: "polygon-3d"
					}, {
						readOnly: !0
					})], c.prototype, "type", void 0);
					return c = u = b.__decorate([f.subclass("esri.symbols.PolygonSymbol3D")], c)
				})
		},
		"esri/symbols/SimpleFillSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../core/jsonMap ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./FillSymbol ./SimpleLineSymbol".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					e = new e.JSONMap({
						esriSFSSolid: "solid",
						esriSFSNull: "none",
						esriSFSHorizontal: "horizontal",
						esriSFSVertical: "vertical",
						esriSFSForwardDiagonal: "forward-diagonal",
						esriSFSBackwardDiagonal: "backward-diagonal",
						esriSFSCross: "cross",
						esriSFSDiagonalCross: "diagonal-cross"
					});
					g = r = function(p) {
						function n(...h) {
							h = p.call(this, ...h) || this;
							h.color = new c([0, 0, 0, .25]);
							h.outline = new l;
							h.type = "simple-fill";
							h.style = "solid";
							return h
						}
						a._inheritsLoose(n, p);
						var t = n.prototype;
						t.normalizeCtorArgs =
							function(h, q, u) {
								if (h && "string" !== typeof h) return h;
								const x = {};
								h && (x.style = h);
								q && (x.outline = q);
								u && (x.color = u);
								return x
							};
						t.clone = function() {
							return new r({
								color: d.clone(this.color),
								outline: this.outline && this.outline.clone(),
								style: this.style
							})
						};
						t.hash = function() {
							return `${p.prototype.hash.call(this)}${this.style}.${this.color&&this.color.hash()}`
						};
						return n
					}(g);
					b.__decorate([k.property()], g.prototype, "color", void 0);
					b.__decorate([k.property()], g.prototype, "outline", void 0);
					b.__decorate([m.enumeration({
						esriSFS: "simple-fill"
					}, {
						readOnly: !0
					})], g.prototype, "type", void 0);
					b.__decorate([k.property({
						type: e.apiValues,
						json: {
							read: e.read,
							write: e.write
						}
					})], g.prototype, "style", void 0);
					return g = r = b.__decorate([f.subclass("esri.symbols.SimpleFillSymbol")], g)
				})
		},
		"esri/symbols/SimpleMarkerSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../core/jsonMap ../core/lang ../core/screenUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./MarkerSymbol ./SimpleLineSymbol".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					var n;
					e = new e.JSONMap({
						esriSMSCircle: "circle",
						esriSMSSquare: "square",
						esriSMSCross: "cross",
						esriSMSX: "x",
						esriSMSDiamond: "diamond",
						esriSMSTriangle: "triangle",
						esriSMSPath: "path"
					});
					r = n = function(t) {
						function h(...u) {
							u = t.call(this, ...u) || this;
							u.color = new c([255, 255, 255, .25]);
							u.type = "simple-marker";
							u.size = 12;
							u.style = "circle";
							u.outline = new p;
							return u
						}
						a._inheritsLoose(h, t);
						var q = h.prototype;
						q.normalizeCtorArgs = function(u, x, y, w) {
							if (u && "string" !== typeof u) return u;
							const A = {};
							u && (A.style = u);
							null != x && (A.size = k.toPt(x));
							y && (A.outline = y);
							w && (A.color = w);
							return A
						};
						q.writeColor = function(u, x) {
							u && "x" !== this.style && "cross" !== this.style && (x.color = u.toJSON());
							null === u && (x.color = null)
						};
						q.clone = function() {
							return new n({
								angle: this.angle,
								color: d.clone(this.color),
								outline: this.outline && this.outline.clone(),
								path: this.path,
								size: this.size,
								style: this.style,
								xoffset: this.xoffset,
								yoffset: this.yoffset
							})
						};
						q.hash = function() {
							return `${t.prototype.hash.call(this)}.${this.color&&this.color.hash()}.${this.path}.${this.style}.${this.outline?.hash()}`
						};
						a._createClass(h, [{
							key: "path",
							set: function(u) {
								this.style = "path";
								this._set("path", u)
							}
						}]);
						return h
					}(r);
					b.__decorate([v.property()], r.prototype, "color", void 0);
					b.__decorate([l.writer("color")], r.prototype, "writeColor", null);
					b.__decorate([f.enumeration({
						esriSMS: "simple-marker"
					}, {
						readOnly: !0
					})], r.prototype, "type", void 0);
					b.__decorate([v.property()], r.prototype, "size", void 0);
					b.__decorate([v.property({
						type: e.apiValues,
						json: {
							read: e.read,
							write: e.write
						}
					})], r.prototype, "style", void 0);
					b.__decorate([v.property({
						type: String,
						json: {
							write: !0
						}
					})], r.prototype, "path", null);
					b.__decorate([v.property({
						types: {
							key: "type",
							base: null,
							defaultKeyValue: "simple-line",
							typeMap: {
								"simple-line": p
							}
						},
						json: {
							default: null,
							write: !0
						}
					})], r.prototype, "outline", void 0);
					return r = n = b.__decorate([g.subclass("esri.symbols.SimpleMarkerSymbol")], r)
				})
		},
		"esri/symbols/TextSymbol": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../core/lang ../core/screenUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./Font ./Symbol ./support/textUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					var n;
					r = n = function(t) {
						function h(...u) {
							u = t.call(this, ...u) || this;
							u.backgroundColor = null;
							u.borderLineColor = null;
							u.borderLineSize = null;
							u.font = new l;
							u.horizontalAlignment = "center";
							u.kerning = !0;
							u.haloColor = null;
							u.haloSize = null;
							u.rightToLeft = null;
							u.rotated = !1;
							u.text = "";
							u.type = "text";
							u.verticalAlignment = "baseline";
							u.xoffset = 0;
							u.yoffset = 0;
							u.angle = 0;
							u.width = null;
							u.lineWidth = 192;
							u.lineHeight = 1;
							return u
						}
						a._inheritsLoose(h, t);
						var q = h.prototype;
						q.normalizeCtorArgs = function(u,
							x, y) {
							if (u && "string" !== typeof u) return u;
							const w = {};
							u && (w.text = u);
							x && (w.font = x);
							y && (w.color = y);
							return w
						};
						q.writeLineWidth = function(u, x, y, w) {
							w && "string" !== typeof w || (x[y] = u)
						};
						q.castLineWidth = function(u) {
							return d.toPt(u)
						};
						q.writeLineHeight = function(u, x, y, w) {
							w && "string" !== typeof w || (x[y] = u)
						};
						q.clone = function() {
							return new n({
								angle: this.angle,
								backgroundColor: e.clone(this.backgroundColor),
								borderLineColor: e.clone(this.borderLineColor),
								borderLineSize: this.borderLineSize,
								color: e.clone(this.color),
								font: this.font &&
									this.font.clone(),
								haloColor: e.clone(this.haloColor),
								haloSize: this.haloSize,
								horizontalAlignment: this.horizontalAlignment,
								kerning: this.kerning,
								lineHeight: this.lineHeight,
								lineWidth: this.lineWidth,
								rightToLeft: this.rightToLeft,
								rotated: this.rotated,
								text: this.text,
								verticalAlignment: this.verticalAlignment,
								width: this.width,
								xoffset: this.xoffset,
								yoffset: this.yoffset
							})
						};
						q.hash = function() {
							return `${this.backgroundColor&&this.backgroundColor.hash()}.${this.borderLineColor}.${this.borderLineSize}.${this.color?.hash()}.${this.font&&
this.font.hash()}.${this.haloColor&&this.haloColor.hash()}.${this.haloSize}.${this.horizontalAlignment}.${this.kerning}.${this.rightToLeft}.${this.rotated}.${this.text}.${this.verticalAlignment}.${this.width}.${this.xoffset}.${this.yoffset}.${this.lineHeight}.${this.lineWidth}.${this.angle}`
						};
						return h
					}(r);
					b.__decorate([k.property({
						type: c,
						json: {
							write: !0
						}
					})], r.prototype, "backgroundColor", void 0);
					b.__decorate([k.property({
						type: c,
						json: {
							write: !0
						}
					})], r.prototype, "borderLineColor", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0
						}
					})], r.prototype, "borderLineSize", void 0);
					b.__decorate([k.property({
						type: l,
						json: {
							write: !0
						}
					})], r.prototype, "font", void 0);
					b.__decorate([k.property({
						...p.horizontalAlignmentProperty,
						json: {
							write: !0
						}
					})], r.prototype, "horizontalAlignment", void 0);
					b.__decorate([k.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], r.prototype, "kerning", void 0);
					b.__decorate([k.property({
						type: c,
						json: {
							write: !0
						}
					})], r.prototype, "haloColor", void 0);
					b.__decorate([k.property({
							type: Number,
							cast: d.toPt,
							json: {
								write: !0
							}
						})], r.prototype,
						"haloSize", void 0);
					b.__decorate([k.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], r.prototype, "rightToLeft", void 0);
					b.__decorate([k.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], r.prototype, "rotated", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], r.prototype, "text", void 0);
					b.__decorate([m.enumeration({
						esriTS: "text"
					}, {
						readOnly: !0
					})], r.prototype, "type", void 0);
					b.__decorate([k.property({
						...p.verticalAlignmentProperty,
						json: {
							write: !0
						}
					})], r.prototype, "verticalAlignment", void 0);
					b.__decorate([k.property({
						type: Number,
						cast: d.toPt,
						json: {
							write: !0
						}
					})], r.prototype, "xoffset", void 0);
					b.__decorate([k.property({
						type: Number,
						cast: d.toPt,
						json: {
							write: !0
						}
					})], r.prototype, "yoffset", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							read: t => t && -1 * t,
							write: (t, h) => h.angle = t && -1 * t
						}
					})], r.prototype, "angle", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0
						}
					})], r.prototype, "width", void 0);
					b.__decorate([k.property({
						type: Number
					})], r.prototype, "lineWidth", void 0);
					b.__decorate([g.writer("lineWidth")], r.prototype, "writeLineWidth",
						null);
					b.__decorate([v.cast("lineWidth")], r.prototype, "castLineWidth", null);
					b.__decorate([k.property(p.lineHeightProperty)], r.prototype, "lineHeight", void 0);
					b.__decorate([g.writer("lineHeight")], r.prototype, "writeLineHeight", null);
					return r = n = b.__decorate([f.subclass("esri.symbols.TextSymbol")], r)
				})
		},
		"esri/symbols/WebStyleSymbol": function() {
			define("require ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Logger ../core/maybe ../core/promiseUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ../portal/Portal ../chunks/persistableUrlUtils ./Symbol ./support/Thumbnail".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					function h() {
						return new Promise((u, x) => a(["./support/webStyleSymbolUtils"], u, x))
					}
					var q;
					m = q = function(u) {
						function x(w) {
							w = u.call(this, w) || this;
							w.styleName = null;
							w.portal = null;
							w.styleUrl = null;
							w.thumbnail = null;
							w.name = null;
							w.type = "web-style";
							return w
						}
						b._inheritsLoose(x, u);
						var y = x.prototype;
						y.read = function(w, A) {
							this.portal = A ? A.portal : void 0;
							u.prototype.read.call(this, w, A)
						};
						y.clone = function() {
							return new q({
								name: this.name,
								styleUrl: this.styleUrl,
								styleName: this.styleName,
								portal: this.portal
							})
						};
						y.fetchSymbol = function(w) {
							return this._fetchSymbol("webRef", w)
						};
						y.fetchCIMSymbol = function(w) {
							return this._fetchSymbol("cimRef", w)
						};
						y._fetchSymbol = function() {
							var w = b._asyncToGenerator(function*(A, B) {
								const E = d.isSome(B) ? B.cache : null,
									z = E ? this._fetchCacheKey : null;
								if (d.isSome(E)) {
									var C = z && E.get(z);
									if (C) return C.clone()
								}
								C = yield h();
								k.throwIfAborted(B);
								B = C.resolveWebStyleSymbol(this, {
									portal: this.portal
								}, A, B);
								B.catch(D => {
									e.getLogger(this.declaredClass)
										.error("#fetchSymbol()", "Failed to create symbol from style",
											D)
								});
								B = yield B;
								if (!("webRef" === A && "point-3d" === B.type || "cimRef" === A && "cim" === B.type)) return null;
								d.isSome(E) && E.set(z, B.clone());
								return B
							});
							return function(A, B) {
								return w.apply(this, arguments)
							}
						}();
						b._createClass(x, [{
							key: "_fetchCacheKey",
							get: function() {
								const w = d.isSome(this.portal) ? this.portal : r.getDefault();
								return `${this.styleName}:${this.styleUrl}:${this.name}:${w.user?w.user.username:null}:${w.url}`
							}
						}]);
						return x
					}(n);
					c.__decorate([v.property({
						json: {
							write: !1
						}
					})], m.prototype, "color", void 0);
					c.__decorate([v.property({
						type: String,
						json: {
							write: !0
						}
					})], m.prototype, "styleName", void 0);
					c.__decorate([v.property({
						type: r,
						json: {
							write: !1
						}
					})], m.prototype, "portal", void 0);
					c.__decorate([v.property({
						type: String,
						json: {
							read: p.read,
							write: p.write
						}
					})], m.prototype, "styleUrl", void 0);
					c.__decorate([v.property({
						type: t.Thumbnail,
						json: {
							read: !1
						}
					})], m.prototype, "thumbnail", void 0);
					c.__decorate([v.property({
						type: String,
						json: {
							write: !0
						}
					})], m.prototype, "name", void 0);
					c.__decorate([g.enumeration({
							styleSymbolReference: "web-style"
						}, {
							readOnly: !0
						})], m.prototype,
						"type", void 0);
					c.__decorate([v.property()], m.prototype, "_fetchCacheKey", null);
					return m = q = c.__decorate([l.subclass("esri.symbols.WebStyleSymbol")], m)
				})
		},
		"esri/renderers/Renderer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/jsonMap ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./support/AuthoringInfo".split(" "), function(a, b, c, e, d, k, v, m, f) {
				c = new c.JSONMap({
					simple: "simple",
					uniqueValue: "unique-value",
					classBreaks: "class-breaks",
					heatmap: "heatmap",
					dotDensity: "dot-density",
					dictionary: "dictionary",
					pieChart: "pie-chart"
				}, {
					ignoreUnknown: !0
				});
				e = function(g) {
					function l(p) {
						p = g.call(this, p) || this;
						p.authoringInfo = null;
						p.type = null;
						return p
					}
					a._inheritsLoose(l, g);
					var r = l.prototype;
					r.getRequiredFields = function() {
						var p = a._asyncToGenerator(function*(n) {
							if (!this.collectRequiredFields) return [];
							const t = new Set;
							yield this.collectRequiredFields(t, n);
							return Array.from(t)
								.sort()
						});
						return function(n) {
							return p.apply(this,
								arguments)
						}
					}();
					r.getSymbol = function(p, n) {};
					r.getSymbolAsync = function() {
						var p = a._asyncToGenerator(function*(n, t) {});
						return function(n, t) {
							return p.apply(this, arguments)
						}
					}();
					r.getSymbols = function() {
						return []
					};
					r.getAttributeHash = function() {
						return JSON.stringify(this)
					};
					r.getMeshHash = function() {
						return JSON.stringify(this)
					};
					return l
				}(e.JSONSupport);
				b.__decorate([d.property({
					type: f,
					json: {
						write: !0
					}
				})], e.prototype, "authoringInfo", void 0);
				b.__decorate([d.property({
					type: c.apiValues,
					readOnly: !0,
					json: {
						type: c.jsonValues,
						read: !1,
						write: {
							writer: c.write,
							ignoreOrigin: !0
						}
					}
				})], e.prototype, "type", void 0);
				return e = b.__decorate([m.subclass("esri.renderers.Renderer")], e)
			})
		},
		"esri/renderers/support/AuthoringInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ./AuthoringInfoFieldInfo ./AuthoringInfoVisualVariable ../../rest/support/colorRamps".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					const n = new c.JSONMap({
							esriClassifyDefinedInterval: "defined-interval",
							esriClassifyEqualInterval: "equal-interval",
							esriClassifyManual: "manual",
							esriClassifyNaturalBreaks: "natural-breaks",
							esriClassifyQuantile: "quantile",
							esriClassifyStandardDeviation: "standard-deviation"
						}),
						t = new c.JSONMap({
							pieChart: "pie-chart",
							classedSize: "class-breaks-size",
							classedColor: "class-breaks-color",
							univariateColorSize: "univariate-color-size",
							relationship: "relationship",
							predominance: "predominance",
							dotDensity: "dot-density",
							flow: "flow"
						});
					c = new c.JSONMap({
						classedSize: "class-breaks-size",
						classedColor: "class-breaks-color",
						univariateColorSize: "univariate-color-size",
						relationship: "relationship",
						predominance: "predominance",
						dotDensity: "dot-density"
					});
					const h = "inches feet yards miles nautical-miles millimeters centimeters decimeters meters kilometers decimal-degrees".split(" ");
					e = p = function(q) {
						function u(y) {
							y = q.call(this, y) || this;
							y.colorRamp = null;
							y.fadeRatio = null;
							y.isAutoGenerated = !1;
							y.lengthUnit = null;
							y.maxSliderValue = null;
							y.minSliderValue = null;
							y.visualVariables = null;
							return y
						}
						a._inheritsLoose(u, q);
						var x = u.prototype;
						x.readColorRamp = function(y) {
							return y ? r.fromJSON(y) : void 0
						};
						x.clone = function() {
							return new p({
								classificationMethod: this.classificationMethod,
								colorRamp: d.clone(this.colorRamp),
								fadeRatio: d.clone(this.fadeRatio),
								fields: this.fields && this.fields.slice(0),
								field1: d.clone(this.field1),
								field2: d.clone(this.field2),
								isAutoGenerated: this.isAutoGenerated,
								focus: this.focus,
								numClasses: this.numClasses,
								maxSliderValue: this.maxSliderValue,
								minSliderValue: this.minSliderValue,
								lengthUnit: this.lengthUnit,
								statistics: this.statistics,
								standardDeviationInterval: this.standardDeviationInterval,
								type: this.type,
								visualVariables: this.visualVariables && this.visualVariables.map(y => y.clone()),
								univariateSymbolStyle: this.univariateSymbolStyle,
								univariateTheme: this.univariateTheme,
								flowTheme: this.flowTheme
							})
						};
						a._createClass(u, [{
								key: "classificationMethod",
								get: function() {
									const y = this._get("classificationMethod"),
										w = this.type;
									return w && "relationship" !== w ? "class-breaks-size" === w || "class-breaks-color" === w ? y || "manual" : null : y
								},
								set: function(y) {
									this._set("classificationMethod", y)
								}
							}, {
								key: "fields",
								get: function() {
									return this.type && "predominance" !== this.type ? null : this._get("fields")
								},
								set: function(y) {
									this._set("fields", y)
								}
							}, {
								key: "field1",
								get: function() {
									return this.type && "relationship" !== this.type ? null : this._get("field1")
								},
								set: function(y) {
									this._set("field1", y)
								}
							}, {
								key: "field2",
								get: function() {
									return this.type && "relationship" !== this.type ?
										null : this._get("field2")
								},
								set: function(y) {
									this._set("field2", y)
								}
							}, {
								key: "flowTheme",
								get: function() {
									return "flow" === this.type ? this._get("flowTheme") : null
								},
								set: function(y) {
									this._set("flowTheme", y)
								}
							}, {
								key: "focus",
								get: function() {
									return this.type && "relationship" !== this.type ? null : this._get("focus")
								},
								set: function(y) {
									this._set("focus", y)
								}
							}, {
								key: "numClasses",
								get: function() {
									return this.type && "relationship" !== this.type ? null : this._get("numClasses")
								},
								set: function(y) {
									this._set("numClasses", y)
								}
							}, {
								key: "statistics",
								get: function() {
									return "univariate-color-size" === this.type && "above-and-below" === this.univariateTheme ? this._get("statistics") : null
								},
								set: function(y) {
									this._set("statistics", y)
								}
							}, {
								key: "standardDeviationInterval",
								get: function() {
									const y = this.type;
									return y && "relationship" !== y && "class-breaks-size" !== y && "class-breaks-color" !== y ? null : this.classificationMethod && "standard-deviation" !== this.classificationMethod ? null : this._get("standardDeviationInterval")
								},
								set: function(y) {
									this._set("standardDeviationInterval", y)
								}
							},
							{
								key: "type",
								get: function() {
									return this._get("type")
								},
								set: function(y) {
									let w = y;
									"classed-size" === y ? w = "class-breaks-size" : "classed-color" === y && (w = "class-breaks-color");
									this._set("type", w)
								}
							}, {
								key: "univariateSymbolStyle",
								get: function() {
									return "univariate-color-size" === this.type && "above-and-below" === this.univariateTheme ? this._get("univariateSymbolStyle") : null
								},
								set: function(y) {
									this._set("univariateSymbolStyle", y)
								}
							}, {
								key: "univariateTheme",
								get: function() {
									return "univariate-color-size" === this.type ? this._get("univariateTheme") :
										null
								},
								set: function(y) {
									this._set("univariateTheme", y)
								}
							}
						]);
						return u
					}(e.JSONSupport);
					b.__decorate([k.property({
						type: n.apiValues,
						value: null,
						json: {
							type: n.jsonValues,
							read: n.read,
							write: n.write,
							origins: {
								"web-document": {
									default: "manual",
									type: n.jsonValues,
									read: n.read,
									write: n.write
								}
							}
						}
					})], e.prototype, "classificationMethod", null);
					b.__decorate([k.property({
						types: r.types,
						json: {
							write: !0
						}
					})], e.prototype, "colorRamp", void 0);
					b.__decorate([m.reader("colorRamp")], e.prototype, "readColorRamp", null);
					b.__decorate([k.property({
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1,
									read: !1
								}
							}
						}
					})], e.prototype, "fadeRatio", void 0);
					b.__decorate([k.property({
						type: [String],
						value: null,
						json: {
							write: !0
						}
					})], e.prototype, "fields", null);
					b.__decorate([k.property({
						type: g.AuthoringInfoFieldInfo,
						value: null,
						json: {
							write: !0
						}
					})], e.prototype, "field1", null);
					b.__decorate([k.property({
						type: g.AuthoringInfoFieldInfo,
						value: null,
						json: {
							write: !0
						}
					})], e.prototype, "field2", null);
					b.__decorate([k.property({
							type: ["flow-line", "wave-front"],
							value: null,
							json: {
								write: !0,
								origins: {
									"web-scene": {
										write: !1
									}
								}
							}
						})],
						e.prototype, "flowTheme", null);
					b.__decorate([k.property({
						type: ["HH", "HL", "LH", "LL"],
						value: null,
						json: {
							write: !0
						}
					})], e.prototype, "focus", null);
					b.__decorate([k.property({
						type: Boolean,
						json: {
							write: !0,
							default: !1,
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], e.prototype, "isAutoGenerated", void 0);
					b.__decorate([k.property({
						type: Number,
						value: null,
						json: {
							type: v.Integer,
							write: !0
						}
					})], e.prototype, "numClasses", null);
					b.__decorate([k.property({
							type: h,
							json: {
								type: h,
								read: !1,
								write: !1,
								origins: {
									"web-scene": {
										read: !0,
										write: !0
									}
								}
							}
						})],
						e.prototype, "lengthUnit", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1,
									read: !1
								}
							}
						}
					})], e.prototype, "maxSliderValue", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1,
									read: !1
								}
							}
						}
					})], e.prototype, "minSliderValue", void 0);
					b.__decorate([k.property({
						type: Object,
						value: null,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1,
									read: !1
								}
							}
						}
					})], e.prototype, "statistics", null);
					b.__decorate([k.property({
						type: [.25, .33, .5, 1],
						value: null,
						json: {
							type: [.25,
								.33, .5, 1
							],
							write: !0
						}
					})], e.prototype, "standardDeviationInterval", null);
					b.__decorate([k.property({
						type: t.apiValues,
						value: null,
						json: {
							type: t.jsonValues,
							read: t.read,
							write: t.write,
							origins: {
								"web-scene": {
									type: c.jsonValues,
									write: {
										writer: c.write,
										overridePolicy(q) {
											return {
												enabled: "flow" !== q
											}
										}
									}
								}
							}
						}
					})], e.prototype, "type", null);
					b.__decorate([k.property({
						type: [l],
						json: {
							write: !0
						}
					})], e.prototype, "visualVariables", void 0);
					b.__decorate([k.property({
						type: "caret circle-caret arrow circle-arrow plus-minus circle-plus-minus square circle triangle happy-sad thumb custom".split(" "),
						value: null,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], e.prototype, "univariateSymbolStyle", null);
					b.__decorate([k.property({
						type: ["high-to-low", "above-and-below", "above", "below", "90-10"],
						value: null,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], e.prototype, "univariateTheme", null);
					return e = p = b.__decorate([f.subclass("esri.renderers.support.AuthoringInfo")], e)
				})
		},
		"esri/renderers/support/AuthoringInfoFieldInfo": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./AuthoringInfoClassBreakInfo".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					a.AuthoringInfoFieldInfo = g = function(l) {
						function r(p) {
							p = l.call(this, p) || this;
							p.field = "";
							p.normalizationField = "";
							p.label = "";
							p.classBreakInfos = [];
							return p
						}
						b._inheritsLoose(r, l);
						r.prototype.clone = function() {
							return new g({
								field: this.field,
								normalizationField: this.normalizationField,
								label: this.label,
								classBreakInfos: d.clone(this.classBreakInfos)
							})
						};
						return r
					}(e.JSONSupport);
					c.__decorate([k.property({
							type: String,
							json: {
								write: !0
							}
						})], a.AuthoringInfoFieldInfo.prototype, "field",
						void 0);
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.AuthoringInfoFieldInfo.prototype, "normalizationField", void 0);
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.AuthoringInfoFieldInfo.prototype, "label", void 0);
					c.__decorate([k.property({
						type: [f.AuthoringInfoClassBreakInfo],
						json: {
							write: !0
						}
					})], a.AuthoringInfoFieldInfo.prototype, "classBreakInfos", void 0);
					a.AuthoringInfoFieldInfo = g = c.__decorate([m.subclass("esri.renderers.support.AuthoringInfoFieldInfo")], a.AuthoringInfoFieldInfo);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/support/AuthoringInfoClassBreakInfo": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				a.AuthoringInfoClassBreakInfo = f = function(g) {
					function l(r) {
						r =
							g.call(this, r) || this;
						r.minValue = 0;
						r.maxValue = 0;
						return r
					}
					b._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							minValue: this.minValue,
							maxValue: this.maxValue
						})
					};
					return l
				}(e.JSONSupport);
				c.__decorate([d.property({
					type: Number,
					json: {
						write: !0
					}
				})], a.AuthoringInfoClassBreakInfo.prototype, "minValue", void 0);
				c.__decorate([d.property({
					type: Number,
					json: {
						write: !0
					}
				})], a.AuthoringInfoClassBreakInfo.prototype, "maxValue", void 0);
				a.AuthoringInfoClassBreakInfo = f = c.__decorate([m.subclass("esri.renderer.support.AuthoringInfoClassBreakInfo")],
					a.AuthoringInfoClassBreakInfo);
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/renderers/support/AuthoringInfoVisualVariable": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				k = new c.JSONMap({
					percentTotal: "percent-of-total",
					ratio: "ratio",
					percent: "percent"
				});
				c = new c.JSONMap({
					sizeInfo: "size",
					colorInfo: "color",
					transparencyInfo: "opacity",
					rotationInfo: "rotation"
				});
				const g = {
						key(n) {
							return "number" === typeof n ? "number" : "string"
						},
						typeMap: {
							number: Number,
							string: String
						},
						base: null
					},
					l = ["high-to-low", "above-and-below", "centered-on", "extremes"],
					r = [...(new Set("high-to-low above-and-below centered-on extremes 90-10 above below high-to-low above-and-below 90-10 above below".split(" ")))],
					p = "seconds minutes hours days months years".split(" ");
				e = f = function(n) {
					function t(q) {
						q = n.call(this, q) || this;
						q.endTime = null;
						q.field = null;
						q.maxSliderValue = null;
						q.minSliderValue = null;
						q.startTime = null;
						q.type = null;
						q.units = null;
						return q
					}
					a._inheritsLoose(t, n);
					var h = t.prototype;
					h.castEndTime = function(q) {
						return "string" === typeof q || "number" === typeof q ? q : null
					};
					h.castStartTime = function(q) {
						return "string" === typeof q || "number" === typeof q ? q : null
					};
					h.clone = function() {
						return new f({
							endTime: this.endTime,
							field: this.field,
							maxSliderValue: this.maxSliderValue,
							minSliderValue: this.minSliderValue,
							startTime: this.startTime,
							style: this.style,
							theme: this.theme,
							type: this.type,
							units: this.units
						})
					};
					a._createClass(t, [{
						key: "style",
						get: function() {
							return "color" === this.type ? this._get("style") : null
						},
						set: function(q) {
							this._set("style", q)
						}
					}, {
						key: "theme",
						get: function() {
							return "color" === this.type || "size" === this.type ? this._get("theme") || "high-to-low" : null
						},
						set: function(q) {
							this._set("theme", q)
						}
					}]);
					return t
				}(e.JSONSupport);
				b.__decorate([d.property({
					types: g,
					json: {
						write: !0
					}
				})], e.prototype, "endTime", void 0);
				b.__decorate([v.cast("endTime")], e.prototype, "castEndTime", null);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], e.prototype, "field", void 0);
				b.__decorate([d.property({
					type: Number,
					json: {
						write: !0
					}
				})], e.prototype, "maxSliderValue", void 0);
				b.__decorate([d.property({
					type: Number,
					json: {
						write: !0
					}
				})], e.prototype, "minSliderValue", void 0);
				b.__decorate([d.property({
					types: g,
					json: {
						write: !0
					}
				})], e.prototype, "startTime", void 0);
				b.__decorate([v.cast("startTime")],
					e.prototype, "castStartTime", null);
				b.__decorate([d.property({
					type: k.apiValues,
					value: null,
					json: {
						type: k.jsonValues,
						read: k.read,
						write: k.write
					}
				})], e.prototype, "style", null);
				b.__decorate([d.property({
					type: r,
					value: null,
					json: {
						type: r,
						origins: {
							"web-scene": {
								type: l,
								write: {
									writer: (n, t) => {
										l.includes(n) && (t.theme = n)
									}
								}
							}
						},
						write: !0
					}
				})], e.prototype, "theme", null);
				b.__decorate([d.property({
					type: c.apiValues,
					json: {
						type: c.jsonValues,
						read: c.read,
						write: c.write
					}
				})], e.prototype, "type", void 0);
				b.__decorate([d.property({
					type: p,
					json: {
						type: p,
						write: !0
					}
				})], e.prototype, "units", void 0);
				return e = f = b.__decorate([m.subclass("esri.renderers.support.AuthoringInfoVisualVariable")], e)
			})
		},
		"esri/rest/support/colorRamps": function() {
			define(["exports", "./AlgorithmicColorRamp", "./ColorRamp", "./MultipartColorRamp"], function(a, b, c, e) {
				c = {
					key: "type",
					base: c,
					typeMap: {
						algorithmic: b,
						multipart: e
					}
				};
				a.fromJSON = function(d) {
					return d && d.type ? "algorithmic" === d.type ? b.fromJSON(d) : "multipart" === d.type ? e.fromJSON(d) : null : null
				};
				a.types = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/support/AlgorithmicColorRamp": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./ColorRamp".split(" "), function(a, b, c, e, d, k, v, m, f) {
				var g;
				f = g = function(l) {
					function r(p) {
						p = l.call(this, p) ||
							this;
						p.algorithm = null;
						p.fromColor = null;
						p.toColor = null;
						p.type = "algorithmic";
						return p
					}
					a._inheritsLoose(r, l);
					r.prototype.clone = function() {
						return new g({
							fromColor: e.clone(this.fromColor),
							toColor: e.clone(this.toColor),
							algorithm: this.algorithm
						})
					};
					return r
				}(f);
				b.__decorate([v.enumeration({
					esriCIELabAlgorithm: "cie-lab",
					esriHSVAlgorithm: "hsv",
					esriLabLChAlgorithm: "lab-lch"
				})], f.prototype, "algorithm", void 0);
				b.__decorate([d.property({
					type: c,
					json: {
						type: [k.Integer],
						write: !0
					}
				})], f.prototype, "fromColor", void 0);
				b.__decorate([d.property({
					type: c,
					json: {
						type: [k.Integer],
						write: !0
					}
				})], f.prototype, "toColor", void 0);
				b.__decorate([d.property({
					type: ["algorithmic"]
				})], f.prototype, "type", void 0);
				return f = g = b.__decorate([m.subclass("esri.rest.support.AlgorithmicColorRamp")], f)
			})
		},
		"esri/rest/support/ColorRamp": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f(g) {
							g = m.call(this, g) || this;
							g.type = null;
							return g
						}
						a._inheritsLoose(f, m);
						return f
					}(c.JSONSupport);
					b.__decorate([e.property({
						readOnly: !0,
						json: {
							read: !1,
							write: !0
						}
					})], c.prototype, "type", void 0);
					return c = b.__decorate([v.subclass("esri.rest.support.ColorRamp")], c)
				})
		},
		"esri/rest/support/MultipartColorRamp": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./AlgorithmicColorRamp ./ColorRamp".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					d = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.colorRamps = null;
							r.type = "multipart";
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								colorRamps: c.clone(this.colorRamps)
							})
						};
						return l
					}(m);
					b.__decorate([e.property({
						type: [v],
						json: {
							write: !0
						}
					})], d.prototype, "colorRamps", void 0);
					b.__decorate([e.property({
						type: ["multipart"]
					})], d.prototype, "type", void 0);
					return d = f = b.__decorate([k.subclass("esri.rest.support.MultipartColorRamp")], d)
				})
		},
		"esri/renderers/mixins/VisualVariablesMixin": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../layers/support/fieldUtils ../support/randomRotationExpression ../visualVariables/ColorVariable ../visualVariables/OpacityVariable ../visualVariables/RotationVariable ../visualVariables/SizeVariable ../visualVariables/VisualVariable ../visualVariables/VisualVariableFactory".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u) {
					const x = {
						base: q,
						key: "type",
						typeMap: {
							opacity: n,
							color: p,
							rotation: t,
							size: h
						}
					};
					a.VisualVariablesMixin = y => {
						y = function(w) {
							function A() {
								var E = w.apply(this, arguments) || this;
								E._vvFactory = new u;
								return E
							}
							b._inheritsLoose(A, w);
							var B = A.prototype;
							B.readVisualVariables = function(E, z, C) {
								return this._vvFactory.readVariables(E, z, C)
							};
							B.writeVisualVariables = function(E, z, C, D) {
								z[C] = this._vvFactory.writeVariables(E, D)
							};
							B.hasVisualVariables = function(E, z) {
								return E ? 0 < this.getVisualVariablesForType(E,
										z)
									.length : 0 < this.getVisualVariablesForType("size", z)
									.length || 0 < this.getVisualVariablesForType("color", z)
									.length || 0 < this.getVisualVariablesForType("opacity", z)
									.length || 0 < this.getVisualVariablesForType("rotation", z)
									.length
							};
							B.getVisualVariablesForType = function(E, z) {
								const C = this.visualVariables;
								return C ? C.filter(D => D.type === E && ("string" === typeof z ? D.target === z : !1 === z ? !D.target : !0)) : []
							};
							B.collectVVRequiredFields = function() {
								var E = b._asyncToGenerator(function*(z, C) {
									var D = [];
									this.visualVariables && (D = D.concat(this.visualVariables));
									for (const K of D)
										if (K && (K.field && l.collectField(z, C, K.field), K.normalizationField && l.collectField(z, C, K.normalizationField), K.valueExpression)) {
											{
												D = z;
												var J = C;
												const H = r.matchRandomRotationExpression(K.valueExpression);
												e.isSome(H) ? (l.collectField(D, J, H), D = !0) : D = !1
											}
											D || (yield l.collectArcadeFieldNames(z, C, K.valueExpression))
										}
								});
								return function(z, C) {
									return E.apply(this, arguments)
								}
							}();
							b._createClass(A, [{
									key: "visualVariables",
									set: function(E) {
										this._vvFactory.visualVariables = E;
										this._set("visualVariables", this._vvFactory.visualVariables)
									}
								},
								{
									key: "arcadeRequiredForVisualVariables",
									get: function() {
										if (!this.visualVariables) return !1;
										for (const E of this.visualVariables)
											if (E.arcadeRequired) return !0;
										return !1
									}
								}
							]);
							return A
						}(y);
						c.__decorate([d.property({
							types: [x],
							value: null,
							json: {
								write: !0
							}
						})], y.prototype, "visualVariables", null);
						c.__decorate([m.reader("visualVariables", ["visualVariables", "rotationType", "rotationExpression"])], y.prototype, "readVisualVariables", null);
						c.__decorate([g.writer("visualVariables")], y.prototype, "writeVisualVariables", null);
						return y = c.__decorate([f.subclass("esri.renderers.mixins.VisualVariablesMixin")], y)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/support/randomRotationExpression": function() {
			define(["exports"], function(a) {
				const b = /^hash\(\$feature\['((\\'|[^'])+)'\]\) \* 8\.381e-8$/;
				a.matchRandomRotationExpression = function(c) {
					return c.match(b) ? . [1] ? .replace(/\\'/g, "'") ? ? null
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/renderers/visualVariables/ColorVariable": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./VisualVariable ./support/ColorStop".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				e = f = function(g) {
					function l(p) {
						p = g.call(this, p) || this;
						p.type = "color";
						p.normalizationField = null;
						return p
					}
					a._inheritsLoose(l, g);
					var r = l.prototype;
					r.clone = function() {
						return new f({
							field: this.field,
							normalizationField: this.normalizationField,
							valueExpression: this.valueExpression,
							valueExpressionTitle: this.valueExpressionTitle,
							stops: this.stops && this.stops.map(p => p.clone()),
							legendOptions: this.legendOptions && this.legendOptions.clone()
						})
					};
					r.getAttributeHash = function() {
						return `${g.prototype.getAttributeHash.call(this)}-${this.normalizationField}`
					};
					r._interpolateData = function() {
						return this.stops && this.stops.map(p => p.value || 0)
					};
					a._createClass(l, [{
						key: "cache",
						get: function() {
							return {
								ipData: this._interpolateData(),
								hasExpression: !!this.valueExpression,
								compiledFunc: null
							}
						}
					}, {
						key: "stops",
						set: function(p) {
							p && Array.isArray(p) && (p = p.filter(n => !!n), p.sort((n, t) => n.value - t.value));
							this._set("stops", p)
						}
					}]);
					return l
				}(v);
				b.__decorate([c.property({
					readOnly: !0
				})], e.prototype, "cache", null);
				b.__decorate([c.property({
					type: ["color"],
					json: {
						type: ["colorInfo"]
					}
				})], e.prototype, "type", void 0);
				b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "normalizationField",
					void 0);
				b.__decorate([c.property({
					type: [m],
					json: {
						write: !0
					}
				})], e.prototype, "stops", null);
				return e = f = b.__decorate([k.subclass("esri.renderers.visualVariables.ColorVariable")], e)
			})
		},
		"esri/renderers/visualVariables/VisualVariable": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/ensureType ./support/VisualVariableLegendOptions".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					c = new c.JSONMap({
						colorInfo: "color",
						transparencyInfo: "opacity",
						rotationInfo: "rotation",
						sizeInfo: "size"
					});
					e = function(r) {
						function p(t) {
							t = r.call(this, t) || this;
							t.index = null;
							t.type = null;
							t.field = null;
							t.valueExpression = null;
							t.valueExpressionTitle = null;
							t.legendOptions = null;
							return t
						}
						a._inheritsLoose(p, r);
						var n = p.prototype;
						n.castField = function(t) {
							return null == t ? t : "function" === typeof t ? (d.getLogger(this.declaredClass)
								.error(".field: field must be a string value"), null) : g.ensureString(t)
						};
						n.clone = function() {};
						n.getAttributeHash = function() {
							return `${this.type}-${this.field}-${this.valueExpression}`
						};
						a._createClass(p, [{
							key: "arcadeRequired",
							get: function() {
								return !!this.valueExpression
							}
						}]);
						return p
					}(e.JSONSupport);
					b.__decorate([k.property()], e.prototype, "index", void 0);
					b.__decorate([k.property({
						type: c.apiValues,
						readOnly: !0,
						json: {
							read: c.read,
							write: c.write
						}
					})], e.prototype, "type", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "field", void 0);
					b.__decorate([m.cast("field")],
						e.prototype, "castField", null);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "valueExpression", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "valueExpressionTitle", void 0);
					b.__decorate([k.property({
						readOnly: !0
					})], e.prototype, "arcadeRequired", null);
					b.__decorate([k.property({
						type: l,
						json: {
							write: !0
						}
					})], e.prototype, "legendOptions", void 0);
					return e = b.__decorate([f.subclass("esri.renderers.visualVariables.VisualVariable")], e)
				})
		},
		"esri/renderers/visualVariables/support/VisualVariableLegendOptions": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../support/LegendOptions".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g() {
							var l = f.apply(this, arguments) || this;
							l.showLegend = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								title: this.title,
								showLegend: this.showLegend
							})
						};
						return g
					}(v.LegendOptions);
					b.__decorate([c.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], e.prototype, "showLegend", void 0);
					return e = m = b.__decorate([k.subclass("esri.renderers.visualVariables.support.VisualVariableLegendOptions")], e)
				})
		},
		"esri/renderers/support/LegendOptions": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					a.LegendOptions = f = function(g) {
						function l() {
							var r = g.apply(this, arguments) || this;
							r.title = null;
							return r
						}
						b._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								title: this.title
							})
						};
						return l
					}(e.JSONSupport);
					c.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], a.LegendOptions.prototype, "title", void 0);
					a.LegendOptions = f = c.__decorate([m.subclass("esri.renderers.support.LegendOptions")], a.LegendOptions);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/visualVariables/support/ColorStop": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Color ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../core/accessorSupport/decorators/writer".split(" "), function(a, b, c, e, d, k, v, m, f) {
				var g;
				e = g = function(l) {
					function r(n) {
						n = l.call(this, n) || this;
						n.color = null;
						n.label = null;
						n.value = null;
						return n
					}
					a._inheritsLoose(r, l);
					var p = r.prototype;
					p.writeValue = function(n, t, h) {
						t[h] = null == n ? 0 : n
					};
					p.clone = function() {
						return new g({
							color: this.color && this.color.clone(),
							label: this.label,
							value: this.value
						})
					};
					return r
				}(e.JSONSupport);
				b.__decorate([d.property({
					type: c,
					json: {
						type: [v.Integer],
						write: !0
					}
				})], e.prototype, "color", void 0);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], e.prototype, "label", void 0);
				b.__decorate([d.property({
						type: Number,
						json: {
							write: {
								writerEnsuresNonNull: !0
							}
						}
					})],
					e.prototype, "value", void 0);
				b.__decorate([f.writer("value")], e.prototype, "writeValue", null);
				return e = g = b.__decorate([m.subclass("esri.renderers.visualVariables.support.ColorStop")], e)
			})
		},
		"esri/renderers/visualVariables/OpacityVariable": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./VisualVariable ./support/OpacityStop".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					e = f = function(g) {
						function l(p) {
							p = g.call(this, p) || this;
							p.type = "opacity";
							p.normalizationField = null;
							return p
						}
						a._inheritsLoose(l, g);
						var r = l.prototype;
						r.clone = function() {
							return new f({
								field: this.field,
								normalizationField: this.normalizationField,
								valueExpression: this.valueExpression,
								valueExpressionTitle: this.valueExpressionTitle,
								stops: this.stops && this.stops.map(p => p.clone()),
								legendOptions: this.legendOptions && this.legendOptions.clone()
							})
						};
						r.getAttributeHash = function() {
							return `${g.prototype.getAttributeHash.call(this)}-${this.normalizationField}`
						};
						r._interpolateData = function() {
							return this.stops && this.stops.map(p => p.value || 0)
						};
						a._createClass(l, [{
							key: "cache",
							get: function() {
								return {
									ipData: this._interpolateData(),
									hasExpression: !!this.valueExpression,
									compiledFunc: null
								}
							}
						}, {
							key: "stops",
							set: function(p) {
								p && Array.isArray(p) && (p = p.filter(n => !!n), p.sort((n, t) => n.value - t.value));
								this._set("stops", p)
							}
						}]);
						return l
					}(v);
					b.__decorate([c.property({
						readOnly: !0
					})], e.prototype, "cache", null);
					b.__decorate([c.property({
							type: ["opacity"],
							json: {
								type: ["transparencyInfo"]
							}
						})],
						e.prototype, "type", void 0);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "normalizationField", void 0);
					b.__decorate([c.property({
						type: [m],
						json: {
							write: !0
						}
					})], e.prototype, "stops", null);
					return e = f = b.__decorate([k.subclass("esri.renderers.visualVariables.OpacityVariable")], e)
				})
		},
		"esri/renderers/visualVariables/support/OpacityStop": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/reader ../../../core/accessorSupport/decorators/subclass ../../../core/accessorSupport/decorators/writer ../../../webdoc/support/opacityUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					c = l = function(r) {
						function p(t) {
							t = r.call(this, t) || this;
							t.label = null;
							t.opacity = null;
							t.value = null;
							return t
						}
						a._inheritsLoose(p, r);
						var n = p.prototype;
						n.readOpacity = function(t, h) {
							return g.transparencyToOpacity(h.transparency)
						};
						n.writeOpacity = function(t, h, q) {
							h[q] = g.opacityToTransparency(t)
						};
						n.clone = function() {
							return new l({
								label: this.label,
								opacity: this.opacity,
								value: this.value
							})
						};
						return p
					}(c.JSONSupport);
					b.__decorate([e.property({
							type: String,
							json: {
								write: !0
							}
						})], c.prototype,
						"label", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							type: k.Integer,
							write: {
								target: "transparency"
							}
						}
					})], c.prototype, "opacity", void 0);
					b.__decorate([v.reader("opacity", ["transparency"])], c.prototype, "readOpacity", null);
					b.__decorate([f.writer("opacity")], c.prototype, "writeOpacity", null);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], c.prototype, "value", void 0);
					return c = l = b.__decorate([m.subclass("esri.renderers.visualVariables.support.OpacityStop")], c)
				})
		},
		"esri/renderers/visualVariables/RotationVariable": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Error ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./VisualVariable".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					d = g = function(l) {
						function r(n) {
							n = l.call(this, n) || this;
							n.axis = null;
							n.type = "rotation";
							n.rotationType = "geographic";
							n.valueExpressionTitle = null;
							return n
						}
						a._inheritsLoose(r, l);
						var p = r.prototype;
						p.writeValueExpressionTitleWebScene = function(n, t, h, q) {
							q && q.messages && q.messages.push(new c("property:unsupported", this.type + "VisualVariable.valueExpressionTitle is not supported in Web Scene. Please remove this property to save the Web Scene.", {
								instance: this,
								propertyName: `visualVariables[${this.index}]` +
									".valueExpressionTitle",
								context: q
							}))
						};
						p.clone = function() {
							return new g({
								axis: this.axis,
								rotationType: this.rotationType,
								field: this.field,
								valueExpression: this.valueExpression,
								valueExpressionTitle: this.valueExpressionTitle,
								legendOptions: this.legendOptions && this.legendOptions.clone()
							})
						};
						a._createClass(r, [{
							key: "cache",
							get: function() {
								return {
									hasExpression: !!this.valueExpression,
									compiledFunc: null
								}
							}
						}]);
						return r
					}(f);
					b.__decorate([e.property({
						readOnly: !0
					})], d.prototype, "cache", null);
					b.__decorate([e.property({
						type: ["heading",
							"tilt", "roll"
						],
						json: {
							origins: {
								"web-scene": {
									default: "heading",
									write: !0
								}
							}
						}
					})], d.prototype, "axis", void 0);
					b.__decorate([e.property({
						type: ["rotation"],
						json: {
							type: ["rotationInfo"]
						}
					})], d.prototype, "type", void 0);
					b.__decorate([e.property({
						type: ["geographic", "arithmetic"],
						json: {
							write: !0,
							origins: {
								"web-document": {
									write: !0,
									default: "geographic"
								}
							}
						}
					})], d.prototype, "rotationType", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], d.prototype, "valueExpressionTitle", void 0);
					b.__decorate([m.writer("web-scene",
						"valueExpressionTitle")], d.prototype, "writeValueExpressionTitleWebScene", null);
					return d = g = b.__decorate([v.subclass("esri.renderers.visualVariables.RotationVariable")], d)
				})
		},
		"esri/renderers/visualVariables/SizeVariable": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Error ../../core/jsonMap ../../core/Logger ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./VisualVariable ./support/SizeStop ./support/SizeVariableLegendOptions ./support/sizeVariableUtils ./support/visualVariableUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q) {
					function u(B) {
						if (null != B) {
							if ("string" === typeof B || "number" === typeof B) return k.toPt(B);
							if ("size" === B.type) {
								if (h.isSizeVariable(B)) return B;
								B = {
									...B
								};
								delete B.type;
								return new A(B)
							}
						}
					}

					function x(B, E, z) {
						if ("object" !== typeof B) return B;
						E = new A;
						E.read(B, z);
						return E
					}
					var y;
					m = new e.JSONMap({
						width: "width",
						depth: "depth",
						height: "height",
						widthAndDepth: "width-and-depth",
						all: "all"
					});
					const w = new e.JSONMap({
						unknown: "unknown",
						inch: "inches",
						foot: "feet",
						yard: "yards",
						mile: "miles",
						"nautical-mile": "nautical-miles",
						millimeter: "millimeters",
						centimeter: "centimeters",
						decimeter: "decimeters",
						meter: "meters",
						kilometer: "kilometers",
						"decimal-degree": "decimal-degrees"
					});
					let A = y = function(B) {
						function E(C) {
							C = B.call(this, C) || this;
							C.axis = null;
							C.legendOptions = null;
							C.normalizationField = null;
							C.scaleBy = null;
							C.target = null;
							C.type = "size";
							C.useSymbolValue = null;
							C.valueExpression = null;
							C.valueRepresentation = null;
							C.valueUnit = null;
							return C
						}
						a._inheritsLoose(E, B);
						var z = E.prototype;
						z.castMaxSize = function(C) {
							return u(C)
						};
						z.readMaxSize = function(C, D, J) {
							return x(C, D, J)
						};
						z.castMinSize = function(C) {
							return u(C)
						};
						z.readMinSize = function(C, D, J) {
							return x(C, D, J)
						};
						z.readValueExpression = function(C, D) {
							return C || D.expression && "$view.scale"
						};
						z.writeValueExpressionWebScene = function(C, D, J, K) {
							"$view.scale" === C ? K && K.messages && (C = this.index, K.messages.push(new c("property:unsupported", this.type + "VisualVariable.valueExpression \x3d '$view.scale' is not supported in Web Scene. Please remove this property to save the Web Scene.", {
								instance: this,
								propertyName: ("string" === typeof C ? C : `visualVariables[${C}]`) + ".valueExpression",
								context: K
							}))) : D[J] = C
						};
						z.readValueUnit = function(C) {
							return C ? w.read(C) : null
						};
						z.clone = function() {
							return new y({
								axis: this.axis,
								field: this.field,
								valueExpression: this.valueExpression,
								valueExpressionTitle: this.valueExpressionTitle,
								maxDataValue: this.maxDataValue,
								maxSize: h.isSizeVariable(this.maxSize) ? this.maxSize.clone() : this.maxSize,
								minDataValue: this.minDataValue,
								minSize: h.isSizeVariable(this.minSize) ? this.minSize.clone() : this.minSize,
								normalizationField: this.normalizationField,
								stops: this.stops && this.stops.map(C => C.clone()),
								target: this.target,
								useSymbolValue: this.useSymbolValue,
								valueRepresentation: this.valueRepresentation,
								valueUnit: this.valueUnit,
								legendOptions: this.legendOptions && this.legendOptions.clone()
							})
						};
						z.flipSizes = function() {
							if (this.transformationType === h.TransformationType.ClampedLinear) {
								const {
									minSize: C,
									maxSize: D
								} = this;
								this.minSize = D;
								this.maxSize = C;
								return this
							}
							if (this.transformationType === h.TransformationType.Stops) {
								const C =
									this.stops;
								if (!C) return this;
								const D = C.map(K => K.size)
									.reverse(),
									J = C.length;
								for (let K = 0; K < J; K++) C[K].size = D[K]
							}
							return this
						};
						z.getAttributeHash = function() {
							return `${B.prototype.getAttributeHash.call(this)}-${this.target}-${this.normalizationField}`
						};
						z._interpolateData = function() {
							return this.stops && this.stops.map(C => C.value || 0)
						};
						a._createClass(E, [{
							key: "cache",
							get: function() {
								return {
									ipData: this._interpolateData(),
									hasExpression: !!this.valueExpression,
									compiledFunc: null,
									isScaleDriven: null != this.valueExpression &&
										q.viewScaleRE.test(this.valueExpression)
								}
							}
						}, {
							key: "expression",
							set: function(C) {
								d.getLogger(this.declaredClass)
									.warn("'expression' is deprecated since version 4.2. Use 'valueExpression' instead. The only supported expression is 'view.scale'.");
								"view.scale" === C ? (this.valueExpression = "$view.scale", this._set("expression", C)) : this._set("expression", null)
							}
						}, {
							key: "index",
							set: function(C) {
								h.isSizeVariable(this.maxSize) && (this.maxSize.index = `visualVariables[${C}].maxSize`);
								h.isSizeVariable(this.minSize) && (this.minSize.index =
									`visualVariables[${C}].minSize`);
								this._set("index", C)
							}
						}, {
							key: "inputValueType",
							get: function() {
								return h.getInputValueType(this)
							}
						}, {
							key: "maxDataValue",
							set: function(C) {
								C && this.stops && (d.getLogger(this.declaredClass)
									.warn("cannot set maxDataValue when stops is not null."), C = null);
								this._set("maxDataValue", C)
							}
						}, {
							key: "maxSize",
							set: function(C) {
								C && this.stops && (d.getLogger(this.declaredClass)
									.warn("cannot set maxSize when stops is not null."), C = null);
								this._set("maxSize", C)
							}
						}, {
							key: "minDataValue",
							set: function(C) {
								C &&
									this.stops && (d.getLogger(this.declaredClass)
										.warn("cannot set minDataValue when stops is not null."), C = null);
								this._set("minDataValue", C)
							}
						}, {
							key: "minSize",
							set: function(C) {
								C && this.stops && (d.getLogger(this.declaredClass)
									.warn("cannot set minSize when stops is not null."), C = null);
								this._set("minSize", C)
							}
						}, {
							key: "arcadeRequired",
							get: function() {
								return this.valueExpression ? !0 : null != this.minSize && "object" === typeof this.minSize && this.minSize.arcadeRequired || null != this.maxSize && "object" === typeof this.maxSize &&
									this.maxSize.arcadeRequired
							}
						}, {
							key: "stops",
							set: function(C) {
								null == this.minDataValue && null == this.maxDataValue && null == this.minSize && null == this.maxSize ? C && Array.isArray(C) && (C = C.filter(D => !!D), C.sort((D, J) => D.value - J.value)) : C && (d.getLogger(this.declaredClass)
									.warn("cannot set stops when one of minDataValue, maxDataValue, minSize or maxSize is not null."), C = null);
								this._set("stops", C)
							}
						}, {
							key: "transformationType",
							get: function() {
								return h.getTransformationType(this, this.inputValueType)
							}
						}]);
						return E
					}(p);
					b.__decorate([v.property({
							readOnly: !0
						})],
						A.prototype, "cache", null);
					b.__decorate([v.property({
						type: m.apiValues,
						json: {
							type: m.jsonValues,
							origins: {
								"web-map": {
									read: !1
								}
							},
							read: m.read,
							write: m.write
						}
					})], A.prototype, "axis", void 0);
					b.__decorate([v.property({
						type: String,
						value: null,
						json: {
							read: !1
						}
					})], A.prototype, "expression", null);
					b.__decorate([v.property()], A.prototype, "index", null);
					b.__decorate([v.property({
						type: String,
						readOnly: !0
					})], A.prototype, "inputValueType", null);
					b.__decorate([v.property({
						type: t,
						json: {
							write: !0
						}
					})], A.prototype, "legendOptions", void 0);
					b.__decorate([v.property({
						type: Number,
						value: null,
						json: {
							write: !0
						}
					})], A.prototype, "maxDataValue", null);
					b.__decorate([v.property({
						type: Number,
						value: null,
						json: {
							write: !0
						}
					})], A.prototype, "maxSize", null);
					b.__decorate([f.cast("maxSize")], A.prototype, "castMaxSize", null);
					b.__decorate([g.reader("maxSize")], A.prototype, "readMaxSize", null);
					b.__decorate([v.property({
						type: Number,
						value: null,
						json: {
							write: !0
						}
					})], A.prototype, "minDataValue", null);
					b.__decorate([v.property({
							type: Number,
							value: null,
							json: {
								write: !0
							}
						})], A.prototype,
						"minSize", null);
					b.__decorate([f.cast("minSize")], A.prototype, "castMinSize", null);
					b.__decorate([g.reader("minSize")], A.prototype, "readMinSize", null);
					b.__decorate([v.property({
						type: String,
						json: {
							write: !0
						}
					})], A.prototype, "normalizationField", void 0);
					b.__decorate([v.property({
						readOnly: !0
					})], A.prototype, "arcadeRequired", null);
					b.__decorate([v.property({
						type: String
					})], A.prototype, "scaleBy", void 0);
					b.__decorate([v.property({
						type: [n],
						value: null,
						json: {
							write: !0
						}
					})], A.prototype, "stops", null);
					b.__decorate([v.property({
						type: ["outline"],
						json: {
							write: !0
						}
					})], A.prototype, "target", void 0);
					b.__decorate([v.property({
						type: String,
						readOnly: !0
					})], A.prototype, "transformationType", null);
					b.__decorate([v.property({
						type: ["size"],
						json: {
							type: ["sizeInfo"]
						}
					})], A.prototype, "type", void 0);
					b.__decorate([v.property({
						type: Boolean,
						json: {
							write: !0,
							origins: {
								"web-map": {
									read: !1
								}
							}
						}
					})], A.prototype, "useSymbolValue", void 0);
					b.__decorate([v.property({
						type: String,
						json: {
							write: !0
						}
					})], A.prototype, "valueExpression", void 0);
					b.__decorate([g.reader("valueExpression", ["valueExpression",
						"expression"
					])], A.prototype, "readValueExpression", null);
					b.__decorate([r.writer("web-scene", "valueExpression")], A.prototype, "writeValueExpressionWebScene", null);
					b.__decorate([v.property({
						type: ["radius", "diameter", "area", "width", "distance"],
						json: {
							write: !0
						}
					})], A.prototype, "valueRepresentation", void 0);
					b.__decorate([v.property({
						type: w.apiValues,
						json: {
							write: w.write,
							origins: {
								"web-map": {
									read: !1
								},
								"web-scene": {
									write: !0
								}
							}
						}
					})], A.prototype, "valueUnit", void 0);
					b.__decorate([g.reader("valueUnit")], A.prototype,
						"readValueUnit", null);
					return A = y = b.__decorate([l.subclass("esri.renderers.visualVariables.SizeVariable")], A)
				})
		},
		"esri/renderers/visualVariables/support/SizeStop": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/screenUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v,
				m) {
				var f;
				c = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.label = null;
						r.size = null;
						r.value = null;
						return r
					}
					a._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							label: this.label,
							size: this.size,
							value: this.value
						})
					};
					return l
				}(c.JSONSupport);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "label", void 0);
				b.__decorate([d.property({
					type: Number,
					cast: e.toPt,
					json: {
						write: !0
					}
				})], c.prototype, "size", void 0);
				b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], c.prototype,
					"value", void 0);
				return c = f = b.__decorate([m.subclass("esri.renderers.visualVariables.support.SizeStop")], c)
			})
		},
		"esri/renderers/visualVariables/support/SizeVariableLegendOptions": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./VisualVariableLegendOptions".split(" "), function(a, b, c, e, d, k, v) {
				var m;
				e = m = function(f) {
					function g() {
						var l = f.apply(this, arguments) || this;
						l.customValues = null;
						return l
					}
					a._inheritsLoose(g, f);
					g.prototype.clone = function() {
						return new m({
							title: this.title,
							showLegend: this.showLegend,
							customValues: this.customValues && this.customValues.slice(0)
						})
					};
					return g
				}(v);
				b.__decorate([c.property({
					type: [Number],
					json: {
						write: !0
					}
				})], e.prototype, "customValues", void 0);
				return e = m = b.__decorate([k.subclass("esri.renderers.visualVariables.support.SizeVariableLegendOptions")], e)
			})
		},
		"esri/renderers/visualVariables/support/sizeVariableUtils": function() {
			define(["exports"],
				function(a) {
					function b(c) {
						return c.valueExpression ? a.InputValueType.Expression : c.field && "string" === typeof c.field ? a.InputValueType.Field : a.InputValueType.Unknown
					}
					a.InputValueType = void 0;
					(function(c) {
						c.Unknown = "unknown";
						c.Expression = "expression";
						c.Field = "field"
					})(a.InputValueType || (a.InputValueType = {}));
					a.TransformationType = void 0;
					(function(c) {
						c.Unknown = "unknown";
						c.Stops = "stops";
						c.ClampedLinear = "clamped-linear";
						c.Proportional = "proportional";
						c.Additive = "additive";
						c.Constant = "constant";
						c.Identity = "identity";
						c.RealWorldSize = "real-world-size"
					})(a.TransformationType || (a.TransformationType = {}));
					a.getInputValueType = b;
					a.getTransformationType = function(c, e) {
						return (e || b(c)) === a.InputValueType.Unknown ? a.TransformationType.Constant : c.stops ? a.TransformationType.Stops : null != c.minSize && null != c.maxSize && null != c.minDataValue && null != c.maxDataValue ? a.TransformationType.ClampedLinear : "unknown" === (c.valueUnit || "unknown") ? null != c.minSize && null != c.minDataValue ? c.minSize && c.minDataValue ? a.TransformationType.Proportional : a.TransformationType.Additive :
							a.TransformationType.Identity : a.TransformationType.RealWorldSize
					};
					a.isSizeVariable = function(c) {
						return c && "esri.renderers.visualVariables.SizeVariable" === c.declaredClass
					};
					a.isValidNumber = function(c) {
						return null != c && !isNaN(c) && isFinite(c)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/visualVariables/support/visualVariableUtils": function() {
			define("exports ../../../Color ../../../Graphic ../../../core/compilerUtils ../../../core/Logger ../../../core/maybe ../../support/lengthUtils ./sizeVariableUtils".split(" "),
				function(a, b, c, e, d, k, v, m) {
					function f(w, A, B) {
						if (w = "visualVariables" in w && w.visualVariables ? w.visualVariables.find(G => "color" === G.type) : w)
							if ("esri.renderers.visualVariables.ColorVariable" !== w.declaredClass) u.warn("The visualVariable should be an instance of esri.renderers.visualVariables.ColorVariable");
							else {
								var E = "number" === typeof A,
									z = E ? null : A,
									C = z && z.attributes,
									D = E ? A : null,
									J = w.field,
									{
										ipData: K,
										hasExpression: H
									} = w.cache;
								A = w.cache.compiledFunc;
								if (!J && !H) return (B = w.stops) && B[0] && B[0].color;
								if ("number" !==
									typeof D)
									if (H) {
										if (k.isNone(B) || k.isNone(B.arcade)) {
											u.error("Use of arcade expressions requires an arcade context");
											return
										}
										D = B.arcade.arcadeUtils;
										J = D.getViewInfo({
											viewingMode: B.viewingMode,
											scale: B.scale,
											spatialReference: B.spatialReference
										});
										z = D.createExecContext(z, J);
										A || (A = D.createSyntaxTree(w.valueExpression), A = D.createFunction(A), w.cache.compiledFunc = A);
										D = D.executeFunction(A, z)
									} else C && (D = C[J]);
								z = w.normalizationField;
								C = null != C && null != z ? parseFloat(C[z]) : void 0;
								if (null != D && (!z || E || !isNaN(C) && 0 !== C) &&
									(isNaN(C) || E || (D /= C), E = q(D, K))) return C = E[0], z = E[1], B = C === z ? w.stops[C].color : b.blendColors(w.stops[C].color, w.stops[z].color, E[2], k.isSome(B) ? B.color : void 0), new b(B)
							}
					}

					function g(w, A, B) {
						if (w = "visualVariables" in w && w.visualVariables ? w.visualVariables.find(G => "opacity" === G.type) : w)
							if ("esri.renderers.visualVariables.OpacityVariable" !== w.declaredClass) u.warn("The visualVariable should be an instance of esri.renderers.visualVariables.OpacityVariable");
							else {
								var E = "number" === typeof A,
									z = E ? null : A,
									C = z && z.attributes,
									D = E ? A : null,
									J = w.field,
									{
										ipData: K,
										hasExpression: H
									} = w.cache;
								A = w.cache.compiledFunc;
								if (!J && !H) return (w = w.stops) && w[0] && w[0].opacity;
								if ("number" !== typeof D)
									if (H) {
										if (k.isNone(B) || k.isNone(B.arcade)) {
											u.error("Use of arcade expressions requires an arcade context");
											return
										}
										D = B.arcade.arcadeUtils;
										B = D.getViewInfo({
											viewingMode: B.viewingMode,
											scale: B.scale,
											spatialReference: B.spatialReference
										});
										B = D.createExecContext(z, B);
										A || (z = D.createSyntaxTree(w.valueExpression), A = D.createFunction(z), w.cache.compiledFunc = A);
										D = D.executeFunction(A,
											B)
									} else C && (D = C[J]);
								B = w.normalizationField;
								C = null != C && null != B ? parseFloat(C[B]) : void 0;
								if (null != D && (!B || E || !isNaN(C) && 0 !== C) && (isNaN(C) || E || (D /= C), E = q(D, K))) {
									B = E[0];
									C = E[1];
									if (B === C) return w.stops[B].opacity;
									B = w.stops[B].opacity;
									return B + (w.stops[C].opacity - B) * E[2]
								}
							}
					}

					function l(w, A, B) {
						if (w = "visualVariables" in w && w.visualVariables ? w.visualVariables.find(G => "rotation" === G.type) : w)
							if ("esri.renderers.visualVariables.RotationVariable" !== w.declaredClass) u.warn("The visualVariable should be an instance of esri.renderers.visualVariables.RotationVariable");
							else {
								var E = w.axis || "heading",
									z = "heading" === E && "arithmetic" === w.rotationType ? 90 : 0;
								E = "heading" === E && "arithmetic" === w.rotationType ? -1 : 1;
								var C = "number" === typeof A ? null : A,
									D = C && C.attributes,
									J = w.field,
									{
										hasExpression: K
									} = w.cache;
								A = w.cache.compiledFunc;
								var H = 0;
								if (!J && !K) return H;
								if (K) {
									if (k.isNone(B) || k.isNone(B.arcade)) {
										u.error("Use of arcade expressions requires an arcade context");
										return
									}
									D = B.arcade.arcadeUtils;
									B = D.getViewInfo({
										viewingMode: B.viewingMode,
										scale: B.scale,
										spatialReference: B.spatialReference
									});
									B = D.createExecContext(C, B);
									A || (A = D.createSyntaxTree(w.valueExpression), A = D.createFunction(A), w.cache.compiledFunc = A);
									H = D.executeFunction(A, B)
								} else D && (H = D[J] || 0);
								return H = "number" !== typeof H || isNaN(H) ? null : z + E * H
							}
					}

					function r(w, A, B) {
						const E = "number" === typeof A;
						var z = E ? null : A;
						const C = z && z.attributes;
						var D = E ? A : null;
						const {
							isScaleDriven: J
						} = w.cache;
						A = w.cache.compiledFunc;
						if (J) z = k.isSome(B) ? B.scale : void 0, B = k.isSome(B) ? B.view : void 0, null == z || "3d" === B ? (z = B = null, (z = w.stops) ? (B = z[0].value, z = z[z.length - 1].value) :
							(B = w.minDataValue || 0, z = w.maxDataValue || 0), B = (B + z) / 2) : B = z, D = B;
						else if (!E) switch (w.inputValueType) {
							case m.InputValueType.Expression:
								if (k.isNone(B) || k.isNone(B.arcade)) {
									u.error("Use of arcade expressions requires an arcade context");
									return
								}
								D = B.arcade.arcadeUtils;
								B = D.getViewInfo({
									viewingMode: B.viewingMode,
									scale: B.scale,
									spatialReference: B.spatialReference
								});
								B = D.createExecContext(z, B);
								A || (z = D.createSyntaxTree(w.valueExpression), A = D.createFunction(z), w.cache.compiledFunc = A);
								D = D.executeFunction(A, B);
								break;
							case m.InputValueType.Field:
								C && (D = C[w.field]);
								break;
							case m.InputValueType.Unknown:
								D = null
						}
						if (!m.isValidNumber(D)) return null;
						if (E || !w.normalizationField) return D;
						w = C ? parseFloat(C[w.normalizationField]) : null;
						return m.isValidNumber(w) && 0 !== w ? D / w : null
					}

					function p(w, A, B) {
						if (w = "visualVariables" in w && w.visualVariables ? w.visualVariables.find(z => "size" === z.type) : w)
							if ("esri.renderers.visualVariables.SizeVariable" !== w.declaredClass) u.warn("The visualVariable should be an instance of esri.renderers.visualVariables.SizeVariable");
							else {
								var E = r(w, A, B);
								A = h(E, w, A, B, w.cache.ipData);
								return null === A || void 0 === A || isNaN(A) ? 0 : A
							}
					}

					function n(w, A, B) {
						return null == w ? null : m.isSizeVariable(w) ? p(w, A, B) : m.isValidNumber(w) ? w : null
					}

					function t(w, A, B) {
						return m.isValidNumber(B) && w > B ? B : m.isValidNumber(A) && w < A ? A : w
					}

					function h(w, A, B, E, z) {
						switch (A.transformationType) {
							case m.TransformationType.Additive:
								return E = n(A.minSize, B, E), w + ((E || A.minDataValue) ? ? 0);
							case m.TransformationType.Constant:
								return w = (w = A.stops) && w.length && w[0].size, null == w && (w = A.minSize),
									n(w, B, E);
							case m.TransformationType.ClampedLinear:
								z = (w - A.minDataValue) / (A.maxDataValue - A.minDataValue);
								var C = n(A.minSize, B, E);
								B = n(A.maxSize, B, E);
								E = k.isSome(E) ? E.shape : void 0;
								w <= A.minDataValue ? A = C : w >= A.maxDataValue ? A = B : null == C || null == B ? A = null : "area" === A.scaleBy && E ? (w = (A = "circle" === E) ? y * (C / 2) ** 2 : C * C, w += z * ((A ? y * (B / 2) ** 2 : B * B) - w), A = A ? 2 * Math.sqrt(w / y) : Math.sqrt(w)) : A = C + z * (B - C);
								return A;
							case m.TransformationType.Proportional:
								return z = k.isSome(E) ? E.shape : void 0, w /= A.minDataValue, C = n(A.minSize, B, E), A = n(A.maxSize,
									B, E), E = null, E = "circle" === z ? 2 * Math.sqrt(w * (C / 2) ** 2) : "square" === z || "diamond" === z || "image" === z ? Math.sqrt(w * C ** 2) : w * C, t(E, C, A);
							case m.TransformationType.Stops:
								{
									const [D, J, K] = q(w, z);D === J ? A = n(A.stops ? . [D].size, B, E) : (w = n(A.stops ? . [D].size, B, E), A = n(A.stops ? . [J].size, B, E), A = w + (A - w) * K)
								}
								return A;
							case m.TransformationType.RealWorldSize:
								return z = (k.isSome(E) && E.resolution ? E.resolution : 1) * v.meterIn[A.valueUnit], C = n(A.minSize, B, E), E = n(A.maxSize, B, E), {
										valueRepresentation: A
									} = A, B = null, B = "area" === A ? 2 * Math.sqrt(w / y) /
									z : "radius" === A || "distance" === A ? 2 * w / z : w / z, t(B, C, E);
							case m.TransformationType.Identity:
								return w;
							case m.TransformationType.Unknown:
								return null
						}
					}

					function q(w, A) {
						if (A) {
							var B = 0,
								E = A.length - 1;
							A.some((z, C) => {
								if (w < z) return E = C, !0;
								B = C;
								return !1
							});
							return [B, E, (w - A[B]) / (A[E] - A[B])]
						}
					}
					const u = d.getLogger("esri.renderers.visualVariables.support.visualVariableUtils"),
						x = new c,
						y = Math.PI;
					a.getAllSizes = function(w, A, B) {
						const E = ["proportional", "proportional", "proportional"];
						for (const z of w) switch (w = z.useSymbolValue ? "symbol-value" :
							p(z, A, B), z.axis) {
							case "width":
								E[0] = w;
								break;
							case "depth":
								E[1] = w;
								break;
							case "height":
								E[2] = w;
								break;
							case "width-and-depth":
								E[0] = w;
								E[1] = w;
								break;
							case "all":
							case void 0:
							case null:
								E[0] = w;
								E[1] = w;
								E[2] = w;
								break;
							default:
								e.neverReached(z.axis)
						}
						return E
					};
					a.getColor = f;
					a.getOpacity = g;
					a.getRotationAngle = l;
					a.getSize = p;
					a.getSizeForValue = h;
					a.getSizeFromNumberOrVariable = n;
					a.getSizeRangeAtScale = function(w, A, B) {
						const {
							isScaleDriven: E
						} = w.cache;
						if (!(E && "3d" === B || A)) return null;
						B = {
							scale: A,
							view: B
						};
						A = n(w.minSize, x, B);
						w = n(w.maxSize,
							x, B);
						if (null != A || null != w) return A > w && (B = w, w = A, A = B), {
							minSize: A,
							maxSize: w
						}
					};
					a.getVisualVariableValues = function(w, A, B) {
						if (w.visualVariables) {
							var E = [],
								z = [],
								C = [],
								D = [],
								J = [];
							for (const K of w.visualVariables) switch (K.type) {
								case "color":
									z.push(K);
									break;
								case "opacity":
									C.push(K);
									break;
								case "rotation":
									J.push(K);
									break;
								case "size":
									D.push(K)
							}
							z.forEach(K => {
								const H = f(K, A, B);
								E.push({
									variable: K,
									value: H
								})
							});
							C.forEach(K => {
								const H = g(K, A, B);
								E.push({
									variable: K,
									value: H
								})
							});
							J.forEach(K => {
								const H = l(K, A, B);
								E.push({
									variable: K,
									value: H
								})
							});
							D.forEach(K => {
								const H = p(K, A, B);
								E.push({
									variable: K,
									value: H
								})
							});
							return E.filter(K => null != K.value)
						}
					};
					a.viewScaleRE = /^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/Graphic": function() {
			define("./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./geometry ./PopupTemplate ./symbols ./core/Clonable ./core/JSONSupport ./core/maybe ./core/uid ./core/accessorSupport/decorators/property ./core/arrayUtils ./core/accessorSupport/ensureType ./core/accessorSupport/decorators/subclass ./geometry/support/jsonUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					k = function(t) {
						function h(...u) {
							u = t.call(this, ...u) || this;
							u.isAggregate = !1;
							u.layer = null;
							u.popupTemplate = null;
							u.sourceLayer = null;
							Object.defineProperty(a._assertThisInitialized(u), "uid", {
								value: f.generateUID(),
								configurable: !0
							});
							return u
						}
						a._inheritsLoose(h, t);
						var q = h.prototype;
						q.normalizeCtorArgs = function(u, x, y, w) {
							return u && !u.declaredClass ? u : {
								geometry: u,
								symbol: x,
								attributes: y,
								popupTemplate: w
							}
						};
						q.getEffectivePopupTemplate = function(u = !1) {
							if (this.popupTemplate) return this.popupTemplate;
							for (const x of [this.sourceLayer, this.layer])
								if (x) {
									if ("popupTemplate" in x && x.popupTemplate) return x.popupTemplate;
									if (u && "defaultPopupTemplate" in x && m.isSome(x.defaultPopupTemplate)) return x.defaultPopupTemplate
								} return null
						};
						q.getAttribute = function(u) {
							return this.attributes ? . [u]
						};
						q.setAttribute = function(u, x) {
							if (this.attributes) {
								const y = this.getAttribute(u);
								this.attributes[u] = x;
								this._notifyLayer("attributes", y, x, u)
							} else this.attributes = {
								[u]: x
							}, this._notifyLayer("attributes", void 0, x, u)
						};
						q.getObjectId =
							function() {
								return this.sourceLayer ? "objectIdField" in this.sourceLayer && this.sourceLayer.objectIdField ? this.getAttribute(this.sourceLayer.objectIdField) : null : null
							};
						q.toJSON = function() {
							var u = this.aggregateGeometries;
							if (m.isSome(u)) {
								var x = {};
								for (const y in u) {
									const w = u[y];
									w && (x[y] = w.toJSON())
								}
								u = 0 !== Object.keys(x)
									.length ? x : null
							} else u = null;
							return {
								aggregateGeometries: u,
								geometry: m.isSome(this.geometry) ? this.geometry.toJSON() : null,
								symbol: m.isSome(this.symbol) ? this.symbol.toJSON() : null,
								attributes: {
									...this.attributes
								},
								popupTemplate: this.popupTemplate && this.popupTemplate.toJSON()
							}
						};
						q.notifyGeometryChanged = function() {
							this._notifyLayer("geometry", this.geometry, this.geometry)
						};
						q.notifyMeshTransformChanged = function() {
							m.isSome(this.geometry) && "mesh" === this.geometry.type && this._notifyLayer("transform", this.geometry.transform, this.geometry.transform)
						};
						q._notifyLayer = function(u, x, y, w) {
							this.layer && "graphicChanged" in this.layer && (x = {
								graphic: this,
								property: u,
								oldValue: x,
								newValue: y
							}, "attributes" === u && (x.attributeName = w), this.layer.graphicChanged(x))
						};
						a._createClass(h, [{
							key: "aggregateGeometries",
							set: function(u) {
								const x = this._get("aggregateGeometries");
								JSON.stringify(x) !== JSON.stringify(u) && this._set("aggregateGeometries", u)
							}
						}, {
							key: "attributes",
							set: function(u) {
								const x = this._get("attributes");
								x !== u && (this._set("attributes", u), this._notifyLayer("attributes", x, u))
							}
						}, {
							key: "geometry",
							set: function(u) {
								const x = this._get("geometry");
								x !== u && (this._set("geometry", u), this._notifyLayer("geometry", x, u))
							}
						}, {
							key: "symbol",
							set: function(u) {
								const x = this._get("symbol");
								x !== u && (this._set("symbol", u), this._notifyLayer("symbol", x, u))
							}
						}, {
							key: "visible",
							set: function(u) {
								const x = this._get("visible");
								x !== u && (this._set("visible", u), this._notifyLayer("visible", x, u))
							}
						}]);
						return h
					}(k.ClonableMixin(v.JSONSupport));
					b.__decorate([g.property({
						value: null,
						json: {
							read: function(t) {
								if (!t) return null;
								const h = {};
								for (const q in t) {
									const u = n.fromJSON(t[q]);
									u && (h[q] = u)
								}
								return 0 !== Object.keys(h)
									.length ? h : null
							}
						}
					})], k.prototype, "aggregateGeometries", null);
					b.__decorate([g.property({
							value: null
						})],
						k.prototype, "attributes", null);
					b.__decorate([g.property({
						value: null,
						types: c.geometryTypes,
						json: {
							read: n.fromJSON
						}
					})], k.prototype, "geometry", null);
					b.__decorate([g.property({
						type: Boolean
					})], k.prototype, "isAggregate", void 0);
					b.__decorate([g.property({
						clonable: "reference"
					})], k.prototype, "layer", void 0);
					b.__decorate([g.property({
						type: e
					})], k.prototype, "popupTemplate", void 0);
					b.__decorate([g.property({
						clonable: "reference"
					})], k.prototype, "sourceLayer", void 0);
					b.__decorate([g.property({
							value: null,
							types: d.symbolTypes
						})],
						k.prototype, "symbol", null);
					b.__decorate([g.property({
						type: Boolean,
						value: !0
					})], k.prototype, "visible", null);
					k = b.__decorate([p.subclass("esri.Graphic")], k);
					(k || (k = {}))
					.generateUID = f.generateUID;
					return k
				})
		},
		"esri/renderers/visualVariables/VisualVariableFactory": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/jsonMap ../../core/Logger ../../core/Warning ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./ColorVariable ./OpacityVariable ./RotationVariable ./SizeVariable".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					const t = {
							color: l,
							size: n,
							opacity: r,
							rotation: p
						},
						h = new e.JSONMap({
							colorInfo: "color",
							transparencyInfo: "opacity",
							rotationInfo: "rotation",
							sizeInfo: "size"
						}),
						q = /^\[([^\]]+)\]$/i;
					c = function(u) {
						function x() {
							var w = u.apply(this, arguments) || this;
							w.colorVariables = null;
							w.opacityVariables = null;
							w.rotationVariables = null;
							w.sizeVariables = null;
							return w
						}
						a._inheritsLoose(x, u);
						var y = x.prototype;
						y.readVariables = function(w, A, B) {
							const {
								rotationExpression: E,
								rotationType: z
							} = A;
							if (A = (A = E &&
								E.match(q)) && A[1]) w || (w = []), w.push({
								type: "rotationInfo",
								rotationType: z,
								field: A
							});
							if (w) return w.map(C => {
								var D = h.read(C.type);
								const J = t[D];
								J || (d.getLogger(this.declaredClass)
									.warn(`Unknown variable type: ${D}`), B && B.messages && B.messages.push(new k("visual-variable:unsupported", `visualVariable of type '${D}' is not supported`, {
										definition: C,
										context: B
									})));
								D = new J;
								D.read(C, B);
								return D
							})
						};
						y.writeVariables = function(w, A) {
							const B = [];
							for (const E of w)(w = E.toJSON(A)) && B.push(w);
							return B
						};
						y._resetVariables = function() {
							this.colorVariables = [];
							this.opacityVariables = [];
							this.rotationVariables = [];
							this.sizeVariables = []
						};
						a._createClass(x, [{
							key: "visualVariables",
							set: function(w) {
								this._resetVariables();
								if ((w = w && w.filter(B => !!B)) && w.length) {
									for (var A of w) switch (A.type) {
										case "color":
											this.colorVariables.push(A);
											break;
										case "opacity":
											this.opacityVariables.push(A);
											break;
										case "rotation":
											this.rotationVariables.push(A);
											break;
										case "size":
											this.sizeVariables.push(A)
									}
									this.sizeVariables.length && this.sizeVariables.some(B => !!B.target) && w.sort((B, E) => {
										let z =
											null;
										return z = B.target === E.target ? 0 : B.target ? 1 : -1
									});
									for (A = 0; A < w.length; A++) w[A].index = A
								}
								this._set("visualVariables", w)
							}
						}]);
						return x
					}(c);
					b.__decorate([v.property()], c.prototype, "visualVariables", null);
					return c = b.__decorate([g.subclass("esri.renderers.visualVariables.VisualVariableFactory")], c)
				})
		},
		"esri/renderers/support/ClassBreakInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./commonProperties".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					c = f = function(g) {
						function l(p) {
							p = g.call(this, p) || this;
							p.description = null;
							p.label = null;
							p.minValue = null;
							p.maxValue = 0;
							p.symbol = null;
							return p
						}
						a._inheritsLoose(l, g);
						var r = l.prototype;
						r.clone = function() {
							return new f({
								description: this.description,
								label: this.label,
								minValue: this.minValue,
								maxValue: this.maxValue,
								symbol: this.symbol ? this.symbol.clone() : null
							})
						};
						r.getMeshHash = function() {
							const p = JSON.stringify(this.symbol);
							return `${this.minValue}.${this.maxValue}.${p}`
						};
						return l
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "description", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "label", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							read: {
								source: "classMinValue"
							},
							write: {
								target: "classMinValue"
							}
						}
					})], c.prototype, "minValue", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							read: {
								source: "classMaxValue"
							},
							write: {
								target: "classMaxValue"
							}
						}
					})], c.prototype, "maxValue", void 0);
					b.__decorate([e.property(m.rendererSymbolProperty)],
						c.prototype, "symbol", void 0);
					return c = f = b.__decorate([v.subclass("esri.renderers.support.ClassBreakInfo")], c)
				})
		},
		"esri/renderers/support/commonProperties": function() {
			define("exports ../../symbols ../../core/accessorSupport/extensions/serializableProperty/reader ../../symbols/support/jsonUtils ../../symbols/Symbol ../../symbols/PolygonSymbol3D".split(" "), function(a, b, c, e, d, k) {
				c = {
					types: b.symbolTypesRenderer,
					json: {
						write: {
							writer: e.write
						},
						origins: {
							"web-scene": {
								types: b.symbolTypesRenderer3D,
								write: {
									writer: e.write
								},
								read: {
									reader: c.createTypeReader({
										types: b.symbolTypesRenderer3D
									})
								}
							}
						}
					}
				};
				const v = {
					cast: m => null == m || "string" === typeof m || "number" === typeof m ? m : `${m}`,
					json: {
						type: String,
						write: {
							writer: (m, f) => {
								f.value = m ? .toString()
							}
						}
					}
				};
				a.rendererBackgroundFillSymbolProperty = {
					types: {
						base: d,
						key: "type",
						typeMap: {
							"simple-fill": b.symbolTypes.typeMap["simple-fill"],
							"picture-fill": b.symbolTypes.typeMap["picture-fill"],
							"polygon-3d": b.symbolTypes.typeMap["polygon-3d"]
						}
					},
					json: {
						write: {
							writer: e.write
						},
						origins: {
							"web-scene": {
								type: k,
								write: {
									writer: e.write
								}
							}
						}
					}
				};
				a.rendererSymbolProperty = c;
				a.uniqueValueProperty = v;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/support/jsonUtils": function() {
			define("exports ../../symbols ../../core/Error ../../core/maybe ../Symbol3D ./symbolConversion ../WebStyleSymbol".split(" "), function(a, b, c, e, d, k, v) {
				function m(g, l, r) {
					if (e.isNone(g)) return null;
					const {
						context: p,
						isLabelSymbol: n
					} = r;
					var t = p ? .origin;
					r = p ? .messages;
					if ("web-scene" === t && !(g instanceof d || g instanceof v)) {
						t =
							k.to3D(g, {
								retainCIM: !0,
								hasLabelingContext: n
							});
						if (e.isSome(t.symbol)) return t.symbol.write(l, p);
						r ? .push(new c("symbol:unsupported", `Symbols of type '${g.declaredClass}' are not supported in scenes. Use 3D symbology instead when working with WebScene and SceneView`, {
							symbol: g,
							context: p,
							error: t.error
						}));
						return null
					}
					const h = p ? .layer ? .type;
					return "web-map" !== t && ("portal-item" !== t || h && f.includes(h)) || !(g instanceof d || g instanceof v) ? g.write(l, p) : (r ? .push(new c("symbol:unsupported", `Symbols of type '${g.declaredClass}' are not supported in web maps and portal items. Use 2D symbology and CIMSymbol instead when working with MapView`, {
						symbol: g,
						context: p
					})), null)
				}
				const f = ["building-scene", "integrated-mesh", "point-cloud", "scene"];
				a.fromJSON = function(g, l) {
					return b.readSymbol(g, null, l)
				};
				a.write = function(g, l, r, p) {
					g = m(g, {}, {
						context: p,
						isLabelSymbol: !1
					});
					e.isSome(g) && (l[r] = g)
				};
				a.writeLabelSymbol = function(g, l, r, p) {
					g = m(g, {}, {
						context: p,
						isLabelSymbol: !0
					});
					e.isSome(g) && (l[r] = g)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/support/symbolConversion": function() {
			define("exports ../../symbols ../../core/Error ../WebStyleSymbol ../PointSymbol3D ../SimpleLineSymbol ../LineSymbol3D ../SimpleMarkerSymbol ../PictureMarkerSymbol ../SimpleFillSymbol ../MeshSymbol3D ../PolygonSymbol3D ../TextSymbol ../LabelSymbol3D".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					const t = {
						retainId: !1,
						ignoreDrivers: !1,
						hasLabelingContext: !0
					};
					a.defaultTo3DOptions = t;
					a.to3D = function(h, q = t) {
						if (!h) return {
							symbol: null
						};
						const {
							retainId: u = t.retainId,
							ignoreDrivers: x = t.ignoreDrivers,
							hasLabelingContext: y = t.hasLabelingContext,
							retainCIM: w = t.retainCIM
						} = q;
						var A = null;
						if (b.isSymbol3D(h) || h instanceof e) A = h.clone();
						else if ("cim" === h.type) {
							A = h.data ? .symbol ? .type;
							if ("CIMPointSymbol" !== A) return {
								error: new c("symbol-conversion:unsupported-cim-symbol", `CIM symbol of type '${A||
"unknown"}' is unsupported in 3D`, {
									symbol: h
								})
							};
							A = w ? h.clone() : d.fromCIMSymbol(h)
						} else if (h instanceof k) A = v.fromSimpleLineSymbol(h);
						else if (h instanceof m) A = d.fromSimpleMarkerSymbol(h);
						else if (h instanceof f) A = d.fromPictureMarkerSymbol(h);
						else if (h instanceof g) A = q.geometryType && "mesh" === q.geometryType ? l.fromSimpleFillSymbol(h) : r.fromSimpleFillSymbol(h);
						else if (h instanceof p) A = y ? n.fromTextSymbol(h) : d.fromTextSymbol(h);
						else return {
							error: new c("symbol-conversion:unsupported-2d-symbol", `2D symbol of type '${h.type||
h.declaredClass}' is unsupported in 3D`, {
								symbol: h
							})
						};
						u && A && "cim" !== A.type && (A.id = h.id);
						if (x && b.isSymbol3D(A))
							for (h = 0; h < A.symbolLayers.length; ++h) A.symbolLayers.getItemAt(h)
								._ignoreDrivers = !0;
						return {
							symbol: A
						}
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/DictionaryRenderer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../layers/support/fieldUtils ./Renderer ./mixins/VisualVariablesMixin ./support/DictionaryLoader".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					d = r = function(p) {
						function n(h) {
							h = p.call(this, h) || this;
							h.config = null;
							h.fieldMap = null;
							h.scaleExpression = null;
							h.scaleExpressionTitle = null;
							h.url = null;
							h.type = "dictionary";
							return h
						}
						a._inheritsLoose(n, p);
						var t = n.prototype;
						t.writeData = function(h, q) {
							h && (q.scalingExpressionInfo = {
								expression: h,
								returnType: "number"
							})
						};
						t.writeVisualVariables = function(h, q, u, x) {
							x ? .origin || p.prototype.writeVisualVariables.call(this, h, q, u, x)
						};
						t.clone = function() {
							return new r({
								config: c.clone(this.config),
								scaleExpression: this.scaleExpression,
								scaleExpressionTitle: this.scaleExpressionTitle,
								fieldMap: c.clone(this.fieldMap),
								url: c.clone(this.url),
								visualVariables: c.clone(this.visualVariables)
							})
						};
						t.getSymbolAsync = function() {
							var h = a._asyncToGenerator(function*(q, u) {
								return this._loader.getSymbolAsync(q, u)
							});
							return function(q, u) {
								return h.apply(this, arguments)
							}
						}();
						t.collectRequiredFields = function() {
							var h = a._asyncToGenerator(function*(q, u) {
								yield this.collectVVRequiredFields(q, u);
								this.scaleExpression && (yield m.collectArcadeFieldNames(q,
									u, this.scaleExpression));
								for (const x in this.fieldMap) {
									const y = this.fieldMap[x];
									u.has(y) && q.add(y)
								}
							});
							return function(q, u) {
								return h.apply(this, arguments)
							}
						}();
						t.getSymbol = function() {
							return null
						};
						t.getSymbols = function() {
							return []
						};
						t.getAttributeHash = function() {
							return this.visualVariables && this.visualVariables.reduce((h, q) => h + q.getAttributeHash(), "")
						};
						t.getMeshHash = function() {
							return `${this.url}-${JSON.stringify(this.fieldMap)}`
						};
						t.getSymbolFields = function() {
							return this._loader.getSymbolFields()
						};
						a._createClass(n,
							[{
								key: "_loader",
								get: function() {
									return new l.DictionaryLoader(this.url, this.config, this.fieldMap)
								}
							}, {
								key: "arcadeRequired",
								get: function() {
									return !0
								}
							}]);
						return n
					}(g.VisualVariablesMixin(f));
					b.__decorate([e.property({
						type: l.DictionaryLoader
					})], d.prototype, "_loader", null);
					b.__decorate([e.property({
						type: Object,
						json: {
							read: {
								source: "configuration"
							},
							write: {
								target: "configuration"
							}
						}
					})], d.prototype, "config", void 0);
					b.__decorate([e.property({
						type: Object,
						json: {
							write: !0
						}
					})], d.prototype, "fieldMap", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							read: {
								source: "scalingExpressionInfo.expression"
							},
							write: !0
						}
					})], d.prototype, "scaleExpression", void 0);
					b.__decorate([v.writer("scaleExpression")], d.prototype, "writeData", null);
					b.__decorate([e.property({
						type: String,
						json: {
							read: {
								source: "scalingExpressionInfo.title"
							},
							write: {
								target: "scalingExpressionInfo.title",
								overridePolicy(p) {
									return {
										enabled: !!p && !!this.scaleExpression
									}
								}
							}
						}
					})], d.prototype, "scaleExpressionTitle", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], d.prototype, "url", void 0);
					b.__decorate([v.writer("visualVariables")], d.prototype, "writeVisualVariables", null);
					return d = r = b.__decorate([k.subclass("esri.renderers.DictionaryRenderer")], d)
				})
		},
		"esri/renderers/support/DictionaryLoader": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../Color ../../request ../../core/Error ../../core/Logger ../../core/LRUCache ../../core/maybe ../../core/promiseUtils ../../core/string ../../support/arcadeOnDemand ../../symbols/CIMSymbol".split(" "), function(a, b, c, e, d, k, v, m,
				f, g, l, r) {
				function p(h, q) {
					if (h && (h = h.symbolLayers))
						for (var u = h.length; u--;) {
							var x = h[u];
							if (x && !1 !== x.enable) switch (x.type) {
								case "CIMVectorMarker":
									var y = q;
									if (x = x.markerGraphics)
										for (const w of x)
											if (w && (x = w.symbol)) switch (x.type) {
												case "CIMPointSymbol":
												case "CIMLineSymbol":
												case "CIMPolygonSymbol":
													p(x, y);
													break;
												case "CIMTextSymbol":
													x.fieldMap = y
											}
							}
						}
				}
				const n = {
					type: "CIMSimpleLineCallout",
					lineSymbol: {
						type: "CIMLineSymbol",
						symbolLayers: [{
							type: "CIMSolidStroke",
							width: .5,
							color: [0, 0, 0, 255]
						}]
					}
				};
				let t = function() {
					function h(u,
						x, y) {
						this.url = this.fieldMap = this.config = null;
						this._ongoingRequests = new Map;
						this._symbolCache = new v(100);
						this._dictionaryPromise = null;
						this.url = u;
						this.config = x;
						this.fieldMap = y
					}
					var q = h.prototype;
					q.getSymbolFields = function() {
						return this._symbolFields
					};
					q.getSymbolAsync = function() {
						var u = b._asyncToGenerator(function*(x, y) {
							this._dictionaryPromise || (this._dictionaryPromise = this.fetchResources(y));
							try {
								var w = yield this._dictionaryPromise
							} catch (D) {
								if (f.isAbortError(D)) return this._dictionaryPromise = null
							}
							var A = {};
							if (this.fieldMap)
								for (var B of this._symbolFields) {
									var E = this.fieldMap[B];
									A[B] = E && null != x.attributes[E] ? "" + x.attributes[E] : ""
								}
							w = w ? .(A, y);
							if (!w || "string" !== typeof w) return null;
							const z = g.numericHash(w)
								.toString();
							if (A = this._symbolCache.get(z)) return A.catch(() => {
								this._symbolCache.pop(z)
							}), A;
							B = w.split(";");
							w = [];
							A = [];
							for (const D of B)
								if (D)
									if (D.includes("po:")) {
										var C = D.substr(3)
											.split("|");
										3 === C.length && (B = C[0], E = C[1], C = C[2], "DashTemplate" === E ? C = C.split(" ")
											.map(J => Number(J)) : "Color" === E ? (C = (new c(C))
												.toRgba(),
												C = [C[0], C[1], C[2], 255 * C[3]]) : C = Number(C), A.push({
												primitiveName: B,
												propertyName: E,
												value: C
											}))
									} else if (D.includes("|"))
								for (const J of D.split("|")) {
									if (this._itemNames.has(J)) {
										w.push(J);
										break
									}
								} else this._itemNames.has(D) && w.push(D);
							x = m.isSome(x.geometry) && (x.geometry.hasZ || "point" !== x.geometry.type) ? !1 : !0;
							y = this._cimPartsToCIMSymbol(w, A, x, y);
							this._symbolCache.put(z, y, 1);
							return y
						});
						return function(x, y) {
							return u.apply(this, arguments)
						}
					}();
					q.fetchResources = function() {
						var u = b._asyncToGenerator(function*(x) {
							if (this._dictionaryPromise) return this._dictionaryPromise;
							if (this.url) {
								var y = e(this.url + "/resources/styles/dictionary-info.json", {
										responseType: "json",
										query: {
											f: "json"
										},
										signal: m.isSome(x) ? x.signal : null
									}),
									[{
										data: w
									}] = yield Promise.all([y, l.loadArcade()]);
								if (!w) throw this._dictionaryPromise = null, new d("esri.renderers.DictionaryRenderer", "Bad dictionary data!");
								y = w.expression;
								var A = w.authoringInfo;
								this._refSymbolUrlTemplate = this.url + "/" + w.cimRefTemplateUrl;
								this._itemNames = new Set(w.itemsNames);
								this._symbolFields = A.symbol;
								w = {};
								if (this.config) {
									const z = this.config;
									for (var B in z) w[B] = z[B]
								}
								if (A.configuration)
									for (var E of A.configuration) w.hasOwnProperty(E.name) || (w[E.name] = E.value);
								B = [];
								if (m.isSome(x) && x.fields && this.fieldMap)
									for (const z of this._symbolFields) {
										const C = this.fieldMap[z];
										E = x.fields.filter(D => D.name === C);
										0 < E.length && B.push({
											...E[0],
											name: z
										})
									}
								return this._dictionaryPromise = x = l.createDictionaryExpression(y, m.isSome(x) ? x.spatialReference : null, B, w)
									.then(z => {
										const C = {
											scale: 0
										};
										return (D, J) => {
											if (m.isNone(z)) return null;
											D = z.repurposeFeature({
												geometry: null,
												attributes: D
											});
											C.scale = m.isSome(J) ? J.scale : void 0;
											return z.evaluate({
												$feature: D,
												$view: C
											})
										}
									})
									.catch(z => {
										k.getLogger("esri.renderers.support.DictionaryLoader")
											.error("Creating dictinoary expression failed:", z);
										return null
									})
							}
							k.getLogger("esri.renderers.support.DictionaryLoader")
								.error("no valid URL!")
						});
						return function(x) {
							return u.apply(this, arguments)
						}
					}();
					q._cimPartsToCIMSymbol = function() {
						var u = b._asyncToGenerator(function*(x, y, w, A) {
							const B = Array(x.length);
							for (let E = 0; E < x.length; E++) B[E] = this._getSymbolPart(x[E],
								A);
							x = yield Promise.all(B);
							if (A = this.fieldMap)
								for (const E of x) p(E, A);
							return new r({
								data: this._combineSymbolParts(x, y, w)
							})
						});
						return function(x, y, w, A) {
							return u.apply(this, arguments)
						}
					}();
					q._getSymbolPart = function() {
						var u = b._asyncToGenerator(function*(x, y) {
							if (this._ongoingRequests.has(x)) return this._ongoingRequests.get(x)
								.then(A => A.data);
							const w = this._refSymbolUrlTemplate.replace(/\{itemName\}/gi, x);
							y = e(w, {
								responseType: "json",
								query: {
									f: "json"
								},
								...y
							});
							this._ongoingRequests.set(x, y);
							try {
								return (yield y)
									.data
							} catch (A) {
								throw this._ongoingRequests.delete(x),
									A;
							}
						});
						return function(x, y) {
							return u.apply(this, arguments)
						}
					}();
					q._combineSymbolParts = function(u, x, y) {
						if (!u || 0 === u.length) return null;
						const w = {
							...u[0]
						};
						if (1 < u.length) {
							w.symbolLayers = [];
							for (const A of u) w.symbolLayers.unshift(...A.symbolLayers)
						}
						y && (w.callout = n);
						return {
							type: "CIMSymbolReference",
							symbol: w,
							primitiveOverrides: x
						}
					};
					return h
				}();
				a.DictionaryLoader = t;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/LRUCache": function() {
			define(["../chunks/_rollupPluginBabelHelpers",
				"./MemCache"
			], function(a, b) {
				return function() {
					function c(d, k) {
						this._storage = new b.MemCacheStorage;
						this._storage.maxSize = d;
						k && this._storage.registerRemoveFunc("", k)
					}
					var e = c.prototype;
					e.put = function(d, k, v) {
						this._storage.put(d, k, v, 1)
					};
					e.pop = function(d) {
						return this._storage.pop(d)
					};
					e.get = function(d) {
						return this._storage.get(d)
					};
					e.clear = function() {
						this._storage.clearAll()
					};
					e.destroy = function() {
						this._storage.destroy()
					};
					a._createClass(c, [{
						key: "maxSize",
						get: function() {
							return this._storage.maxSize
						},
						set: function(d) {
							this._storage.maxSize =
								d
						}
					}]);
					return c
				}()
			})
		},
		"esri/core/MemCache": function() {
			define(["exports", "../chunks/_rollupPluginBabelHelpers", "./maybe", "./PooledArray"], function(a, b, c, e) {
				a.RemoveMode = void 0;
				(function(v) {
					v[v.ALL = 0] = "ALL";
					v[v.SOME = 1] = "SOME"
				})(a.RemoveMode || (a.RemoveMode = {}));
				let d = function() {
						function v(f, g, l) {
							this._namespace = f;
							this._storage = g;
							this._removeFunc = !1;
							this._miss = this._hit = 0;
							this._storage.register(this);
							this._namespace += ":";
							l && (this._storage.registerRemoveFunc(this._namespace, l), this._removeFunc = !0)
						}
						var m =
							v.prototype;
						m.destroy = function() {
							this._storage.clear(this._namespace);
							this._removeFunc && this._storage.deregisterRemoveFunc(this._namespace);
							this._storage.deregister(this);
							this._storage = null
						};
						m.resetHitRate = function() {
							this._hit = this._miss = 0
						};
						m.put = function(f, g, l, r = 0) {
							this._storage.put(this._namespace + f, g, l, r)
						};
						m.get = function(f) {
							f = this._storage.get(this._namespace + f);
							void 0 === f ? ++this._miss : ++this._hit;
							return f
						};
						m.pop = function(f) {
							f = this._storage.pop(this._namespace + f);
							void 0 === f ? ++this._miss : ++this._hit;
							return f
						};
						m.updateSize = function(f, g, l) {
							this._storage.updateSize(this._namespace + f, g, l)
						};
						m.clear = function() {
							this._storage.clear(this._namespace)
						};
						m.clearAll = function() {
							this._storage.clearAll()
						};
						m.getStats = function() {
							return this._storage.getStats()
						};
						m.resetStats = function() {
							this._storage.resetStats()
						};
						b._createClass(v, [{
								key: "namespace",
								get: function() {
									return this._namespace.slice(0, -1)
								}
							}, {
								key: "hitRate",
								get: function() {
									return this._hit / (this._hit + this._miss)
								}
							}, {
								key: "size",
								get: function() {
									return this._storage.size
								}
							},
							{
								key: "maxSize",
								get: function() {
									return this._storage.maxSize
								}
							}
						]);
						return v
					}(),
					k = function() {
						function v(f = 10485760) {
							this._maxSize = f;
							this._db = new Map;
							this._miss = this._hit = this._size = 0;
							this._removeFuncs = new e;
							this._users = new e
						}
						var m = v.prototype;
						m.destroy = function() {
							this.clearAll();
							this._removeFuncs.clear();
							this._users.clear();
							this._db = null
						};
						m.register = function(f) {
							this._users.push(f)
						};
						m.deregister = function(f) {
							this._users.removeUnordered(f)
						};
						m.registerRemoveFunc = function(f, g) {
							this._removeFuncs.push([f, g])
						};
						m.deregisterRemoveFunc = function(f) {
							this._removeFuncs.filterInPlace(g => g[0] !== f)
						};
						m.put = function(f, g, l, r) {
							const p = this._db.get(f);
							p && (this._size -= p.size, this._db.delete(f), p.entry !== g && this._notifyRemove(f, p.entry, a.RemoveMode.ALL));
							l > this._maxSize ? this._notifyRemove(f, g, a.RemoveMode.ALL) : void 0 === g ? console.warn("Refusing to cache undefined entry ") : !l || 0 > l ? console.warn("Refusing to cache entry with invalid size " + l) : (r = 1 + Math.max(r, -3) - -3, this._db.set(f, {
									entry: g,
									size: l,
									lifetime: r,
									lives: r
								}), this._size +=
								l, this._checkSizeLimit())
						};
						m.updateSize = function(f, g, l) {
							const r = this._db.get(f);
							if (r && r.entry === g) {
								for (this._size -= r.size; l > this._maxSize;)
									if (l = this._notifyRemove(f, g, a.RemoveMode.SOME), !(c.isSome(l) && 0 < l)) {
										this._db.delete(f);
										return
									} r.size = l;
								this._size += l;
								this._checkSizeLimit()
							}
						};
						m.pop = function(f) {
							const g = this._db.get(f);
							if (g) return this._size -= g.size, this._db.delete(f), ++this._hit, g.entry;
							++this._miss
						};
						m.get = function(f) {
							const g = this._db.get(f);
							if (void 0 === g) ++this._miss;
							else return this._db.delete(f),
								g.lives = g.lifetime, this._db.set(f, g), ++this._hit, g.entry
						};
						m.getStats = function() {
							const f = {
									Size: Math.round(this._size / 1048576) + "/" + Math.round(this._maxSize / 1048576) + "MB",
									"Hit rate": Math.round(100 * this._getHitRate()) + "%",
									Entries: this._db.size.toString()
								},
								g = {},
								l = [];
							this._db.forEach((n, t) => {
								const h = n.lifetime;
								l[h] = (l[h] || 0) + n.size;
								this._users.forAll(q => {
									q = q.namespace;
									t.startsWith(q) && (g[q] = (g[q] || 0) + n.size)
								})
							});
							const r = {};
							this._users.forAll(n => {
								const t = n.namespace;
								!isNaN(n.hitRate) && 0 < n.hitRate ? (g[t] =
									g[t] || 0, r[t] = Math.round(100 * n.hitRate) + "%") : r[t] = "0%"
							});
							var p = Object.keys(g);
							p.sort((n, t) => g[t] - g[n]);
							p.forEach(n => f[n] = Math.round(g[n] / 2 ** 20) + "MB / " + r[n]);
							for (p = l.length - 1; 0 <= p; --p) {
								const n = l[p];
								n && (f["Priority " + (p + -3 - 1)] = Math.round(n / this.size * 100) + "%")
							}
							return f
						};
						m.resetStats = function() {
							this._hit = this._miss = 0;
							this._users.forAll(f => f.resetHitRate())
						};
						m.clear = function(f) {
							this._db.forEach((g, l) => {
								l.startsWith(f) && (this._size -= g.size, this._db.delete(l), this._notifyRemove(l, g.entry, a.RemoveMode.ALL))
							})
						};
						m.clearAll = function() {
							this._db.forEach((f, g) => this._notifyRemove(g, f.entry, a.RemoveMode.ALL));
							this._size = 0;
							this._db.clear()
						};
						m._getHitRate = function() {
							return this._hit / (this._hit + this._miss)
						};
						m._notifyRemove = function(f, g, l) {
							let r;
							this._removeFuncs.some(p => f.startsWith(p[0]) ? (p = p[1](g, l), "number" === typeof p && (r = p), !0) : !1);
							return r
						};
						m._checkSizeLimit = function() {
							if (!(this._size <= this._maxSize))
								for (const [f, g] of this._db) {
									this._db.delete(f);
									if (1 >= g.lives) {
										this._size -= g.size;
										const l = this._notifyRemove(f,
											g.entry, a.RemoveMode.SOME);
										c.isSome(l) && 0 < l && (this._size += l, g.lives = g.lifetime, g.size = l, this._db.set(f, g))
									} else --g.lives, this._db.set(f, g);
									if (this._size <= .9 * this.maxSize) break
								}
						};
						b._createClass(v, [{
							key: "size",
							get: function() {
								return this._size
							}
						}, {
							key: "maxSize",
							get: function() {
								return this._maxSize
							},
							set: function(f) {
								this._maxSize = Math.max(f, 0);
								this._checkSizeLimit()
							}
						}]);
						return v
					}();
				a.MIN_PRIORITY = -3;
				a.MemCache = d;
				a.MemCacheStorage = k;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/renderers/DotDensityRenderer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ../layers/support/fieldUtils ./Renderer ./mixins/VisualVariablesMixin ./support/AttributeColorInfo ./support/DotDensityLegendOptions ../symbols/SimpleFillSymbol ../symbols/SimpleLineSymbol".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					var h;
					k = h = function(q) {
						function u(y) {
							y = q.call(this, y) || this;
							y.attributes = null;
							y.backgroundColor = new c([0, 0, 0, 0]);
							y.dotBlendingEnabled = !0;
							y.dotShape = "square";
							y.dotSize = 1;
							y.legendOptions = null;
							y.outline = new t;
							y.dotValue = null;
							y.referenceScale = null;
							y.seed = 1;
							y.type = "dot-density";
							return y
						}
						a._inheritsLoose(u, q);
						var x = u.prototype;
						x.calculateDotValue = function(y) {
							if (null == this.referenceScale) return this.dotValue;
							y = y / this.referenceScale * this.dotValue;
							return 1 > y ? 1 : y
						};
						x.getSymbol =
							function() {
								return new n({
									outline: this.outline
								})
							};
						x.getSymbolAsync = function() {
							var y = a._asyncToGenerator(function*() {
								return this.getSymbol()
							});
							return function() {
								return y.apply(this, arguments)
							}
						}();
						x.getSymbols = function() {
							return [this.getSymbol()]
						};
						x.getAttributeHash = function() {
							return this.attributes ? .reduce((y, w) => y + w.getAttributeHash(), "") ? ? ""
						};
						x.getMeshHash = function() {
							return JSON.stringify(this.outline)
						};
						x.clone = function() {
							return new h({
								attributes: e.clone(this.attributes),
								backgroundColor: e.clone(this.backgroundColor),
								dotBlendingEnabled: e.clone(this.dotBlendingEnabled),
								dotShape: e.clone(this.dotShape),
								dotSize: e.clone(this.dotSize),
								dotValue: e.clone(this.dotValue),
								legendOptions: e.clone(this.legendOptions),
								outline: e.clone(this.outline),
								referenceScale: e.clone(this.referenceScale),
								visualVariables: e.clone(this.visualVariables),
								authoringInfo: this.authoringInfo && this.authoringInfo.clone()
							})
						};
						x.getControllerHash = function() {
							const y = this.attributes ? .map(A => A.field || A.valueExpression || ""),
								w = this.outline && JSON.stringify(this.outline.toJSON()) ||
								"";
							return `${y}-${w}`
						};
						x.collectRequiredFields = function() {
							var y = a._asyncToGenerator(function*(w, A) {
								yield this.collectVVRequiredFields(w, A);
								for (const B of this.attributes ? ? []) B.valueExpression && (yield f.collectArcadeFieldNames(w, A, B.valueExpression)), B.field && w.add(B.field)
							});
							return function(w, A) {
								return y.apply(this, arguments)
							}
						}();
						return u
					}(l.VisualVariablesMixin(g));
					b.__decorate([d.property({
						type: [r],
						json: {
							write: !0
						}
					})], k.prototype, "attributes", void 0);
					b.__decorate([d.property({
							type: c,
							json: {
								write: !0
							}
						})],
						k.prototype, "backgroundColor", void 0);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], k.prototype, "dotBlendingEnabled", void 0);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !1
						}
					})], k.prototype, "dotShape", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "dotSize", void 0);
					b.__decorate([d.property({
						type: p,
						json: {
							write: !0
						}
					})], k.prototype, "legendOptions", void 0);
					b.__decorate([d.property({
						type: t,
						json: {
							default: null,
							write: !0
						}
					})], k.prototype, "outline", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "dotValue", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "referenceScale", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "seed", void 0);
					b.__decorate([v.enumeration({
						dotDensity: "dot-density"
					})], k.prototype, "type", void 0);
					return k = h = b.__decorate([m.subclass("esri.renderers.DotDensityRenderer")], k)
				})
		},
		"esri/renderers/support/AttributeColorInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/JSONSupport ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/ensureType".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					e = l = function(r) {
						function p(t) {
							t = r.call(this, t) || this;
							t.color = null;
							t.field = null;
							t.label = null;
							t.valueExpression = null;
							t.valueExpressionTitle = null;
							return t
						}
						a._inheritsLoose(p, r);
						var n = p.prototype;
						n.castField = function(t) {
							return null == t ? t : "function" === typeof t ? (d.getLogger(this.declaredClass)
								.error(".field: field must be a string value"), null) : g.ensureString(t)
						};
						n.getAttributeHash = function() {
							return `${this.field}-${this.valueExpression}`
						};
						n.clone = function() {
							return new l({
								color: this.color &&
									this.color.clone(),
								field: this.field,
								label: this.label,
								valueExpression: this.valueExpression,
								valueExpressionTitle: this.valueExpressionTitle
							})
						};
						return p
					}(e.JSONSupport);
					b.__decorate([k.property({
						type: c,
						json: {
							type: [Number],
							write: !0
						}
					})], e.prototype, "color", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "field", void 0);
					b.__decorate([m.cast("field")], e.prototype, "castField", null);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "label", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "valueExpression", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "valueExpressionTitle", void 0);
					return e = l = b.__decorate([f.subclass("esri.renderers.support.AttributeColorInfo")], e)
				})
		},
		"esri/renderers/support/DotDensityLegendOptions": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					c = m = function(f) {
						function g() {
							var l = f.apply(this, arguments) || this;
							l.unit = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								unit: this.unit
							})
						};
						return g
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "unit", void 0);
					return c = m = b.__decorate([v.subclass("esri.renderers.support.DotDensityLegendOptions")], c)
				})
		},
		"esri/renderers/HeatmapRenderer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../symbols ../core/deprecate ../core/lang ../core/Logger ../core/scheduling ../core/screenUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/utils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ../layers/support/fieldUtils ./Renderer ./support/AuthoringInfo ./support/HeatmapColorStop ./support/HeatmapLegendOptions ./support/heatmapUtils ../symbols/SimpleMarkerSymbol".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w) {
					function A(z) {
						if (null != z) {
							const {
								maxDensity: C,
								minDensity: D,
								radius: J
							} = z;
							if (null != C || null != D || null != J) {
								const {
									blurRadius: K,
									maxPixelIntensity: H,
									minPixelIntensity: G,
									...F
								} = z;
								return F
							}
						}
						return z
					}
					var B;
					const E = v.getLogger("esri.renderers.HeatmapRenderer");
					e = B = function(z) {
						function C(J) {
							J = z.call(this, J) || this;
							J.authoringInfo = null;
							J.colorStops = [new u({
								ratio: 0,
								color: new c("rgba(255, 140, 0, 0)")
							}), new u({
								ratio: .75,
								color: new c("rgba(255, 140, 0, 1)")
							}), new u({
								ratio: .9,
								color: new c("rgba(255, 0,   0, 1)")
							})];
							J.field = null;
							J.fieldOffset = 0;
							J.legendOptions = null;
							J.maxDensity = .04;
							J.minDensity = 0;
							J.radius = 18;
							J.referenceScale = 0;
							J.type = "heatmap";
							J.valueExpression = null;
							J.valueExpressionTitle = null;
							J._warnedProps = {
								blurRadius: !1,
								maxPixelIntensity: !1,
								minPixelIntensity: !1
							};
							return J
						}
						a._inheritsLoose(C, z);
						var D = C.prototype;
						D.normalizeCtorArgs = function(J) {
							return A(J)
						};
						D._warnAboutDeprecatedGaussianBlurProp = function(J, K) {
							this._warnedProps[J] || "user" !== l.getProperties(this)
								.getDefaultOrigin() ||
								(this._warnedProps[J] = !0, m.schedule(() => {
									d.deprecatedProperty(E, J, {
										replacement: `${String(K)} (suggested value: ${this._get(K)})`,
										version: "4.24"
									})
								}))
						};
						D.read = function(J, K) {
							J = A(J);
							z.prototype.read.call(this, J, K)
						};
						D.getSymbol = function() {
							return new w
						};
						D.getSymbolAsync = function() {
							var J = a._asyncToGenerator(function*() {
								return this.getSymbol()
							});
							return function() {
								return J.apply(this, arguments)
							}
						}();
						D.getSymbols = function() {
							return [this.getSymbol()]
						};
						D.collectRequiredFields = function() {
							var J = a._asyncToGenerator(function*(K,
								H) {
								const G = this.field,
									F = this.valueExpression;
								G && "string" === typeof G && (yield t.collectField(K, H, G));
								F && "string" === typeof F && (yield t.collectArcadeFieldNames(K, H, F))
							});
							return function(K, H) {
								return J.apply(this, arguments)
							}
						}();
						D.getAttributeHash = function() {
							return null
						};
						D.getMeshHash = function() {
							return `${JSON.stringify(this.colorStops)}.${this.blurRadius}.${this.field}`
						};
						D.clone = function() {
							return new B({
								authoringInfo: this.authoringInfo && this.authoringInfo.clone(),
								colorStops: k.clone(this.colorStops),
								field: this.field,
								legendOptions: k.clone(this.legendOptions),
								maxDensity: this.maxDensity,
								minDensity: this.minDensity,
								radius: this.radius,
								referenceScale: this.referenceScale,
								valueExpression: this.valueExpression,
								valueExpressionTitle: this.valueExpressionTitle
							})
						};
						a._createClass(C, [{
							key: "blurRadius",
							get: function() {
								return y.kernelDensityRadiusPtToGaussianBlurRadiusPx(this.radius)
							},
							set: function(J) {
								const K = this.maxPixelIntensity,
									H = this.minPixelIntensity;
								this._set("radius", y.gaussianBlurRadiusPxToKernelDensityRadiusPt(J));
								this._warnAboutDeprecatedGaussianBlurProp("blurRadius",
									"radius");
								this._set("maxDensity", K * this._pixelIntensityToDensity);
								this._set("minDensity", H * this._pixelIntensityToDensity)
							}
						}, {
							key: "maxPixelIntensity",
							get: function() {
								return this.maxDensity / this._pixelIntensityToDensity
							},
							set: function(J) {
								this._set("maxDensity", J * this._pixelIntensityToDensity);
								this._warnAboutDeprecatedGaussianBlurProp("maxPixelIntensity", "maxDensity")
							}
						}, {
							key: "minPixelIntensity",
							get: function() {
								return this.minDensity / this._pixelIntensityToDensity
							},
							set: function(J) {
								this._set("minDensity",
									J * this._pixelIntensityToDensity);
								this._warnAboutDeprecatedGaussianBlurProp("minPixelIntensity", "minDensity")
							}
						}, {
							key: "_pixelIntensityToDensity",
							get: function() {
								return 24 / (y.MAGIC_KERNEL_DENSITY_RADIUS_INFLATION_FACTOR ** 2 * this.blurRadius ** 4)
							}
						}]);
						return C
					}(h);
					b.__decorate([g.property({
						type: q,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1,
									read: !1
								}
							}
						}
					})], e.prototype, "authoringInfo", void 0);
					b.__decorate([g.property({
							type: Number,
							json: {
								origins: {
									"portal-item": {
										write: !0
									},
									"web-map": {
										write: !0
									}
								}
							}
						})], e.prototype,
						"blurRadius", null);
					b.__decorate([g.property({
						type: [u],
						json: {
							write: !0
						}
					})], e.prototype, "colorStops", void 0);
					b.__decorate([g.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "field", void 0);
					b.__decorate([g.property({
						type: Number,
						json: {
							write: {
								overridePolicy: (z, C, D) => ({
									enabled: null == D
								})
							},
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], e.prototype, "fieldOffset", void 0);
					b.__decorate([g.property({
						type: x.HeatmapLegendOptions,
						json: {
							write: !0
						}
					})], e.prototype, "legendOptions", void 0);
					b.__decorate([g.property({
						type: Number,
						json: {
							write: !0
						}
					})], e.prototype, "maxDensity", void 0);
					b.__decorate([g.property({
						type: Number,
						json: {
							origins: {
								"portal-item": {
									write: !0
								},
								"web-map": {
									write: !0
								}
							}
						}
					})], e.prototype, "maxPixelIntensity", null);
					b.__decorate([g.property({
						type: Number,
						json: {
							write: !0
						}
					})], e.prototype, "minDensity", void 0);
					b.__decorate([g.property({
						type: Number,
						json: {
							origins: {
								"portal-item": {
									write: !0
								},
								"web-map": {
									write: !0
								}
							}
						}
					})], e.prototype, "minPixelIntensity", null);
					b.__decorate([g.property({
							type: Number,
							cast: f.toPt,
							json: {
								write: !0
							}
						})], e.prototype,
						"radius", void 0);
					b.__decorate([g.property({
						type: Number,
						range: {
							min: 0
						},
						json: {
							default: 0,
							write: !0
						}
					})], e.prototype, "referenceScale", void 0);
					b.__decorate([p.enumeration({
						heatmap: "heatmap"
					})], e.prototype, "type", void 0);
					b.__decorate([g.property({
						type: String,
						json: {
							write: !0,
							origins: {
								"web-document": {
									write: !1
								},
								"portal-item": {
									write: !1
								}
							}
						}
					})], e.prototype, "valueExpression", void 0);
					b.__decorate([g.property({
						type: String
					})], e.prototype, "valueExpressionTitle", void 0);
					b.__decorate([g.property({
							readOnly: !0
						})], e.prototype,
						"_pixelIntensityToDensity", null);
					return e = B = b.__decorate([n.subclass("esri.renderers.HeatmapRenderer")], e)
				})
		},
		"esri/renderers/support/HeatmapColorStop": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				e = f = function(g) {
					function l(r) {
						r = g.call(this,
							r) || this;
						r.color = null;
						r.ratio = null;
						return r
					}
					a._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							color: this.color,
							ratio: this.ratio
						})
					};
					return l
				}(e.JSONSupport);
				b.__decorate([d.property({
					type: c,
					json: {
						type: [v.Integer],
						default: null,
						write: !0
					}
				})], e.prototype, "color", void 0);
				b.__decorate([d.property({
					type: Number,
					json: {
						write: !0
					}
				})], e.prototype, "ratio", void 0);
				return e = f = b.__decorate([m.subclass("esri.renderers.support.HeatmapColorStop")], e)
			})
		},
		"esri/renderers/support/HeatmapLegendOptions": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					a.HeatmapLegendOptions = function(g) {
						function l() {
							var r = g.apply(this, arguments) || this;
							r.minLabel = null;
							r.maxLabel = null;
							r.title = null;
							return r
						}
						b._inheritsLoose(l, g);
						return l
					}(e.ClonableMixin(d.JSONSupport));
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.HeatmapLegendOptions.prototype, "minLabel", void 0);
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.HeatmapLegendOptions.prototype, "maxLabel", void 0);
					c.__decorate([k.property({
							type: String,
							json: {
								write: !0
							}
						})],
						a.HeatmapLegendOptions.prototype, "title", void 0);
					a.HeatmapLegendOptions = c.__decorate([f.subclass("esri.renderers.support.HeatmapLegendOptions")], a.HeatmapLegendOptions);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/support/heatmapUtils": function() {
			define(["exports", "../../core/mathUtils", "../../core/screenUtils", "../../chunks/vec4", "../../chunks/vec4f64"], function(a, b, c, e, d) {
				function k(g, l, r, p) {
					let {
						color: n,
						ratio: t
					} = l, {
						color: h,
						ratio: q
					} =
					r;
					q === t && (1 === q ? t -= 1E-6 : q += 1E-6);
					l = b.clamp((p - t) / (q - t), 0, 1);
					e.lerp(g, n.toArray(), h.toArray(), l)
				}

				function v(g, l, r, p, n) {
					g = new Uint32Array(g * g);
					l = "buffer" in l ? l : new Float64Array(l);
					r = "buffer" in r ? new Uint32Array(r.buffer) : new Uint32Array((new Uint8Array(r))
						.buffer);
					n = r.length / (n - p);
					for (let t = 0; t < l.length; t++) g[t] = r[b.clamp(Math.floor((l[t] - p) * n), 0, r.length - 1)];
					return g.buffer
				}

				function m(g, l, r) {
					g = Math.sqrt(g ** 2 + l ** 2) / r;
					return 1 < g ? 0 : 3 / (Math.PI * r ** 2) * (1 - g ** 2) ** 2
				}

				function f(g, l) {
					return null != g ? "string" ===
						typeof l ? r => -1 * +r.readAttribute(g) : r => +r.readAttribute(g) + l : r => 1
				}
				a.MAGIC_KERNEL_DENSITY_RADIUS_INFLATION_FACTOR = 2.4;
				a.calculateHeatmapIntensityInfoReaders = function(g, l, r, p) {
					const {
						radius: n,
						fieldOffset: t,
						field: h
					} = l;
					l = Math.round(c.pt2px(n));
					const q = new Float64Array(r * p);
					let u = Number.NEGATIVE_INFINITY;
					const x = f(h, t),
						y = new Set;
					for (const E of g)
						for (g = E.getCursor(); g.next();) {
							var w = g.getObjectId();
							if (y.has(w)) continue;
							y.add(w);
							w = g.readLegacyPointGeometry();
							if (-128 > w.x || w.x >= r + 128 || -128 > w.y || w.y > p + 128) continue;
							const z = +x(g),
								C = Math.max(0, Math.round(w.x) - l);
							var A = Math.max(0, Math.round(w.y) - l);
							const D = Math.min(p, Math.round(w.y) + l),
								J = Math.min(r, Math.round(w.x) + l);
							for (; A < D; A++)
								for (let K = C; K < J; K++) {
									var B = A * r + K;
									const H = m(w.x - K, w.y - A, l);
									B = q[B] += H * z;
									B > u && (u = B)
								}
						}
					return {
						matrix: q.buffer,
						max: u
					}
				};
				a.createHeatmapImageData = v;
				a.createValueFunction = function(g, l) {
					return "function" === typeof g ? g : g ? "string" === typeof l ? r => -1 * +r[g] : r => +r[g] + l : () => 1
				};
				a.createValueFunctionCursor = f;
				a.drawHeatmap = function(g, l, r, p, n, t) {
					g.canvas.width =
						g.canvas.height = l;
					g.clearRect(0, 0, l, l);
					const h = g.getImageData(0, 0, l, l);
					r && p && h.data.set(new Uint8ClampedArray(v(l, r, p, n, t)));
					g.putImageData(h, 0, 0)
				};
				a.evaluateDensityKernel = m;
				a.gaussianBlurRadiusPxToKernelDensityRadiusPt = function(g) {
					return c.px2pt(2.4 * g)
				};
				a.generateGradient = function(g) {
					const l = new Uint8ClampedArray(2048);
					g = g.filter(({
							ratio: h
						}) => 0 <= h && 1 >= h)
						.sort((h, q) => h.ratio - q.ratio)
						.map(({
							color: h,
							ratio: q
						}) => ({
							color: h,
							ratio: Math.max(q, .001)
						}));
					if (1 > g.length) return l;
					let r = g[0],
						p = g[0],
						n = 1;
					const t =
						d.create();
					for (let h = 0; 512 > h; h++) {
						const q = (h + .5) / 512;
						for (; q > p.ratio && n < g.length;) r = p, p = g[n++];
						k(t, r, p, q);
						l.set(t, 4 * h)
					}
					return l
				};
				a.kernelDensityRadiusPtToGaussianBlurRadiusPx = function(g) {
					return c.pt2px(g) / 2.4
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/chunks/vec4f64": function() {
			define(["exports"], function(a) {
				function b() {
					return [0, 0, 0, 0]
				}

				function c(y) {
					return [y[0], y[1], y[2], y[3]]
				}

				function e(y, w, A, B) {
					return [y, w, A, B]
				}

				function d(y) {
					const w = b(),
						A = Math.min(4,
							y.length);
					for (let B = 0; B < A; ++B) w[B] = y[B];
					return w
				}

				function k(y, w) {
					return new Float64Array(y, w, 4)
				}

				function v() {
					return b()
				}

				function m() {
					return [1, 1, 1, 1]
				}

				function f() {
					return [1, 0, 0, 0]
				}

				function g() {
					return [0, 1, 0, 0]
				}

				function l() {
					return [0, 0, 1, 0]
				}

				function r() {
					return [0, 0, 0, 1]
				}
				const p = b(),
					n = m(),
					t = f(),
					h = g(),
					q = l(),
					u = r(),
					x = Object.freeze(Object.defineProperty({
						__proto__: null,
						create: b,
						clone: c,
						fromValues: e,
						fromArray: d,
						createView: k,
						zeros: v,
						ones: m,
						unitX: f,
						unitY: g,
						unitZ: l,
						unitW: r,
						ZEROS: p,
						ONES: n,
						UNIT_X: t,
						UNIT_Y: h,
						UNIT_Z: q,
						UNIT_W: u
					}, Symbol.toStringTag, {
						value: "Module"
					}));
				a.ONES = n;
				a.UNIT_W = u;
				a.UNIT_X = t;
				a.UNIT_Y = h;
				a.UNIT_Z = q;
				a.ZEROS = p;
				a.clone = c;
				a.create = b;
				a.createView = k;
				a.fromArray = d;
				a.fromValues = e;
				a.ones = m;
				a.unitW = r;
				a.unitX = f;
				a.unitY = g;
				a.unitZ = l;
				a.vec4f64 = x;
				a.zeros = v
			})
		},
		"esri/renderers/PieChartRenderer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Color ../symbols ../core/Clonable ../core/maybe ../core/screenUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ../layers/support/fieldUtils ./Renderer ./mixins/VisualVariablesMixin ./support/AttributeColorInfo ./support/OthersCategory ./support/PieChartLegendOptions ../symbols/SimpleMarkerSymbol ../symbols/SimpleFillSymbol ../symbols/SimpleLineSymbol".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w) {
					e = function(A) {
						function B(z) {
							z = A.call(this, z) || this;
							z.attributes = null;
							z.backgroundFillSymbol = null;
							z.defaultColor = new c([0, 0, 0, 0]);
							z.defaultLabel = null;
							z.holePercentage = 0;
							z.othersCategory = new q.OthersCategory;
							z.legendOptions = null;
							z.outline = null;
							z.size = 12;
							z.type = "pie-chart";
							return z
						}
						a._inheritsLoose(B, A);
						var E = B.prototype;
						E.getSymbol = function() {
							return new x({
								size: this.size ? this.size / 2 + (this.outline ? .width || 0) : 0
							})
						};
						E.getSymbolAsync = function() {
							var z = a._asyncToGenerator(function*() {
								return this.getSymbol()
							});
							return function() {
								return z.apply(this, arguments)
							}
						}();
						E.getSymbols = function() {
							return [this.getSymbol(), this.backgroundFillSymbol].filter(k.isSome)
						};
						E.getAttributeHash = function() {
							return this.visualVariables && this.visualVariables.reduce((z, C) => z + C.getAttributeHash(), "")
						};
						E.getMeshHash = function() {
							return this.getSymbols()
								.reduce((z, C) => z += JSON.stringify(C), "")
						};
						E.collectRequiredFields = function() {
							var z = a._asyncToGenerator(function*(C, D) {
								yield this.collectVVRequiredFields(C, D);
								for (const J of this.attributes) J.valueExpression &&
									(yield p.collectArcadeFieldNames(C, D, J.valueExpression)), J.field && C.add(J.field)
							});
							return function(C, D) {
								return z.apply(this, arguments)
							}
						}();
						return B
					}(t.VisualVariablesMixin(d.ClonableMixin(n)));
					b.__decorate([m.property({
						type: [h],
						json: {
							write: !0
						}
					})], e.prototype, "attributes", void 0);
					b.__decorate([m.property({
						type: y,
						json: {
							default: null,
							write: !0
						}
					})], e.prototype, "backgroundFillSymbol", void 0);
					b.__decorate([m.property({
						type: c,
						json: {
							write: !0
						}
					})], e.prototype, "defaultColor", void 0);
					b.__decorate([m.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "defaultLabel", void 0);
					b.__decorate([m.property({
						type: Number,
						range: {
							min: 0,
							max: 1
						},
						json: {
							write: !0
						}
					})], e.prototype, "holePercentage", void 0);
					b.__decorate([m.property({
						type: q.OthersCategory,
						json: {
							write: !0
						}
					})], e.prototype, "othersCategory", void 0);
					b.__decorate([m.property({
						type: u.PieChartLegendOptions,
						json: {
							write: !0
						}
					})], e.prototype, "legendOptions", void 0);
					b.__decorate([m.property({
						type: w,
						json: {
							default: null,
							write: !0
						}
					})], e.prototype, "outline", void 0);
					b.__decorate([m.property({
						type: Number,
						cast: v.toPt,
						json: {
							write: !0
						}
					})], e.prototype, "size", void 0);
					b.__decorate([l.enumeration({
						pieChart: "pie-chart"
					})], e.prototype, "type", void 0);
					return e = b.__decorate([r.subclass("esri.renderers.PieChartRenderer")], e)
				})
		},
		"esri/renderers/support/OthersCategory": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../Color ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					a.OthersCategory = function(l) {
						function r() {
							var p = l.apply(this, arguments) || this;
							p.color = new e([0, 0, 0, 0]);
							p.label = null;
							p.threshold = 0;
							return p
						}
						b._inheritsLoose(r, l);
						return r
					}(d.ClonableMixin(k.JSONSupport));
					c.__decorate([v.property({
						type: e,
						json: {
							write: !0
						}
					})], a.OthersCategory.prototype, "color", void 0);
					c.__decorate([v.property({
						type: String,
						json: {
							write: !0
						}
					})], a.OthersCategory.prototype, "label", void 0);
					c.__decorate([v.property({
							type: Number,
							range: {
								min: 0,
								max: 1
							},
							json: {
								write: !0
							}
						})],
						a.OthersCategory.prototype, "threshold", void 0);
					a.OthersCategory = c.__decorate([g.subclass("esri.renderers.support.OthersCategory")], a.OthersCategory);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/support/PieChartLegendOptions": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					a.PieChartLegendOptions = function(g) {
						function l() {
							var r = g.apply(this, arguments) || this;
							r.title = null;
							return r
						}
						b._inheritsLoose(l, g);
						return l
					}(e.ClonableMixin(d.JSONSupport));
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.PieChartLegendOptions.prototype, "title", void 0);
					a.PieChartLegendOptions = c.__decorate([f.subclass("esri.renderers.support.PieChartLegendOptions")], a.PieChartLegendOptions);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/SimpleRenderer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/subclass ./Renderer ./mixins/VisualVariablesMixin ./support/commonProperties".split(" "), function(a, b, c, e, d, k, v, m, f, g) {
				var l;
				d = l = function(r) {
					function p(t) {
						t = r.call(this, t) || this;
						t.description = null;
						t.label = null;
						t.symbol = null;
						t.type = "simple";
						return t
					}
					a._inheritsLoose(p, r);
					var n = p.prototype;
					n.collectRequiredFields = function() {
						var t = a._asyncToGenerator(function*(h, q) {
							yield Promise.all([this.collectSymbolFields(h, q), this.collectVVRequiredFields(h, q)])
						});
						return function(h, q) {
							return t.apply(this, arguments)
						}
					}();
					n.collectSymbolFields = function() {
						var t = a._asyncToGenerator(function*(h, q) {
							yield Promise.all(this.getSymbols()
								.map(u => u.collectRequiredFields(h, q)))
						});
						return function(h, q) {
							return t.apply(this, arguments)
						}
					}();
					n.getSymbol =
						function(t, h) {
							return this.symbol
						};
					n.getSymbolAsync = function() {
						var t = a._asyncToGenerator(function*(h, q) {
							return this.symbol
						});
						return function(h, q) {
							return t.apply(this, arguments)
						}
					}();
					n.getSymbols = function() {
						return this.symbol ? [this.symbol] : []
					};
					n.getAttributeHash = function() {
						return this.visualVariables && this.visualVariables.reduce((t, h) => t + h.getAttributeHash(), "")
					};
					n.getMeshHash = function() {
						return this.getSymbols()
							.reduce((t, h) => t += JSON.stringify(h), "")
					};
					n.clone = function() {
						return new l({
							description: this.description,
							label: this.label,
							symbol: this.symbol && this.symbol.clone(),
							visualVariables: c.clone(this.visualVariables),
							authoringInfo: this.authoringInfo && this.authoringInfo.clone()
						})
					};
					a._createClass(p, [{
						key: "arcadeRequired",
						get: function() {
							return this.arcadeRequiredForVisualVariables
						}
					}]);
					return p
				}(f.VisualVariablesMixin(m));
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], d.prototype, "description", void 0);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], d.prototype, "label", void 0);
				b.__decorate([e.property(g.rendererSymbolProperty)],
					d.prototype, "symbol", void 0);
				b.__decorate([k.enumeration({
					simple: "simple"
				})], d.prototype, "type", void 0);
				return d = l = b.__decorate([v.subclass("esri.renderers.SimpleRenderer")], d)
			})
		},
		"esri/renderers/UniqueValueRenderer": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../symbols ../core/Error ../core/lang ../core/Logger ../core/maybe ../core/object ../core/reactiveUtils ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/enumeration ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ../core/accessorSupport/diffUtils ../core/accessorSupport/ensureType ../layers/support/fieldUtils ../portal/Portal ./Renderer ./mixins/VisualVariablesMixin ./support/commonProperties ./support/LegendOptions ./support/UniqueValue ./support/UniqueValueClass ./support/UniqueValueGroup ./support/UniqueValueInfo ../support/arcadeOnDemand ../chunks/persistableUrlUtils ../symbols/support/styleUtils ../symbols/WebStyleSymbol".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D, J, K, H, G) {
					function F(U) {
						const {
							field1: W,
							field2: M,
							field3: T,
							fieldDelimiter: Z,
							uniqueValueInfos: oa,
							valueExpression: qa
						} = U, Aa = !(!W || !M);
						return [{
							classes: (oa ? ? [])
								.map(Ka => {
									const {
										symbol: da,
										label: ja,
										value: sa,
										description: I
									} = Ka, [N, ea, pa] = Aa ? sa ? .toString() ? .split(Z || "") || [] : [sa];
									Ka = [];
									(W || qa) && Ka.push(N);
									M && Ka.push(ea);
									T && Ka.push(pa);
									return {
										symbol: da,
										label: ja,
										values: [Ka],
										description: I
									}
								})
						}]
					}
					var L;
					const R = k.getLogger("esri.renderers.UniqueValueRenderer"),
						V = q.ensureType(D);
					k = L = function(U) {
						function W(T) {
							T = U.call(this, T) || this;
							T._valueInfoMap = {};
							T._isDefaultSymbolDerived = !1;
							T._isInfosSource = null;
							T.type = "unique-value";
							T.backgroundFillSymbol = null;
							T.valueExpressionTitle = null;
							T.legendOptions = null;
							T.defaultLabel = null;
							T.portal = null;
							T.styleOrigin = null;
							T.diff = {
								uniqueValueInfos(Z, oa) {
									if (Z || oa) {
										if (!Z || !oa) return {
											type: "complete",
											oldValue: Z,
											newValue: oa
										};
										var qa = !1,
											Aa = {
												type: "collection",
												added: [],
												removed: [],
												changed: [],
												unchanged: []
											};
										for (let Ka = 0; Ka < oa.length; Ka++) {
											const da =
												Z.find(ja => ja.value === oa[Ka].value);
											da ? h.diff(da, oa[Ka]) ? (Aa.changed.push({
												type: "complete",
												oldValue: da,
												newValue: oa[Ka]
											}), qa = !0) : Aa.unchanged.push({
												oldValue: da,
												newValue: oa[Ka]
											}) : (Aa.added.push(oa[Ka]), qa = !0)
										}
										for (let Ka = 0; Ka < Z.length; Ka++) oa.find(da => da.value === Z[Ka].value) || (Aa.removed.push(Z[Ka]), qa = !0);
										return qa ? Aa : void 0
									}
								}
							};
							T._set("uniqueValueInfos", []);
							T._set("uniqueValueGroups", []);
							return T
						}
						a._inheritsLoose(W, U);
						var M = W.prototype;
						M.castField = function(T) {
							return null == T || "function" === typeof T ? T :
								q.ensureString(T)
						};
						M.writeField = function(T, Z, oa, qa) {
							"string" === typeof T ? Z[oa] = T : qa && qa.messages ? qa.messages.push(new e("property:unsupported", "UniqueValueRenderer.field set to a function cannot be written to JSON")) : R.error(".field: cannot write field to JSON since it's not a string value")
						};
						M.readPortal = function(T, Z, oa) {
							return oa.portal || x.getDefault()
						};
						M.readStyleOrigin = function(T, Z, oa) {
							if (Z.styleName) return Object.freeze({
								styleName: Z.styleName
							});
							if (Z.styleUrl) return T = K.fromJSON(Z.styleUrl, oa),
								Object.freeze({
									styleUrl: T
								})
						};
						M.writeStyleOrigin = function(T, Z, oa, qa) {
							T.styleName ? Z.styleName = T.styleName : T.styleUrl && (Z.styleUrl = K.toJSON(T.styleUrl, qa))
						};
						M.addUniqueValueInfo = function(T, Z) {
							this.styleOrigin ? R.error("#addUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style") : (T = "object" === typeof T ? V(T) : new D({
								value: T,
								symbol: c.ensureType(Z)
							}), this.uniqueValueInfos ? .push(T), this._valueInfoMap[T.value] = T, this._updateGroupsFromInfos(), this._isInfosSource = !0, this._watchUniqueValueInfos())
						};
						M.removeUniqueValueInfo = function(T) {
							if (this.styleOrigin) R.error("#removeUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
							else {
								var Z = this.uniqueValueInfos;
								if (Z)
									for (let oa = 0; oa < Z.length; oa++)
										if (Z[oa].value === T + "") {
											delete this._valueInfoMap[T];
											Z.splice(oa, 1);
											break
										} this._updateGroupsFromInfos();
								this._isInfosSource = !0;
								this._watchUniqueValueInfos()
							}
						};
						M.getUniqueValueInfo = function() {
							var T = a._asyncToGenerator(function*(Z,
								oa) {
								let qa = oa;
								this.valueExpression && (v.isNone(oa) || v.isNone(oa.arcade)) && (qa = {
									...qa,
									arcade: yield J.loadArcade()
								});
								return this._getUniqueValueInfo(Z, qa)
							});
							return function(Z, oa) {
								return T.apply(this, arguments)
							}
						}();
						M.getSymbol = function(T, Z) {
							if (this.valueExpression && (v.isNone(Z) || v.isNone(Z.arcade))) R.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
							else return (T = this._getUniqueValueInfo(T, Z)) && T.symbol || this.defaultSymbol
						};
						M.getSymbolAsync = function() {
							var T = a._asyncToGenerator(function*(Z,
								oa) {
								if (this.valueExpression && (v.isNone(oa) || v.isNone(oa.arcade))) {
									const qa = yield J.loadArcade(), {
										arcadeUtils: Aa
									} = qa;
									Aa.hasGeometryOperations(this.valueExpression) && (yield Aa.enableGeometryOperations());
									oa = {
										...oa,
										arcade: qa
									}
								}
								return (Z = this._getUniqueValueInfo(Z, oa)) && Z.symbol || this.defaultSymbol
							});
							return function(Z, oa) {
								return T.apply(this, arguments)
							}
						}();
						M.getSymbols = function() {
							const T = [];
							for (const Z of this.uniqueValueInfos ? ? []) Z.symbol && T.push(Z.symbol);
							this.defaultSymbol && T.push(this.defaultSymbol);
							return T
						};
						M.getAttributeHash = function() {
							return this.visualVariables && this.visualVariables.reduce((T, Z) => T + Z.getAttributeHash(), "")
						};
						M.getMeshHash = function() {
							const T = JSON.stringify(this.backgroundFillSymbol),
								Z = JSON.stringify(this.defaultSymbol),
								oa = this.uniqueValueInfos ? .reduce((qa, Aa) => qa + Aa.getMeshHash(), "");
							return `${T}.${Z}.${oa}.${`${this.field}.${this.field2}.${this.field3}.${this.fieldDelimiter}`}.${this.valueExpression}`
						};
						M.clone = function() {
							const T = new L({
								field: this.field,
								field2: this.field2,
								field3: this.field3,
								defaultLabel: this.defaultLabel,
								defaultSymbol: d.clone(this.defaultSymbol),
								valueExpression: this.valueExpression,
								valueExpressionTitle: this.valueExpressionTitle,
								fieldDelimiter: this.fieldDelimiter,
								visualVariables: d.clone(this.visualVariables),
								legendOptions: d.clone(this.legendOptions),
								authoringInfo: this.authoringInfo && this.authoringInfo.clone(),
								backgroundFillSymbol: d.clone(this.backgroundFillSymbol)
							});
							this._isDefaultSymbolDerived && (T._isDefaultSymbolDerived = !0);
							T._set("portal", this.portal);
							const Z = d.clone(this.uniqueValueInfos),
								oa = d.clone(this.uniqueValueGroups);
							this.styleOrigin && (T._set("styleOrigin", Object.freeze(d.clone(this.styleOrigin))), Object.freeze(Z), Object.freeze(oa));
							T._set("uniqueValueInfos", Z);
							T._updateValueInfoMap();
							T._set("uniqueValueGroups", oa);
							T._isInfosSource = this._isInfosSource;
							T._watchUniqueValueInfosAndGroups();
							return T
						};
						M.collectRequiredFields = function() {
							var T = a._asyncToGenerator(function*(Z, oa) {
								Z = [this.collectVVRequiredFields(Z, oa), this.collectSymbolFields(Z,
									oa)];
								yield Promise.all(Z)
							});
							return function(Z, oa) {
								return T.apply(this, arguments)
							}
						}();
						M.collectSymbolFields = function() {
							var T = a._asyncToGenerator(function*(Z, oa) {
								const qa = [...this.getSymbols()
									.map(Aa => Aa.collectRequiredFields(Z, oa)), u.collectArcadeFieldNames(Z, oa, this.valueExpression)
								];
								u.collectField(Z, oa, this.field);
								u.collectField(Z, oa, this.field2);
								u.collectField(Z, oa, this.field3);
								yield Promise.all(qa)
							});
							return function(Z, oa) {
								return T.apply(this, arguments)
							}
						}();
						M.populateFromStyle = function() {
							return H.fetchStyle(this.styleOrigin, {
									portal: this.portal
								})
								.then(T => {
									const Z = [];
									this._valueInfoMap = {};
									T && T.data && Array.isArray(T.data.items) && T.data.items.forEach(oa => {
										var qa = new G({
											styleUrl: T.styleUrl,
											styleName: T.styleName,
											portal: this.portal,
											name: oa.name
										});
										this.defaultSymbol || oa.name !== T.data.defaultItem || (this.defaultSymbol = qa, this._isDefaultSymbolDerived = !0);
										qa = new D({
											value: oa.name,
											symbol: qa
										});
										Z.push(qa);
										this._valueInfoMap[oa.name] = qa
									});
									this._set("uniqueValueInfos", Object.freeze(Z));
									this._updateGroupsFromInfos(!0);
									this._isInfosSource =
										null;
									this._watchUniqueValueInfos();
									!this.defaultSymbol && this.uniqueValueInfos ? .length && (this.defaultSymbol = this.uniqueValueInfos[0].symbol, this._isDefaultSymbolDerived = !0);
									return this
								})
						};
						M._updateFieldDelimiter = function() {
							this.field && this.field2 && !this.fieldDelimiter && this._set("fieldDelimiter", ",")
						};
						M._updateUniqueValues = function() {
							null != this._isInfosSource && (this._isInfosSource ? this._updateGroupsFromInfos() : this._updateInfosFromGroups())
						};
						M._updateValueInfoMap = function() {
							this._valueInfoMap = {};
							const {
								uniqueValueInfos: T
							} =
							this;
							if (T)
								for (const Z of T) this._valueInfoMap[Z.value + ""] = Z
						};
						M._watchUniqueValueInfosAndGroups = function() {
							this._watchUniqueValueInfos();
							this._watchUniqueValueGroups()
						};
						M._watchUniqueValueInfos = function() {
							this.removeHandles("uvInfos-watcher");
							const {
								uniqueValueInfos: T
							} = this;
							if (T) {
								const Z = [];
								for (const oa of T) Z.push(f.watch(() => ({
									symbol: oa.symbol,
									value: oa.value,
									label: oa.label,
									description: oa.description
								}), (qa, Aa) => {
									qa !== Aa && (this._updateGroupsFromInfos(), this._isInfosSource = !0)
								}, {
									sync: !0
								}));
								this.addHandles(Z,
									"uvInfos-watcher")
							}
						};
						M._watchUniqueValueGroups = function() {
							this.removeHandles("uvGroups-watcher");
							const {
								uniqueValueGroups: T
							} = this;
							if (T) {
								const Z = [];
								for (const oa of T) {
									Z.push(f.watch(() => ({
										classes: oa.classes
									}), (qa, Aa) => {
										qa !== Aa && (this._updateInfosFromGroups(), this._isInfosSource = !1)
									}, {
										sync: !0
									}));
									for (const qa of oa.classes) Z.push(f.watch(() => ({
										symbol: qa.symbol,
										values: qa.values,
										label: qa.label,
										description: qa.description
									}), (Aa, Ka) => {
										Aa !== Ka && (this._updateInfosFromGroups(), this._isInfosSource = !1)
									}, {
										sync: !0
									}))
								}
								this.addHandles(Z,
									"uvGroups-watcher")
							}
						};
						M._updateInfosFromGroups = function() {
							if (this.uniqueValueGroups) {
								var T = [],
									{
										field: Z,
										field2: oa,
										field3: qa,
										fieldDelimiter: Aa,
										uniqueValueGroups: Ka,
										valueExpression: da
									} = this;
								if (Z || da) {
									var ja = !(!Z || !oa);
									for (const I of Ka)
										for (const N of I.classes ? ? []) {
											const {
												symbol: ea,
												label: pa,
												values: xa,
												description: S
											} = N;
											for (const ba of xa ? ? []) {
												const {
													value: la,
													value2: ha,
													value3: P
												} = ba;
												var sa = [la];
												oa && sa.push(ha);
												qa && sa.push(P);
												sa = ja ? sa.join(Aa || "") : sa[0];
												T.push(new D({
													symbol: ea,
													label: pa,
													value: sa,
													description: S
												}))
											}
										}
								}
								this._set("uniqueValueInfos",
									T)
							} else this._set("uniqueValueInfos", null);
							this._updateValueInfoMap();
							this._watchUniqueValueInfos()
						};
						M._updateGroupsFromInfos = function(T = !1) {
							if (this.uniqueValueInfos) {
								var {
									field: Z,
									field2: oa,
									valueExpression: qa,
									fieldDelimiter: Aa,
									uniqueValueInfos: Ka
								} = this;
								if ((Z || qa) && Ka.length) {
									var da = !(!Z || !oa),
										ja = Ka.map(sa => {
											const {
												symbol: I,
												label: N,
												value: ea,
												description: pa
											} = sa, [xa, S, ba] = da ? ea ? .toString() ? .split(Aa || "") || [] : [ea];
											return new z({
												symbol: I,
												label: N,
												description: pa,
												values: [new E({
													value: xa,
													value2: S,
													value3: ba
												})]
											})
										});
									ja = [new C({
										classes: ja
									})];
									T && Object.freeze(ja);
									this._set("uniqueValueGroups", ja)
								} else this._set("uniqueValueGroups", [])
							} else this._set("uniqueValueGroups", null);
							this._watchUniqueValueGroups()
						};
						M._getUniqueValueInfo = function(T, Z) {
							return this.valueExpression ? this._getUnqiueValueInfoForExpression(T, Z) : this._getUnqiueValueInfoForFields(T)
						};
						M._getUnqiueValueInfoForExpression = function(T, Z) {
							const {
								viewingMode: oa,
								scale: qa,
								spatialReference: Aa,
								arcade: Ka
							} = v.unwrapOr(Z, {});
							var da = this._cache.compiledFunc;
							Z = v.unwrap(Ka)
								.arcadeUtils;
							da || (da = Z.createSyntaxTree(this.valueExpression), da = Z.createFunction(da), this._cache.compiledFunc = da);
							T = Z.executeFunction(da, Z.createExecContext(T, Z.getViewInfo({
								viewingMode: oa,
								scale: qa,
								spatialReference: Aa
							})));
							return this._valueInfoMap[T + ""]
						};
						M._getUnqiueValueInfoForFields = function(T) {
							const Z = this.field,
								oa = T.attributes;
							if ("function" !== typeof Z && this.field2) {
								T = this.field2;
								var qa = this.field3;
								const Aa = [];
								Z && Aa.push(oa[Z]);
								T && Aa.push(oa[T]);
								qa && Aa.push(oa[qa]);
								qa = Aa.join(this.fieldDelimiter || "")
							} else "function" ===
								typeof Z ? qa = Z(T) : Z && (qa = oa[Z]);
							return this._valueInfoMap[qa + ""]
						};
						W.fromPortalStyle = function(T, Z) {
							const oa = new L(Z && Z.properties);
							oa._set("styleOrigin", Object.freeze({
								styleName: T
							}));
							oa._set("portal", Z && Z.portal || x.getDefault());
							Z = oa.populateFromStyle();
							Z.catch(qa => {
								R.error(`#fromPortalStyle('${T}'[, ...])`, "Failed to create unique value renderer from style name", qa)
							});
							return Z
						};
						W.fromStyleUrl = function(T, Z) {
							Z = new L(Z && Z.properties);
							Z._set("styleOrigin", Object.freeze({
								styleUrl: T
							}));
							Z = Z.populateFromStyle();
							Z.catch(oa => {
								R.error(`#fromStyleUrl('${T}'[, ...])`, "Failed to create unique value renderer from style URL", oa)
							});
							return Z
						};
						a._createClass(W, [{
							key: "_cache",
							get: function() {
								return {
									compiledFunc: null
								}
							}
						}, {
							key: "field",
							set: function(T) {
								this._set("field", T);
								this._updateFieldDelimiter();
								this._updateUniqueValues()
							}
						}, {
							key: "field2",
							set: function(T) {
								this._set("field2", T);
								this._updateFieldDelimiter();
								this._updateUniqueValues()
							}
						}, {
							key: "field3",
							set: function(T) {
								this._set("field3", T);
								this._updateUniqueValues()
							}
						}, {
							key: "valueExpression",
							set: function(T) {
								this._set("valueExpression", T);
								this._updateUniqueValues()
							}
						}, {
							key: "defaultSymbol",
							set: function(T) {
								this._isDefaultSymbolDerived = !1;
								this._set("defaultSymbol", T)
							}
						}, {
							key: "fieldDelimiter",
							set: function(T) {
								this._set("fieldDelimiter", T);
								this._updateUniqueValues()
							}
						}, {
							key: "uniqueValueGroups",
							set: function(T) {
								this.styleOrigin ? R.error("#uniqueValueGroups\x3d", "Cannot modify unique value groups of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueGroups", T), this._updateInfosFromGroups(),
									this._isInfosSource = !1, this._watchUniqueValueGroups())
							}
						}, {
							key: "uniqueValueInfos",
							set: function(T) {
								this.styleOrigin ? R.error("#uniqueValueInfos\x3d", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueInfos", T), this._updateValueInfoMap(), this._updateGroupsFromInfos(), this._isInfosSource = !0, this._watchUniqueValueInfos())
							}
						}, {
							key: "arcadeRequired",
							get: function() {
								return this.arcadeRequiredForVisualVariables || !!this.valueExpression
							}
						}]);
						return W
					}(w.VisualVariablesMixin(y));
					b.__decorate([g.property({
						readOnly: !0
					})], k.prototype, "_cache", null);
					b.__decorate([r.enumeration({
						uniqueValue: "unique-value"
					})], k.prototype, "type", void 0);
					b.__decorate([g.property(A.rendererBackgroundFillSymbolProperty)], k.prototype, "backgroundFillSymbol", void 0);
					b.__decorate([g.property({
						value: null,
						json: {
							type: String,
							read: {
								source: "field1"
							},
							write: {
								target: "field1"
							}
						}
					})], k.prototype, "field", null);
					b.__decorate([l.cast("field")], k.prototype, "castField", null);
					b.__decorate([t.writer("field")], k.prototype,
						"writeField", null);
					b.__decorate([g.property({
						type: String,
						value: null,
						json: {
							write: !0
						}
					})], k.prototype, "field2", null);
					b.__decorate([g.property({
						type: String,
						value: null,
						json: {
							write: !0
						}
					})], k.prototype, "field3", null);
					b.__decorate([g.property({
						type: String,
						value: null,
						json: {
							write: !0
						}
					})], k.prototype, "valueExpression", null);
					b.__decorate([g.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "valueExpressionTitle", void 0);
					b.__decorate([g.property({
							type: B.LegendOptions,
							json: {
								write: !0
							}
						})], k.prototype, "legendOptions",
						void 0);
					b.__decorate([g.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "defaultLabel", void 0);
					b.__decorate([g.property(m.deepMerge({
						...A.rendererSymbolProperty
					}, {
						json: {
							write: {
								overridePolicy() {
									return {
										enabled: !this._isDefaultSymbolDerived
									}
								}
							},
							origins: {
								"web-scene": {
									write: {
										overridePolicy() {
											return {
												enabled: !this._isDefaultSymbolDerived
											}
										}
									}
								}
							}
						}
					}))], k.prototype, "defaultSymbol", null);
					b.__decorate([g.property({
						type: String,
						value: null,
						json: {
							write: !0
						}
					})], k.prototype, "fieldDelimiter", null);
					b.__decorate([g.property({
						type: x,
						readOnly: !0
					})], k.prototype, "portal", void 0);
					b.__decorate([p.reader("portal", ["styleName"])], k.prototype, "readPortal", null);
					b.__decorate([g.property({
						readOnly: !0,
						json: {
							write: {
								enabled: !1,
								overridePolicy: () => ({
									enabled: !0
								})
							}
						}
					})], k.prototype, "styleOrigin", void 0);
					b.__decorate([p.reader("styleOrigin", ["styleName", "styleUrl"])], k.prototype, "readStyleOrigin", null);
					b.__decorate([t.writer("styleOrigin", {
						styleName: {
							type: String
						},
						styleUrl: {
							type: String
						}
					})], k.prototype, "writeStyleOrigin", null);
					b.__decorate([g.property({
						type: [C],
						json: {
							read: {
								source: ["uniqueValueGroups", "uniqueValueInfos"],
								reader: (U, W, M) => (W.uniqueValueGroups || F(W))
									.map(T => C.fromJSON(T, M))
							},
							write: {
								overridePolicy() {
									return this.styleOrigin ? {
										enabled: !1
									} : {
										enabled: !0
									}
								}
							}
						}
					})], k.prototype, "uniqueValueGroups", null);
					b.__decorate([g.property({
						type: [D],
						json: {
							read: !1,
							write: {
								overridePolicy() {
									return this.styleOrigin ? {
										enabled: !1
									} : {
										enabled: !0
									}
								}
							}
						}
					})], k.prototype, "uniqueValueInfos", null);
					return k = L = b.__decorate([n.subclass("esri.renderers.UniqueValueRenderer")], k)
				})
		},
		"esri/core/reactiveUtils": function() {
			define("exports ./events ./handleUtils ./maybe ./promiseUtils ./accessorSupport/watch ./accessorSupport/trackingUtils".split(" "),
				function(a, b, c, e, d, k, v) {
					function m(p, n, t = {}) {
						return f(p, n, t, l)
					}

					function f(p, n, t = {}, h) {
						let q = null;
						const u = t.once ? (x, y) => {
							h(x) && (e.removeMaybe(q), n(x, y))
						} : (x, y) => {
							h(x) && n(x, y)
						};
						q = k.watchTracked(p, u, t.sync, t.equals);
						t.initial && (p = p(), u(p, p));
						return q
					}

					function g(p, n, t) {
						if (d.isAborted(t)) return Promise.reject(d.createAbortError());
						const h = p();
						if (n ? .(h)) return Promise.resolve(h);
						let q = null;
						return new Promise((u, x) => {
							q = c.handlesGroup([d.onAbort(t, () => {
								q = e.removeMaybe(q);
								x(d.createAbortError())
							}), f(p, y => {
								q = e.removeMaybe(q);
								u(y)
							}, {
								sync: !1,
								once: !0
							}, n ? ? l)])
						})
					}

					function l(p) {
						return !0
					}

					function r(p) {
						return !!p
					}
					a.autorun = v.autorun;
					a.initial = {
						initial: !0
					};
					a.on = function(p, n, t, h = {}) {
						function q() {
							x && y && (y.remove(), h.onListenerRemove ? .(x), y = x = null)
						}

						function u(B) {
							h.once && h.once && e.removeMaybe(w);
							t(B)
						}
						let x = null,
							y = null,
							w = null;
						const A = m(p, (B, E) => {
							q();
							b.isEventTarget(B) && (x = B, y = b.on(B, n, u), h.onListenerAdd ? .(B))
						}, {
							sync: h.sync,
							initial: !0
						});
						return w = c.makeHandle(() => {
							A.remove();
							q()
						})
					};
					a.once = function(p, n) {
						return g(p,
							null, n)
					};
					a.pausable = function(p, n, t = {}) {
						let h = !1;
						const q = m(p, (u, x) => {
							h || n(u, x)
						}, t);
						return {
							remove() {
								q.remove()
							},
							pause() {
								h = !0
							},
							resume() {
								h = !1
							}
						}
					};
					a.sync = {
						sync: !0
					};
					a.syncAndInitial = {
						sync: !0,
						initial: !0
					};
					a.watch = m;
					a.when = function(p, n, t = {}) {
						return f(p, n, t, r)
					};
					a.whenOnce = function(p, n) {
						return g(p, r, n)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/accessorSupport/diffUtils": function() {
			define(["exports", "../Accessor", "../Collection", "../maybe", "./utils"],
				function(a, b, c, e, d) {
					function k(n) {
						return n instanceof c ? Object.keys(n.items) : n instanceof b ? d.getProperties(n)
							.keys() : n ? Object.keys(n) : []
					}

					function v(n, t) {
						return n instanceof c ? n.items[t] : n[t]
					}

					function m(n, t) {
						return Array.isArray(n) && Array.isArray(t) ? n.length !== t.length : !1
					}

					function f(n) {
						return n ? n.declaredClass : null
					}

					function g(n, t) {
						const h = n.diff;
						if (h && "function" === typeof h) return h(n, t);
						const q = k(n),
							u = k(t);
						if (0 !== q.length || 0 !== u.length) {
							if (!q.length || !u.length || m(n, t)) return {
								type: "complete",
								oldValue: n,
								newValue: t
							};
							var x = u.filter(A => !q.includes(A)),
								y = q.filter(A => !u.includes(A));
							y = q.filter(A => u.includes(A) && v(n, A) !== v(t, A))
								.concat(x, y)
								.sort();
							if ((x = f(n)) && p.includes(x) && y.length) return {
								type: "complete",
								oldValue: n,
								newValue: t
							};
							var w;
							x = n instanceof b && t instanceof b;
							for (const A of y) {
								y = v(n, A);
								const B = v(t, A);
								if ((x || "function" !== typeof y && "function" !== typeof B) && y !== B && (null != y || null != B)) {
									if (h && h[A] && "function" === typeof h[A]) y = h[A](y, B);
									else if (y instanceof Date && B instanceof Date) {
										if (y.getTime() === B.getTime()) continue;
										y = {
											type: "complete",
											oldValue: y,
											newValue: B
										}
									} else y = "object" === typeof y && "object" === typeof B && f(y) === f(B) ? g(y, B) : {
										type: "complete",
										oldValue: y,
										newValue: B
									};
									e.isSome(y) && (e.isSome(w) ? w.diff[A] = y : w = {
										type: "partial",
										diff: {
											[A]: y
										}
									})
								}
							}
							return w
						}
					}

					function l(n, t) {
						if (e.isNone(n)) return !1;
						t = t.split(".");
						for (const h of t) {
							if ("complete" === n.type) break;
							if ("partial" === n.type) {
								if (n = n.diff[h], !n) return !1
							} else return !1
						}
						return !0
					}

					function r(n) {
						if (e.isNone(n)) return !0;
						switch (n.type) {
							case "complete":
								return !1;
							case "collection":
								for (const t of n.added)
									if (!r(t)) return !1;
								for (const t of n.removed)
									if (!r(t)) return !1;
								for (const t of n.changed)
									if (!r(t)) return !1;
								return !0;
							case "partial":
								for (const t in n.diff)
									if (!r(n.diff[t])) return !1;
								return !0
						}
					}
					const p = ["esri.Color", "esri.portal.Portal", "esri.symbols.support.Symbol3DAnchorPosition2D", "esri.symbols.support.Symbol3DAnchorPosition3D"];
					a.diff = function(n, t) {
						if (!("function" === typeof n || "function" === typeof t || e.isNone(n) && e.isNone(t))) return e.isNone(n) || e.isNone(t) || "object" === typeof n && "object" === typeof t && f(n) !== f(t) ? {
							type: "complete",
							oldValue: n,
							newValue: t
						} : g(n, t)
					};
					a.hasDiff = l;
					a.hasDiffAny = function(n, t) {
						for (const h of t)
							if (l(n, h)) return !0;
						return !1
					};
					a.isEmpty = r;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/renderers/support/UniqueValue": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./commonProperties".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					c = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.value = null;
							r.value2 = null;
							r.value3 = null;
							return r
						}
						a._inheritsLoose(l, g);
						return l
					}(c.ClonableMixin(e.JSONSupport));
					b.__decorate([d.property(f.uniqueValueProperty)], c.prototype, "value", void 0);
					b.__decorate([d.property(f.uniqueValueProperty)], c.prototype, "value2", void 0);
					b.__decorate([d.property(f.uniqueValueProperty)], c.prototype, "value3", void 0);
					return c = b.__decorate([m.subclass("esri.renderers.support.UniqueValue")], c)
				})
		},
		"esri/renderers/support/UniqueValueClass": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/subclass ./commonProperties ./UniqueValue".split(" "), function(a, b, c, e, d, k, v, m, f, g, l) {
				c = function(r) {
					function p(n) {
						n = r.call(this, n) || this;
						n.description = null;
						n.label = null;
						n.symbol = null;
						n.values = null;
						return n
					}
					a._inheritsLoose(p, r);
					p.prototype.castValues = function(n) {
						if (null == n) return null;
						n = Array.isArray(n) ? n : [n];
						const t = typeof n[0];
						return "string" === t || "number" === t ? n.map(h => new l({
							value: h
						})) : "object" === t ? n[0] instanceof l ? n : n.map(h => new l(h)) : null
					};
					return p
				}(c.ClonableMixin(e.JSONSupport));
				b.__decorate([k.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "description", void 0);
				b.__decorate([k.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "label", void 0);
				b.__decorate([k.property(g.rendererSymbolProperty)],
					c.prototype, "symbol", void 0);
				b.__decorate([k.property({
					type: [l],
					json: {
						type: [
							[String]
						],
						read: {
							reader: r => r ? r.map(p => new l({
								value: p[0],
								value2: p[1],
								value3: p[2]
							})) : null
						},
						write: {
							writer: (r, p) => {
								const n = [];
								for (const t of r) r = [t.value, t.value2, t.value3].filter(d.isSome)
									.map(h => h.toString()), n.push(r);
								p.values = n
							}
						}
					}
				})], c.prototype, "values", void 0);
				b.__decorate([m.cast("values")], c.prototype, "castValues", null);
				return c = b.__decorate([f.subclass("esri.renderers.support.UniqueValueClass")], c)
			})
		},
		"esri/renderers/support/UniqueValueGroup": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./UniqueValueClass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					c = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.heading = null;
							r.classes = null;
							return r
						}
						a._inheritsLoose(l, g);
						return l
					}(c.ClonableMixin(e.JSONSupport));
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "heading", void 0);
					b.__decorate([d.property({
						type: [f],
						json: {
							write: !0
						}
					})], c.prototype, "classes", void 0);
					return c = b.__decorate([m.subclass("esri.renderers.support.UniqueValueGroup")], c)
				})
		},
		"esri/renderers/support/UniqueValueInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./commonProperties".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					c = f = function(g) {
						function l(p) {
							p = g.call(this, p) || this;
							p.description = null;
							p.label = null;
							p.symbol = null;
							p.value = null;
							return p
						}
						a._inheritsLoose(l, g);
						var r = l.prototype;
						r.clone = function() {
							return new f({
								value: this.value,
								description: this.description,
								label: this.label,
								symbol: this.symbol ? this.symbol.clone() : null
							})
						};
						r.getMeshHash = function() {
							const p = JSON.stringify(this.symbol && this.symbol.toJSON());
							return `${this.value}.${p}`
						};
						return l
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "description", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "label", void 0);
					b.__decorate([e.property(m.rendererSymbolProperty)], c.prototype, "symbol", void 0);
					b.__decorate([e.property(m.uniqueValueProperty)], c.prototype, "value", void 0);
					return c = f = b.__decorate([v.subclass("esri.renderers.support.UniqueValueInfo")], c)
				})
		},
		"esri/symbols/support/styleUtils": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../request ../../core/Error ../../core/maybe ../../core/promiseUtils ../../core/urlUtils ../../portal/Portal ../../portal/PortalQueryParams ../../support/featureFlags".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					function l(q, u) {
						return r.apply(this, arguments)
					}

					function r() {
						r = b._asyncToGenerator(function*(q, u) {
							try {
								return {
									data: (yield t(q, u))
										.data,
									baseUrl: v.removeFile(q),
									styleUrl: q
								}
							} catch (x) {
								return k.throwIfAbortError(x), null
							}
						});
						return r.apply(this, arguments)
					}

					function p(q, u, x) {
						u = d.isSome(u.portal) ? u.portal : m.getDefault();
						let y;
						const w = `${u.url} - ${u.user&&u.user.username} - ${q}`;
						h[w] || (h[w] = n(q, u, x)
							.then(A => {
								y = A;
								return A.fetchData()
							})
							.then(A => ({
								data: A,
								baseUrl: y.itemUrl ? ? "",
								styleName: q
							})));
						return h[w]
					}

					function n(q, u, x) {
						return u.load(x)
							.then(() => {
								const y = new f({
									disableExtraQuery: !0,
									query: `owner:${"esri_en"} AND type:${"Style"} AND typekeywords:"${q}"`
								});
								return u.queryItems(y, x)
							})
							.then(({
								results: y
							}) => {
								let w = null;
								const A = q.toLowerCase();
								if (y && Array.isArray(y))
									for (const B of y)
										if (B.typeKeywords ? .some(E => E.toLowerCase() === A) && "Style" === B.type && "esri_en" === B.owner) {
											w = B;
											break
										} if (!w) throw new e("symbolstyleutils:style-not-found", `The style '${q}' could not be found`, {
									styleName: q
								});
								return w.load(x)
							})
					}

					function t(q, u) {
						u = {
							responseType: "json",
							query: {
								f: "json"
							},
							...u
						};
						return c(v.normalize(q), u)
					}
					const h = {};
					a.Style2DUrlTemplate = "https://cdn.arcgis.com/sharing/rest/content/items/220936cc6ed342c9937abd8f180e7d1e/resources/styles/cim/{SymbolName}.json?f\x3djson";
					a.fetchStyle = function(q, u, x) {
						return q && d.isSome(q.styleUrl) ? l(q.styleUrl, x) : q && d.isSome(q.styleName) ? p(q.styleName, u, x) : Promise.reject(new e("symbolstyleutils:style-url-and-name-missing", "Either styleUrl or styleName is required to resolve a style"))
					};
					a.makeCIMSymbolRef = function(q) {
						return null === q || "CIMSymbolReference" === q.type ? q : {
							type: "CIMSymbolReference",
							symbol: q
						}
					};
					a.requestJSON = t;
					a.symbolUrlFromStyleItem = function(q, u) {
						if ("cimRef" === u) return q.cimRef;
						if (q.formatInfos && !g.enableWebStyleForceWOSR())
							for (const x of q.formatInfos)
								if ("gltf" === x.type) return x.href;
						return q.webRef
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/support/featureFlags": function() {
			define(["exports", "../core/has"], function(a,
				b) {
				const c = () => b.cache["enable-feature:direct-3d-object-feature-layer-display"] = !0;
				a.enableDirect3DObjectFeatureLayerDisplay = () => !!b("enable-feature:direct-3d-object-feature-layer-display");
				a.enableSceneLayerEditing = () => {
					b.cache["enable-feature:SceneLayer-editing"] = !0;
					c()
				};
				a.enableWebStyleForceWOSR = () => !!b("enable-feature:force-wosr");
				a.sceneLayerEditingEnabled = () => !!b("enable-feature:SceneLayer-editing");
				a.turnOnDirect3DObjectFeatureLayerDisplay = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/renderers/support/jsonUtils": function() {
			define(["exports", "../../core/Warning", "../../core/accessorSupport/extensions/serializableProperty/reader", "./types"], function(a, b, c, e) {
				function d(v, m, f) {
					return v ? v && (v.styleName || v.styleUrl) && "uniqueValue" !== v.type ? (f && f.messages && f.messages.push(new b("renderer:unsupported", "Only UniqueValueRenderer can be referenced from a web style, but found '" + v.type + "'", {
						definition: v,
						context: f
					})), null) : k(v, m, f) : null
				}
				const k =
					c.createTypeReader({
						types: e.rendererTypes
					});
				a.fromJSON = function(v, m) {
					return d(v, null, m)
				};
				a.read = d;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/renderers/support/types": function() {
			define("exports ../ClassBreaksRenderer ../DictionaryRenderer ../DotDensityRenderer ../HeatmapRenderer ../PieChartRenderer ../Renderer ../SimpleRenderer ../UniqueValueRenderer".split(" "), function(a, b, c, e, d, k, v, m, f) {
				const g = {
					key: "type",
					base: v,
					typeMap: {
						simple: m,
						"unique-value": f,
						"class-breaks": b,
						heatmap: d
					},
					errorContext: "renderer"
				};
				a.rendererTypes = {
					key: "type",
					base: v,
					typeMap: {
						heatmap: d,
						simple: m,
						"unique-value": f,
						"class-breaks": b,
						"dot-density": e,
						dictionary: c,
						"pie-chart": k
					},
					errorContext: "renderer"
				};
				a.webSceneRendererTypes = g;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/MultiOriginJSONSupport": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Accessor ./ReadOnlyMultiOriginJSONSupport ./accessorSupport/PropertyOrigin ./accessorSupport/utils ./accessorSupport/write ./accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					const g = r => {
							r = function(p) {
								function n(...h) {
									return p.call(this, ...h) || this
								}
								b._inheritsLoose(n, p);
								var t = n.prototype;
								t.clear = function(h, q = "user") {
									return v.getProperties(this)
										.store.delete(h, k.nameToId(q))
								};
								t.write = function(h = {}, q) {
									h = h || {};
									m.write(this, h, q);
									return h
								};
								t.setAtOrigin = function(h, q, u) {
									v.getProperties(this)
										.setAtOrigin(h, q, k.nameToId(u))
								};
								t.removeOrigin = function(h) {
									const q = v.getProperties(this)
										.store;
									h = k.nameToId(h);
									const u = q.keys(h);
									for (const x of u) q.originOf(x) ===
										h && q.set(x, q.get(x, h), k.OriginId.USER)
								};
								t.updateOrigin = function(h, q) {
									const u = v.getProperties(this)
										.store;
									q = k.nameToId(q);
									const x = this.get(h);
									for (let y = q + 1; y < k.OriginIdNum; ++y) u.delete(h, y);
									u.set(h, x, q)
								};
								t.toJSON = function(h) {
									return this.write({}, h)
								};
								return n
							}(r);
							r = c.__decorate([f.subclass("esri.core.WriteableMultiOriginJSONSupport")], r);
							r.prototype.toJSON.isDefaultToJSON = !0;
							return r
						},
						l = r => {
							r = function(p) {
								function n(...t) {
									return p.call(this, ...t) || this
								}
								b._inheritsLoose(n, p);
								return n
							}(g(d.ReadOnlyMultiOriginJSONMixin(r)));
							return r = c.__decorate([f.subclass("esri.core.MultiOriginJSONSupport")], r)
						};
					a.MultiOriginJSONSupport = function(r) {
						function p() {
							return r.apply(this, arguments) || this
						}
						b._inheritsLoose(p, r);
						return p
					}(l(e));
					a.MultiOriginJSONSupport = c.__decorate([f.subclass("esri.core.MultiOriginJSONSupport")], a.MultiOriginJSONSupport);
					a.MultiOriginJSONMixin = l;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/ReadOnlyMultiOriginJSONSupport": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Accessor ./maybe ./accessorSupport/defaultsStoreUtils ./accessorSupport/MultiOriginStore ./accessorSupport/PropertyOrigin ./accessorSupport/read ./accessorSupport/utils ./accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					const r = p => {
						p = function(n) {
							function t(...q) {
								q = n.call(this, ...q) || this;
								const u = d.assumeNonNull(g.getProperties(b._assertThisInitialized(q))),
									x = u.store,
									y = new v;
								u.store = y;
								k.setupConstructedDefaults(u, x, y);
								return q
							}
							b._inheritsLoose(t, n);
							var h = t.prototype;
							h.read = function(q, u) {
								f.read(this, q, u)
							};
							h.getAtOrigin = function(q, u) {
								const x = g.getProperties(this)
									.store,
									y = m.nameToId(u);
								if ("string" === typeof q) return x.get(q, y);
								const w = {};
								q.forEach(A => {
									w[A] = x.get(A, y)
								});
								return w
							};
							h.originOf =
								function(q) {
									return m.idToName(this.originIdOf(q))
								};
							h.originIdOf = function(q) {
								return g.getProperties(this)
									.store.originOf(q)
							};
							h.revert = function(q, u) {
								const x = g.getProperties(this)
									.store,
									y = m.nameToId(u),
									w = g.getProperties(this);
								("string" === typeof q ? "*" === q ? x.keys(y) : [q] : q)
								.forEach(A => {
									w.invalidate(A);
									x.revert(A, y);
									w.commit(A)
								})
							};
							return t
						}(p);
						return p = c.__decorate([l.subclass("esri.core.ReadOnlyMultiOriginJSONSupport")], p)
					};
					a.ReadOnlyMultiOriginJSONSupport = function(p) {
						function n() {
							return p.apply(this, arguments) ||
								this
						}
						b._inheritsLoose(n, p);
						return n
					}(r(e));
					a.ReadOnlyMultiOriginJSONSupport = c.__decorate([l.subclass("esri.core.ReadOnlyMultiOriginJSONSupport")], a.ReadOnlyMultiOriginJSONSupport);
					a.ReadOnlyMultiOriginJSONMixin = r;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/accessorSupport/MultiOriginStore": function() {
			define(["../lang", "../maybe", "./PropertyOrigin"], function(a, b, c) {
				return function() {
					function e() {
						this._propertyOriginMap = new Map;
						this._originStores =
							Array(c.OriginIdNum);
						this._values = new Map;
						this.multipleOriginsSupported = !0
					}
					var d = e.prototype;
					d.clone = function(k) {
						const v = new e;
						var m = this._originStores[c.OriginId.DEFAULTS];
						m && m.forEach((f, g) => {
							v.set(g, a.clone(f), c.OriginId.DEFAULTS)
						});
						for (let f = c.OriginId.SERVICE; f < c.OriginIdNum; f++)(m = this._originStores[f]) && m.forEach((g, l) => {
							k && k.has(l) || v.set(l, a.clone(g), f)
						});
						return v
					};
					d.get = function(k, v) {
						return (v = void 0 === v ? this._values : this._originStores[v]) ? v.get(k) : void 0
					};
					d.keys = function(k) {
						return (k = null ==
							k ? this._values : this._originStores[k]) ? [...k.keys()] : []
					};
					d.set = function(k, v, m = c.OriginId.USER) {
						var f = this._originStores[m];
						f || (f = new Map, this._originStores[m] = f);
						f.set(k, v);
						return !this._values.has(k) || b.assumeNonNull(this._propertyOriginMap.get(k)) <= m ? (f = this._values.get(k), this._values.set(k, v), this._propertyOriginMap.set(k, m), f !== v) : !1
					};
					d.delete = function(k, v = c.OriginId.USER) {
						var m = this._originStores[v];
						if (m) {
							var f = m.get(k);
							m.delete(k);
							if (this._values.has(k) && this._propertyOriginMap.get(k) === v)
								for (this._values.delete(k),
									--v; 0 <= v; v--)
									if ((m = this._originStores[v]) && m.has(k)) {
										this._values.set(k, m.get(k));
										this._propertyOriginMap.set(k, v);
										break
									} return f
						}
					};
					d.has = function(k, v) {
						return (v = void 0 === v ? this._values : this._originStores[v]) ? v.has(k) : !1
					};
					d.revert = function(k, v) {
						for (; 0 < v && !this.has(k, v);) --v;
						var m = this._originStores[v];
						m = m && m.get(k);
						const f = this._values.get(k);
						this._values.set(k, m);
						this._propertyOriginMap.set(k, v);
						return f !== m
					};
					d.originOf = function(k) {
						return this._propertyOriginMap.get(k) || c.OriginId.DEFAULTS
					};
					d.forEach =
						function(k) {
							this._values.forEach(k)
						};
					return e
				}()
			})
		},
		"esri/core/sql": function() {
			define(["require", "exports", "../chunks/_rollupPluginBabelHelpers", "./maybe"], function(a, b, c, e) {
				function d() {
					d = c._asyncToGenerator(function*(k, v) {
						const {
							WhereClause: m
						} = yield new Promise((f, g) => a(["./sql/WhereClause"], f, g));
						return m.create(k, v)
					});
					return d.apply(this, arguments)
				}
				b.parseWhereClause = function(k, v) {
					return d.apply(this, arguments)
				};
				b.sqlAnd = function(k, v) {
					return e.isSome(k) ? e.isSome(v) ? `(${k}) AND (${v})` : k : v
				};
				Object.defineProperties(b, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/form/FormTemplate": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/lang ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer ./ExpressionInfo ./elements/GroupElement ./support/elements".split(" "), function(a, b, c, e, d,
				k, v, m, f, g, l, r) {
				var p;
				const n = r.buildTypeMaps(l);
				c = p = function(t) {
					function h(u) {
						u = t.call(this, u) || this;
						u.description = null;
						u.elements = null;
						u.expressionInfos = null;
						u.preserveFieldValuesWhenHidden = !1;
						u.title = null;
						return u
					}
					a._inheritsLoose(h, t);
					var q = h.prototype;
					q.castElements = function(u) {
						return r.ensureType(u, n)
					};
					q.readElements = function(u, x) {
						return r.fromJSON(x.formElements, n)
					};
					q.writeElements = function(u, x) {
						x.formElements = r.toJSON(u, n)
					};
					q.clone = function() {
						return new p({
							description: this.description,
							expressionInfos: e.clone(this.expressionInfos),
							elements: e.clone(this.elements),
							title: this.title,
							preserveFieldValuesWhenHidden: this.preserveFieldValuesWhenHidden
						})
					};
					return h
				}(c.JSONSupport);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "description", void 0);
				b.__decorate([d.property({
					json: {
						write: !0
					}
				})], c.prototype, "elements", void 0);
				b.__decorate([k.cast("elements")], c.prototype, "castElements", null);
				b.__decorate([v.reader("elements", ["formElements"])], c.prototype, "readElements", null);
				b.__decorate([f.writer("elements")], c.prototype,
					"writeElements", null);
				b.__decorate([d.property({
					type: [g],
					json: {
						write: !0
					}
				})], c.prototype, "expressionInfos", void 0);
				b.__decorate([d.property({
					type: Boolean,
					json: {
						default: !1,
						write: !0
					}
				})], c.prototype, "preserveFieldValuesWhenHidden", void 0);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "title", void 0);
				return c = p = b.__decorate([m.subclass("esri.form.FormTemplate")], c)
			})
		},
		"esri/form/ExpressionInfo": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/JSONSupport ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					c = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.expression = null;
							l.name = null;
							l.returnType = "boolean";
							l.title = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								name: this.name,
								title: this.title,
								expression: this.expression,
								returnType: this.returnType
							})
						};
						return g
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "expression", void 0);
					b.__decorate([e.property({
							type: String,
							json: {
								write: !0
							}
						})], c.prototype, "name",
						void 0);
					b.__decorate([e.property({
						type: ["boolean", "date", "number", "string"],
						json: {
							write: !0
						}
					})], c.prototype, "returnType", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "title", void 0);
					return c = m = b.__decorate([v.subclass("esri.form.ExpressionInfo")], c)
				})
		},
		"esri/form/elements/GroupElement": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./Element ../support/elements".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					f = l = function(p) {
						function n(h) {
							h = p.call(this, h) || this;
							h.elements = null;
							h.initialState = "expanded";
							h.type = "group";
							return h
						}
						a._inheritsLoose(n, p);
						var t = n.prototype;
						t.castElements = function(h) {
							return g.ensureType(h, r, !1)
						};
						t.readElements = function(h, q) {
							return g.fromJSON(q.formElements, r, !1)
						};
						t.writeElements = function(h, q) {
							q.formElements = g.toJSON(h, r, !1)
						};
						t.clone = function() {
							return new l({
								description: this.description,
								elements: c.clone(this.elements),
								initialState: this.initialState,
								label: this.label,
								visibilityExpression: this.visibilityExpression
							})
						};
						return n
					}(f);
					b.__decorate([e.property({
						json: {
							write: !0
						}
					})], f.prototype, "elements", void 0);
					b.__decorate([d.cast("elements")], f.prototype, "castElements", null);
					b.__decorate([k.reader("elements", ["formElements"])], f.prototype, "readElements", null);
					b.__decorate([m.writer("elements")], f.prototype, "writeElements", null);
					b.__decorate([e.property({
						type: ["collapsed", "expanded"],
						json: {
							write: !0
						}
					})], f.prototype, "initialState", void 0);
					b.__decorate([e.property({
						type: String,
						json: {
							read: !1,
							write: !0
						}
					})], f.prototype, "type", void 0);
					f = l = b.__decorate([v.subclass("esri.form.elements.GroupElement")], f);
					const r = g.buildTypeMaps(f);
					return f
				})
		},
		"esri/form/elements/Element": function() {
			define(["../../chunks/_rollupPluginBabelHelpers", "../../chunks/tslib.es6", "../../core/JSONSupport", "../../core/accessorSupport/decorators/property", "../../core/accessorSupport/decorators/subclass"], function(a, b, c, e, d) {
				c = function(k) {
					function v(m) {
						m = k.call(this, m) || this;
						m.description = null;
						m.label = null;
						m.type = null;
						m.visibilityExpression = null;
						return m
					}
					a._inheritsLoose(v, k);
					return v
				}(c.JSONSupport);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "description", void 0);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "label", void 0);
				b.__decorate([e.property()], c.prototype, "type", void 0);
				b.__decorate([e.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "visibilityExpression", void 0);
				return c = b.__decorate([d.subclass("esri.form.elements.Element")], c)
			})
		},
		"esri/form/support/elements": function() {
			define("exports ../../core/accessorSupport/ensureType ../elements/AttachmentElement ../elements/Element ../elements/FieldElement ../elements/RelationshipElement".split(" "),
				function(a, b, c, e, d, k) {
					a.buildTypeMaps = function(v) {
						return {
							typesWithGroup: {
								base: e,
								key: "type",
								typeMap: {
									attachment: c,
									field: d,
									group: v,
									relationship: k
								}
							},
							typesWithoutGroup: {
								base: e,
								key: "type",
								typeMap: {
									attachment: c,
									field: d,
									relationship: k
								}
							}
						}
					};
					a.ensureType = function(v, m, f = !0) {
						return v ? v.map(g => b.ensureOneOfType(f ? m.typesWithGroup : m.typesWithoutGroup, g)) : null
					};
					a.fromJSON = function(v, m, f = !0) {
						if (!v) return null;
						const g = f ? m.typesWithGroup.typeMap : m.typesWithoutGroup.typeMap;
						return v.filter(l => g[l.type])
							.map(l => g[l.type].fromJSON(l))
					};
					a.toJSON = function(v, m, f = !0) {
						if (!v) return null;
						const g = f ? m.typesWithGroup.typeMap : m.typesWithoutGroup.typeMap;
						return v.filter(l => g[l.type])
							.map(l => l.toJSON())
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/form/elements/AttachmentElement": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Element ./inputs/AttachmentInput".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					e = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.attachmentKeyword = null;
							r.editable = !0;
							r.input = null;
							r.type = "attachment";
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								attachmentKeyword: this.attachmentKeyword,
								description: this.description,
								editable: this.editable,
								input: this.input,
								label: this.label,
								visibilityExpression: this.visibilityExpression
							})
						};
						return l
					}(v);
					b.__decorate([c.property({
							type: String,
							json: {
								write: !0
							}
						})], e.prototype, "attachmentKeyword",
						void 0);
					b.__decorate([c.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], e.prototype, "editable", void 0);
					b.__decorate([c.property({
						type: m,
						json: {
							read: {
								source: "inputType"
							},
							write: {
								target: "inputType"
							}
						}
					})], e.prototype, "input", void 0);
					b.__decorate([c.property({
						type: ["attachment"],
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = f = b.__decorate([k.subclass("esri.form.elements.AttachmentElement")], e)
				})
		},
		"esri/form/elements/inputs/AttachmentInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					c = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.type = null;
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								type: this.type
							})
						};
						return g
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: "attachment audio document image signature video".split(" "),
						json: {
							write: !0
						}
					})], c.prototype, "type", void 0);
					return c = m = b.__decorate([v.subclass("esri.form.elements.inputs.AttachmentInput")], c)
				})
		},
		"esri/form/elements/FieldElement": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Element ./support/inputs ../../layers/support/domains".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					e = g = function(l) {
						function r(p) {
							p = l.call(this, p) || this;
							p.domain = null;
							p.editable = !0;
							p.editableExpression = null;
							p.fieldName = null;
							p.hint = null;
							p.input = null;
							p.requiredExpression = null;
							p.type = "field";
							p.valueExpression = null;
							return p
						}
						a._inheritsLoose(r, l);
						r.prototype.clone = function() {
							return new g({
								description: this.description,
								domain: this.domain,
								editable: this.editable,
								editableExpression: this.editableExpression,
								fieldName: this.fieldName,
								hint: this.hint,
								input: this.input,
								label: this.label,
								requiredExpression: this.requiredExpression,
								valueExpression: this.valueExpression,
								visibilityExpression: this.visibilityExpression
							})
						};
						return r
					}(v);
					b.__decorate([c.property({
						types: f.types,
						json: {
							read: {
								reader: f.fromJSON
							},
							write: !0
						}
					})], e.prototype, "domain", void 0);
					b.__decorate([c.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], e.prototype, "editable", void 0);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "editableExpression", void 0);
					b.__decorate([c.property({
							type: String,
							json: {
								write: !0
							}
						})], e.prototype,
						"fieldName", void 0);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "hint", void 0);
					b.__decorate([c.property({
						types: m.types,
						json: {
							read: {
								source: "inputType"
							},
							write: {
								target: "inputType"
							}
						}
					})], e.prototype, "input", void 0);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "requiredExpression", void 0);
					b.__decorate([c.property({
						type: String,
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					b.__decorate([c.property({
							type: String,
							json: {
								write: !0
							}
						})], e.prototype, "valueExpression",
						void 0);
					return e = g = b.__decorate([k.subclass("esri.form.elements.FieldElement")], e)
				})
		},
		"esri/form/elements/support/inputs": function() {
			define("exports ../inputs/BarcodeScannerInput ../inputs/ComboBoxInput ../inputs/DateTimePickerInput ../inputs/Input ../inputs/RadioButtonsInput ../inputs/SwitchInput ../inputs/TextAreaInput ../inputs/TextBoxInput".split(" "), function(a, b, c, e, d, k, v, m, f) {
				a.types = {
					base: d,
					key: "type",
					typeMap: {
						"barcode-scanner": b,
						"combo-box": c,
						"datetime-picker": e,
						"radio-buttons": k,
						switch: v,
						"text-area": m,
						"text-box": f
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/form/elements/inputs/BarcodeScannerInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./TextInput".split(" "), function(a, b, c, e, d, k, v) {
				var m;
				e = m = function(f) {
					function g(l) {
						l =
							f.call(this, l) || this;
						l.type = "barcode-scanner";
						return l
					}
					a._inheritsLoose(g, f);
					g.prototype.clone = function() {
						return new m({
							maxLength: this.maxLength,
							minLength: this.minLength
						})
					};
					return g
				}(v);
				b.__decorate([c.property({
					type: ["barcode-scanner"],
					json: {
						read: !1,
						write: !0
					}
				})], e.prototype, "type", void 0);
				return e = m = b.__decorate([k.subclass("esri.form.elements.inputs.BarcodeScannerInput")], e)
			})
		},
		"esri/form/elements/inputs/TextInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./Input".split(" "),
				function(a, b, c, e, d, k, v) {
					e = function(m) {
						function f(g) {
							g = m.call(this, g) || this;
							g.maxLength = null;
							g.minLength = 0;
							return g
						}
						a._inheritsLoose(f, m);
						return f
					}(v);
					b.__decorate([c.property({
						type: Number,
						json: {
							write: !0
						}
					})], e.prototype, "maxLength", void 0);
					b.__decorate([c.property({
						type: Number,
						json: {
							write: !0
						}
					})], e.prototype, "minLength", void 0);
					return e = b.__decorate([k.subclass("esri.form.elements.inputs.TextInput")], e)
				})
		},
		"esri/form/elements/inputs/Input": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f(g) {
							g = m.call(this, g) || this;
							g.type = null;
							return g
						}
						a._inheritsLoose(f, m);
						return f
					}(c.JSONSupport);
					b.__decorate([e.property()], c.prototype, "type", void 0);
					return c = b.__decorate([v.subclass("esri.form.elements.inputs.Input")], c)
				})
		},
		"esri/form/elements/inputs/ComboBoxInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./Input".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.noValueOptionLabel = null;
							l.showNoValueOption = !0;
							l.type = "combo-box";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								showNoValueOption: this.showNoValueOption,
								noValueOptionLabel: this.noValueOptionLabel
							})
						};
						return g
					}(v);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "noValueOptionLabel", void 0);
					b.__decorate([c.property({
							type: Boolean,
							json: {
								write: !0
							}
						})], e.prototype, "showNoValueOption",
						void 0);
					b.__decorate([c.property({
						type: ["combo-box"],
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = m = b.__decorate([k.subclass("esri.form.elements.inputs.ComboBoxInput")], e)
				})
		},
		"esri/form/elements/inputs/DateTimePickerInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/reader ../../../core/accessorSupport/decorators/subclass ../../../core/accessorSupport/decorators/writer ./Input".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					function g(r) {
						return null != r ? new Date(r) : null
					}
					var l;
					e = l = function(r) {
						function p(t) {
							t = r.call(this, t) || this;
							t.includeTime = !1;
							t.max = null;
							t.min = null;
							t.type = "datetime-picker";
							return t
						}
						a._inheritsLoose(p, r);
						var n = p.prototype;
						n.readMax = function(t, h) {
							return g(h.max)
						};
						n.writeMax = function(t, h) {
							h.max = t ? t.getTime() : null
						};
						n.readMin = function(t, h) {
							return g(h.min)
						};
						n.writeMin = function(t, h) {
							h.min = t ? t.getTime() : null
						};
						n.clone = function() {
							return new l({
								includeTime: this.includeTime,
								max: this.max,
								min: this.min,
								type: this.type
							})
						};
						return p
					}(f);
					b.__decorate([c.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], e.prototype, "includeTime", void 0);
					b.__decorate([c.property({
						type: Date,
						json: {
							type: Number,
							write: !0
						}
					})], e.prototype, "max", void 0);
					b.__decorate([k.reader("max")], e.prototype, "readMax", null);
					b.__decorate([m.writer("max")], e.prototype, "writeMax", null);
					b.__decorate([c.property({
						type: Date,
						json: {
							type: Number,
							write: !0
						}
					})], e.prototype, "min", void 0);
					b.__decorate([k.reader("min")], e.prototype, "readMin", null);
					b.__decorate([m.writer("min")],
						e.prototype, "writeMin", null);
					b.__decorate([c.property({
						type: ["datetime-picker"],
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = l = b.__decorate([v.subclass("esri.form.elements.inputs.DateTimePickerInput")], e)
				})
		},
		"esri/form/elements/inputs/RadioButtonsInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./Input".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.noValueOptionLabel = null;
							l.showNoValueOption = !0;
							l.type = "radio-buttons";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								noValueOptionLabel: this.noValueOptionLabel,
								showNoValueOption: this.showNoValueOption
							})
						};
						return g
					}(v);
					b.__decorate([c.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "noValueOptionLabel", void 0);
					b.__decorate([c.property({
							type: Boolean,
							json: {
								write: !0
							}
						})], e.prototype, "showNoValueOption",
						void 0);
					b.__decorate([c.property({
						type: ["radio-buttons"],
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = m = b.__decorate([k.subclass("esri.form.elements.inputs.RadioButtonsInput")], e)
				})
		},
		"esri/form/elements/inputs/SwitchInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./Input".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.offValue = null;
							l.onValue = null;
							l.type = "switch";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								offValue: this.offValue,
								onValue: this.onValue
							})
						};
						return g
					}(v);
					b.__decorate([c.property({
						type: [String, Number],
						json: {
							write: !0
						}
					})], e.prototype, "offValue", void 0);
					b.__decorate([c.property({
						type: [String, Number],
						json: {
							write: !0
						}
					})], e.prototype, "onValue", void 0);
					b.__decorate([c.property({
						type: ["switch"],
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = m = b.__decorate([k.subclass("esri.form.elements.inputs.SwitchInput")], e)
				})
		},
		"esri/form/elements/inputs/TextAreaInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./TextInput".split(" "), function(a, b, c, e, d, k, v) {
				var m;
				e = m = function(f) {
					function g(l) {
						l =
							f.call(this, l) || this;
						l.type = "text-area";
						return l
					}
					a._inheritsLoose(g, f);
					g.prototype.clone = function() {
						return new m({
							maxLength: this.maxLength,
							minLength: this.minLength
						})
					};
					return g
				}(v);
				b.__decorate([c.property({
					type: ["text-area"],
					json: {
						read: !1,
						write: !0
					}
				})], e.prototype, "type", void 0);
				return e = m = b.__decorate([k.subclass("esri.form.elements.inputs.TextAreaInput")], e)
			})
		},
		"esri/form/elements/inputs/TextBoxInput": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./TextInput".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.type = "text-box";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m({
								maxLength: this.maxLength,
								minLength: this.minLength
							})
						};
						return g
					}(v);
					b.__decorate([c.property({
						type: ["text-box"],
						json: {
							read: !1,
							write: !0
						}
					})], e.prototype, "type", void 0);
					return e = m = b.__decorate([k.subclass("esri.form.elements.inputs.TextBoxInput")], e)
				})
		},
		"esri/layers/support/domains": function() {
			define("exports ../../core/has ./CodedValueDomain ./Domain ./InheritedDomain ./RangeDomain".split(" "),
				function(a, b, c, e, d, k) {
					b = {
						key: "type",
						base: e,
						typeMap: {
							range: k,
							"coded-value": c,
							inherited: d
						}
					};
					a.CodedValueDomain = c;
					a.DomainBase = e;
					a.InheritedDomain = d;
					a.RangeDomain = k;
					a.fromJSON = function(v) {
						if (!v || !v.type) return null;
						switch (v.type) {
							case "range":
								return k.fromJSON(v);
							case "codedValue":
								return c.fromJSON(v);
							case "inherited":
								return d.fromJSON(v)
						}
						return null
					};
					a.types = b;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/CodedValueDomain": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./CodedValue ./Domain".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					d = g = function(l) {
						function r(n) {
							n = l.call(this, n) || this;
							n.codedValues = null;
							n.type = "coded-value";
							return n
						}
						a._inheritsLoose(r, l);
						var p = r.prototype;
						p.getName = function(n) {
							let t = null;
							if (this.codedValues) {
								const h = String(n);
								this.codedValues.some(q => {
									String(q.code) === h && (t = q.name);
									return !!t
								})
							}
							return t
						};
						p.clone = function() {
							return new g({
								codedValues: c.clone(this.codedValues),
								name: this.name
							})
						};
						return r
					}(f);
					b.__decorate([e.property({
							type: [m.CodedValue],
							json: {
								write: !0
							}
						})], d.prototype,
						"codedValues", void 0);
					b.__decorate([k.enumeration({
						codedValue: "coded-value"
					})], d.prototype, "type", void 0);
					return d = g = b.__decorate([v.subclass("esri.layers.support.CodedValueDomain")], d)
				})
		},
		"esri/layers/support/CodedValue": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a,
				b, c, e, d, k, v, m) {
				var f;
				a.CodedValue = f = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.name = null;
						r.code = null;
						return r
					}
					b._inheritsLoose(l, g);
					l.prototype.clone = function() {
						return new f({
							name: this.name,
							code: this.code
						})
					};
					return l
				}(e.JSONSupport);
				c.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], a.CodedValue.prototype, "name", void 0);
				c.__decorate([d.property({
					type: [String, Number],
					json: {
						write: !0
					}
				})], a.CodedValue.prototype, "code", void 0);
				a.CodedValue = f = c.__decorate([m.subclass("esri.layers.support.CodedValue")],
					a.CodedValue);
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/Domain": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m, f) {
				c =
					new c.JSONMap({
						inherited: "inherited",
						codedValue: "coded-value",
						range: "range"
					});
				e = function(g) {
					function l(r) {
						r = g.call(this, r) || this;
						r.name = null;
						r.type = null;
						return r
					}
					a._inheritsLoose(l, g);
					return l
				}(e.JSONSupport);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], e.prototype, "name", void 0);
				b.__decorate([m.enumeration(c)], e.prototype, "type", void 0);
				return e = b.__decorate([f.subclass("esri.layers.support.Domain")], e)
			})
		},
		"esri/layers/support/InheritedDomain": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Logger ../../core/accessorSupport/ensureType ../../core/arrayUtils ../../core/Error ../../core/has ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./Domain".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					c = l = function(r) {
						function p(n) {
							n = r.call(this, n) || this;
							n.type = "inherited";
							return n
						}
						a._inheritsLoose(p, r);
						p.prototype.clone = function() {
							return new l
						};
						return p
					}(g);
					b.__decorate([m.enumeration({
						inherited: "inherited"
					})], c.prototype, "type", void 0);
					return c = l = b.__decorate([f.subclass("esri.layers.support.InheritedDomain")], c)
				})
		},
		"esri/layers/support/RangeDomain": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ./Domain".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					e = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.maxValue = null;
							r.minValue = null;
							r.type = "range";
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								maxValue: this.maxValue,
								minValue: this.minValue,
								name: this.name
							})
						};
						return l
					}(m);
					b.__decorate([c.property({
						type: Number,
						json: {
							type: [Number],
							read: {
								source: "range",
								reader(g, l) {
									return l.range && l.range[1]
								}
							},
							write: {
								enabled: !1,
								overridePolicy() {
									return {
										enabled: null != this.maxValue && null == this.minValue
									}
								},
								target: "range",
								writer(g, l, r) {
									l[r] = [this.minValue || 0, g]
								}
							}
						}
					})], e.prototype, "maxValue", void 0);
					b.__decorate([c.property({
						type: Number,
						json: {
							type: [Number],
							read: {
								source: "range",
								reader(g, l) {
									return l.range && l.range[0]
								}
							},
							write: {
								target: "range",
								writer(g, l, r) {
									l[r] = [g, this.maxValue || 0]
								}
							}
						}
					})], e.prototype, "minValue", void 0);
					b.__decorate([k.enumeration({
						range: "range"
					})], e.prototype, "type", void 0);
					return e = f = b.__decorate([v.subclass("esri.layers.support.RangeDomain")], e)
				})
		},
		"esri/form/elements/RelationshipElement": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./Element ../../popup/support/RelatedRecordsInfoFieldOrder".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					d = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.displayCount = null;
							r.displayType = "list";
							r.editable = !0;
							r.orderByFields = null;
							r.relationshipId = null;
							r.type = "relationship";
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								description: this.description,
								displayCount: this.displayCount,
								displayType: this.displayType,
								editable: this.editable,
								label: this.label,
								orderByFields: c.clone(this.orderByFields),
								relationshipId: this.relationshipId,
								visibilityExpression: this.visibilityExpression
							})
						};
						return l
					}(v);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], d.prototype, "displayCount", void 0);
					b.__decorate([e.property({
						type: ["list"],
						json: {
							write: !0
						}
					})], d.prototype, "displayType", void 0);
					b.__decorate([e.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], d.prototype, "editable", void 0);
					b.__decorate([e.property({
						type: [m],
						json: {
							write: !0
						}
					})], d.prototype, "orderByFields", void 0);
					b.__decorate([e.property({
						type: Number,
						json: {
							write: !0
						}
					})], d.prototype, "relationshipId", void 0);
					b.__decorate([e.property({
						type: ["relationship"],
						json: {
							read: !1,
							write: !0
						}
					})], d.prototype, "type", void 0);
					return d = f = b.__decorate([k.subclass("esri.form.elements.RelationshipElement")], d)
				})
		},
		"esri/layers/graphics/sources/MemorySource": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../geometry ../../../Graphic ../../../core/Collection ../../../core/Error ../../../core/HandleOwner ../../../core/has ../../../core/Loadable ../../../core/Logger ../../../core/maybe ../../../core/Promise ../../../core/workers/workers ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/shared ../../../core/accessorSupport/decorators/subclass ../../../rest/query/operations/editsZScale ../../../rest/query/operations/queryZScale ../../../rest/support/FeatureSet ../../../geometry/Extent ../../../geometry/Polygon ../../../geometry/support/typeUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z) {
					let C = 0;
					const D = l.getLogger("esri.layers.graphics.sources.MemorySource");
					a.MemorySource = function(J) {
						function K(G) {
							G = J.call(this, G) || this;
							G._idToClientGraphic = null;
							G.type = "memory";
							return G
						}
						b._inheritsLoose(K, J);
						var H = K.prototype;
						H.load = function(G) {
							G = r.isSome(G) ? G.signal : null;
							this.addResolvingPromise(this._startWorker(G));
							return Promise.resolve(this)
						};
						H.destroy = function() {
							this._connection ? .close();
							this._connection = null
						};
						H.applyEdits = function(G) {
							return this.load()
								.then(() =>
									this._applyEdits(G))
						};
						H.openPorts = function() {
							return this.load()
								.then(() => this._connection.openPorts())
						};
						H.queryFeatures = function() {
							var G = b._asyncToGenerator(function*(F, L = {}) {
								yield this.load(L);
								L = yield this._connection.invoke("queryFeatures", F ? F.toJSON() : null, L);
								w.applyFeatureSetZUnitScaling(F, this.layer.spatialReference, L);
								F = A.fromJSON(L);
								if (!this._requiresClientGraphicMapping()) return F;
								L = this.layer.objectIdField;
								for (const R of F.features) {
									const V = this._idToClientGraphic.get(R.attributes[L]);
									V &&
										(R.geometry = V.geometry)
								}
								F.geometryType = this.layer.geometryType;
								return F
							});
							return function(F) {
								return G.apply(this, arguments)
							}
						}();
						H.queryFeaturesJSON = function() {
							var G = b._asyncToGenerator(function*(F, L = {}) {
								if (this._requiresClientGraphicMapping()) throw new v("query-features-json:unsupported", "Cannot query in JSON format for client only geometry types (mesh and extent)");
								yield this.load(L);
								L = yield this._connection.invoke("queryFeatures", F ? F.toJSON() : null, L);
								w.applyFeatureSetZUnitScaling(F, this.layer.spatialReference,
									L);
								return L
							});
							return function(F) {
								return G.apply(this, arguments)
							}
						}();
						H.queryFeatureCount = function(G, F = {}) {
							return this.load(F)
								.then(() => this._connection.invoke("queryFeatureCount", G ? G.toJSON() : null, F))
						};
						H.queryObjectIds = function(G, F = {}) {
							return this.load(F)
								.then(() => this._connection.invoke("queryObjectIds", G ? G.toJSON() : null, F))
						};
						H.queryExtent = function(G, F = {}) {
							return this.load(F)
								.then(() => this._connection.invoke("queryExtent", G ? G.toJSON() : null, F))
								.then(L => ({
									count: L.count,
									extent: B.fromJSON(L.extent)
								}))
						};
						H.querySnapping = function(G, F = {}) {
							return this.load(F)
								.then(() => this._connection.invoke("querySnapping", G, F))
						};
						H._applyEdits = function() {
							var G = b._asyncToGenerator(function*(F) {
								if (!this._connection) throw new v("feature-layer-source:edit-failure", "Memory source not loaded");
								const L = this.layer.objectIdField;
								let R = null;
								const V = [],
									U = [];
								yield Promise.all([this._prepareClientMapping(F.addFeatures, null), this._prepareClientMapping(F.updateFeatures, null)]);
								const W = oa => "objectId" in oa && null != oa.objectId ? oa.objectId :
									"attributes" in oa && null != oa.attributes[L] ? oa.attributes[L] : null;
								F.addFeatures && (R = this._prepareAddFeatures(F.addFeatures));
								if (F.deleteFeatures)
									for (var M of F.deleteFeatures) {
										const oa = W(M);
										null != oa && V.push(oa)
									}
								M = F.updateFeatures && this._idToClientGraphic ? new Map : null;
								if (F.updateFeatures)
									for (const oa of F.updateFeatures) U.push(this._serializeFeature(oa)), M && (F = W(oa), null != F && M.set(F, oa));
								y.unapplyEditsZUnitScaling(R ? R.features : null, U, this.layer.spatialReference);
								const {
									fullExtent: T,
									featureEditResults: Z
								} =
								yield this._connection.invoke("applyEdits", {
									adds: R ? R.features : [],
									updates: U,
									deletes: V
								});
								this.fullExtent = T;
								R && R.finish(Z.uidToObjectId);
								this._updateClientGraphicIds(M, Z);
								return this._createEditsResult(Z)
							});
							return function(F) {
								return G.apply(this, arguments)
							}
						}();
						H._prepareClientMapping = function() {
							var G = b._asyncToGenerator(function*(F, L) {
								if ("mesh" === this._layerOrSourceGeometryType && !r.isNone(F)) {
									var R = [];
									for (const {
										geometry: V
									} of F) !r.isSome(V) || "mesh" !== V.type || V.hasExtent || V.loaded || R.push(V.load({
										signal: L
									}));
									R.length && (yield Promise.all(R))
								}
							});
							return function(F, L) {
								return G.apply(this, arguments)
							}
						}();
						H._updateClientGraphicIds = function(G, F) {
							if (this._idToClientGraphic) {
								if (G)
									for (const L of F.updateResults) {
										if (!L.success) continue;
										const R = G.get(L.objectId);
										null != R && this._addIdToClientGraphic(R)
									}
								for (const L of F.deleteResults) L.success && this._idToClientGraphic.delete(L.objectId)
							}
						};
						H._createEditsResult = function(G) {
							return {
								addFeatureResults: G.addResults ? G.addResults.map(this._createFeatureEditResult, this) : [],
								updateFeatureResults: G.updateResults ?
									G.updateResults.map(this._createFeatureEditResult, this) : [],
								deleteFeatureResults: G.deleteResults ? G.deleteResults.map(this._createFeatureEditResult, this) : [],
								addAttachmentResults: [],
								updateAttachmentResults: [],
								deleteAttachmentResults: []
							}
						};
						H._createFeatureEditResult = function(G) {
							const F = !0 === G.success ? null : G.error || {
								code: void 0,
								description: void 0
							};
							return {
								objectId: G.objectId,
								globalId: G.globalId,
								error: F ? new v("feature-layer-source:edit-failure", F.description, {
									code: F.code
								}) : null
							}
						};
						H._prepareAddFeatures = function(G) {
							const F =
								new Map,
								L = Array(G.length);
							let R = null;
							for (let U = 0; U < G.length; U++) {
								const W = G[U],
									M = this._serializeFeature(W);
								!R && r.isSome(W.geometry) && (R = W.geometry.type);
								L[U] = M;
								F.set(`${M.uid}`, W)
							}
							const V = this;
							return {
								features: L,
								inferredGeometryType: R,
								finish(U) {
									const W = V.sourceJSON.objectIdField;
									for (const M in U) {
										const T = U[M],
											Z = F.get(M);
										Z && (Z.attributes || (Z.attributes = {}), -1 === T ? delete Z.attributes[W] : Z.attributes[W] = T, V._addIdToClientGraphic(Z))
									}
								}
							}
						};
						H._addIdToClientGraphic = function(G) {
							if (this._idToClientGraphic) {
								var F =
									this.sourceJSON.objectIdField;
								F = G.attributes && G.attributes[F];
								null != F && this._idToClientGraphic.set(F, G)
							}
						};
						H._requiresClientGraphicMapping = function() {
							return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType)
						};
						H._geometryRequiresClientGraphicMapping = function(G) {
							return this._geometryTypeRequiresClientGraphicMapping(G.type)
						};
						H._geometryTypeRequiresClientGraphicMapping = function(G) {
							return "mesh" === G || "multipatch" === G || "extent" === G
						};
						H._serializeFeature = function(G) {
							const {
								attributes: F
							} =
							G;
							G = this._geometryForSerialization(G);
							const L = (C++)
								.toString();
							return G ? {
								uid: L,
								geometry: G.toJSON(),
								attributes: F
							} : {
								uid: L,
								attributes: F
							}
						};
						H._geometryForSerialization = function(G) {
							({
								geometry: G
							} = G);
							return r.isNone(G) ? null : this._geometryRequiresClientGraphicMapping(G) ? G.extent ? E.fromExtent(G.extent) : null : G
						};
						H._startWorker = function() {
							var G = b._asyncToGenerator(function*(F) {
								this._connection = yield n.open("MemorySourceWorker", {
									strategy: f("feature-layers-workers") ? "dedicated" : "local",
									signal: F
								});
								const {
									fields: L,
									spatialReference: R,
									objectIdField: V,
									hasM: U,
									hasZ: W,
									timeInfo: M
								} = this.layer;
								var T = "defaults" === this.layer.originOf("spatialReference");
								yield this._prepareClientMapping(this.items, F);
								const Z = this._prepareAddFeatures(this.items);
								this.handles.add(this.on("before-changes", qa => {
									D.error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead");
									qa.preventDefault()
								}));
								T = {
									features: Z.features,
									fields: L && L.map(qa => qa.toJSON()),
									geometryType: z.typeKebabDictionary.toJSON(this._workerGeometryType),
									hasM: "mesh" === this._layerOrSourceGeometryType ? !1 : U,
									hasZ: "mesh" === this._layerOrSourceGeometryType ? !0 : W,
									objectIdField: V,
									spatialReference: T ? null : R && R.toJSON(),
									timeInfo: M ? M.toJSON() : null
								};
								F = yield this._connection.invoke("load", T, {
									signal: F
								});
								for (var oa of F.warnings) D.warn(oa.message, {
									layer: this.layer,
									warning: oa
								});
								F.featureErrors.length && D.warn(`Encountered ${F.featureErrors.length} validation errors while loading features`, F.featureErrors);
								oa = F.layerDefinition;
								this._geometryTypeRequiresClientGraphicMapping(Z.inferredGeometryType) &&
									(oa.geometryType = z.typeKebabDictionary.toJSON(Z.inferredGeometryType));
								this.sourceJSON = oa;
								this._requiresClientGraphicMapping() && (this._idToClientGraphic = new Map);
								Z.finish(F.assignedObjectIds)
							});
							return function(F) {
								return G.apply(this, arguments)
							}
						}();
						b._createClass(K, [{
							key: "_workerGeometryType",
							get: function() {
								const G = this.layer ? .geometryType;
								return G ? this._geometryTypeRequiresClientGraphicMapping(G) ? "polygon" : G : null
							}
						}, {
							key: "_layerOrSourceGeometryType",
							get: function() {
								return this.layer ? .geometryType ? ?
									this.sourceJSON ? .geometryType
							}
						}]);
						return K
					}(g.LoadableMixin(p.EsriPromiseMixin(m.HandleOwnerMixin(k))));
					c.__decorate([u.shared({
						Type: d,
						ensureType: q.ensureType(d)
					})], a.MemorySource.prototype, "itemType", void 0);
					c.__decorate([t.property()], a.MemorySource.prototype, "type", void 0);
					c.__decorate([t.property({
						constructOnly: !0
					})], a.MemorySource.prototype, "layer", void 0);
					c.__decorate([t.property({
						readOnly: !0
					})], a.MemorySource.prototype, "_workerGeometryType", null);
					c.__decorate([t.property()], a.MemorySource.prototype,
						"sourceJSON", void 0);
					a.MemorySource = c.__decorate([x.subclass("esri.layers.graphics.sources.MemorySource")], a.MemorySource);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/HandleOwner": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ./Accessor ./Handles ./accessorSupport/decorators/property ./accessorSupport/decorators/subclass ./support/WatchUpdatingTracking".split(" "), function(a, b, c, e, d, k, v, m) {
				const f = g => {
					g =
						function(l) {
							function r() {
								return l.apply(this, arguments) || this
							}
							b._inheritsLoose(r, l);
							r.prototype.destroy = function() {
								this.destroyed || (this._get("handles") ? .destroy(), this._get("updatingHandles") ? .destroy())
							};
							b._createClass(r, [{
								key: "handles",
								get: function() {
									return this._get("handles") || new d
								}
							}, {
								key: "updatingHandles",
								get: function() {
									return this._get("updatingHandles") || new m.WatchUpdatingTracking
								}
							}]);
							return r
						}(g);
					c.__decorate([k.property({
						readOnly: !0
					})], g.prototype, "handles", null);
					c.__decorate([k.property({
							readOnly: !0
						})],
						g.prototype, "updatingHandles", null);
					return g = c.__decorate([v.subclass("esri.core.HandleOwner")], g)
				};
				a.HandleOwner = function(g) {
					function l() {
						return g.apply(this, arguments) || this
					}
					b._inheritsLoose(l, g);
					return l
				}(f(e));
				a.HandleOwner = c.__decorate([v.subclass("esri.core.HandleOwner")], a.HandleOwner);
				a.HandleOwnerMixin = f;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/support/WatchUpdatingTracking": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../Accessor ../Handles ../maybe ../reactiveUtils ../scheduling ../accessorSupport/decorators/property ../accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					a.WatchUpdatingTracking = function(l) {
						function r() {
							var n = l.apply(this, arguments) || this;
							n.updating = !1;
							n._handleId = 0;
							n._handles = new d;
							n._scheduleHandleId = 0;
							n._pendingPromises = new Set;
							return n
						}
						b._inheritsLoose(r, l);
						var p = r.prototype;
						p.destroy = function() {
							this.removeAll();
							this._handles.destroy()
						};
						p.add = function(n, t, h = {}) {
							return this._installWatch(n, t, h, v.watch)
						};
						p.addWhen = function(n, t, h = {}) {
							return this._installWatch(n, t, h, v.when)
						};
						p.addOnCollectionChange = function(n, t, {
							initial: h = !1,
							final: q = !1
						} = {}) {
							const u = ++this._handleId;
							this._handles.add([v.on(n, "after-changes", this._createSyncUpdatingCallback(), v.sync), v.on(n, "change", t, {
								onListenerAdd: h ? x => t({
									added: x.toArray(),
									removed: []
								}) : void 0,
								onListenerRemove: q ? x => t({
									added: [],
									removed: x.toArray()
								}) : void 0
							})], u);
							return {
								remove: () => this._handles.remove(u)
							}
						};
						p.addPromise = function(n) {
							if (k.isNone(n)) return n;
							const t = ++this._handleId;
							this._handles.add({
								remove: () => {
									this._pendingPromises.delete(n) && (0 !== this._pendingPromises.size || this._handles.has(-42) ||
										this._set("updating", !1))
								}
							}, t);
							this._pendingPromises.add(n);
							this._set("updating", !0);
							const h = () => this._handles.remove(t);
							n.then(h, h);
							return n
						};
						p.removeAll = function() {
							this._pendingPromises.clear();
							this._handles.removeAll();
							this._set("updating", !1)
						};
						p._installWatch = function(n, t, h = {}, q) {
							const u = ++this._handleId;
							h.sync || this._installSyncUpdatingWatch(n, u);
							n = q(n, t, h);
							this._handles.add(n, u);
							return {
								remove: () => this._handles.remove(u)
							}
						};
						p._installSyncUpdatingWatch = function(n, t) {
							const h = this._createSyncUpdatingCallback();
							n = v.watch(n, h, {
								sync: !0,
								equals: () => !1
							});
							this._handles.add(n, t);
							return n
						};
						p._createSyncUpdatingCallback = function() {
							return () => {
								this._handles.remove(-42);
								++this._scheduleHandleId;
								const n = this._scheduleHandleId;
								this._get("updating") || this._set("updating", !0);
								this._handles.add(m.schedule(() => {
									n === this._scheduleHandleId && (this._set("updating", 0 < this._pendingPromises.size), this._handles.remove(-42))
								}), -42)
							}
						};
						return r
					}(e);
					c.__decorate([f.property({
							readOnly: !0
						})], a.WatchUpdatingTracking.prototype, "updating",
						void 0);
					a.WatchUpdatingTracking = c.__decorate([g.subclass("esri.core.support.WatchUpdatingTracking")], a.WatchUpdatingTracking);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/workers/workers": function() {
			define("require exports ../../chunks/_rollupPluginBabelHelpers ../Error ../has ../promiseUtils ./Connection ./RemoteClient ./WorkerOwner".split(" "), function(a, b, c, e, d, k, v, m, f) {
				function g(w) {
					if (w && w.__esModule) return w;
					const A = Object.create(null, {
						[Symbol.toStringTag]: {
							value: "Module"
						}
					});
					if (w)
						for (const B in w)
							if ("default" !== B) {
								const E = Object.getOwnPropertyDescriptor(w, B);
								Object.defineProperty(A, B, E.get ? E : {
									enumerable: !0,
									get: () => w[B]
								})
							} A.default = w;
					return Object.freeze(A)
				}

				function l(w, A) {
					return r.apply(this, arguments)
				}

				function r() {
					r = c._asyncToGenerator(function*(w, A) {
						const B = new v;
						yield B.open(w, A);
						return B
					});
					return r.apply(this, arguments)
				}

				function p() {
					p = c._asyncToGenerator(function*(w, A = {}) {
						if ("string" !== typeof w) throw new e("workers:undefined-module",
							"modulePath is missing");
						var B = A.strategy || "distributed";
						d("host-webworker") && !d("esri-workers") && (B = "local");
						if ("local" === B) {
							var E = yield m.loadWorker(w);
							E || (E = yield new Promise((z, C) => a([w], D => z(g(D)), C)));
							k.throwIfAborted(A.signal);
							B = A.client || E;
							E = m.connect(E);
							return l([E], {
								...A,
								client: B
							})
						}
						yield n();
						k.throwIfAborted(A.signal);
						if ("dedicated" === B) return B = q++ % h, B = yield u[B].open(w, A), l([B], A);
						if (A.maxNumWorkers && 0 < A.maxNumWorkers && (B = Math.min(A.maxNumWorkers, h), B < h)) {
							E = Array(B);
							for (let z = 0; z < B; ++z) {
								const C =
									q++ % h;
								E[z] = u[C].open(w, A)
							}
							return l(E, A)
						}
						B = u.map(z => z.open(w, A));
						return l(B, A)
					});
					return p.apply(this, arguments)
				}

				function n() {
					return t.apply(this, arguments)
				}

				function t() {
					t = c._asyncToGenerator(function*() {
						if (x) return x;
						y = new AbortController;
						const w = [];
						for (let A = 0; A < h; A++) {
							const B = f.create(A)
								.then(E => u[A] = E);
							w.push(B)
						}
						return x = Promise.all(w)
					});
					return t.apply(this, arguments)
				}
				let h = d("esri-workers-debug") ? 1 : d("esri-mobile") ? Math.min(navigator.hardwareConcurrency - 1, 3) : d("host-browser") ? navigator.hardwareConcurrency -
					1 : 0;
				h || (h = d("safari") && d("mac") || d("trident") ? 7 : 2);
				let q = 0;
				const u = [];
				let x = null,
					y;
				b.Connection = v;
				b.RemoteClient = m;
				b.initialize = function() {
					n()
				};
				b.open = function(w) {
					return p.apply(this, arguments)
				};
				b.openWithPorts = function(w, A) {
					return l(w, {
						client: A
					})
				};
				b.terminate = function() {
					x && (y.abort(), x = null);
					for (let w = 0; w < u.length; w++) u[w] && u[w].terminate();
					u.length = 0
				};
				Object.defineProperties(b, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/workers/Connection": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../handleUtils ../Logger ../promiseUtils ../Queue ./RemoteClient".split(" "),
				function(a, b, c, e, d, k) {
					return function() {
						function v() {
							this._inUseClients = [];
							this._clients = [];
							this._clientPromises = [];
							this._ongoingJobsQueue = new d
						}
						var m = v.prototype;
						m.destroy = function() {
							this.close()
						};
						m.open = function(f, g) {
							return new Promise((l, r) => {
								let p = !0;
								const n = t => {
									e.throwIfAborted(g.signal);
									p && (p = !1, t())
								};
								this._clients.length = f.length;
								this._clientPromises.length = f.length;
								this._inUseClients.length = f.length;
								for (let t = 0; t < f.length; ++t) {
									const h = f[t];
									e.isPromiseLike(h) ? this._clientPromises[t] = h.then(q => {
										this._clients[t] = new k(q, g, () => this._ongoingJobsQueue.pop() ? ? null);
										n(l);
										return this._clients[t]
									}, () => {
										n(r);
										return null
									}) : (this._clients[t] = new k(h, g, () => this._ongoingJobsQueue.pop() ? ? null), this._clientPromises[t] = Promise.resolve(this._clients[t]), n(l))
								}
							})
						};
						m.broadcast = function(f, g, l) {
							const r = Array(this._clientPromises.length);
							for (let p = 0; p < this._clientPromises.length; ++p) r[p] = this._clientPromises[p].then(n => n ? .invoke(f, g, l));
							return r
						};
						m.close = function() {
							let f;
							for (; f = this._ongoingJobsQueue.pop();) f.deferred.reject(e.createAbortError(`Worker closing, aborting job calling '${f.methodName}'`));
							for (const g of this._clientPromises) g.then(l => l ? .close());
							this._clients.length = 0;
							this._clientPromises.length = 0
						};
						m.invoke = function(f, g, l) {
							let r;
							Array.isArray(l) ? (c.getLogger("esri.core.workers.Connection")
								.warn("invoke()", "The transferList parameter is deprecated, use the options object instead"), r = {
									transferList: l
								}) : r = l;
							l = e.createDeferred();
							this._ongoingJobsQueue.push({
								methodName: f,
								data: g,
								invokeOptions: r,
								deferred: l
							});
							for (f = 0; f < this._clientPromises.length; f++)(g = this._clients[f]) ? g.jobAdded() : this._clientPromises[f].then(p =>
								p ? .jobAdded());
							return l.promise
						};
						m.on = function(f, g) {
							return Promise.all(this._clientPromises)
								.then(() => b.handlesGroup(this._clients.map(l => l.on(f, g))))
						};
						m.openPorts = function() {
							return new Promise(f => {
								const g = Array(this._clientPromises.length);
								let l = g.length;
								for (let r = 0; r < this._clientPromises.length; ++r) this._clientPromises[r].then(p => {
									p && (g[r] = p.openPort());
									0 === --l && f(g)
								})
							})
						};
						a._createClass(v, [{
							key: "closed",
							get: function() {
								return !this._clients || !this._clients.length
							}
						}, {
							key: "test",
							get: function() {
								return {
									numClients: this._clients.length
								}
							}
						}]);
						return v
					}()
				})
		},
		"esri/core/Queue": function() {
			define(["../chunks/_rollupPluginBabelHelpers", "./maybe"], function(a, b) {
				return function() {
					function c(d = k => k.values()
						.next()
						.value) {
						this._peeker = d;
						this._items = new Set
					}
					var e = c.prototype;
					e.clear = function() {
						this._items.clear()
					};
					e.last = function() {
						if (0 !== this._items.size) {
							for (var d of this._items);
							return d
						}
					};
					e.peek = function() {
						if (0 !== this._items.size) return this._peeker(this._items)
					};
					e.push = function(d) {
						this.contains(d) || this._items.add(d)
					};
					e.contains = function(d) {
						return this._items.has(d)
					};
					e.pop = function() {
						if (0 !== this.length) {
							var d = this.peek();
							this._items.delete(b.assumeNonNull(d));
							return d
						}
					};
					e.popLast = function() {
						if (0 !== this.length) {
							var d = this.last();
							this._items.delete(b.assumeNonNull(d));
							return d
						}
					};
					e.remove = function(d) {
						this._items.delete(d)
					};
					e.filter = function(d) {
						this._items.forEach(k => {
							d(k) || this._items.delete(k)
						});
						return this
					};
					a._createClass(c, [{
						key: "length",
						get: function() {
							return this._items.size
						}
					}]);
					return c
				}()
			})
		},
		"esri/core/workers/RemoteClient": function() {
			define("require ../../kernel ../Error ../events ../maybe ../promiseUtils ./utils ../../support/revision".split(" "),
				function(a, b, c, e, d, k, v, m) {
					const f = x => Object.freeze(Object.defineProperty({
							__proto__: null,
							default: x
						}, Symbol.toStringTag, {
							value: "Module"
						})),
						g = {
							statsWorker: () => new Promise((x, y) => a(["../../smartMapping/statistics/support/statsWorker"], x, y)),
							geometryEngineWorker: () => new Promise((x, y) => a(["../../geometry/geometryEngineWorker"], x, y)),
							CSVSourceWorker: () => new Promise((x, y) => a(["../../layers/graphics/sources/support/CSVSourceWorker"], w => x(f(w)), y)),
							EdgeProcessingWorker: () => new Promise((x, y) => a(["../../views/3d/webgl-engine/lib/edgeRendering/EdgeProcessingWorker"],
								w => x(f(w)), y)),
							ElevationSamplerWorker: () => new Promise((x, y) => a(["../../geometry/support/meshUtils/ElevationSamplerWorker"], w => x(f(w)), y)),
							FeatureServiceSnappingSourceWorker: () => new Promise((x, y) => a(["../../views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker"], w => x(f(w)), y)),
							GeoJSONSourceWorker: () => new Promise((x, y) => a(["../../layers/graphics/sources/geojson/GeoJSONSourceWorker"], w => x(f(w)), y)),
							LercWorker: () => new Promise((x, y) => a(["../../layers/support/LercWorker"],
								w => x(f(w)), y)),
							MemorySourceWorker: () => new Promise((x, y) => a(["../../layers/graphics/sources/support/MemorySourceWorker"], w => x(f(w)), y)),
							PBFDecoderWorker: () => new Promise((x, y) => a(["../../views/3d/support/PBFDecoderWorker"], w => x(f(w)), y)),
							Pipeline: () => new Promise((x, y) => a(["../../views/2d/layers/features/Pipeline"], w => x(f(w)), y)),
							PointCloudWorker: () => new Promise((x, y) => a(["../../views/3d/layers/PointCloudWorker"], w => x(f(w)), y)),
							RasterWorker: () => new Promise((x, y) => a(["../../layers/support/RasterWorker"],
								w => x(f(w)), y)),
							SceneLayerSnappingSourceWorker: () => new Promise((x, y) => a(["../../views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker"], w => x(f(w)), y)),
							SceneLayerWorker: () => new Promise((x, y) => a(["../../views/3d/layers/SceneLayerWorker"], x, y)),
							WFSSourceWorker: () => new Promise((x, y) => a(["../../layers/graphics/sources/WFSSourceWorker"], w => x(f(w)), y)),
							WorkerTileHandler: () => new Promise((x, y) => a(["../../views/2d/engine/vectorTiles/WorkerTileHandler"], w => x(f(w)), y))
						},
						{
							CLOSE: l,
							ABORT: r,
							INVOKE: p,
							RESPONSE: n,
							OPEN_PORT: t,
							ON: h
						} = v.MessageType;
					let q = function() {
							function x(w) {
								this._timer = null;
								this._cancelledJobIds = new Set;
								this._invokeMessages = [];
								this._invoke = w;
								this._timer = null;
								this._process = this._process.bind(this)
							}
							var y = x.prototype;
							y.push = function(w) {
								w.type === v.MessageType.ABORT ? this._cancelledJobIds.add(w.jobId) : (this._invokeMessages.push(w), null === this._timer && (this._timer = setTimeout(this._process, 0)))
							};
							y.clear = function() {
								this._invokeMessages.length = 0;
								this._cancelledJobIds.clear();
								this._timer = null
							};
							y._process = function() {
								this._timer = null;
								for (const w of this._invokeMessages) this._cancelledJobIds.has(w.jobId) || this._invoke(w);
								this._cancelledJobIds.clear();
								this._invokeMessages.length = 0
							};
							return x
						}(),
						u = function() {
							function x(w, A, B) {
								this._port = w;
								this._getNextJob = B;
								this._outJobs = new Map;
								this._inJobs = new Map;
								this._invokeQueue = new q(E => this._onInvokeMessage(E));
								this._client = A.client;
								this._onMessage = this._onMessage.bind(this);
								this._channel = A.channel;
								this._schedule = A.schedule;
								this._port.addEventListener("message",
									this._onMessage);
								this._port.start()
							}
							x.connect = function(w) {
								const A = new MessageChannel;
								w = "function" === typeof w ? new w : "default" in w && "function" === typeof w.default ? new w.default : w;
								const B = new x(A.port1, {
									channel: A,
									client: w
								}, () => null);
								"object" === typeof w && "remoteClient" in w && (w.remoteClient = B);
								x.clients.set(B, w);
								return A.port2
							};
							x.loadWorker = function(w) {
								return (w = g[w]) ? w() : Promise.resolve(null)
							};
							var y = x.prototype;
							y.close = function() {
								this._post({
									type: l
								});
								this._close()
							};
							y.isBusy = function() {
								return 0 < this._outJobs.size
							};
							y.invoke = function(w, A, B) {
								const E = B && B.signal,
									z = B && B.transferList;
								if (!this._port) return Promise.reject(new c("worker:port-closed", `Cannot call invoke('${w}'), port is closed`, {
									methodName: w,
									data: A
								}));
								const C = v.newJobId();
								return new Promise((D, J) => {
									if (k.isAborted(E)) this._processWork(), J(k.createAbortError());
									else {
										var K = k.onAbort(E, () => {
											const H = this._outJobs.get(C);
											H && (this._outJobs.delete(C), this._processWork(), d.removeMaybe(H.abortHandle), this._post({
												type: r,
												jobId: C
											}), J(k.createAbortError()))
										});
										this._outJobs.set(C, {
											resolve: D,
											reject: J,
											abortHandle: K,
											debugInfo: w
										});
										this._post({
											type: p,
											jobId: C,
											methodName: w,
											abortable: null != E
										}, A, z)
									}
								})
							};
							y.on = function(w, A) {
								function B(z) {
									A(z.data)
								}
								const E = new MessageChannel;
								this._port.postMessage({
									type: v.MessageType.ON,
									eventType: w,
									port: E.port2
								}, [E.port2]);
								E.port1.addEventListener("message", B);
								E.port1.start();
								return {
									remove() {
										E.port1.postMessage({
											type: v.MessageType.CLOSE
										});
										E.port1.close();
										E.port1.removeEventListener("message", B)
									}
								}
							};
							y.jobAdded = function() {
								this._processWork()
							};
							y.openPort =
								function() {
									const w = new MessageChannel;
									this._post({
										type: t,
										port: w.port2
									});
									return w.port1
								};
							y._processWork = function() {
								if (!(2 <= this._outJobs.size)) {
									var w = this._getNextJob();
									if (w) {
										var {
											methodName: A,
											data: B,
											invokeOptions: E,
											deferred: z
										} = w;
										this.invoke(A, B, E)
											.then(C => z.resolve(C))
											.catch(C => z.reject(C))
									}
								}
							};
							y._close = function() {
								this._channel && (this._channel = void 0);
								this._port.removeEventListener("message", this._onMessage);
								this._port.close();
								this._outJobs.forEach(w => {
									d.removeMaybe(w.abortHandle);
									w.reject(k.createAbortError(`Worker closing, aborting job calling '${w.debugInfo}'`))
								});
								this._inJobs.clear();
								this._outJobs.clear();
								this._invokeQueue.clear();
								this._port = this._client = this._schedule = null
							};
							y._onMessage = function(w) {
								d.isSome(this._schedule) ? this._schedule(() => this._processMessage(w)) : this._processMessage(w)
							};
							y._processMessage = function(w) {
								if (w = v.receiveMessage(w)) switch (w.type) {
									case n:
										this._onResponseMessage(w);
										break;
									case p:
										this._invokeQueue.push(w);
										break;
									case r:
										this._onAbortMessage(w);
										break;
									case l:
										this._onCloseMessage();
										break;
									case t:
										this._onOpenPortMessage(w);
										break;
									case h:
										this._onOnMessage(w)
								}
							};
							y._onAbortMessage = function(w) {
								const A = this._inJobs,
									B = w.jobId,
									E = A.get(B);
								this._invokeQueue.push(w);
								E && (E.controller && E.controller.abort(), A.delete(B))
							};
							y._onCloseMessage = function() {
								const w = this._client;
								this._close();
								w && "destroy" in w && x.clients.get(this) === w && w.destroy();
								x.clients.delete(this);
								w && w.remoteClient && (w.remoteClient = null)
							};
							y._onInvokeMessage = function(w) {
								const {
									methodName: A,
									jobId: B,
									data: E,
									abortable: z
								} = w;
								w = z ? new AbortController : null;
								const C = this._inJobs;
								let D = this._client,
									J = D[A],
									K;
								try {
									if (!J &&
										A && A.includes(".")) {
										const H = A.split(".");
										for (let G = 0; G < H.length - 1; G++) D = D[H[G]], J = D[H[G + 1]]
									}
									if ("function" !== typeof J) throw new TypeError(`${A} is not a function`);
									K = J.call(D, E, {
										client: this,
										signal: w ? w.signal : null
									})
								} catch (H) {
									this._post({
										type: n,
										jobId: B,
										error: v.toInvokeError(H)
									});
									return
								}
								k.isPromiseLike(K) ? (C.set(B, {
									controller: w,
									promise: K
								}), K.then(H => {
									C.has(B) && (C.delete(B), this._post({
										type: n,
										jobId: B
									}, H))
								}, H => {
									C.has(B) && (C.delete(B), k.isAbortError(H) || this._post({
										type: n,
										jobId: B,
										error: v.toInvokeError(H || {
											message: `Error encountered at method ${A}`
										})
									}))
								})) : this._post({
									type: n,
									jobId: B
								}, K)
							};
							y._onOpenPortMessage = function(w) {
								new x(w.port, {
									client: this._client
								}, () => null)
							};
							y._onOnMessage = function(w) {
								const {
									port: A
								} = w, B = this._client.on(w.eventType, z => {
									A.postMessage(z)
								}), E = e.on(w.port, "message", z => {
									v.receiveMessage(z) ? .type === v.MessageType.CLOSE && (E.remove(), B.remove(), A.close())
								})
							};
							y._onResponseMessage = function(w) {
								const {
									jobId: A,
									error: B,
									data: E
								} = w;
								w = this._outJobs;
								if (w.has(A)) {
									var z = w.get(A);
									w.delete(A);
									this._processWork();
									d.removeMaybe(z.abortHandle);
									B ? z.reject(c.fromJSON(JSON.parse(B))) : z.resolve(E)
								}
							};
							y._post = function(w, A, B) {
								return v.postMessage(this._port, w, A, B)
							};
							return x
						}();
					u.kernelInfo = {
						revision: m.commitHash,
						version: b.version,
						buildDate: m.buildDate
					};
					u.clients = new Map;
					return u
				})
		},
		"esri/core/workers/utils": function() {
			define(["exports", "../has"], function(a, b) {
				function c(m) {
					return m && "object" === typeof m && ("result" in m || "transferList" in m)
				}

				function e(m) {
					return m ? "string" === typeof m ? JSON.stringify({
							name: "message",
							message: m
						}) :
						m.toJSON ? JSON.stringify(m) : JSON.stringify({
							name: m.name,
							message: m.message,
							details: m.details || {
								stack: m.stack
							}
						}) : null
				}

				function d(m, f, g, l) {
					if (f.type === a.MessageType.OPEN_PORT) m.postMessage(f, [f.port]);
					else if (f.type !== a.MessageType.INVOKE && f.type !== a.MessageType.RESPONSE) m.postMessage(f);
					else if (c(g) ? (l = k(g.transferList), f.data = g.result) : (l = k(l), f.data = g), l) {
						if (b("ff"))
							for (const r of l)
								if ("byteLength" in r && 267386880 < r.byteLength) switch (f.type) {
									case a.MessageType.INVOKE:
										throw "Worker call with large ArrayBuffer would crash Firefox";
									case a.MessageType.RESPONSE:
										d(m, {
											type: a.MessageType.RESPONSE,
											jobId: f.jobId,
											error: e("Worker call with large ArrayBuffer would crash Firefox")
										});
										return
								}
						m.postMessage(f, l)
					} else m.postMessage(f)
				}

				function k(m) {
					if (!m || !m.length) return null;
					if (b("esri-workers-arraybuffer-transfer")) return m;
					m = m.filter(f => !(f instanceof ArrayBuffer || f && f.constructor && "ArrayBuffer" === f.constructor.name));
					return m.length ? m : null
				}
				a.MessageType = void 0;
				(function(m) {
					m[m.HANDSHAKE = 0] = "HANDSHAKE";
					m[m.OPEN = 1] = "OPEN";
					m[m.OPENED = 2] =
						"OPENED";
					m[m.RESPONSE = 3] = "RESPONSE";
					m[m.INVOKE = 4] = "INVOKE";
					m[m.ABORT = 5] = "ABORT";
					m[m.CLOSE = 6] = "CLOSE";
					m[m.OPEN_PORT = 7] = "OPEN_PORT";
					m[m.ON = 8] = "ON"
				})(a.MessageType || (a.MessageType = {}));
				let v = 0;
				a.isTranferableResult = c;
				a.newJobId = function() {
					return v++
				};
				a.postMessage = d;
				a.receiveMessage = function(m) {
					return m ? (m = m.data) ? "string" === typeof m ? JSON.parse(m) : m : null : null
				};
				a.toInvokeError = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/workers/WorkerOwner": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../kernel ../Error ../Logger ../maybe ../promiseUtils ./utils ./workerFactory".split(" "),
				function(a, b, c, e, d, k, v, m) {
					const {
						ABORT: f,
						INVOKE: g,
						OPEN: l,
						OPENED: r,
						RESPONSE: p
					} = v.MessageType;
					return function() {
						function n(h, q) {
							this._outJobs = new Map;
							this._inJobs = new Map;
							this.worker = h;
							this.id = q;
							h.addEventListener("message", this._onMessage.bind(this));
							h.addEventListener("error", u => {
								u.preventDefault();
								e.getLogger("esri.core.workers.WorkerOwner")
									.error(u)
							})
						}
						n.create = function() {
							var h = a._asyncToGenerator(function*(q) {
								const u = yield m.createWorker();
								return new n(u, q)
							});
							return function(q) {
								return h.apply(this,
									arguments)
							}
						}();
						var t = n.prototype;
						t.terminate = function() {
							this.worker.terminate()
						};
						t.open = function() {
							var h = a._asyncToGenerator(function*(q, u = {}) {
								const {
									signal: x
								} = u, y = v.newJobId();
								return new Promise((w, A) => {
									const B = k.onAbortOrThrow(x, () => {
										this._outJobs.delete(y);
										this._post({
											type: f,
											jobId: y
										})
									});
									this._outJobs.set(y, {
										resolve: w,
										reject: A,
										abortHandle: B
									});
									this._post({
										type: l,
										jobId: y,
										modulePath: q
									})
								})
							});
							return function(q) {
								return h.apply(this, arguments)
							}
						}();
						t._onMessage = function(h) {
							if (h = v.receiveMessage(h)) switch (h.type) {
								case r:
									this._onOpenedMessage(h);
									break;
								case p:
									this._onResponseMessage(h);
									break;
								case f:
									this._onAbortMessage(h);
									break;
								case g:
									this._onInvokeMessage(h)
							}
						};
						t._onAbortMessage = function(h) {
							const q = this._inJobs;
							h = h.jobId;
							const u = q.get(h);
							u && (u.controller && u.controller.abort(), q.delete(h))
						};
						t._onInvokeMessage = function(h) {
							const {
								methodName: q,
								jobId: u,
								data: x,
								abortable: y
							} = h;
							h = y ? new AbortController : null;
							const w = this._inJobs,
								A = b.workerMessages[q];
							let B;
							try {
								if ("function" !== typeof A) throw new TypeError(`${q} is not a function`);
								B = A.call(null, x, {
									signal: h ?
										h.signal : null
								})
							} catch (E) {
								this._post({
									type: p,
									jobId: u,
									error: v.toInvokeError(E)
								});
								return
							}
							k.isPromiseLike(B) ? (w.set(u, {
								controller: h,
								promise: B
							}), B.then(E => {
								w.has(u) && (w.delete(u), this._post({
									type: p,
									jobId: u
								}, E))
							}, E => {
								w.has(u) && (w.delete(u), E || (E = {
									message: "Error encountered at method" + q
								}), k.isAbortError(E) || this._post({
									type: p,
									jobId: u,
									error: v.toInvokeError(E || {
										message: `Error encountered at method ${q}`
									})
								}))
							})) : this._post({
								type: p,
								jobId: u
							}, B)
						};
						t._onOpenedMessage = function(h) {
							const {
								jobId: q,
								data: u
							} = h;
							if (h = this._outJobs.get(q)) this._outJobs.delete(q),
								d.removeMaybe(h.abortHandle), h.resolve(u)
						};
						t._onResponseMessage = function(h) {
							const {
								jobId: q,
								error: u,
								data: x
							} = h;
							if (h = this._outJobs.get(q)) this._outJobs.delete(q), d.removeMaybe(h.abortHandle), u ? h.reject(c.fromJSON(JSON.parse(u))) : h.resolve(x)
						};
						t._post = function(h, q, u) {
							return v.postMessage(this.worker, h, q, u)
						};
						return n
					}()
				})
		},
		"esri/core/workers/workerFactory": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../assets ../../config ../../intl ../../kernel ../has ../Logger ../urlUtils ./loaderConfig ./utils ./WorkerFallback ../../intl/locale ../../support/revision".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					function t() {
						t = b._asyncToGenerator(function*() {
							if (!v("esri-workers") || (v("mozilla"), 0)) return h(new r);
							if (!y && !w) try {
								var B = ["let globalId\x3d0;const outgoing\x3dnew Map,configuration\x3dJSON.parse(", ');self.esriConfig\x3dconfiguration.esriConfig;const workerPath\x3dself.esriConfig.workers.workerPath,HANDSHAKE\x3d0,OPEN\x3d1,OPENED\x3d2,RESPONSE\x3d3,INVOKE\x3d4,ABORT\x3d5;function createAbortError(){const e\x3dnew Error("Aborted");return e.name\x3d"AbortError",e}function receiveMessage(e){return e\x26\x26e.data?"string"\x3d\x3dtypeof e.data?JSON.parse(e.data):e.data:null}function invokeStaticMessage(e,o,r){const t\x3dr\x26\x26r.signal,n\x3dglobalId++;return new Promise(((r,i)\x3d\x3e{if(t){if(t.aborted)return i(createAbortError());t.addEventListener("abort",(()\x3d\x3e{outgoing.get(n)\x26\x26(outgoing.delete(n),self.postMessage({type:5,jobId:n}),i(createAbortError()))}))}outgoing.set(n,{resolve:r,reject:i}),self.postMessage({type:4,jobId:n,methodName:e,abortable:null!\x3dt,data:o})}))}let workerRevisionChecked\x3d!1;function checkWorkerRevision(e){if(!workerRevisionChecked\x26\x26e.kernelInfo){workerRevisionChecked\x3d!0;const{revision:o,version:r}\x3dconfiguration.kernelInfo,{revision:t,version:n}\x3de.kernelInfo;esriConfig.assetsPath!\x3d\x3desriConfig.defaultAssetsPath\x26\x26o!\x3d\x3dt\x26\x26console.warn(`Version mismatch detected between ArcGIS API for JavaScript modules and assets. For more information visit https://bit.ly/3QnsuSo.\\nModules version: ${r}\\nAssets version: ${n}`)}}function messageHandler(e){const o\x3dreceiveMessage(e);if(!o)return;const r\x3do.jobId;switch(o.type){case 1:let n;function t(e){const o\x3dn.connect(e);self.postMessage({type:2,jobId:r,data:o},[o])}"function"\x3d\x3dtypeof define\x26\x26define.amd?require([workerPath],(e\x3d\x3e{n\x3de.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e\x3d\x3ee||new Promise((e\x3d\x3e{require([o.modulePath],e)})))).then(t)})):"System"in self\x26\x26"function"\x3d\x3dtypeof System.import?System.import(workerPath).then((e\x3d\x3e(n\x3de.default,checkWorkerRevision(n),n.loadWorker(o.modulePath)))).then((e\x3d\x3ee||System.import(o.modulePath))).then(t):esriConfig.workers.useDynamicImport?import(workerPath).then((e\x3d\x3e{n\x3de.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e\x3d\x3ee||import(o.modulePath))).then(t)})):(self.RemoteClient||importScripts(workerPath),n\x3dself.RemoteClient.default||self.RemoteClient,checkWorkerRevision(n),n.loadWorker(o.modulePath).then(t));break;case 3:if(outgoing.has(r)){const i\x3doutgoing.get(r);outgoing.delete(r),o.error?i.reject(JSON.parse(o.error)):i.resolve(o.data)}}}self.dojoConfig\x3dconfiguration.loaderConfig,esriConfig.workers.loaderUrl\x26\x26(self.importScripts(esriConfig.workers.loaderUrl),"function"\x3d\x3dtypeof require\x26\x26"function"\x3d\x3dtypeof require.config\x26\x26require.config(configuration.loaderConfig)),self.addEventListener("message",messageHandler),self.postMessage({type:0});'],
									E = B.join;
								let D;
								if (null != e["default"]) {
									const G = {
										...e
									};
									delete G["default"];
									D = JSON.parse(JSON.stringify(G))
								} else D = JSON.parse(JSON.stringify(e));
								D.assetsPath = f.makeAbsolute(D.assetsPath);
								D.defaultAssetsPath = D.defaultAssetsPath ? f.makeAbsolute(D.defaultAssetsPath) : void 0;
								D.request.interceptors = [];
								D.log.interceptors = [];
								D.locale = p.getLocale();
								D.has = {
									"esri-csp-restrictions": v("esri-csp-restrictions"),
									"esri-2d-debug": !1,
									"esri-2d-update-debug": v("esri-2d-update-debug"),
									"featurelayer-pbf": v("featurelayer-pbf"),
									"featurelayer-simplify-thresholds": v("featurelayer-simplify-thresholds"),
									"featurelayer-simplify-payload-size-factors": v("featurelayer-simplify-payload-size-factors"),
									"featurelayer-simplify-mobile-factor": v("featurelayer-simplify-mobile-factor"),
									"esri-atomics": v("esri-atomics"),
									"esri-shared-array-buffer": v("esri-shared-array-buffer"),
									"esri-tiles-debug": v("esri-tiles-debug"),
									"esri-workers-arraybuffer-transfer": v("esri-workers-arraybuffer-transfer"),
									"feature-polyline-generalization-factor": v("feature-polyline-generalization-factor"),
									"host-webworker": 1,
									"polylabel-placement-enabled": v("polylabel-placement-enabled")
								};
								D.workers.loaderUrl ? D.workers.loaderUrl = f.makeAbsolute(D.workers.loaderUrl) : g.DEFAULT_LOADER_URL && (D.workers.loaderUrl = g.DEFAULT_LOADER_URL);
								D.workers.workerPath = D.workers.workerPath ? f.makeAbsolute(D.workers.workerPath) : "esri/core/workers/RemoteClient";
								D.workers.useDynamicImport = !1;
								const J = e.workers.loaderConfig,
									K = g.loaderConfig({
										baseUrl: J ? .baseUrl,
										locale: p.getLocale(),
										has: {
											"csp-restrictions": 1,
											"dojo-test-sniff": 0,
											"host-webworker": 1,
											...J ? .has
										},
										map: {
											...J ? .map
										},
										paths: {
											...J ? .paths
										},
										packages: J ? .packages || []
									});
								var z = JSON.stringify({
									esriConfig: D,
									loaderConfig: K,
									kernelInfo: {
										version: k.version,
										buildDate: n.buildDate,
										revision: n.commitHash
									}
								});
								const H = E.call(B, `'${z}'`);
								y = URL.createObjectURL(new Blob([H], {
									type: "text/javascript"
								}))
							} catch (D) {
								w = D || {}
							}
							let C;
							if (y) try {
								C = new Worker(y, {
									name: `esri-worker-${A++}`
								})
							} catch (D) {
								u.warn("Failed to create Worker. Fallback to execute module in main thread", w), C = new r
							} else u.warn("Failed to create Worker. Fallback to execute module in main thread",
								w), C = new r;
							return h(C)
						});
						return t.apply(this, arguments)
					}

					function h(B) {
						return q.apply(this, arguments)
					}

					function q() {
						q = b._asyncToGenerator(function*(B) {
							return new Promise(E => {
								function z(D) {
									(D = l.receiveMessage(D)) && D.type === x && (B.removeEventListener("message", z), B.removeEventListener("error", C), E(B))
								}

								function C(D) {
									D.preventDefault();
									B.removeEventListener("message", z);
									B.removeEventListener("error", C);
									u.warn("Failed to create Worker. Fallback to execute module in main thread", D);
									B = new r;
									B.addEventListener("message",
										z);
									B.addEventListener("error", C)
								}
								B.addEventListener("message", z);
								B.addEventListener("error", C)
							})
						});
						return q.apply(this, arguments)
					}
					const u = m.getLogger("esri.core.workers.workerFactory"),
						{
							HANDSHAKE: x
						} = l.MessageType;
					let y, w, A = 0;
					a.createWorker = function() {
						return t.apply(this, arguments)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/intl": function() {
			define("exports ./intl/date ./intl/number ./intl/substitute ./intl/locale ./intl/messages ./intl/t9n ./assets".split(" "),
				function(a, b, c, e, d, k, v, m) {
					k.registerMessageBundleLoader(v.createJSONLoader({
						pattern: "esri/",
						location: m.getAssetUrl
					}));
					a.convertDateFormatToIntlOptions = b.convertDateFormatToIntlOptions;
					a.formatDate = b.formatDate;
					a.convertNumberFormatToIntlOptions = c.convertNumberFormatToIntlOptions;
					a.formatNumber = c.formatNumber;
					a.substitute = e.substitute;
					a.getLocale = d.getLocale;
					a.onLocaleChange = d.onLocaleChange;
					a.prefersRTL = d.prefersRTL;
					a.setLocale = d.setLocale;
					a.fetchMessageBundle = k.fetchMessageBundle;
					a.normalizeMessageBundleLocale =
						k.normalizeMessageBundleLocale;
					a.registerMessageBundleLoader = k.registerMessageBundleLoader;
					a.createJSONLoader = v.createJSONLoader;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/intl/substitute": function() {
			define("exports ../core/Logger ../core/object ../core/string ./date ./number".split(" "), function(a, b, c, e, d, k) {
				function v(f) {
					switch (typeof f) {
						case "string":
							return f;
						case "number":
							return k.formatNumber(f);
						case "boolean":
							return "" + f;
						default:
							return f instanceof
							Date ? d.formatDate(f) : ""
					}
				}
				const m = b.getLogger("esri.intl.substitute");
				a.substitute = function(f, g, l = {}) {
					const {
						format: r = {}
					} = l;
					return e.replace(f, p => {
						{
							const h = p.indexOf(":");
							if (-1 === h) var n = p.trim();
							else {
								n = p.slice(0, h)
									.trim();
								var t = p.slice(h + 1)
									.trim()
							}
							if (n)
								if (p = c.getDeepValue(n, g), null == p) t = "";
								else if (n = (t ? r ? . [t] : null) ? ? r ? . [n]) b: switch (n.type) {
									case "date":
										t = d.formatDate(p, n.intlOptions);
										break b;
									case "number":
										t = k.formatNumber(p, n.intlOptions);
										break b;
									default:
										m.warn("missing format descriptor for key {key}"),
											t = v(p)
								} else if (t) b: switch (t.toLowerCase()) {
									case "dateformat":
										t = d.formatDate(p);
										break b;
									case "numberformat":
										t = k.formatNumber(p);
										break b;
									default:
										m.warn(`inline format is unsupported since 4.12: ${t}`), t = /^(dateformat|datestring)/i.test(t) ? d.formatDate(p) : /^numberformat/i.test(t) ? k.formatNumber(p) : v(p)
								} else t = v(p);
								else t = ""
						}
						return t
					})
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/intl/t9n": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../request ../core/Error ../core/maybe ./messages".split(" "),
				function(a, b, c, e, d, k) {
					function v(p, n, t, h) {
						return m.apply(this, arguments)
					}

					function m() {
						m = b._asyncToGenerator(function*(p, n, t, h) {
							var q = n.exec(t);
							if (!q) throw new e("esri-intl:invalid-bundle", `Bundle id "${t}" is not compatible with the pattern "${n}"`);
							n = q[1] ? `${q[1]}/` : "";
							q = q[2];
							const u = k.normalizeMessageBundleLocale(h);
							h = `${n}${q}.json`;
							n = u ? `${n}${q}_${u}.json` : h;
							let x;
							try {
								x = yield f(p(n))
							} catch (y) {
								if (n === h) throw new e("intl:unknown-bundle", `Bundle "${t}" cannot be loaded`, {
									error: y
								});
								try {
									x = yield f(p(h))
								} catch (w) {
									throw new e("intl:unknown-bundle",
										`Bundle "${t}" cannot be loaded`, {
											error: w
										});
								}
							}
							return x
						});
						return m.apply(this, arguments)
					}

					function f(p) {
						return g.apply(this, arguments)
					}

					function g() {
						g = b._asyncToGenerator(function*(p) {
							if (d.isSome(r.fetchBundleAsset)) return r.fetchBundleAsset(p);
							p = yield c(p, {
								responseType: "text"
							});
							return JSON.parse(p.data)
						});
						return g.apply(this, arguments)
					}
					let l = function() {
						function p({
							base: n = "",
							pattern: t,
							location: h = new URL(window.location.href)
						}) {
							let q;
							q = "string" === typeof h ? u => (new URL(u, new URL(h, window.location.href)))
								.href :
								h instanceof URL ? u => (new URL(u, h))
								.href : h;
							this.pattern = "string" === typeof t ? new RegExp(`^${t}`) : t;
							this.getAssetUrl = q;
							n = n ? n.endsWith("/") ? n : n + "/" : "";
							this.matcher = new RegExp(`^${n}(?:(.*)/)?(.*)$`)
						}
						p.prototype.fetchMessageBundle = function(n, t) {
							return v(this.getAssetUrl, this.matcher, n, t)
						};
						return p
					}();
					const r = {};
					a.JSONLoader = l;
					a.createJSONLoader = function(p) {
						return new l(p)
					};
					a.test = r;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/workers/loaderConfig": function() {
			define(["exports",
				"../../assets", "../has", "../urlUtils"
			], function(a, b, c, e) {
				a.DEFAULT_LOADER_URL = null;
				a.DEFAULT_LOADER_URL = e.makeAbsolute(b.getAssetUrl("esri/core/workers/init.js"));
				var d = e.makeAbsolute(b.getAssetUrl("dojo/"));
				var k = [{
					name: "esri",
					location: "../esri"
				}];
				a.loaderConfig = function(v) {
					const m = {
						async: v.async,
						isDebug: v.isDebug,
						locale: v.locale,
						baseUrl: v.baseUrl,
						has: {
							...v.has
						},
						map: {
							...v.map
						},
						packages: v.packages && v.packages.concat() || [],
						paths: {
							...v.paths
						}
					};
					v.hasOwnProperty("async") || (m.async = !0);
					v.hasOwnProperty("isDebug") ||
						(m.isDebug = !1);
					v.baseUrl || (m.baseUrl = d);
					k ? .forEach(f => {
						a: {
							var g = m.packages ? ? [];
							for (const l of g)
								if (l.name === f.name) break a;g.push(f)
						}
					});
					return m
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/workers/WorkerFallback": function() {
			define(["require", "../../chunks/_rollupPluginBabelHelpers", "../nextTick", "./RemoteClient", "./utils"], function(a, b, c, e, d) {
				function k(m) {
					if (m && m.__esModule) return m;
					const f = Object.create(null, {
						[Symbol.toStringTag]: {
							value: "Module"
						}
					});
					if (m)
						for (const g in m)
							if ("default" !== g) {
								const l = Object.getOwnPropertyDescriptor(m, g);
								Object.defineProperty(f, g, l.get ? l : {
									enumerable: !0,
									get: () => m[g]
								})
							} f.default = m;
					return Object.freeze(f)
				}
				let v = function() {
					const m = document.createDocumentFragment();
					["addEventListener", "dispatchEvent", "removeEventListener"].forEach(f => {
						this[f] = (...g) => m[f](...g)
					})
				};
				return function() {
					function m() {
						this._dispatcher = new v;
						this._workerPostMessage({
							type: d.MessageType.HANDSHAKE
						})
					}
					var f = m.prototype;
					f.terminate = function() {};
					f.postMessage =
						function(g) {
							c.nextTick(() => {
								this._workerMessageHandler(new MessageEvent("message", {
									data: g
								}))
							})
						};
					f.dispatchEvent = function(g) {
						return this._dispatcher.dispatchEvent(g)
					};
					f.addEventListener = function(g, l, r) {
						this._dispatcher.addEventListener(g, l, r)
					};
					f.removeEventListener = function(g, l, r) {
						this._dispatcher.removeEventListener(g, l, r)
					};
					f._workerPostMessage = function(g) {
						c.nextTick(() => {
							this.dispatchEvent(new MessageEvent("message", {
								data: g
							}))
						})
					};
					f._workerMessageHandler = function() {
						var g = b._asyncToGenerator(function*(l) {
							if ((l =
								d.receiveMessage(l)) && l.type === d.MessageType.OPEN) {
								const {
									modulePath: r,
									jobId: p
								} = l;
								(l = yield e.loadWorker(r)) || (l = yield new Promise((n, t) => a([r], h => n(k(h)), t)));
								l = e.connect(l);
								this._workerPostMessage({
									type: d.MessageType.OPENED,
									jobId: p,
									data: l
								})
							}
						});
						return function(l) {
							return g.apply(this, arguments)
						}
					}();
					b._createClass(m, [{
						key: "onmessage",
						get: function() {
							return this._onmessageHandler
						},
						set: function(g) {
							this._onmessageHandler && this.removeEventListener("message", this._onmessageHandler);
							(this._onmessageHandler =
								g) && this.addEventListener("message", g)
						}
					}, {
						key: "onmessageerror",
						get: function() {
							return this._onmessageerrorHandler
						},
						set: function(g) {
							this._onmessageerrorHandler && this.removeEventListener("messageerror", this._onmessageerrorHandler);
							(this._onmessageerrorHandler = g) && this.addEventListener("messageerror", g)
						}
					}, {
						key: "onerror",
						get: function() {
							return this._onerrorHandler
						},
						set: function(g) {
							this._onerrorHandler && this.removeEventListener("error", this._onerrorHandler);
							(this._onerrorHandler = g) && this.addEventListener("error",
								g)
						}
					}]);
					return m
				}()
			})
		},
		"esri/rest/query/operations/editsZScale": function() {
			define(["exports", "../../../core/maybe", "../../../core/unitUtils", "../../../geometry/support/spatialReferenceUtils"], function(a, b, c, e) {
				function d(v, m, f) {
					if (null == v.hasM || v.hasZ)
						for (const g of m)
							for (const l of g) 2 < l.length && (l[2] *= f)
				}

				function k(v, m, f) {
					if (v)
						for (const r of v) {
							v = r.geometry;
							var g = m,
								l = f;
							if (!b.isNone(v) && v.spatialReference && !e.equals(v.spatialReference, g) && (g = c.getMetersPerVerticalUnitForSR(v.spatialReference) / l, 1 !==
								g))
								if ("x" in v) null != v.z && (v.z *= g);
								else if ("rings" in v) d(v, v.rings, g);
							else if ("paths" in v) d(v, v.paths, g);
							else if ("points" in v && (null == v.hasM || v.hasZ))
								for (const p of v.points) 2 < p.length && (p[2] *= g)
						}
				}
				a.unapplyEditsZUnitScaling = function(v, m, f) {
					if ((v || m) && f) {
						var g = c.getMetersPerVerticalUnitForSR(f);
						k(v, f, g);
						k(m, f, g)
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/operations/queryZScale": function() {
			define(["exports", "../../../core/maybe", "../../../geometry/support/zscale"],
				function(a, b, c) {
					a.applyFeatureSetZUnitScaling = function(e, d, k) {
						if (k && k.features && k.hasZ && (e = c.getGeometryZScaler(k.geometryType, d, e.outSpatialReference), !b.isNone(e)))
							for (const v of k.features) e(v.geometry)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/rest/support/FeatureSet": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../Graphic ../../core/jsonMap ../../core/JSONSupport ../../core/lang ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../geometry/SpatialReference ../../geometry/support/jsonUtils ../../layers/support/Field".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h) {
					var q;
					const u = new d.JSONMap({
						esriGeometryPoint: "point",
						esriGeometryMultipoint: "multipoint",
						esriGeometryPolyline: "polyline",
						esriGeometryPolygon: "polygon",
						esriGeometryEnvelope: "extent",
						mesh: "mesh",
						"": null
					});
					d = q = function(x) {
						function y(A) {
							A = x.call(this, A) || this;
							A.displayFieldName = null;
							A.exceededTransferLimit = !1;
							A.features = [];
							A.fields = null;
							A.geometryType = null;
							A.hasM = !1;
							A.hasZ = !1;
							A.queryGeometry = null;
							A.spatialReference = null;
							return A
						}
						a._inheritsLoose(y, x);
						var w =
							y.prototype;
						w.readFeatures = function(A, B) {
							B = n.fromJSON(B.spatialReference);
							const E = [];
							for (let D = 0; D < A.length; D++) {
								var z = A[D];
								const J = e.fromJSON(z);
								var C = z.geometry && z.geometry.spatialReference;
								m.isSome(J.geometry) && !C && (J.geometry.spatialReference = B);
								z = z.aggregateGeometries;
								C = J.aggregateGeometries;
								if (z && m.isSome(C))
									for (const K in C) {
										const H = C[K],
											G = z[K] ? .spatialReference;
										m.isSome(H) && !G && (H.spatialReference = B)
									}
								E.push(J)
							}
							return E
						};
						w.writeGeometryType = function(A, B, E, z) {
							if (A) u.write(A, B, E, z);
							else if ({
									features: A
								} =
								this, A)
								for (const C of A)
									if (C && m.isSome(C.geometry)) {
										u.write(C.geometry.type, B, E, z);
										break
									}
						};
						w.readQueryGeometry = function(A, B) {
							if (!A) return null;
							const E = !!A.spatialReference;
							(A = t.fromJSON(A)) && !E && B.spatialReference && (A.spatialReference = n.fromJSON(B.spatialReference));
							return A
						};
						w.writeSpatialReference = function(A, B) {
							if (A) B.spatialReference = A.toJSON();
							else if ({
								features: A
							} = this, A)
								for (const E of A)
									if (E && m.isSome(E.geometry) && E.geometry.spatialReference) {
										B.spatialReference = E.geometry.spatialReference.toJSON();
										break
									}
						};
						w.clone = function() {
							return new q(this.cloneProperties())
						};
						w.cloneProperties = function() {
							return v.clone({
								displayFieldName: this.displayFieldName,
								exceededTransferLimit: this.exceededTransferLimit,
								features: this.features,
								fields: this.fields,
								geometryType: this.geometryType,
								hasM: this.hasM,
								hasZ: this.hasZ,
								queryGeometry: this.queryGeometry,
								spatialReference: this.spatialReference,
								transform: this.transform
							})
						};
						w.toJSON = function(A) {
							const B = this.write();
							if (B.features && Array.isArray(A) && 0 < A.length)
								for (let E = 0; E <
									B.features.length; E++) {
									const z = B.features[E];
									if (z.geometry) {
										const C = A && A[E];
										z.geometry = C && C.toJSON() || z.geometry
									}
								}
							return B
						};
						w.quantize = function(A) {
							const {
								scale: [B, E],
								translate: [z, C]
							} = A, D = this.features, J = this._getQuantizationFunction(this.geometryType, K => Math.round((K - z) / B), K => Math.round((C - K) / E));
							for (let K = 0, H = D.length; K < H; K++) J ? .(m.unwrap(D[K].geometry)) || (D.splice(K, 1), K--, H--);
							this.transform = A;
							return this
						};
						w.unquantize = function() {
							const {
								geometryType: A,
								features: B,
								transform: E
							} = this;
							if (!E) return this;
							const {
								translate: [z, C],
								scale: [D, J]
							} = E, K = this._getHydrationFunction(A, H => H * D + z, H => C - H * J);
							for (const {
								geometry: H
							} of B) m.isSome(H) && K && K(H);
							this.transform = null;
							return this
						};
						w._quantizePoints = function(A, B, E) {
							let z, C;
							const D = [];
							for (let K = 0, H = A.length; K < H; K++) {
								var J = A[K];
								if (0 < K) {
									const G = B(J[0]);
									J = E(J[1]);
									if (G !== z || J !== C) D.push([G - z, J - C]), z = G, C = J
								} else z = B(J[0]), C = E(J[1]), D.push([z, C])
							}
							return 0 < D.length ? D : null
						};
						w._getQuantizationFunction = function(A, B, E) {
							return "point" === A ? z => {
									z.x = B(z.x);
									z.y = E(z.y);
									return z
								} :
								"polyline" === A || "polygon" === A ? z => {
									const C = t.isPolygon(z) ? z.rings : z.paths,
										D = [];
									for (let J = 0, K = C.length; J < K; J++) {
										const H = this._quantizePoints(C[J], B, E);
										H && D.push(H)
									}
									return 0 < D.length ? (t.isPolygon(z) ? z.rings = D : z.paths = D, z) : null
								} : "multipoint" === A ? z => {
									const C = this._quantizePoints(z.points, B, E);
									return C && 0 < C.length ? (z.points = C, z) : null
								} : "extent" === A ? z => z : null
						};
						w._getHydrationFunction = function(A, B, E) {
							return "point" === A ? z => {
								z.x = B(z.x);
								z.y = E(z.y)
							} : "polyline" === A || "polygon" === A ? z => {
								z = t.isPolygon(z) ? z.rings : z.paths;
								let C, D;
								for (let J = 0, K = z.length; J < K; J++) {
									const H = z[J];
									for (let G = 0, F = H.length; G < F; G++) {
										const L = H[G];
										0 < G ? (C += L[0], D += L[1]) : (C = L[0], D = L[1]);
										L[0] = B(C);
										L[1] = E(D)
									}
								}
							} : "extent" === A ? z => {
								z.xmin = B(z.xmin);
								z.ymin = E(z.ymin);
								z.xmax = B(z.xmax);
								z.ymax = E(z.ymax)
							} : "multipoint" === A ? z => {
								z = z.points;
								let C, D;
								for (let J = 0, K = z.length; J < K; J++) {
									const H = z[J];
									0 < J ? (C += H[0], D += H[1]) : (C = H[0], D = H[1]);
									H[0] = B(C);
									H[1] = E(D)
								}
							} : null
						};
						return y
					}(k.JSONSupport);
					b.__decorate([f.property({
							type: String,
							json: {
								write: !0
							}
						})], d.prototype, "displayFieldName",
						void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(x) {
									return {
										enabled: x
									}
								}
							}
						}
					})], d.prototype, "exceededTransferLimit", void 0);
					b.__decorate([f.property({
						type: [e],
						json: {
							write: !0
						}
					})], d.prototype, "features", void 0);
					b.__decorate([l.reader("features")], d.prototype, "readFeatures", null);
					b.__decorate([f.property({
						type: [h],
						json: {
							write: !0
						}
					})], d.prototype, "fields", void 0);
					b.__decorate([f.property({
							type: "point multipoint polyline polygon extent mesh".split(" "),
							json: {
								read: {
									reader: u.read
								}
							}
						})],
						d.prototype, "geometryType", void 0);
					b.__decorate([p.writer("geometryType")], d.prototype, "writeGeometryType", null);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(x) {
									return {
										enabled: x
									}
								}
							}
						}
					})], d.prototype, "hasM", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(x) {
									return {
										enabled: x
									}
								}
							}
						}
					})], d.prototype, "hasZ", void 0);
					b.__decorate([f.property({
						types: c.geometryTypes,
						json: {
							write: !0
						}
					})], d.prototype, "queryGeometry", void 0);
					b.__decorate([l.reader("queryGeometry")], d.prototype,
						"readQueryGeometry", null);
					b.__decorate([f.property({
						type: n,
						json: {
							write: !0
						}
					})], d.prototype, "spatialReference", void 0);
					b.__decorate([p.writer("spatialReference")], d.prototype, "writeSpatialReference", null);
					b.__decorate([f.property({
						json: {
							write: !0
						}
					})], d.prototype, "transform", void 0);
					d = q = b.__decorate([r.subclass("esri.rest.support.FeatureSet")], d);
					d.prototype.toJSON.isDefaultToJSON = !0;
					return d
				})
		},
		"esri/layers/support/Field": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ./domains ./fieldType".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					const n = new c.JSONMap({
						binary: "binary",
						coordinate: "coordinate",
						countOrAmount: "count-or-amount",
						dateAndTime: "date-and-time",
						description: "description",
						locationOrPlaceName: "location-or-place-name",
						measurement: "measurement",
						nameOrTitle: "name-or-title",
						none: "none",
						orderedOrRanked: "ordered-or-ranked",
						percentageOrRatio: "percentage-or-ratio",
						typeOrCategory: "type-or-category",
						uniqueIdentifier: "unique-identifier"
					});
					c = p = function(t) {
						function h(u) {
							u = t.call(this, u) || this;
							u.alias = null;
							u.defaultValue = void 0;
							u.description = null;
							u.domain = null;
							u.editable = !0;
							u.length = -1;
							u.name = null;
							u.nullable = !0;
							u.type = null;
							u.valueType = null;
							u.visible = !0;
							return u
						}
						a._inheritsLoose(h, t);
						var q = h.prototype;
						q.readDescription = function(u, {
							description: x
						}) {
							u = null;
							try {
								u = x ? JSON.parse(x) : null
							} catch (y) {}
							return u ? .value ? ? null
						};
						q.readValueType = function(u, {
							description: x
						}) {
							u = null;
							try {
								u = x ? JSON.parse(x) : null
							} catch (y) {}
							return u ? n.fromJSON(u.fieldValueType) : null
						};
						q.clone = function() {
							return new p({
								alias: this.alias,
								defaultValue: this.defaultValue,
								description: this.description,
								domain: this.domain && this.domain.clone() || null,
								editable: this.editable,
								length: this.length,
								name: this.name,
								nullable: this.nullable,
								type: this.type,
								valueType: this.valueType,
								visible: this.visible
							})
						};
						return h
					}(e.JSONSupport);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "alias", void 0);
					b.__decorate([d.property({
						type: [String, Number],
						json: {
							write: {
								allowNull: !0
							}
						}
					})], c.prototype, "defaultValue", void 0);
					b.__decorate([d.property()],
						c.prototype, "description", void 0);
					b.__decorate([f.reader("description")], c.prototype, "readDescription", null);
					b.__decorate([d.property({
						types: l.types,
						json: {
							read: {
								reader: l.fromJSON
							},
							write: !0
						}
					})], c.prototype, "domain", void 0);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], c.prototype, "editable", void 0);
					b.__decorate([d.property({
						type: v.Integer,
						json: {
							write: !0
						}
					})], c.prototype, "length", void 0);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "name", void 0);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], c.prototype, "nullable", void 0);
					b.__decorate([m.enumeration(r.kebabDict)], c.prototype, "type", void 0);
					b.__decorate([d.property()], c.prototype, "valueType", void 0);
					b.__decorate([f.reader("valueType", ["description"])], c.prototype, "readValueType", null);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							read: !1
						}
					})], c.prototype, "visible", void 0);
					return c = p = b.__decorate([g.subclass("esri.layers.support.Field")], c)
				})
		},
		"esri/layers/support/fieldType": function() {
			define(["exports", "../../core/jsonMap"],
				function(a, b) {
					b = new b.JSONMap({
						esriFieldTypeSmallInteger: "small-integer",
						esriFieldTypeInteger: "integer",
						esriFieldTypeSingle: "single",
						esriFieldTypeDouble: "double",
						esriFieldTypeLong: "long",
						esriFieldTypeString: "string",
						esriFieldTypeDate: "date",
						esriFieldTypeOID: "oid",
						esriFieldTypeGeometry: "geometry",
						esriFieldTypeBlob: "blob",
						esriFieldTypeRaster: "raster",
						esriFieldTypeGUID: "guid",
						esriFieldTypeGlobalID: "global-id",
						esriFieldTypeXML: "xml"
					});
					a.kebabDict = b;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/mixins/APIKeyMixin": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v) {
				a.APIKeyMixin = m => {
					m = function(f) {
						function g() {
							return f.apply(this, arguments) || this
						}
						b._inheritsLoose(g, f);
						b._createClass(g, [{
							key: "apiKey",
							get: function() {
								return this._isOverridden("apiKey") ? this._get("apiKey") :
									"portalItem" in this ? this.portalItem ? .apiKey : null
							},
							set: function(l) {
								null != l ? this._override("apiKey", l) : (this._clearOverride("apiKey"), this.clear("apiKey", "user"))
							}
						}]);
						return g
					}(m);
					c.__decorate([e.property({
						type: String
					})], m.prototype, "apiKey", null);
					return m = c.__decorate([v.subclass("esri.layers.mixins.APIKeyMixin")], m)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/mixins/ArcGISService": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Logger ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../support/arcgisLayerUrl".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					a.ArcGISService = l => {
						l = function(r) {
							function p() {
								return r.apply(this, arguments) || this
							}
							b._inheritsLoose(p, r);
							b._createClass(p, [{
								key: "title",
								get: function() {
									if (this._get("title") && "defaults" !== this.originOf("title")) return this._get("title");
									if (this.url) {
										const n = g.parse(this.url);
										if (d.isSome(n) && n.title) return n.title
									}
									return this._get("title") || ""
								},
								set: function(n) {
									this._set("title", n)
								}
							}, {
								key: "url",
								set: function(n) {
									this._set("url", g.sanitizeUrl(n, e.getLogger(this.declaredClass)))
								}
							}]);
							return p
						}(l);
						c.__decorate([k.property()], l.prototype, "title", null);
						c.__decorate([k.property({
							type: String
						})], l.prototype, "url", null);
						return l = c.__decorate([f.subclass("esri.layers.mixins.ArcGISService")], l)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/mixins/BlendLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../effects/jsonUtils".split(" "),
				function(a, b, c, e, d, k, v, m) {
					const f = {
						read: {
							reader: m.read
						},
						write: {
							allowNull: !0,
							writer: m.write
						}
					};
					a.BlendLayer = g => {
						g = function(l) {
							function r() {
								var p = l.apply(this, arguments) || this;
								p.blendMode = "normal";
								p.effect = null;
								return p
							}
							b._inheritsLoose(r, l);
							return r
						}(g);
						c.__decorate([e.property({
							type: "average color-burn color-dodge color darken destination-atop destination-in destination-out destination-over difference exclusion hard-light hue invert lighten lighter luminosity minus multiply normal overlay plus reflect saturation screen soft-light source-atop source-in source-out vivid-light xor".split(" "),
							nonNullable: !0,
							json: {
								read: !1,
								write: !1,
								origins: {
									"web-map": {
										read: !0,
										write: !0
									},
									"portal-item": {
										read: !0,
										write: !0
									}
								}
							}
						})], g.prototype, "blendMode", void 0);
						c.__decorate([e.property({
							json: {
								read: !1,
								write: !1,
								origins: {
									"web-map": f,
									"portal-item": f
								}
							}
						})], g.prototype, "effect", void 0);
						return g = c.__decorate([v.subclass("esri.layers.mixins.BlendLayer")], g)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/effects/jsonUtils": function() {
			define(["exports", "../../core/Error",
				"../../core/object", "./parser", "./utils"
			], function(a, b, c, e, d) {
				function k(g) {
					return (g = e.parse(g)) ? d.isEffectFunctions(g) ? g.map(l => l.toJSON()) : g.map(({
						scale: l,
						effects: r
					}) => ({
						scale: l,
						value: r.map(p => p.toJSON())
					})) : null
				}

				function v(g) {
					if (!g || 0 === g.length) return null;
					var l = (l = g[0]) ? "scale" in l : !1;
					if (l) {
						l = [];
						for (const r of g) l.push({
							scale: r.scale,
							value: m(r.value)
						});
						return l
					}
					return m(g)
				}

				function m(g) {
					if (!g || !g.length) return "";
					const l = [];
					for (const t of g) {
						g = [];
						switch (t.type) {
							case "grayscale":
							case "sepia":
							case "saturate":
							case "invert":
							case "brightness":
							case "contrast":
							case "opacity":
								g = [f(t, "amount")];
								break;
							case "blur":
								g = [f(t, "radius", "pt")];
								break;
							case "hue-rotate":
								g = [f(t, "angle", "deg")];
								break;
							case "drop-shadow":
								g = f(t, "xoffset", "pt");
								var r = f(t, "yoffset", "pt"),
									p = f(t, "blurRadius", "pt"),
									n = t;
								if (null == n.color) throw new b("effect:missing-parameter", `Missing parameter '${"color"}' in ${n.type} effect`, {
									effect: n
								});
								n = n.color;
								g = [g, r, p, `rgba(${n[0]||0}, ${n[1]||0}, ${n[2]||0}, ${n[3]/255||0})`];
								break;
							case "bloom":
								g = [f(t, "strength"), f(t, "radius", "pt"), f(t, "threshold")]
						}
						g = `${t.type}(${g.filter(Boolean).join(" ")})`;
						e.parse(g);
						l.push(g)
					}
					return l.join(" ")
				}

				function f(g, l, r) {
					if (null == g[l]) throw new b("effect:missing-parameter", `Missing parameter '${l}' in ${g.type} effect`, {
						effect: g
					});
					return r ? g[l] + r : "" + g[l]
				}
				a.effectFunctionsFromJSON = m;
				a.fromJSON = v;
				a.read = function(g, l, r) {
					try {
						return v(g)
					} catch (p) {
						r ? .messages ? .push(p)
					}
					return null
				};
				a.toJSON = k;
				a.write = function(g, l, r, p) {
					try {
						const n = k(g);
						c.setDeepValue(r, n, l)
					} catch (n) {
						p.messages && p.messages.push(n)
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/effects/parser": function() {
			define("exports ../../colorUtils ../../core/Error ./effects ../../chunks/_commonjsHelpers ./utils".split(" "), function(a, b, c, e, d, k) {
				function v(y) {
					let w;
					if (!y) return [];
					try {
						w = t.exports.parse(y)
					} catch (A) {
						throw new c("effect:invalid-syntax", "Invalid effect syntax", {
							value: y,
							error: A
						});
					}
					return w.map(A => m(A))
				}

				function m(y) {
					try {
						switch (y.name) {
							case "grayscale":
							case "sepia":
							case "saturate":
							case "invert":
							case "brightness":
							case "contrast":
								var w = 1;
								f(y.parameters, 1);
								1 === y.parameters.length &&
									(w = r(y.parameters[0]));
								return new e.ColorMatrixEffect(y.name, w);
							case "opacity":
								return w = 1, f(y.parameters, 1), 1 === y.parameters.length && (w = r(y.parameters[0])), new e.OpacityEffect(w);
							case "hue-rotate":
								w = 0;
								f(y.parameters, 1);
								if (1 === y.parameters.length) {
									var A = y.parameters[0];
									if ("quantity" !== A.type || !(0 === A.value && null === A.unit || A.unit && null != h[A.unit])) throw new c("effect:type-error", `Expected <angle>, Actual: ${g(A)}`, {
										term: A
									});
									w = A.value * h[A.unit] || 0
								}
								return new e.HueRotateEffect(w);
							case "blur":
								return w =
									0, f(y.parameters, 1), 1 === y.parameters.length && (w = p(y.parameters[0]), l(w, y.parameters[0])), new e.BlurEffect(w);
							case "drop-shadow":
								const D = [];
								let J = null;
								for (const K of y.parameters)
									if ("color" === K.type) {
										D.length && Object.freeze(D);
										if (J) throw new c("effect:type-error", "Accepts only one color", {});
										a: {
											A = void 0;
											var B = K;
											switch (B.colorType) {
												case "hex":
													J = b.hex2rgba(B.value);
													break a;
												case "named":
													J = n(B.value);
													break a;
												case "function":
													w = B.value;
													f(w.parameters, 4);
													if (u.test(w.name)) A = [r(w.parameters[0]), r(w.parameters[1]),
														r(w.parameters[2]), w.parameters[3] ? r(w.parameters[3]) : 1
													];
													else if (x.test(w.name)) {
														B = b;
														var E = B.hsla2rgba,
															z = w.parameters[0],
															C = z;
														if ("quantity" !== C.type || null !== C.unit) throw new c("effect:type-error", `Expected <double>, Actual: ${g(C)}`, {
															term: C
														});
														l(z.value, z);
														A = E.call(B, z.value, r(w.parameters[1]), r(w.parameters[2]), w.parameters[3] ? r(w.parameters[3]) : 1)
													} else throw new c("effect:syntax-error", `Invalid color function '${w.name}'`, {
														colorFunction: w
													});
													J = A;
													break a
											}
											J = void 0
										}
									} else {
										const H = p(K);
										if (Object.isFrozen(D)) throw new c("effect:type-error",
											"\x3clength\x3e parameters not consecutive", {
												lengths: D
											});
										D.push(H);
										3 === D.length && l(H, K)
									} if (2 > D.length || 3 < D.length) throw new c("effect:type-error", `Expected <length>{2,3}, Actual: <length>{${D.length}}`, {
									lengths: D
								});
								return new e.DropShadowEffect(D[0], D[1], D[2] || 0, J || n("black"));
							case "bloom":
								return w = 1, z = E = 0, f(y.parameters, 3), y.parameters[0] && (w = r(y.parameters[0])), y.parameters[1] && (E = p(y.parameters[1]), l(E, y.parameters[1])), y.parameters[2] && (z = r(y.parameters[2])), new e.BloomEffect(w, E, z)
						}
					} catch (D) {
						throw D.details.filter =
							y, D;
					}
					throw new c("effect:unknown-effect", `Effect '${y.name}' is not supported`, {
						effect: y
					});
				}

				function f(y, w) {
					if (y.length > w) throw new c("effect:type-error", `Function supports up to ${w} parameters, Actual: ${y.length}`, {
						parameters: y
					});
				}

				function g(y) {
					if ("color" === y.type) return "\x3ccolor\x3e";
					if (y.unit) {
						if (q[y.unit]) return "\x3clength\x3e";
						if (h[y.unit]) return "\x3cangle\x3e";
						if ("%" === y.unit) return "\x3cpercentage\x3e"
					}
					return "\x3cdouble\x3e"
				}

				function l(y, w) {
					if (0 > y) throw new c("effect:type-error", `Negative values are not allowed, Actual: ${y}`, {
						term: w
					});
				}

				function r(y) {
					if ("quantity" !== y.type || null !== y.unit && "%" !== y.unit) throw new c("effect:type-error", `Expected <double> or <percentage>, Actual: ${g(y)}`, {
						term: y
					});
					const w = y.value;
					l(w, y);
					return "%" === y.unit ? .01 * w : w
				}

				function p(y) {
					if ("quantity" !== y.type || !(0 === y.value && null === y.unit || y.unit && null != q[y.unit])) throw new c("effect:type-error", `Expected <length>, Actual: ${g(y)}`, {
						term: y
					});
					return y.value * q[y.unit] || 0
				}

				function n(y) {
					if (!b.isNamedColor(y)) throw new c("effect:unknown-color", `color '${y}' isn't valid`, {
						namedColor: y
					});
					return b.getNamedColorCopy(y)
				}
				var t = {
					exports: {}
				};
				(function(y) {
					(function(w, A) {
						y.exports && (y.exports = A())
					})(d.commonjsGlobal, function() {
						function w(B, E, z, C) {
							B = Error.call(this, B);
							Object.setPrototypeOf && Object.setPrototypeOf(B, w.prototype);
							B.expected = E;
							B.found = z;
							B.location = C;
							B.name = "SyntaxError";
							return B
						}

						function A(B, E, z) {
							z = z || " ";
							if (B.length > E) return B;
							E -= B.length;
							z += z.repeat(E);
							return B + z.slice(0, E)
						}(function(B, E) {
							function z() {
								this.constructor = B
							}
							z.prototype = E.prototype;
							B.prototype = new z
						})(w,
							Error);
						w.prototype.format = function(B) {
							var E = "Error: " + this.message;
							if (this.location) {
								var z = null,
									C;
								for (C = 0; C < B.length; C++)
									if (B[C].source === this.location.source) {
										z = B[C].text.split(/\r\n|\n|\r/g);
										break
									} B = this.location.start;
								C = this.location.source + ":" + B.line + ":" + B.column;
								if (z) {
									var D = this.location.end,
										J = A("", B.line.toString()
											.length, " ");
									z = z[B.line - 1];
									D = (B.line === D.line ? D.column : z.length + 1) - B.column || 1;
									E += "\n --\x3e " + C + "\n" + J + " |\n" + B.line + " | " + z + "\n" + J + " | " + A("", B.column - 1, " ") + A("", D, "^")
								} else E +=
									"\n at " + C
							}
							return E
						};
						w.buildMessage = function(B, E) {
							function z(H) {
								return H.charCodeAt(0)
									.toString(16)
									.toUpperCase()
							}

							function C(H) {
								return H.replace(/\\/g, "\\\\")
									.replace(/"/g, '\\"')
									.replace(/\0/g, "\\0")
									.replace(/\t/g, "\\t")
									.replace(/\n/g, "\\n")
									.replace(/\r/g, "\\r")
									.replace(/[\x00-\x0F]/g, function(G) {
										return "\\x0" + z(G)
									})
									.replace(/[\x10-\x1F\x7F-\x9F]/g, function(G) {
										return "\\x" + z(G)
									})
							}

							function D(H) {
								return H.replace(/\\/g, "\\\\")
									.replace(/\]/g, "\\]")
									.replace(/\^/g, "\\^")
									.replace(/-/g, "\\-")
									.replace(/\0/g,
										"\\0")
									.replace(/\t/g, "\\t")
									.replace(/\n/g, "\\n")
									.replace(/\r/g, "\\r")
									.replace(/[\x00-\x0F]/g, function(G) {
										return "\\x0" + z(G)
									})
									.replace(/[\x10-\x1F\x7F-\x9F]/g, function(G) {
										return "\\x" + z(G)
									})
							}

							function J(H) {
								return K[H.type](H)
							}
							var K = {
								literal: function(H) {
									return '"' + C(H.text) + '"'
								},
								class: function(H) {
									var G = H.parts.map(function(F) {
										return Array.isArray(F) ? D(F[0]) + "-" + D(F[1]) : D(F)
									});
									return "[" + (H.inverted ? "^" : "") + G.join("") + "]"
								},
								any: function() {
									return "any character"
								},
								end: function() {
									return "end of input"
								},
								other: function(H) {
									return H.description
								}
							};
							return "Expected " + function(H) {
								H = H.map(J);
								var G, F;
								H.sort();
								if (0 < H.length) {
									for (F = G = 1; G < H.length; G++) H[G - 1] !== H[G] && (H[F] = H[G], F++);
									H.length = F
								}
								switch (H.length) {
									case 1:
										return H[0];
									case 2:
										return H[0] + " or " + H[1];
									default:
										return H.slice(0, -1)
											.join(", ") + ", or " + H[H.length - 1]
								}
							}(B) + " but " + (E ? '"' + C(E) + '"' : "end of input") + " found."
						};
						return {
							SyntaxError: w,
							parse: function(B, E) {
								function z(Ja, ua) {
									return {
										type: "literal",
										text: Ja,
										ignoreCase: ua
									}
								}

								function C(Ja, ua, Ia) {
									return {
										type: "class",
										parts: Ja,
										inverted: ua,
										ignoreCase: Ia
									}
								}

								function D(Ja) {
									return {
										type: "other",
										description: Ja
									}
								}

								function J(Ja) {
									var ua = ia[Ja],
										Ia;
									if (!ua) {
										for (Ia = Ja - 1; !ia[Ia];) Ia--;
										ua = ia[Ia];
										for (ua = {
											line: ua.line,
											column: ua.column
										}; Ia < Ja;) 10 === B.charCodeAt(Ia) ? (ua.line++, ua.column = 1) : ua.column++, Ia++;
										ia[Ja] = ua
									}
									return ua
								}

								function K(Ja, ua) {
									var Ia = J(Ja),
										X = J(ua);
									return {
										source: T,
										start: {
											offset: Ja,
											line: Ia.line,
											column: Ia.column
										},
										end: {
											offset: ua,
											line: X.line,
											column: X.column
										}
									}
								}

								function H(Ja) {
									Fa < ra || (Fa > ra && (ra = Fa, na = []), na.push(Ja))
								}

								function G() {
									wa++;
									var Ja = Fa;
									R();
									if (B.substr(Fa,
										4) === qa) {
										var ua = qa;
										Fa += 4
									} else ua = M, 0 === wa && H(Da);
									ua !== M ? (R(), hb = Ja, Ja = []) : (Fa = Ja, Ja = M);
									wa--;
									Ja === M && 0 === wa && H(ta);
									if (Ja === M)
										if (Ja = [], ua = F(), ua !== M)
											for (; ua !== M;) Ja.push(ua), ua = F();
										else Ja = M;
									return Ja
								}

								function F() {
									var Ja = Fa;
									R();
									wa++;
									var ua = Fa;
									var Ia = V();
									if (Ia !== M) {
										if (40 === B.charCodeAt(Fa)) {
											var X = da;
											Fa++
										} else X = M, 0 === wa && H(Wa);
										X !== M ? (hb = ua, ua = Ia) : (Fa = ua, ua = M)
									} else Fa = ua, ua = M;
									wa--;
									ua === M && (Ia = M, 0 === wa && H(Ra));
									if (ua !== M) {
										R();
										Ia = Fa;
										X = L();
										if (X !== M) {
											var Ea = [];
											var Ha = Fa;
											var La = R();
											if (44 === B.charCodeAt(Fa)) {
												var Oa =
													Ka;
												Fa++
											} else Oa = M, 0 === wa && H(Na);
											Oa === M && (Oa = null);
											var Va = R();
											var eb = L();
											eb !== M ? Ha = La = [La, Oa, Va, eb] : (Fa = Ha, Ha = M);
											for (; Ha !== M;) Ea.push(Ha), Ha = Fa, La = R(), 44 === B.charCodeAt(Fa) ? (Oa = Ka, Fa++) : (Oa = M, 0 === wa && H(Na)), Oa === M && (Oa = null), Va = R(), eb = L(), eb !== M ? Ha = La = [La, Oa, Va, eb] : (Fa = Ha, Ha = M);
											hb = Ia;
											Ia = 0 < Ea.length ? [X].concat(W(Ea, 3)) : [X]
										} else Fa = Ia, Ia = M;
										Ia === M && (Ia = null);
										R();
										41 === B.charCodeAt(Fa) ? (X = Aa, Fa++) : (X = M, 0 === wa && H(Ga));
										X !== M ? (R(), hb = Ja, Ja = {
											type: "function",
											name: ua,
											parameters: Ia || []
										}) : (Fa = Ja, Ja = M)
									} else Fa =
										Ja, Ja = M;
									return Ja
								}

								function L() {
									var Ja = Fa;
									wa++;
									var ua = Fa;
									R();
									var Ia = U();
									if (Ia !== M) {
										if (37 === B.charCodeAt(Fa)) {
											var X = ja;
											Fa++
										} else X = M, 0 === wa && H(Ya);
										X !== M ? (hb = ua, ua = {
											value: Ia,
											unit: "%"
										}) : (Fa = ua, ua = M)
									} else Fa = ua, ua = M;
									wa--;
									ua === M && 0 === wa && H($a);
									ua === M && (wa++, ua = Fa, R(), Ia = U(), Ia !== M ? (B.substr(Fa, 2) === sa ? (X = sa, Fa += 2) : (X = M, 0 === wa && H(Qa)), X !== M ? (hb = ua, ua = {
										value: Ia,
										unit: "px"
									}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M), ua === M && (ua = Fa, R(), Ia = U(), Ia !== M ? (B.substr(Fa, 2) === I ? (X = I, Fa += 2) : (X = M, 0 === wa && H(Ba)), X !== M ? (hb = ua, ua = {
										value: Ia,
										unit: "cm"
									}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M), ua === M && (ua = Fa, R(), Ia = U(), Ia !== M ? (B.substr(Fa, 2) === N ? (X = N, Fa += 2) : (X = M, 0 === wa && H(O)), X !== M ? (hb = ua, ua = {
										value: Ia,
										unit: "mm"
									}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M), ua === M && (ua = Fa, R(), Ia = U(), Ia !== M ? (B.substr(Fa, 2) === ea ? (X = ea, Fa += 2) : (X = M, 0 === wa && H(Y)), X !== M ? (hb = ua, ua = {
										value: Ia,
										unit: "in"
									}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M), ua === M && (ua = Fa, R(), Ia = U(), Ia !== M ? (B.substr(Fa, 2) === pa ? (X = pa, Fa += 2) : (X = M, 0 === wa && H(ya)), X !== M ? (hb = ua, ua = {
										value: Ia,
										unit: "pt"
									}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M), ua === M && (ua =
										Fa, R(), Ia = U(), Ia !== M ? (B.substr(Fa, 2) === xa ? (X = xa, Fa += 2) : (X = M, 0 === wa && H(za)), X !== M ? (hb = ua, ua = {
											value: Ia,
											unit: "pc"
										}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M)))))), wa--, ua === M && 0 === wa && H(ab), ua === M && (wa++, ua = Fa, Ia = U(), Ia !== M ? (B.substr(Fa, 3) === S ? (X = S, Fa += 3) : (X = M, 0 === wa && H(Pa)), X !== M ? (hb = ua, ua = {
										value: Ia,
										unit: "deg"
									}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M), ua === M && (ua = Fa, Ia = U(), Ia !== M ? (B.substr(Fa, 3) === ba ? (X = ba, Fa += 3) : (X = M, 0 === wa && H(Sa)), X !== M ? (hb = ua, ua = {
										value: Ia,
										unit: "rad"
									}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M), ua === M && (ua = Fa, Ia = U(), Ia !== M ?
										(B.substr(Fa, 4) === la ? (X = la, Fa += 4) : (X = M, 0 === wa && H(Ua)), X !== M ? (hb = ua, ua = {
											value: Ia,
											unit: "grad"
										}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M), ua === M && (ua = Fa, Ia = U(), Ia !== M ? (B.substr(Fa, 4) === ha ? (X = ha, Fa += 4) : (X = M, 0 === wa && H(Za)), X !== M ? (hb = ua, ua = {
											value: Ia,
											unit: "turn"
										}) : (Fa = ua, ua = M)) : (Fa = ua, ua = M)))), wa--, ua === M && (Ia = M, 0 === wa && H(fa)), ua === M && (wa++, ua = Fa, R(), Ia = U(), Ia !== M ? (hb = ua, ua = {
										value: Ia,
										unit: null
									}) : (Fa = ua, ua = M), wa--, ua === M && 0 === wa && H(db))));
									ua !== M && (hb = Ja, ua = {
										type: "quantity",
										value: ua.value,
										unit: ua.unit
									});
									Ja = ua;
									if (Ja === M) {
										Ja =
											Fa;
										wa++;
										ua = Fa;
										35 === B.charCodeAt(Fa) ? (Ia = P, Fa++) : (Ia = M, 0 === wa && H(ib));
										if (Ia !== M) {
											Ia = [];
											ma.test(B.charAt(Fa)) ? (X = B.charAt(Fa), Fa++) : (X = M, 0 === wa && H(gb));
											if (X !== M)
												for (; X !== M;) Ia.push(X), ma.test(B.charAt(Fa)) ? (X = B.charAt(Fa), Fa++) : (X = M, 0 === wa && H(gb));
											else Ia = M;
											Ia !== M ? (hb = ua, ua = {
												type: "hex",
												value: B.substring(hb, Fa)
											}) : (Fa = ua, ua = M)
										} else Fa = ua, ua = M;
										ua === M && (ua = Fa, Ia = F(), Ia !== M && (hb = ua, Ia = {
											type: "function",
											value: Ia
										}), ua = Ia, ua === M && (ua = Fa, Ia = V(), Ia !== M && (hb = ua, Ia = {
											type: "named",
											value: B.substring(hb, Fa)
										}), ua = Ia));
										wa--;
										ua === M && (Ia = M, 0 === wa && H(fb));
										ua !== M && (hb = Ja, ua = {
											type: "color",
											colorType: ua.type,
											value: ua.value
										});
										Ja = ua
									}
									return Ja
								}

								function R() {
									wa++;
									var Ja = [];
									if (va.test(B.charAt(Fa))) {
										var ua = B.charAt(Fa);
										Fa++
									} else ua = M, 0 === wa && H(Ta);
									for (; ua !== M;) Ja.push(ua), va.test(B.charAt(Fa)) ? (ua = B.charAt(Fa), Fa++) : (ua = M, 0 === wa && H(Ta));
									wa--;
									ua = M;
									0 === wa && H(Ma);
									return Ja
								}

								function V() {
									wa++;
									var Ja = Fa;
									var ua = [];
									if (Ca.test(B.charAt(Fa))) {
										var Ia = B.charAt(Fa);
										Fa++
									} else Ia = M, 0 === wa && H(bb);
									if (Ia !== M)
										for (; Ia !== M;) ua.push(Ia), Ca.test(B.charAt(Fa)) ?
											(Ia = B.charAt(Fa), Fa++) : (Ia = M, 0 === wa && H(bb));
									else ua = M;
									ua !== M && (hb = Ja, ua = B.substring(hb, Fa));
									Ja = ua;
									wa--;
									Ja === M && (ua = M, 0 === wa && H(Xa));
									return Ja
								}

								function U() {
									var Ja = Fa;
									Q.test(B.charAt(Fa)) ? (B.charAt(Fa), Fa++) : 0 === wa && H(kb);
									var ua = Fa;
									var Ia = [];
									if (aa.test(B.charAt(Fa))) {
										var X = B.charAt(Fa);
										Fa++
									} else X = M, 0 === wa && H(cb);
									for (; X !== M;) Ia.push(X), aa.test(B.charAt(Fa)) ? (X = B.charAt(Fa), Fa++) : (X = M, 0 === wa && H(cb));
									46 === B.charCodeAt(Fa) ? (X = ca, Fa++) : (X = M, 0 === wa && H(jb));
									if (X !== M) {
										var Ea = [];
										if (aa.test(B.charAt(Fa))) {
											var Ha =
												B.charAt(Fa);
											Fa++
										} else Ha = M, 0 === wa && H(cb);
										if (Ha !== M)
											for (; Ha !== M;) Ea.push(Ha), aa.test(B.charAt(Fa)) ? (Ha = B.charAt(Fa), Fa++) : (Ha = M, 0 === wa && H(cb));
										else Ea = M;
										Ea !== M ? ua = Ia = [Ia, X, Ea] : (Fa = ua, ua = M)
									} else Fa = ua, ua = M;
									if (ua === M)
										if (ua = [], aa.test(B.charAt(Fa)) ? (Ia = B.charAt(Fa), Fa++) : (Ia = M, 0 === wa && H(cb)), Ia !== M)
											for (; Ia !== M;) ua.push(Ia), aa.test(B.charAt(Fa)) ? (Ia = B.charAt(Fa), Fa++) : (Ia = M, 0 === wa && H(cb));
										else ua = M;
									if (ua !== M) {
										Ia = Fa;
										101 === B.charCodeAt(Fa) ? (X = ka, Fa++) : (X = M, 0 === wa && H(lb));
										if (X !== M) {
											Q.test(B.charAt(Fa)) ?
												(Ea = B.charAt(Fa), Fa++) : (Ea = M, 0 === wa && H(kb));
											Ea === M && (Ea = null);
											Ha = [];
											aa.test(B.charAt(Fa)) ? (ua = B.charAt(Fa), Fa++) : (ua = M, 0 === wa && H(cb));
											if (ua !== M)
												for (; ua !== M;) Ha.push(ua), aa.test(B.charAt(Fa)) ? (ua = B.charAt(Fa), Fa++) : (ua = M, 0 === wa && H(cb));
											else Ha = M;
											Ha !== M ? Ia = X = [X, Ea, Ha] : (Fa = Ia, Ia = M)
										} else Fa = Ia, Ia = M;
										Ia === M && (Ia = null);
										hb = Ja;
										Ja = parseFloat(B.substring(hb, Fa))
									} else Fa = Ja, Ja = M;
									return Ja
								}

								function W(Ja, ua) {
									return Ja.map(function(Ia) {
										return Ia[ua]
									})
								}
								E = void 0 !== E ? E : {};
								var M = {},
									T = E.grammarSource,
									Z = {
										start: G
									},
									oa =
									G,
									qa = "none",
									Aa = ")",
									Ka = ",",
									da = "(",
									ja = "%",
									sa = "px",
									I = "cm",
									N = "mm",
									ea = "in",
									pa = "pt",
									xa = "pc",
									S = "deg",
									ba = "rad",
									la = "grad",
									ha = "turn",
									P = "#",
									ca = ".",
									ka = "e",
									va = /^[ \t\n\r]/,
									Ca = /^[a-z\-]/,
									ma = /^[0-9a-fA-F]/,
									Q = /^[+\-]/,
									aa = /^[0-9]/,
									ta = D("none"),
									Da = z("none", !1),
									Ga = z(")", !1),
									Na = z(",", !1),
									Ma = D("whitespace"),
									Ta = C([" ", "\t", "\n", "\r"], !1, !1),
									Ra = D("function"),
									Wa = z("(", !1),
									Xa = D("identifier"),
									bb = C([
										["a", "z"], "-"
									], !1, !1),
									$a = D("percentage"),
									Ya = z("%", !1),
									ab = D("length"),
									Qa = z("px", !1),
									Ba = z("cm", !1),
									O = z("mm", !1),
									Y = z("in", !1),
									ya =
									z("pt", !1),
									za = z("pc", !1),
									fa = D("angle"),
									Pa = z("deg", !1),
									Sa = z("rad", !1),
									Ua = z("grad", !1),
									Za = z("turn", !1),
									db = D("number"),
									fb = D("color"),
									ib = z("#", !1),
									gb = C([
										["0", "9"],
										["a", "f"],
										["A", "F"]
									], !1, !1),
									kb = C(["+", "-"], !1, !1),
									cb = C([
										["0", "9"]
									], !1, !1),
									jb = z(".", !1),
									lb = z("e", !1),
									Fa = 0,
									hb = 0,
									ia = [{
										line: 1,
										column: 1
									}],
									ra = 0,
									na = [],
									wa = 0;
								if ("startRule" in E) {
									if (!(E.startRule in Z)) throw Error("Can't start parsing from rule \"" + E.startRule + '".');
									oa = Z[E.startRule]
								}
								E = oa();
								if (E !== M && Fa === B.length) return E;
								E !== M && Fa < B.length && H({
									type: "end"
								});
								throw function(Ja, ua, Ia) {
									return new w(w.buildMessage(Ja, ua), Ja, ua, Ia)
								}(na, ra < B.length ? B.charAt(ra) : null, ra < B.length ? K(ra, ra + 1) : K(ra, ra));
							}
						}
					})
				})(t);
				const h = {
						deg: 1,
						grad: .9,
						rad: 180 / Math.PI,
						turn: 360
					},
					q = {
						px: 1,
						cm: 96 / 2.54,
						mm: 96 / 2.54 / 10,
						in: 96,
						pc: 16,
						pt: 96 / 72
					},
					u = /^rgba?/i,
					x = /^hsla?/i;
				a.parse = function(y) {
					if (!y || 0 === y.length) return null;
					if ("string" === typeof y) return (y = v(y)) && 0 !== y.length ? y : null;
					y = y.map(w => {
						if (!Number.isFinite(w.scale) || 0 >= w.scale) throw new c("effect:invalid-scale", "scale must be finite and greater than 0", {
							stop: w
						});
						return {
							scale: w.scale,
							effects: v(w.value)
						}
					});
					y.sort((w, A) => A.effects.length - w.effects.length);
					for (let w = 0; w < y.length - 1; w++) {
						if (!k.canInterpolateEffects(y[w].effects, y[w + 1].effects)) throw new c("effect:interpolation-impossible", "Cannot interpolate by scale between 2 lists of mixed effects", {
							a: y[w].effects,
							b: y[w + 1].effects
						});
						k.normalizeEffects(y[w].effects, y[w + 1].effects)
					}
					y.sort((w, A) => A.scale - w.scale);
					return y
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/effects/effects": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../colorUtils ../../core/screenUtils ../../chunks/mat4f32 ./colorMatrixFunctions".split(" "), function(a, b, c, e, d, k) {
				function v(t, h, q) {
					return t + (h - t) * q
				}

				function m(t) {
					return Math.round(1E3 * e.px2pt(t)) / 1E3
				}
				let f = function() {
						function t(q, u, x) {
							this.strength = q;
							this.radius = u;
							this.threshold = x;
							this.type = "bloom"
						}
						var h = t.prototype;
						h.interpolate = function(q, u, x) {
							this.strength = v(q.strength, u.strength, x);
							this.radius =
								v(q.radius, u.radius, x);
							this.threshold = v(q.threshold, u.threshold, x)
						};
						h.clone = function() {
							return new t(this.strength, this.radius, this.threshold)
						};
						h.toJSON = function() {
							return {
								type: "bloom",
								radius: m(this.radius),
								strength: this.strength,
								threshold: this.threshold
							}
						};
						return t
					}(),
					g = function() {
						function t(q) {
							this.radius = q;
							this.type = "blur"
						}
						var h = t.prototype;
						h.interpolate = function(q, u, x) {
							this.radius = Math.round(v(q.radius, u.radius, x))
						};
						h.clone = function() {
							return new t(this.radius)
						};
						h.toJSON = function() {
							return {
								type: "blur",
								radius: m(this.radius)
							}
						};
						return t
					}(),
					l = function() {
						function t(q, u) {
							this.type = q;
							this.amount = u;
							if ("invert" === this.type || "grayscale" === this.type || "sepia" === this.type) this.amount = Math.min(this.amount, 1)
						}
						var h = t.prototype;
						h.interpolate = function(q, u, x) {
							this.amount = v(q.amount, u.amount, x);
							this._updateMatrix()
						};
						h.clone = function() {
							return new t(this.type, this.amount)
						};
						h.toJSON = function() {
							return {
								type: this.type,
								amount: this.amount
							}
						};
						h._updateMatrix = function() {
							const q = this._colorMatrix || d.create();
							switch (this.type) {
								case "brightness":
									this._colorMatrix =
										k.brightness(q, this.amount);
									break;
								case "contrast":
									this._colorMatrix = k.contrast(q, this.amount);
									break;
								case "grayscale":
									this._colorMatrix = k.grayscale(q, this.amount);
									break;
								case "invert":
									this._colorMatrix = k.invert(q, this.amount);
									break;
								case "saturate":
									this._colorMatrix = k.saturate(q, this.amount);
									break;
								case "sepia":
									this._colorMatrix = k.sepia(q, this.amount)
							}
						};
						b._createClass(t, [{
							key: "colorMatrix",
							get: function() {
								this._colorMatrix || this._updateMatrix();
								return this._colorMatrix
							}
						}]);
						return t
					}(),
					r = function() {
						function t(q,
							u, x, y) {
							this.offsetX = q;
							this.offsetY = u;
							this.blurRadius = x;
							this.color = y;
							this.type = "drop-shadow"
						}
						var h = t.prototype;
						h.interpolate = function(q, u, x) {
							this.offsetX = v(q.offsetX, u.offsetX, x);
							this.offsetY = v(q.offsetY, u.offsetY, x);
							this.blurRadius = v(q.blurRadius, u.blurRadius, x);
							this.color[0] = Math.round(v(q.color[0], u.color[0], x));
							this.color[1] = Math.round(v(q.color[1], u.color[1], x));
							this.color[2] = Math.round(v(q.color[2], u.color[2], x));
							this.color[3] = v(q.color[3], u.color[3], x)
						};
						h.clone = function() {
							return new t(this.offsetX,
								this.offsetY, this.blurRadius, [...this.color])
						};
						h.toJSON = function() {
							const q = [...this.color];
							q[3] *= 255;
							return {
								type: "drop-shadow",
								xoffset: m(this.offsetX),
								yoffset: m(this.offsetY),
								blurRadius: m(this.blurRadius),
								color: q
							}
						};
						return t
					}(),
					p = function() {
						function t(q) {
							this.angle = q;
							this.type = "hue-rotate"
						}
						var h = t.prototype;
						h.interpolate = function(q, u, x) {
							this.angle = v(q.angle, u.angle, x);
							this._updateMatrix()
						};
						h.clone = function() {
							return new t(this.angle)
						};
						h.toJSON = function() {
							return {
								type: "hue-rotate",
								angle: this.angle
							}
						};
						h._updateMatrix = function() {
							const q = this._colorMatrix || d.create();
							this._colorMatrix = k.rotateHue(q, this.angle)
						};
						b._createClass(t, [{
							key: "colorMatrix",
							get: function() {
								this._colorMatrix || this._updateMatrix();
								return this._colorMatrix
							}
						}]);
						return t
					}(),
					n = function() {
						function t(q) {
							this.amount = q;
							this.type = "opacity";
							this.amount = Math.min(this.amount, 1)
						}
						var h = t.prototype;
						h.interpolate = function(q, u, x) {
							this.amount = v(q.amount, u.amount, x)
						};
						h.clone = function() {
							return new t(this.amount)
						};
						h.toJSON = function() {
							return {
								type: "opacity",
								amount: this.amount
							}
						};
						return t
					}();
				a.BloomEffect = f;
				a.BlurEffect = g;
				a.ColorMatrixEffect = l;
				a.DropShadowEffect = r;
				a.HueRotateEffect = p;
				a.OpacityEffect = n;
				a.createEffectWithInitialValues = function(t) {
					switch (t.type) {
						case "grayscale":
						case "sepia":
						case "invert":
							return new l(t.type, 0);
						case "saturate":
						case "brightness":
						case "contrast":
							return new l(t.type, 1);
						case "opacity":
							return new n(1);
						case "hue-rotate":
							return new p(0);
						case "blur":
							return new g(0);
						case "drop-shadow":
							return new r(0, 0, 0, [...c.getNamedColor("transparent")]);
						case "bloom":
							return new f(0, 0, 1)
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/chunks/mat4f32": function() {
			define(["exports"], function(a) {
				function b() {
					const m = new Float32Array(16);
					m[0] = 1;
					m[5] = 1;
					m[10] = 1;
					m[15] = 1;
					return m
				}

				function c(m) {
					const f = new Float32Array(16);
					f[0] = m[0];
					f[1] = m[1];
					f[2] = m[2];
					f[3] = m[3];
					f[4] = m[4];
					f[5] = m[5];
					f[6] = m[6];
					f[7] = m[7];
					f[8] = m[8];
					f[9] = m[9];
					f[10] = m[10];
					f[11] = m[11];
					f[12] = m[12];
					f[13] = m[13];
					f[14] = m[14];
					f[15] = m[15];
					return f
				}

				function e(m,
					f, g, l, r, p, n, t, h, q, u, x, y, w, A, B) {
					const E = new Float32Array(16);
					E[0] = m;
					E[1] = f;
					E[2] = g;
					E[3] = l;
					E[4] = r;
					E[5] = p;
					E[6] = n;
					E[7] = t;
					E[8] = h;
					E[9] = q;
					E[10] = u;
					E[11] = x;
					E[12] = y;
					E[13] = w;
					E[14] = A;
					E[15] = B;
					return E
				}

				function d(m, f) {
					return new Float32Array(m, f, 16)
				}
				const k = b(),
					v = Object.freeze(Object.defineProperty({
						__proto__: null,
						create: b,
						clone: c,
						fromValues: e,
						createView: d,
						IDENTITY: k
					}, Symbol.toStringTag, {
						value: "Module"
					}));
				a.IDENTITY = k;
				a.clone = c;
				a.create = b;
				a.createView = d;
				a.fromValues = e;
				a.mat4f32 = v
			})
		},
		"esri/layers/effects/colorMatrixFunctions": function() {
			define(["exports",
				"../../chunks/mat4"
			], function(a, b) {
				a.brightness = (c, e) => {
					c = b.set(c, e, 0, 0, 0, 0, e, 0, 0, 0, 0, e, 0, 0, 0, 0, 1);
					return b.transpose(c, c)
				};
				a.contrast = (c, e) => {
					c = b.set(c, e, 0, 0, .5 - .5 * e, 0, e, 0, .5 - .5 * e, 0, 0, e, .5 - .5 * e, 0, 0, 0, 1);
					return b.transpose(c, c)
				};
				a.grayscale = (c, e) => {
					e = 1 - e;
					c = b.set(c, .2126 + .7874 * e, .7152 - .7152 * e, .0722 - .0722 * e, 0, .2126 - .2126 * e, .7152 + .2848 * e, .0722 - .0722 * e, 0, .2126 - .2126 * e, .7152 - .7152 * e, .0722 + .9278 * e, 0, 0, 0, 0, 1);
					return b.transpose(c, c)
				};
				a.invert = (c, e) => {
					const d = 1 - 2 * e;
					c = b.set(c, d, 0, 0, e, 0, d, 0, e, 0, 0, d, e, 0, 0, 0,
						1);
					return b.transpose(c, c)
				};
				a.rotateHue = (c, e) => {
					const d = Math.sin(e * Math.PI / 180);
					e = Math.cos(e * Math.PI / 180);
					c = b.set(c, .213 + .787 * e - .213 * d, .715 - .715 * e - .715 * d, .072 - .072 * e + .928 * d, 0, .213 - .213 * e + .143 * d, .715 + .285 * e + .14 * d, .072 - .072 * e - .283 * d, 0, .213 - .213 * e - .787 * d, .715 - .715 * e + .715 * d, .072 + .928 * e + .072 * d, 0, 0, 0, 0, 1);
					return b.transpose(c, c)
				};
				a.saturate = (c, e) => {
					c = b.set(c, .213 + .787 * e, .715 - .715 * e, .072 - .072 * e, 0, .213 - .213 * e, .715 + .285 * e, .072 - .072 * e, 0, .213 - .213 * e, .715 - .715 * e, .072 + .928 * e, 0, 0, 0, 0, 1);
					return b.transpose(c, c)
				};
				a.sepia = (c, e) => {
					e = 1 - e;
					c = b.set(c, .393 + .607 * e, .769 - .769 * e, .189 - .189 * e, 0, .349 - .349 * e, .686 + .314 * e, .168 - .168 * e, 0, .272 - .272 * e, .534 - .534 * e, .131 + .869 * e, 0, 0, 0, 0, 1);
					return b.transpose(c, c)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/chunks/_commonjsHelpers": function() {
			define(["exports"], function(a) {
				a.commonjsGlobal = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ?
					self : {};
				a.commonjsRequire = function(b) {
					throw Error('Could not dynamically require "' + b + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
				};
				a.getDefaultExportFromCjs = function(b) {
					return b && b.__esModule && Object.prototype.hasOwnProperty.call(b, "default") ? b["default"] : b
				}
			})
		},
		"esri/layers/effects/utils": function() {
			define(["exports", "./effects"], function(a, b) {
				a.canInterpolateEffects = function(c, e) {
					const d =
						c.length > e.length ? c : e;
					return (c.length > e.length ? e : c)
						.every((k, v) => k.type === d[v].type)
				};
				a.isEffectFunctions = function(c) {
					return (c = c[0]) ? "type" in c : !1
				};
				a.normalizeEffects = function(c, e) {
					const d = c.length > e.length ? c : e;
					c = c.length > e.length ? e : c;
					for (e = c.length; e < d.length; e++) c.push(b.createEffectWithInitialValues(d[e]))
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/mixins/CustomParametersMixin": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					a.CustomParametersMixin = m => {
						m = function(f) {
							function g() {
								var l = f.apply(this, arguments) || this;
								l.customParameters = null;
								return l
							}
							b._inheritsLoose(g, f);
							return g
						}(m);
						c.__decorate([e.property({
							type: Object,
							json: {
								write: {
									overridePolicy(f) {
										return {
											enabled: !!(f && 0 < Object.keys(f)
												.length)
										}
									}
								}
							}
						})], m.prototype, "customParameters", void 0);
						return m = c.__decorate([v.subclass("esri.layers.mixins.CustomParametersMixin")], m)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/mixins/EditBusLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Evented ../../core/lang ../../core/Logger ../../core/accessorSupport/ensureType ../../core/Error ../../core/has ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m, f, g) {
				const l = new e.EventEmitter,
					r = Symbol("esri.layers.mixins.EditBusLayer");
				a.EditBusLayer = p => {
					p = function(t) {
						function h(...q) {
							var u = t.call(this, ...q) || this;
							u[n] = !0;
							u.when()
								.then(() => {
									u.own([l.on("edits", x => {
										const y = "layer" in x ? x.layer ? .url : x.serviceUrl,
											w = "layer" in x ? x.layer ? .layerId : x.layerId;
										var A = x.event;
										if (("layer" in x ? x.layer : null) !== b._assertThisInitialized(u) && y === u.url)
											if (null != w && null != u.layerId && w === u.layerId) u.emit("edits", d.clone(A));
											else if (x = A.editedFeatures ? .find(({
											layerId: B
										}) => B === u.layerId)) {
											const {
												adds: B,
												updates: E,
												deletes: z
											} = x.editedFeatures;
											A = {
												edits: null,
												addedAttachments: [],
												deletedAttachments: [],
												updatedAttachments: [],
												addedFeatures: B ? B.map(({
														attributes: C
													}) =>
													({
														objectId: u.objectIdField && C[u.objectIdField],
														globalId: u.globalIdField && C[u.globalIdField]
													})) : [],
												deletedFeatures: z ? z.map(({
													attributes: C
												}) => ({
													objectId: u.objectIdField && C[u.objectIdField],
													globalId: u.globalIdField && C[u.globalIdField]
												})) : [],
												updatedFeatures: E ? E.map(({
													current: {
														attributes: C
													}
												}) => ({
													objectId: u.objectIdField && C[u.objectIdField],
													globalId: u.globalIdField && C[u.globalIdField]
												})) : [],
												editedFeatures: d.clone(A.editedFeatures)
											};
											u.emit("edits", A)
										}
									})])
								}, () => {});
							return u
						}
						b._inheritsLoose(h, t);
						return h
					}(p);
					var n = r;
					return p = c.__decorate([g.subclass("esri.layers.mixins.EditBusLayer")], p)
				};
				a.editEventBus = l;
				a.isEditBusLayer = function(p) {
					return null != p && "object" === typeof p && r in p
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/mixins/FeatureEffectLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../support/FeatureEffect".split(" "),
				function(a, b, c, e, d, k, v, m) {
					const f = {
						write: {
							allowNull: !0
						}
					};
					a.FeatureEffectLayer = g => {
						g = function(l) {
							function r() {
								var p = l.apply(this, arguments) || this;
								p.featureEffect = null;
								return p
							}
							b._inheritsLoose(r, l);
							return r
						}(g);
						c.__decorate([e.property({
							type: m,
							json: {
								origins: {
									"web-map": f,
									"portal-item": f
								}
							}
						})], g.prototype, "featureEffect", void 0);
						return g = c.__decorate([v.subclass("esri.layers.mixins.FeatureEffectLayer")], g)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/FeatureEffect": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Error ../../core/JSONSupport ../../core/maybe ../../core/object ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../effects/jsonUtils ./FeatureFilter".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					m = {
						read: {
							reader: l.read
						},
						write: {
							writer: l.write,
							overridePolicy() {
								return {
									allowNull: null != this.excludedEffect,
									isRequired: null == this.excludedEffect
								}
							}
						}
					};
					l = {
						read: {
							reader: l.read
						},
						write: {
							writer: l.write,
							overridePolicy() {
								return {
									allowNull: null != this.includedEffect,
									isRequired: null == this.includedEffect
								}
							}
						}
					};
					f = {
						name: "showExcludedLabels",
						default: !0
					};
					e = p = function(n) {
						function t(q) {
							q = n.call(this, q) || this;
							q.filter = null;
							q.includedEffect = null;
							q.excludedEffect = null;
							q.excludedLabelsVisible = !1;
							return q
						}
						a._inheritsLoose(t, n);
						var h = t.prototype;
						h.write = function(q, u) {
							q = n.prototype.write.call(this, q, u);
							if (u ? .origin) {
								if (q.filter) {
									const x = Object.keys(q.filter);
									if (1 < x.length || "where" !== x[0]) return u.messages ? .push(new c("web-document-write:unsupported-feature-effect", "Invalid feature effect 'filter'. A filter can only contain a 'where' property", {
										layer: u.layer,
										effect: this
									})), null
								}
								if ("showExcludedLabels" in q) return u.messages ? .push(new c("web-document-write:unsupported-feature-effect", "Invalid value for property 'excludedLabelsVisible' which should always be 'true'", {
									layer: u.layer,
									effect: this
								})), null
							}
							return q
						};
						h.clone = function() {
							return new p({
								filter: d.isSome(this.filter) ? this.filter.clone() : null,
								includedEffect: this.includedEffect,
								excludedEffect: this.excludedEffect,
								excludedLabelsVisible: this.excludedLabelsVisible
							})
						};
						return t
					}(e.JSONSupport);
					b.__decorate([v.property({
						type: r,
						json: {
							write: {
								allowNull: !0,
								writer(n, t, h, q) {
									(n = n ? .write({}, q)) && 0 !== Object.keys(n)
										.length ? k.setDeepValue(h, n, t) : k.setDeepValue(h, null, t)
								}
							}
						}
					})], e.prototype, "filter", void 0);
					b.__decorate([v.property({
						json: {
							write: !0,
							origins: {
								"web-map": m,
								"portal-item": m
							}
						}
					})], e.prototype, "includedEffect", void 0);
					b.__decorate([v.property({
						json: {
							write: !0,
							origins: {
								"web-map": l,
								"portal-item": l
							}
						}
					})], e.prototype, "excludedEffect", void 0);
					b.__decorate([v.property({
						type: Boolean,
						json: {
							write: !0,
							name: "showExcludedLabels",
							origins: {
								"web-map": f,
								"portal-item": f
							}
						}
					})], e.prototype, "excludedLabelsVisible", void 0);
					return e = p = b.__decorate([g.subclass("esri.layers.support.FeatureEffect")], e)
				})
		},
		"esri/layers/support/FeatureFilter": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../TimeExtent ../../core/jsonMap ../../core/JSONSupport ../../core/lang ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../rest/support/Query".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					g = new d.JSONMap({
						esriSpatialRelIntersects: "intersects",
						esriSpatialRelContains: "contains",
						esriSpatialRelCrosses: "crosses",
						esriSpatialRelDisjoint: "disjoint",
						esriSpatialRelEnvelopeIntersects: "envelope-intersects",
						esriSpatialRelIndexIntersects: "index-intersects",
						esriSpatialRelOverlaps: "overlaps",
						esriSpatialRelTouches: "touches",
						esriSpatialRelWithin: "within",
						esriSpatialRelRelation: "relation"
					});
					d = new d.JSONMap({
						esriSRUnit_Meter: "meters",
						esriSRUnit_Kilometer: "kilometers",
						esriSRUnit_Foot: "feet",
						esriSRUnit_StatuteMile: "miles",
						esriSRUnit_NauticalMile: "nautical-miles",
						esriSRUnit_USNauticalMile: "us-nautical-miles"
					});
					k = p = function(n) {
						function t(q) {
							q = n.call(this, q) || this;
							q.where = null;
							q.geometry = null;
							q.spatialRelationship = "intersects";
							q.distance = void 0;
							q.objectIds = null;
							q.units = null;
							q.timeExtent = null;
							return q
						}
						a._inheritsLoose(t, n);
						var h = t.prototype;
						h.createQuery = function(q = {}) {
							const {
								where: u,
								geometry: x,
								spatialRelationship: y,
								timeExtent: w,
								objectIds: A,
								units: B,
								distance: E
							} = this;
							return new r({
								geometry: v.clone(x),
								objectIds: v.clone(A),
								spatialRelationship: y,
								timeExtent: v.clone(w),
								where: u,
								units: B,
								distance: E,
								...q
							})
						};
						h.clone = function() {
							const {
								where: q,
								geometry: u,
								spatialRelationship: x,
								timeExtent: y,
								objectIds: w,
								units: A,
								distance: B
							} = this;
							return new p({
								geometry: v.clone(u),
								objectIds: v.clone(w),
								spatialRelationship: x,
								timeExtent: v.clone(y),
								where: q,
								units: A,
								distance: B
							})
						};
						return t
					}(k.JSONSupport);
					b.__decorate([f.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "where", void 0);
					b.__decorate([f.property({
						types: c.geometryTypes,
						json: {
							write: !0
						}
					})], k.prototype, "geometry", void 0);
					b.__decorate([f.property({
						type: g.apiValues,
						json: {
							name: "spatialRel",
							read: {
								reader: g.read
							},
							write: {
								allowNull: !1,
								writer: g.write,
								overridePolicy() {
									return {
										enabled: m.isSome(this.geometry)
									}
								}
							}
						}
					})], k.prototype, "spatialRelationship", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							write: {
								overridePolicy(n) {
									return {
										enabled: null != n && null != this.geometry
									}
								}
							}
						}
					})], k.prototype, "distance", void 0);
					b.__decorate([f.property({
							type: [Number],
							json: {
								write: !0
							}
						})], k.prototype, "objectIds",
						void 0);
					b.__decorate([f.property({
						type: d.apiValues,
						json: {
							read: d.read,
							write: {
								writer: d.write,
								overridePolicy(n) {
									return {
										enabled: null != n && null != this.geometry
									}
								}
							}
						}
					})], k.prototype, "units", void 0);
					b.__decorate([f.property({
						type: e,
						json: {
							write: !0
						}
					})], k.prototype, "timeExtent", void 0);
					return k = p = b.__decorate([l.subclass("esri.layers.support.FeatureFilter")], k)
				})
		},
		"esri/rest/support/Query": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../TimeExtent ../../core/jsonMap ../../core/JSONSupport ../../core/lang ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/cast ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../core/accessorSupport/ensureType ../../geometry/support/jsonUtils ../../layers/support/source/DataLayerSource ./FullTextSearch ./QuantizationParameters ./StatisticDefinition ../../geometry/SpatialReference ../../geometry/Point".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w) {
					var A;
					const B = new d.JSONMap({
						esriSpatialRelIntersects: "intersects",
						esriSpatialRelContains: "contains",
						esriSpatialRelCrosses: "crosses",
						esriSpatialRelDisjoint: "disjoint",
						esriSpatialRelEnvelopeIntersects: "envelope-intersects",
						esriSpatialRelIndexIntersects: "index-intersects",
						esriSpatialRelOverlaps: "overlaps",
						esriSpatialRelTouches: "touches",
						esriSpatialRelWithin: "within",
						esriSpatialRelRelation: "relation"
					});
					d = new d.JSONMap({
						esriSRUnit_Meter: "meters",
						esriSRUnit_Kilometer: "kilometers",
						esriSRUnit_Foot: "feet",
						esriSRUnit_StatuteMile: "miles",
						esriSRUnit_NauticalMile: "nautical-miles",
						esriSRUnit_USNauticalMile: "us-nautical-miles"
					});
					k = A = function(E) {
						function z(D) {
							D = E.call(this, D) || this;
							D.aggregateIds = null;
							D.cacheHint = void 0;
							D.compactGeometryEnabled = !1;
							D.datumTransformation = null;
							D.defaultSpatialReferenceEnabled = !1;
							D.distance = void 0;
							D.dynamicDataSource = void 0;
							D.formatOf3DObjects = null;
							D.fullText = null;
							D.gdbVersion = null;
							D.geometry = null;
							D.geometryPrecision = void 0;
							D.groupByFieldsForStatistics =
								null;
							D.having = null;
							D.historicMoment = null;
							D.maxAllowableOffset = void 0;
							D.maxRecordCountFactor = 1;
							D.multipatchOption = null;
							D.num = void 0;
							D.objectIds = null;
							D.orderByFields = null;
							D.outFields = null;
							D.outSpatialReference = null;
							D.outStatistics = null;
							D.parameterValues = null;
							D.pixelSize = null;
							D.quantizationParameters = null;
							D.rangeValues = null;
							D.relationParameter = null;
							D.resultType = null;
							D.returnCentroid = !1;
							D.returnDistinctValues = !1;
							D.returnExceededLimitFeatures = !0;
							D.returnGeometry = !1;
							D.returnQueryGeometry = !1;
							D.returnM = void 0;
							D.returnZ = void 0;
							D.sourceSpatialReference = null;
							D.spatialRelationship = "intersects";
							D.start = void 0;
							D.sqlFormat = null;
							D.text = null;
							D.timeExtent = null;
							D.timeReferenceUnknownClient = !1;
							D.units = null;
							D.where = null;
							return D
						}
						a._inheritsLoose(z, E);
						z.from = function(D) {
							return n.ensureClass(A, D)
						};
						var C = z.prototype;
						C.castDatumTransformation = function(D) {
							return "number" === typeof D || "object" === typeof D ? D : null
						};
						C.writeHistoricMoment = function(D, J) {
							J.historicMoment = D && D.getTime()
						};
						C.writeParameterValues = function(D, J) {
							if (D) {
								const K = {};
								for (const H in D) {
									const G = D[H];
									Array.isArray(G) ? K[H] = G.map(F => F instanceof Date ? F.getTime() : F) : K[H] = G instanceof Date ? G.getTime() : G
								}
								J.parameterValues = K
							}
						};
						C.writeStart = function(D, J) {
							J.resultOffset = this.start;
							J.resultRecordCount = this.num || 10;
							J.where = "1\x3d1"
						};
						C.writeWhere = function(D, J) {
							J.where = D || "1\x3d1"
						};
						C.clone = function() {
							return new A(v.clone({
								aggregateIds: this.aggregateIds,
								cacheHint: this.cacheHint,
								compactGeometryEnabled: this.compactGeometryEnabled,
								datumTransformation: this.datumTransformation,
								defaultSpatialReferenceEnabled: this.defaultSpatialReferenceEnabled,
								distance: this.distance,
								fullText: this.fullText,
								gdbVersion: this.gdbVersion,
								geometry: this.geometry,
								geometryPrecision: this.geometryPrecision,
								groupByFieldsForStatistics: this.groupByFieldsForStatistics,
								having: this.having,
								historicMoment: m.isSome(this.historicMoment) ? new Date(this.historicMoment.getTime()) : null,
								maxAllowableOffset: this.maxAllowableOffset,
								maxRecordCountFactor: this.maxRecordCountFactor,
								multipatchOption: this.multipatchOption,
								num: this.num,
								objectIds: this.objectIds,
								orderByFields: this.orderByFields,
								outFields: this.outFields,
								outSpatialReference: this.outSpatialReference,
								outStatistics: this.outStatistics,
								parameterValues: this.parameterValues,
								pixelSize: this.pixelSize,
								quantizationParameters: this.quantizationParameters,
								rangeValues: this.rangeValues,
								relationParameter: this.relationParameter,
								resultType: this.resultType,
								returnDistinctValues: this.returnDistinctValues,
								returnGeometry: this.returnGeometry,
								returnCentroid: this.returnCentroid,
								returnExceededLimitFeatures: this.returnExceededLimitFeatures,
								returnQueryGeometry: this.returnQueryGeometry,
								returnM: this.returnM,
								returnZ: this.returnZ,
								dynamicDataSource: this.dynamicDataSource,
								sourceSpatialReference: this.sourceSpatialReference,
								spatialRelationship: this.spatialRelationship,
								start: this.start,
								sqlFormat: this.sqlFormat,
								text: this.text,
								timeExtent: this.timeExtent,
								timeReferenceUnknownClient: this.timeReferenceUnknownClient,
								units: this.units,
								where: this.where
							}))
						};
						return z
					}(k.JSONSupport);
					k.MAX_MAX_RECORD_COUNT_FACTOR =
						5;
					b.__decorate([f.property({
						json: {
							write: !0
						}
					})], k.prototype, "aggregateIds", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], k.prototype, "cacheHint", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							default: !1,
							write: !0
						}
					})], k.prototype, "compactGeometryEnabled", void 0);
					b.__decorate([f.property({
						json: {
							write: !0
						}
					})], k.prototype, "datumTransformation", void 0);
					b.__decorate([g.cast("datumTransformation")], k.prototype, "castDatumTransformation", null);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							default: !1,
							write: !0
						}
					})], k.prototype, "defaultSpatialReferenceEnabled", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							write: {
								overridePolicy(E) {
									return {
										enabled: 0 < E
									}
								}
							}
						}
					})], k.prototype, "distance", void 0);
					b.__decorate([f.property({
						type: h.DataLayerSource,
						json: {
							write: !0
						}
					})], k.prototype, "dynamicDataSource", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "formatOf3DObjects", void 0);
					b.__decorate([f.property({
						type: [q],
						json: {
							write: {
								enabled: !0,
								overridePolicy() {
									return {
										enabled: m.isSome(this.fullText) &&
											0 < this.fullText.length
									}
								}
							}
						}
					})], k.prototype, "fullText", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "gdbVersion", void 0);
					b.__decorate([f.property({
						types: c.geometryTypes,
						json: {
							read: t.fromJSON,
							write: !0
						}
					})], k.prototype, "geometry", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "geometryPrecision", void 0);
					b.__decorate([f.property({
						type: [String],
						json: {
							write: !0
						}
					})], k.prototype, "groupByFieldsForStatistics", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "having", void 0);
					b.__decorate([f.property({
						type: Date
					})], k.prototype, "historicMoment", void 0);
					b.__decorate([p.writer("historicMoment")], k.prototype, "writeHistoricMoment", null);
					b.__decorate([f.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "maxAllowableOffset", void 0);
					b.__decorate([f.property({
							type: Number,
							cast(E) {
								return 1 > E ? 1 : E > A.MAX_MAX_RECORD_COUNT_FACTOR ? A.MAX_MAX_RECORD_COUNT_FACTOR : E
							},
							json: {
								write: {
									overridePolicy(E) {
										return {
											enabled: 1 < E
										}
									}
								}
							}
						})], k.prototype, "maxRecordCountFactor",
						void 0);
					b.__decorate([f.property({
						type: ["xyFootprint"],
						json: {
							write: !0
						}
					})], k.prototype, "multipatchOption", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							read: {
								source: "resultRecordCount"
							}
						}
					})], k.prototype, "num", void 0);
					b.__decorate([f.property({
						json: {
							write: !0
						}
					})], k.prototype, "objectIds", void 0);
					b.__decorate([f.property({
						type: [String],
						json: {
							write: !0
						}
					})], k.prototype, "orderByFields", void 0);
					b.__decorate([f.property({
						type: [String],
						json: {
							write: !0
						}
					})], k.prototype, "outFields", void 0);
					b.__decorate([f.property({
						type: y,
						json: {
							name: "outSR",
							write: !0
						}
					})], k.prototype, "outSpatialReference", void 0);
					b.__decorate([f.property({
						type: [x],
						json: {
							write: {
								enabled: !0,
								overridePolicy() {
									return {
										enabled: m.isSome(this.outStatistics) && 0 < this.outStatistics.length
									}
								}
							}
						}
					})], k.prototype, "outStatistics", void 0);
					b.__decorate([f.property({
						json: {
							write: !0
						}
					})], k.prototype, "parameterValues", void 0);
					b.__decorate([p.writer("parameterValues")], k.prototype, "writeParameterValues", null);
					b.__decorate([f.property({
							type: w,
							json: {
								write: !0
							}
						})], k.prototype, "pixelSize",
						void 0);
					b.__decorate([f.property({
						type: u,
						json: {
							write: !0
						}
					})], k.prototype, "quantizationParameters", void 0);
					b.__decorate([f.property({
						type: [Object],
						json: {
							write: !0
						}
					})], k.prototype, "rangeValues", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							read: {
								source: "relationParam"
							},
							write: {
								target: "relationParam",
								overridePolicy() {
									return {
										enabled: "relation" === this.spatialRelationship
									}
								}
							}
						}
					})], k.prototype, "relationParameter", void 0);
					b.__decorate([f.property({
							type: String,
							json: {
								write: !0
							}
						})], k.prototype, "resultType",
						void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							default: !1,
							write: !0
						}
					})], k.prototype, "returnCentroid", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							default: !1,
							write: !0
						}
					})], k.prototype, "returnDistinctValues", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							default: !0,
							write: !0
						}
					})], k.prototype, "returnExceededLimitFeatures", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], k.prototype, "returnGeometry", void 0);
					b.__decorate([f.property({
							type: Boolean,
							json: {
								default: !1,
								write: !0
							}
						})],
						k.prototype, "returnQueryGeometry", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							default: !1,
							write: !0
						}
					})], k.prototype, "returnM", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(E) {
									return {
										enabled: E
									}
								}
							}
						}
					})], k.prototype, "returnZ", void 0);
					b.__decorate([f.property({
						type: y,
						json: {
							write: !0
						}
					})], k.prototype, "sourceSpatialReference", void 0);
					b.__decorate([l.enumeration(B, {
						ignoreUnknown: !1,
						name: "spatialRel"
					})], k.prototype, "spatialRelationship", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							read: {
								source: "resultOffset"
							}
						}
					})], k.prototype, "start", void 0);
					b.__decorate([p.writer("start"), p.writer("num")], k.prototype, "writeStart", null);
					b.__decorate([f.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "sqlFormat", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "text", void 0);
					b.__decorate([f.property({
						type: e,
						json: {
							write: !0
						}
					})], k.prototype, "timeExtent", void 0);
					b.__decorate([f.property({
							type: Boolean,
							json: {
								default: !1,
								write: !0
							}
						})], k.prototype, "timeReferenceUnknownClient",
						void 0);
					b.__decorate([l.enumeration(d, {
						ignoreUnknown: !1
					}), f.property({
						json: {
							write: {
								overridePolicy(E) {
									return {
										enabled: !!E && null != this.distance && 0 < this.distance
									}
								}
							}
						}
					})], k.prototype, "units", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							write: {
								overridePolicy(E) {
									return {
										enabled: null != E || null != this.start && 0 < this.start
									}
								}
							}
						}
					})], k.prototype, "where", void 0);
					b.__decorate([p.writer("where")], k.prototype, "writeWhere", null);
					return k = A = b.__decorate([r.subclass("esri.rest.support.Query")], k)
				})
		},
		"esri/layers/support/source/DataLayerSource": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/jsonMap ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/decorators/cast ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/reader ../../../core/accessorSupport/decorators/subclass ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/extensions/serializableProperty/reader ../Field ./MapLayerSource ./QueryTableDataSource ./RasterDataSource ./TableDataSource".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u) {
					function x() {
						B || (B = p.createTypeReader({
							types: y()
						}));
						return B
					}

					function y() {
						E || (E = {
							key: "type",
							base: null,
							typeMap: {
								"data-layer": a.DataLayerSource,
								"map-layer": t.MapLayerSource
							}
						});
						return E
					}
					var w, A;
					e = e.strict()({
						esriLeftInnerJoin: "left-inner-join",
						esriLeftOuterJoin: "left-outer-join"
					});
					a.JoinTableDataSource = w = function(z) {
						function C(J) {
							J = z.call(this, J) || this;
							J.type = "join-table";
							return J
						}
						b._inheritsLoose(C, z);
						var D = C.prototype;
						D.readLeftTableSource = function(J, K,
							H) {
							return x()(J, K, H)
						};
						D.castLeftTableSource = function(J) {
							return r.ensureOneOfType(y(), J)
						};
						D.readRightTableSource = function(J, K, H) {
							return x()(J, K, H)
						};
						D.castRightTableSource = function(J) {
							return r.ensureOneOfType(y(), J)
						};
						D.clone = function() {
							const {
								leftTableKey: J,
								rightTableKey: K,
								leftTableSource: H,
								rightTableSource: G,
								joinType: F
							} = this, L = {
								leftTableKey: J,
								rightTableKey: K,
								leftTableSource: H ? .clone() ? ? void 0,
								rightTableSource: G ? .clone() ? ? void 0,
								joinType: F
							};
							return new w(L)
						};
						return C
					}(d.JSONSupport);
					c.__decorate([f.enumeration({
							joinTable: "join-table"
						})],
						a.JoinTableDataSource.prototype, "type", void 0);
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.JoinTableDataSource.prototype, "leftTableKey", void 0);
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.JoinTableDataSource.prototype, "rightTableKey", void 0);
					c.__decorate([k.property({
						json: {
							write: !0
						}
					})], a.JoinTableDataSource.prototype, "leftTableSource", void 0);
					c.__decorate([g.reader("leftTableSource")], a.JoinTableDataSource.prototype, "readLeftTableSource", null);
					c.__decorate([m.cast("leftTableSource")],
						a.JoinTableDataSource.prototype, "castLeftTableSource", null);
					c.__decorate([k.property({
						json: {
							write: !0
						}
					})], a.JoinTableDataSource.prototype, "rightTableSource", void 0);
					c.__decorate([g.reader("rightTableSource")], a.JoinTableDataSource.prototype, "readRightTableSource", null);
					c.__decorate([m.cast("rightTableSource")], a.JoinTableDataSource.prototype, "castRightTableSource", null);
					c.__decorate([f.enumeration(e)], a.JoinTableDataSource.prototype, "joinType", void 0);
					a.JoinTableDataSource = w = c.__decorate([l.subclass("esri.layers.support.source.JoinTableDataSource")],
						a.JoinTableDataSource);
					let B = null,
						E = null;
					m = {
						key: "type",
						base: null,
						typeMap: {
							"join-table": a.JoinTableDataSource,
							"query-table": h.QueryTableDataSource,
							raster: q.RasterDataSource,
							table: u.TableDataSource
						}
					};
					a.DataLayerSource = A = function(z) {
						function C(D) {
							D = z.call(this, D) || this;
							D.type = "data-layer";
							return D
						}
						b._inheritsLoose(C, z);
						C.prototype.clone = function() {
							const {
								fields: D,
								dataSource: J
							} = this;
							return new A({
								fields: D,
								dataSource: J
							})
						};
						return C
					}(d.JSONSupport);
					c.__decorate([f.enumeration({
							dataLayer: "data-layer"
						})],
						a.DataLayerSource.prototype, "type", void 0);
					c.__decorate([k.property({
						type: [n],
						json: {
							write: !0
						}
					})], a.DataLayerSource.prototype, "fields", void 0);
					c.__decorate([k.property({
						types: m,
						json: {
							write: !0
						}
					})], a.DataLayerSource.prototype, "dataSource", void 0);
					a.DataLayerSource = A = c.__decorate([l.subclass("esri.layers.support.source.DataLayerSource")], a.DataLayerSource);
					a.DataLayerSource.from = r.ensureType(a.DataLayerSource);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/source/MapLayerSource": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m, f) {
				var g;
				a.MapLayerSource = g = function(l) {
					function r(p) {
						p = l.call(this, p) || this;
						p.type =
							"map-layer";
						return p
					}
					b._inheritsLoose(r, l);
					r.prototype.clone = function() {
						const {
							mapLayerId: p,
							gdbVersion: n
						} = this;
						return new g({
							mapLayerId: p,
							gdbVersion: n
						})
					};
					return r
				}(e.JSONSupport);
				c.__decorate([m.enumeration({
					mapLayer: "map-layer"
				})], a.MapLayerSource.prototype, "type", void 0);
				c.__decorate([d.property({
					type: v.Integer,
					json: {
						write: !0
					}
				})], a.MapLayerSource.prototype, "mapLayerId", void 0);
				c.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], a.MapLayerSource.prototype, "gdbVersion", void 0);
				a.MapLayerSource =
					g = c.__decorate([f.subclass("esri.layers.support.source.MapLayerSource")], a.MapLayerSource);
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/source/QueryTableDataSource": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../geometry ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass ../../../geometry/SpatialReference ../../../geometry/support/typeUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					var p;
					a.QueryTableDataSource = p = function(n) {
						function t(h) {
							h = n.call(this, h) || this;
							h.type = "query-table";
							return h
						}
						b._inheritsLoose(t, n);
						t.prototype.clone = function() {
							const {
								workspaceId: h,
								query: q,
								oidFields: u,
								spatialReference: x,
								geometryType: y
							} = this, w = {
								workspaceId: h,
								query: q,
								oidFields: u,
								spatialReference: x ? .clone() ? ? void 0,
								geometryType: y
							};
							return new p(w)
						};
						return t
					}(d.JSONSupport);
					c.__decorate([f.enumeration({
							queryTable: "query-table"
						})], a.QueryTableDataSource.prototype, "type",
						void 0);
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.QueryTableDataSource.prototype, "workspaceId", void 0);
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.QueryTableDataSource.prototype, "query", void 0);
					c.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], a.QueryTableDataSource.prototype, "oidFields", void 0);
					c.__decorate([k.property({
						type: l,
						json: {
							write: !0
						}
					})], a.QueryTableDataSource.prototype, "spatialReference", void 0);
					c.__decorate([f.enumeration(r.featureGeometryTypeKebabDictionary)],
						a.QueryTableDataSource.prototype, "geometryType", void 0);
					a.QueryTableDataSource = p = c.__decorate([g.subclass("esri.layers.support.source.QueryTableDataSource")], a.QueryTableDataSource);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/source/RasterDataSource": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					a.RasterDataSource = g = function(l) {
						function r(p) {
							p = l.call(this, p) || this;
							p.type = "raster";
							return p
						}
						b._inheritsLoose(r, l);
						r.prototype.clone = function() {
							const {
								workspaceId: p,
								dataSourceName: n
							} = this;
							return new g({
								workspaceId: p,
								dataSourceName: n
							})
						};
						return r
					}(e.JSONSupport);
					c.__decorate([m.enumeration({
						raster: "raster"
					})], a.RasterDataSource.prototype, "type", void 0);
					c.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], a.RasterDataSource.prototype, "dataSourceName", void 0);
					c.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], a.RasterDataSource.prototype, "workspaceId", void 0);
					a.RasterDataSource = g = c.__decorate([f.subclass("esri.layers.support.source.RasterDataSource")], a.RasterDataSource);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/source/TableDataSource": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/enumeration ../../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					a.TableDataSource = g = function(l) {
						function r(p) {
							p = l.call(this, p) || this;
							p.type = "table";
							return p
						}
						b._inheritsLoose(r, l);
						r.prototype.clone = function() {
							const {
								workspaceId: p,
								gdbVersion: n,
								dataSourceName: t
							} = this;
							return new g({
								workspaceId: p,
								gdbVersion: n,
								dataSourceName: t
							})
						};
						return r
					}(e.JSONSupport);
					c.__decorate([m.enumeration({
						table: "table"
					})], a.TableDataSource.prototype, "type", void 0);
					c.__decorate([d.property({
							type: String,
							json: {
								write: !0
							}
						})], a.TableDataSource.prototype, "workspaceId",
						void 0);
					c.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], a.TableDataSource.prototype, "gdbVersion", void 0);
					c.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], a.TableDataSource.prototype, "dataSourceName", void 0);
					a.TableDataSource = g = c.__decorate([f.subclass("esri.layers.support.source.TableDataSource")], a.TableDataSource);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/rest/support/FullTextSearch": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					c = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.onFields = null;
							r.operator = null;
							r.searchTerm = null;
							r.searchType = null;
							return r
						}
						a._inheritsLoose(l, g);
						return l
					}(c.ClonableMixin(e.JSONSupport));
					b.__decorate([k.property({
						type: [String],
						json: {
							write: {
								enabled: !0,
								overridePolicy() {
									return {
										enabled: d.isSome(this.onFields) && 0 < this.onFields.length
									}
								}
							}
						}
					})], c.prototype, "onFields", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "operator", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "searchTerm", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "searchType", void 0);
					return c = b.__decorate([f.subclass("esri.rest.support.FullTextSearch")], c)
				})
		},
		"esri/rest/support/QuantizationParameters": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../core/jsonMap ../../core/JSONSupport ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../geometry/Extent".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					c = new e.JSONMap({
						upperLeft: "upper-left",
						lowerLeft: "lower-left"
					});
					d = l = function(r) {
						function p(n) {
							n = r.call(this, n) || this;
							n.extent = null;
							n.mode = "view";
							n.originPosition = "upper-left";
							n.tolerance = 1;
							return n
						}
						a._inheritsLoose(p, r);
						p.prototype.clone = function() {
							return new l(k.clone({
								extent: this.extent,
								mode: this.mode,
								originPosition: this.originPosition,
								tolerance: this.tolerance
							}))
						};
						return p
					}(d.JSONSupport);
					b.__decorate([v.property({
						type: g,
						json: {
							write: {
								overridePolicy() {
									return {
										enabled: "view" ===
											this.mode
									}
								}
							}
						}
					})], d.prototype, "extent", void 0);
					b.__decorate([v.property({
						type: ["view", "edit"],
						json: {
							write: !0
						}
					})], d.prototype, "mode", void 0);
					b.__decorate([v.property({
						type: String,
						json: {
							read: c.read,
							write: c.write
						}
					})], d.prototype, "originPosition", void 0);
					b.__decorate([v.property({
						type: Number,
						json: {
							write: {
								overridePolicy() {
									return {
										enabled: "view" === this.mode
									}
								}
							}
						}
					})], d.prototype, "tolerance", void 0);
					return d = l = b.__decorate([f.subclass("esri.rest.support.QuantizationParameters")], d)
				})
		},
		"esri/rest/support/StatisticDefinition": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					c = new c.JSONMap({
						count: "count",
						sum: "sum",
						min: "min",
						max: "max",
						avg: "avg",
						stddev: "stddev",
						var: "var",
						exceedslimit: "exceedslimit",
						percentile_cont: "percentile-continuous",
						percentile_disc: "percentile-discrete",
						EnvelopeAggregate: "envelope-aggregate",
						CentroidAggregate: "centroid-aggregate",
						ConvexHullAggregate: "convex-hull-aggregate"
					});
					e = g = function(l) {
						function r(n) {
							n = l.call(this, n) || this;
							n.maxPointCount = void 0;
							n.maxRecordCount = void 0;
							n.maxVertexCount = void 0;
							n.onStatisticField =
								null;
							n.outStatisticFieldName = null;
							n.statisticType = null;
							n.statisticParameters = null;
							return n
						}
						a._inheritsLoose(r, l);
						var p = r.prototype;
						p.writeStatisticParameters = function(n, t) {
							if ("percentile-continuous" === this.statisticType || "percentile-discrete" === this.statisticType) t.statisticParameters = d.clone(n)
						};
						p.clone = function() {
							return new g({
								maxPointCount: this.maxPointCount,
								maxRecordCount: this.maxRecordCount,
								maxVertexCount: this.maxVertexCount,
								onStatisticField: this.onStatisticField,
								outStatisticFieldName: this.outStatisticFieldName,
								statisticType: this.statisticType,
								statisticParameters: d.clone(this.statisticParameters)
							})
						};
						return r
					}(e.JSONSupport);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0
						}
					})], e.prototype, "maxPointCount", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0
						}
					})], e.prototype, "maxRecordCount", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0
						}
					})], e.prototype, "maxVertexCount", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "onStatisticField", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "outStatisticFieldName", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							read: {
								source: "statisticType",
								reader: c.read
							},
							write: {
								target: "statisticType",
								writer: c.write
							}
						}
					})], e.prototype, "statisticType", void 0);
					b.__decorate([k.property({
						type: Object
					})], e.prototype, "statisticParameters", void 0);
					b.__decorate([f.writer("statisticParameters")], e.prototype, "writeStatisticParameters", null);
					return e = g = b.__decorate([m.subclass("esri.rest.support.StatisticDefinition")], e)
				})
		},
		"esri/layers/mixins/FeatureLayerBase": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Collection ../../core/lang ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../geometry/Extent ../../geometry/HeightModelInfo ../../geometry/SpatialReference ../support/arcgisLayerUrl ../support/commonProperties ../support/FeatureIndex ../support/featureLayerUtils ../support/GeometryFieldsInfo ../support/LayerFloorInfo ../support/Relationship".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w) {
					a.FeatureLayerBase = A => {
						A = function(B) {
							function E() {
								var C = B.apply(this, arguments) || this;
								C.capabilities = null;
								C.copyright = null;
								C.datesInUnknownTimezone = !1;
								C.displayField = null;
								C.definitionExpression = null;
								C.editFieldsInfo = null;
								C.editingInfo = null;
								C.elevationInfo = null;
								C.floorInfo = null;
								C.fullExtent = null;
								C.gdbVersion = null;
								C.geometryFieldsInfo = null;
								C.geometryType = null;
								C.hasM = void 0;
								C.hasZ = void 0;
								C.heightModelInfo = null;
								C.historicMoment = null;
								C.isTable = !1;
								C.layerId =
									void 0;
								C.minScale = 0;
								C.maxScale = 0;
								C.globalIdField = null;
								C.objectIdField = null;
								C.relationships = null;
								C.sourceJSON = null;
								C.returnM = void 0;
								C.returnZ = void 0;
								C.serviceDefinitionExpression = null;
								C.spatialReference = n.WGS84;
								C.subtypeField = null;
								C.trackIdField = null;
								C.indexes = new(e.ofType(q.FeatureIndex));
								C.userIsAdmin = !1;
								C.version = void 0;
								return C
							}
							b._inheritsLoose(E, B);
							var z = E.prototype;
							z.readCapabilitiesFromService = function(C, D) {
								return u.getFeatureLayerCapabilities(C, D, this.url)
							};
							z.readEditingInfo = function(C, D) {
								({
										editingInfo: C
									} =
									D);
								return C ? {
									lastEditDate: null != C.lastEditDate ? new Date(C.lastEditDate) : null
								} : null
							};
							z.readIsTableFromService = function(C, D) {
								return "Table" === D.type
							};
							z.readMinScale = function(C, D) {
								return D.effectiveMinScale || C || 0
							};
							z.readMaxScale = function(C, D) {
								return D.effectiveMaxScale || C || 0
							};
							z.readGlobalIdFieldFromService = function(C, D) {
								return u.readGlobalIdField(D)
							};
							z.readObjectIdFieldFromService = function(C, D) {
								return u.readObjectIdField(D)
							};
							z.readServiceDefinitionExpression = function(C, D) {
								return D.definitionQuery || D.definitionExpression
							};
							z.writeUrl = function(C, D, J, K) {
								t.writeUrlWithLayerId(this, C, null, D, K)
							};
							z.readVersion = function(C, D) {
								return u.readVersion(D)
							};
							b._createClass(E, [{
								key: "url",
								set: function(C) {
									C = t.sanitizeUrlWithLayerId({
										layer: this,
										url: C,
										nonStandardUrlAllowed: !0,
										logger: k.getLogger(this.declaredClass)
									});
									this._set("url", C.url);
									null != C.layerId && this._set("layerId", C.layerId)
								}
							}]);
							return E
						}(A);
						c.__decorate([v.property({
								readOnly: !0,
								json: {
									read: !1,
									origins: {
										service: {
											read: {
												source: "advancedQueryCapabilities allowGeometryUpdates allowUpdateWithoutMValues archivingInfo capabilities datesInUnknownTimezone hasAttachments hasM hasZ maxRecordCount maxRecordCountFactor ownershipBasedAccessControlForFeatures standardMaxRecordCount supportedQueryFormats supportsAdvancedQueries supportsApplyEditsWithGlobalIds supportsAttachmentsByUploadId supportsAttachmentsResizing supportsCalculate supportsCoordinatesQuantization supportsExceedsLimitStatistics supportsFieldDescriptionProperty supportsQuantizationEditMode supportsRollbackOnFailureParameter supportsStatistics supportsTruncate supportsValidateSql tileMaxRecordCount useStandardizedQueries".split(" ")
											}
										}
									}
								}
							})],
							A.prototype, "capabilities", void 0);
						c.__decorate([f.reader("service", "capabilities")], A.prototype, "readCapabilitiesFromService", null);
						c.__decorate([v.property({
							type: String,
							json: {
								origins: {
									service: {
										read: {
											source: "copyrightText"
										}
									}
								}
							}
						})], A.prototype, "copyright", void 0);
						c.__decorate([v.property({
							type: Boolean
						})], A.prototype, "datesInUnknownTimezone", void 0);
						c.__decorate([v.property({
							type: String,
							json: {
								origins: {
									service: {
										read: {
											source: "displayField"
										}
									}
								}
							}
						})], A.prototype, "displayField", void 0);
						c.__decorate([v.property({
							type: String,
							json: {
								origins: {
									service: {
										read: !1,
										write: !1
									}
								},
								name: "layerDefinition.definitionExpression",
								write: {
									enabled: !0,
									allowNull: !0
								}
							}
						})], A.prototype, "definitionExpression", void 0);
						c.__decorate([v.property({
							readOnly: !0
						})], A.prototype, "editFieldsInfo", void 0);
						c.__decorate([v.property({
							readOnly: !0
						})], A.prototype, "editingInfo", void 0);
						c.__decorate([f.reader("editingInfo")], A.prototype, "readEditingInfo", null);
						c.__decorate([v.property((() => {
							const B = d.clone(h.elevationInfo),
								E = B.json.origins;
							E["web-map"] = {
								read: !1,
								write: !1
							};
							E["portal-item"] = {
								read: !1,
								write: !1
							};
							return B
						})())], A.prototype, "elevationInfo", void 0);
						c.__decorate([v.property({
							type: y,
							json: {
								read: {
									source: "layerDefinition.floorInfo"
								},
								write: {
									target: "layerDefinition.floorInfo"
								}
							}
						})], A.prototype, "floorInfo", void 0);
						c.__decorate([v.property({
							type: r,
							json: {
								origins: {
									service: {
										read: {
											source: "extent"
										}
									}
								}
							}
						})], A.prototype, "fullExtent", void 0);
						c.__decorate([v.property()], A.prototype, "gdbVersion", void 0);
						c.__decorate([v.property({
								readOnly: !0,
								type: x,
								json: {
									read: {
										source: "geometryProperties"
									}
								}
							})],
							A.prototype, "geometryFieldsInfo", void 0);
						c.__decorate([v.property({
							type: "point polygon polyline multipoint multipatch mesh".split(" "),
							json: {
								origins: {
									service: {
										read: u.geometryTypeKebabDict.read
									}
								}
							}
						})], A.prototype, "geometryType", void 0);
						c.__decorate([v.property({
							type: Boolean,
							json: {
								origins: {
									service: {
										read: !0
									}
								}
							}
						})], A.prototype, "hasM", void 0);
						c.__decorate([v.property({
							type: Boolean,
							json: {
								origins: {
									service: {
										read: !0
									}
								}
							}
						})], A.prototype, "hasZ", void 0);
						c.__decorate([v.property({
								readOnly: !0,
								type: p
							})], A.prototype,
							"heightModelInfo", void 0);
						c.__decorate([v.property({
							type: Date
						})], A.prototype, "historicMoment", void 0);
						c.__decorate([v.property({
							readOnly: !0
						})], A.prototype, "isTable", void 0);
						c.__decorate([f.reader("service", "isTable", ["type"])], A.prototype, "readIsTableFromService", null);
						c.__decorate([v.property({
							type: Number,
							json: {
								origins: {
									service: {
										read: {
											source: "id"
										}
									},
									"portal-item": {
										read: !1,
										write: {
											target: "id"
										}
									}
								},
								read: !1
							}
						})], A.prototype, "layerId", void 0);
						c.__decorate([v.property(h.minScale)], A.prototype, "minScale", void 0);
						c.__decorate([f.reader("service", "minScale", ["minScale", "effectiveMinScale"])], A.prototype, "readMinScale", null);
						c.__decorate([v.property(h.maxScale)], A.prototype, "maxScale", void 0);
						c.__decorate([f.reader("service", "maxScale", ["maxScale", "effectiveMaxScale"])], A.prototype, "readMaxScale", null);
						c.__decorate([v.property({
							type: String
						})], A.prototype, "globalIdField", void 0);
						c.__decorate([f.reader("service", "globalIdField", ["globalIdField", "fields"])], A.prototype, "readGlobalIdFieldFromService", null);
						c.__decorate([v.property({
								type: String
							})],
							A.prototype, "objectIdField", void 0);
						c.__decorate([f.reader("service", "objectIdField", ["objectIdField", "fields"])], A.prototype, "readObjectIdFieldFromService", null);
						c.__decorate([v.property({
							type: [w],
							readOnly: !0
						})], A.prototype, "relationships", void 0);
						c.__decorate([v.property()], A.prototype, "sourceJSON", void 0);
						c.__decorate([v.property({
							type: Boolean
						})], A.prototype, "returnM", void 0);
						c.__decorate([v.property({
							type: Boolean
						})], A.prototype, "returnZ", void 0);
						c.__decorate([v.property({
								readOnly: !0
							})], A.prototype,
							"serviceDefinitionExpression", void 0);
						c.__decorate([f.reader("service", "serviceDefinitionExpression", ["definitionQuery", "definitionExpression"])], A.prototype, "readServiceDefinitionExpression", null);
						c.__decorate([v.property({
							type: n,
							json: {
								origins: {
									service: {
										read: {
											source: "extent.spatialReference"
										}
									}
								}
							}
						})], A.prototype, "spatialReference", void 0);
						c.__decorate([v.property({
							type: String,
							readOnly: !0,
							json: {
								origins: {
									service: {
										read: !0
									}
								}
							}
						})], A.prototype, "subtypeField", void 0);
						c.__decorate([v.property({
							type: String,
							json: {
								read: {
									source: "timeInfo.trackIdField"
								}
							}
						})], A.prototype, "trackIdField", void 0);
						c.__decorate([v.property({
							readOnly: !0,
							json: {
								write: !1
							}
						})], A.prototype, "serverGens", void 0);
						c.__decorate([v.property({
							type: e.ofType(q.FeatureIndex),
							readOnly: !0
						})], A.prototype, "indexes", void 0);
						c.__decorate([v.property(h.url)], A.prototype, "url", null);
						c.__decorate([l.writer("url")], A.prototype, "writeUrl", null);
						c.__decorate([v.property({
							readOnly: !0
						})], A.prototype, "userIsAdmin", void 0);
						c.__decorate([v.property({
							json: {
								origins: {
									service: {
										read: !0
									}
								},
								read: !1
							}
						})], A.prototype, "version", void 0);
						c.__decorate([f.reader("service", "version", "currentVersion capabilities drawingInfo hasAttachments htmlPopupType relationships timeInfo typeIdField types".split(" "))], A.prototype, "readVersion", null);
						return A = c.__decorate([g.subclass("esri.layers.mixins.FeatureLayerBase")], A)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/geometry/HeightModelInfo": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/arrayUtils ../core/jsonMap ../core/JSONSupport ../core/unitUtils ../core/Warning ../core/accessorSupport/decorators/property ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/reader ../core/accessorSupport/decorators/subclass ../core/accessorSupport/decorators/writer".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					function p(q, u) {
						return new v("height-unit:unsupported", `Height unit of value '${q}' is not supported`, u)
					}
					var n;
					const t = e.strict()({
						orthometric: "gravity-related-height",
						gravity_related_height: "gravity-related-height",
						ellipsoidal: "ellipsoidal"
					});
					f = t.jsonValues.slice();
					c.removeUnordered(f, "orthometric");
					const h = e.strict()({
						meter: "meters",
						foot: "feet",
						"us-foot": "us-feet",
						"clarke-foot": "clarke-feet",
						"clarke-yard": "clarke-yards",
						"clarke-link": "clarke-links",
						"sears-yard": "sears-yards",
						"sears-foot": "sears-feet",
						"sears-chain": "sears-chains",
						"benoit-1895-b-chain": "benoit-1895-b-chains",
						"indian-yard": "indian-yards",
						"indian-1937-yard": "indian-1937-yards",
						"gold-coast-foot": "gold-coast-feet",
						"sears-1922-truncated-chain": "sears-1922-truncated-chains",
						"50-kilometers": "50-kilometers",
						"150-kilometers": "150-kilometers"
					});
					c = n = function(q) {
						function u(y) {
							y = q.call(this, y) || this;
							y.heightModel = "gravity-related-height";
							y.heightUnit = "meters";
							y.vertCRS = null;
							return y
						}
						a._inheritsLoose(u, q);
						var x = u.prototype;
						x.writeHeightModel = function(y, w, A) {
							return t.write(y, w, A)
						};
						x.readHeightModel = function(y, w, A) {
							if (w = t.read(y)) return w;
							if (A && A.messages) {
								w = A.messages;
								var B = w.push;
								y = new v("height-model:unsupported", `Height model of value '${y}' is not supported`, {
									context: A
								});
								B.call(w, y)
							}
							return null
						};
						x.readHeightUnit = function(y, w, A) {
							if (w = h.read(y)) return w;
							A && A.messages && A.messages.push(p(y, {
								context: A
							}));
							return null
						};
						x.readHeightUnitService = function(y, w, A) {
							if (w = k.unitFromRESTJSON(y) || h.read(y)) return w;
							A && A.messages &&
								A.messages.push(p(y, {
									context: A
								}));
							return null
						};
						x.readVertCRS = function(y, w) {
							return w.vertCRS || w.ellipsoid || w.geoid
						};
						x.clone = function() {
							return new n({
								heightModel: this.heightModel,
								heightUnit: this.heightUnit,
								vertCRS: this.vertCRS
							})
						};
						x.equals = function(y) {
							return y ? this === y ? !0 : this.heightModel === y.heightModel && this.heightUnit === y.heightUnit && this.vertCRS === y.vertCRS : !1
						};
						u.deriveUnitFromSR = function(y, w) {
							w = k.getVerticalUnitStringForSR(w);
							return new n({
								heightModel: y.heightModel,
								heightUnit: w,
								vertCRS: y.vertCRS
							})
						};
						x.write = function(y, w) {
							w = {
								origin: "web-scene",
								...w
							};
							return q.prototype.write.call(this, y, w)
						};
						u.fromJSON = function(y) {
							if (!y) return null;
							const w = new n;
							w.read(y, {
								origin: "web-scene"
							});
							return w
						};
						return u
					}(d.JSONSupport);
					b.__decorate([m.property({
						type: t.apiValues,
						constructOnly: !0,
						json: {
							origins: {
								"web-scene": {
									type: f,
									default: "ellipsoidal"
								}
							}
						}
					})], c.prototype, "heightModel", void 0);
					b.__decorate([r.writer("web-scene", "heightModel")], c.prototype, "writeHeightModel", null);
					b.__decorate([g.reader(["web-scene", "service"],
						"heightModel")], c.prototype, "readHeightModel", null);
					b.__decorate([m.property({
						type: h.apiValues,
						constructOnly: !0,
						json: {
							origins: {
								"web-scene": {
									type: h.jsonValues,
									write: h.write
								}
							}
						}
					})], c.prototype, "heightUnit", void 0);
					b.__decorate([g.reader("web-scene", "heightUnit")], c.prototype, "readHeightUnit", null);
					b.__decorate([g.reader("service", "heightUnit")], c.prototype, "readHeightUnitService", null);
					b.__decorate([m.property({
							type: String,
							constructOnly: !0,
							json: {
								origins: {
									"web-scene": {
										write: !0
									}
								}
							}
						})], c.prototype, "vertCRS",
						void 0);
					b.__decorate([g.reader("service", "vertCRS", ["vertCRS", "ellipsoid", "geoid"])], c.prototype, "readVertCRS", null);
					return c = n = b.__decorate([l.subclass("esri.geometry.HeightModelInfo")], c)
				})
		},
		"esri/layers/support/FeatureIndex": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					a.FeatureIndex = function(g) {
						function l(r) {
							return g.call(this, r) || this
						}
						b._inheritsLoose(l, g);
						return l
					}(e.ClonableMixin(d.JSONSupport));
					c.__decorate([k.property({
						constructOnly: !0,
						json: {
							write: !0
						}
					})], a.FeatureIndex.prototype, "name", void 0);
					c.__decorate([k.property({
						constructOnly: !0,
						json: {
							write: !0
						}
					})], a.FeatureIndex.prototype, "fields", void 0);
					c.__decorate([k.property({
						constructOnly: !0,
						json: {
							write: !0
						}
					})], a.FeatureIndex.prototype, "isAscending", void 0);
					c.__decorate([k.property({
						constructOnly: !0,
						json: {
							write: !0
						}
					})], a.FeatureIndex.prototype, "indexType", void 0);
					c.__decorate([k.property({
						constructOnly: !0,
						json: {
							write: !0
						}
					})], a.FeatureIndex.prototype, "isUnique", void 0);
					c.__decorate([k.property({
						constructOnly: !0,
						json: {
							write: !0
						}
					})], a.FeatureIndex.prototype, "description", void 0);
					a.FeatureIndex = c.__decorate([f.subclass("esri.layers.support.FeatureIndex")], a.FeatureIndex);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/featureLayerUtils": function() {
			define("require exports ../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/has ../../core/jsonMap ../../core/maybe ../../core/sql ./arcgisLayerUrl ../../rest/support/AttachmentQuery ../../rest/support/Query ../../rest/support/RelationshipQuery".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					function p(V, U, W) {
						return !(V && V.hasOwnProperty(U) ? !V[U] : !W)
					}

					function n(V, U, W) {
						return V && V.hasOwnProperty(U) ? V[U] : W
					}

					function t(V) {
						V = V ? .supportedSpatialAggregationStatistics ? .map(U => U.toLowerCase());
						return {
							envelope: !!V ? .includes("envelopeaggregate"),
							centroid: !!V ? .includes("centroidaggregate"),
							convexHull: !!V ? .includes("convexhullaggregate")
						}
					}

					function h(V, U) {
						return !!V ? .supportedOperationsWithCacheHint ? .map(W => W.toLowerCase()) ? .includes(U.toLowerCase())
					}

					function q(V) {
						const U =
							V.attachmentProperties,
							W = {
								supportsName: !1,
								supportsSize: !1,
								supportsContentType: !1,
								supportsKeywords: !1,
								supportsExifInfo: !1,
								supportsCacheHint: h(V.advancedQueryCapabilities, "queryAttachments"),
								supportsResize: p(V, "supportsAttachmentsResizing", !1)
							};
						U && Array.isArray(U) && U.forEach(M => {
							const T = R[M.name];
							T && (W[T] = !!M.isEnabled)
						});
						return W
					}

					function u(V, U, W) {
						V = V ? V.toLowerCase()
							.split(",")
							.map(Ka => Ka.trim()) : [];
						W = W ? f.parse(W) : null;
						W = V.includes(v.isSome(W) && "MapServer" === W.serverType ? "data" : "query");
						const M = V.includes("editing") &&
							!U.datesInUnknownTimezone;
						let T = M && V.includes("create"),
							Z = M && V.includes("delete"),
							oa = M && V.includes("update");
						const qa = V.includes("changetracking"),
							Aa = U.advancedQueryCapabilities;
						!M || T || Z || oa || (T = Z = oa = !0);
						return {
							supportsCalculate: p(U, "supportsCalculate", !1),
							supportsTruncate: p(U, "supportsTruncate", !1),
							supportsValidateSql: p(U, "supportsValidateSql", !1),
							supportsAdd: T,
							supportsDelete: Z,
							supportsEditing: M,
							supportsChangeTracking: qa,
							supportsQuery: W,
							supportsQueryAnalytics: p(Aa, "supportsQueryAnalytic", !1),
							supportsQueryAttachments: p(Aa,
								"supportsQueryAttachments", !1),
							supportsQueryTopFeatures: p(Aa, "supportsTopFeaturesQuery", !1),
							supportsResizeAttachments: p(U, "supportsAttachmentsResizing", !1),
							supportsSync: V.includes("sync"),
							supportsUpdate: oa,
							supportsExceedsLimitStatistics: p(U, "supportsExceedsLimitStatistics", !1)
						}
					}

					function x(V, U) {
						const W = V.advancedQueryCapabilities,
							M = V.ownershipBasedAccessControlForFeatures,
							T = V.archivingInfo;
						var Z = L(V),
							oa = U ? .includes("MapServer");
						Z = !d("mapserver-pbf-enabled") && oa && 10.81 > (Z ? ? 0);
						U = f.isHostedAgolService(U);
						oa = (V.supportedQueryFormats || "")
							.split(",")
							.reduce((qa, Aa) => {
								(Aa = Aa.toLowerCase()
									.trim()) && qa.add(Aa);
								return qa
							}, new Set);
						return {
							supportsStatistics: p(W, "supportsStatistics", V.supportsStatistics),
							supportsPercentileStatistics: p(W, "supportsPercentileStatistics", !1),
							supportsSpatialAggregationStatistics: p(W, "supportsSpatialAggregationStatistics", !1),
							supportedSpatialAggregationStatistics: t(W),
							supportsCentroid: p(W, "supportsReturningGeometryCentroid", !1),
							supportsDistance: p(W, "supportsQueryWithDistance", !1),
							supportsDistinct: p(W, "supportsDistinct", V.supportsAdvancedQueries),
							supportsExtent: p(W, "supportsReturningQueryExtent", !1),
							supportsGeometryProperties: p(W, "supportsReturningGeometryProperties", !1),
							supportsHavingClause: p(W, "supportsHavingClause", !1),
							supportsOrderBy: p(W, "supportsOrderBy", V.supportsAdvancedQueries),
							supportsPagination: p(W, "supportsPagination", !1),
							supportsQuantization: p(V, "supportsCoordinatesQuantization", !1),
							supportsQuantizationEditMode: p(V, "supportsQuantizationEditMode", !1),
							supportsQueryGeometry: p(V,
								"supportsReturningQueryGeometry", !1),
							supportsResultType: p(W, "supportsQueryWithResultType", !1),
							supportsMaxRecordCountFactor: p(W, "supportsMaxRecordCountFactor", !1),
							supportsSqlExpression: p(W, "supportsSqlExpression", !1),
							supportsStandardizedQueriesOnly: p(V, "useStandardizedQueries", !1),
							supportsTopFeaturesQuery: p(W, "supportsTopFeaturesQuery", !1),
							supportsQueryByOthers: p(M, "allowOthersToQuery", !0),
							supportsHistoricMoment: p(T, "supportsQueryWithHistoricMoment", !1),
							supportsFormatPBF: !Z && oa.has("pbf"),
							supportsDisjointSpatialRelationship: p(W,
								"supportsDisjointSpatialRel", !1),
							supportsCacheHint: p(W, "supportsQueryWithCacheHint", !1) || h(W, "query"),
							supportsDefaultSpatialReference: p(W, "supportsDefaultSR", !1),
							supportsCompactGeometry: U,
							supportsFullTextSearch: p(W, "supportsFullTextSearch", !1),
							maxRecordCountFactor: n(V, "maxRecordCountFactor", void 0),
							maxRecordCount: n(V, "maxRecordCount", void 0),
							standardMaxRecordCount: n(V, "standardMaxRecordCount", void 0),
							tileMaxRecordCount: n(V, "tileMaxRecordCount", void 0)
						}
					}

					function y() {
						y = c._asyncToGenerator(function*(V,
							U, W, M) {
							const {
								source: T
							} = yield V.load();
							yield w(V, U, M);
							if (!T.addAttachment) throw new e(M, "Layer source does not support addAttachment capability");
							return T.addAttachment(U, W)
						});
						return y.apply(this, arguments)
					}

					function w(V, U, W) {
						const {
							attributes: M
						} = U, {
							objectIdField: T
						} = V;
						return V.get("capabilities.data.supportsAttachment") ? U ? M ? T && M[T] ? Promise.resolve() : Promise.reject(new e(W, `feature is missing the identifying attribute ${T}`)) : Promise.reject(new e(W, "'attributes' are required on a feature to query attachments")) :
							Promise.reject(new e(W, "A feature is required to add/delete/update attachments")) : Promise.reject(new e(W, "this layer doesn't support attachments"))
					}

					function A() {
						A = c._asyncToGenerator(function*(V, U, W, M, T) {
							const {
								source: Z
							} = yield V.load();
							yield w(V, U, T);
							if (!Z.updateAttachment) throw new e(T, "Layer source does not support updateAttachment capability");
							return Z.updateAttachment(U, W, M)
						});
						return A.apply(this, arguments)
					}

					function B() {
						B = c._asyncToGenerator(function*(V, U, W) {
							const M = yield new Promise((T, Z) => a(["../graphics/editingSupport"],
								T, Z));
							V = yield V.load();
							return M.applyEdits(V, V.source, U, W)
						});
						return B.apply(this, arguments)
					}

					function E() {
						E = c._asyncToGenerator(function*(V, U, W, M) {
							const {
								source: T
							} = yield V.load();
							yield w(V, U, M);
							if (!T.deleteAttachments) throw new e(M, "Layer source does not support deleteAttachments capability");
							return T.deleteAttachments(U, W)
						});
						return E.apply(this, arguments)
					}

					function z() {
						z = c._asyncToGenerator(function*(V, U, W) {
							({
								source: V
							} = yield V.load({
								signal: U ? .signal
							}));
							if (!V.fetchRecomputedExtents) throw new e(W, "Layer source does not support fetchUpdates capability");
							return V.fetchRecomputedExtents(U)
						});
						return z.apply(this, arguments)
					}

					function C() {
						C = c._asyncToGenerator(function*(V, U, W, M) {
							U = g.from(U);
							const {
								source: T,
								capabilities: Z
							} = yield V.load();
							if (!Z ? .data ? .supportsAttachment) throw new e(M, "this layer doesn't support attachments");
							const {
								attachmentTypes: oa,
								objectIds: qa,
								globalIds: Aa,
								num: Ka,
								size: da,
								start: ja,
								where: sa
							} = U;
							if (!Z ? .operations ? .supportsQueryAttachments) {
								V = oa && oa.length;
								W = Aa && Aa.length;
								const I = da && da.length;
								if (qa && 1 < qa.length || V || W || I || Ka || ja || sa) throw new e(M,
									"when 'supportsQueryAttachments' is false, only objectIds of length 1 are supported", U);
							}
							if (!qa ? .length && !sa) throw new e(M, "'objectIds' or 'where' are required to perform attachment query", U);
							if (!T.queryAttachments) throw new e(M, "Layer source does not support queryAttachments capability", U);
							return T.queryAttachments(U)
						});
						return C.apply(this, arguments)
					}

					function D() {
						D = c._asyncToGenerator(function*(V, U, W, M) {
							const {
								source: T
							} = yield V.load();
							if (!T.queryObjectIds) throw new e(M, "Layer source does not support queryObjectIds capability");
							return T.queryObjectIds(l.from(U) ? ? V.createQuery(), W)
						});
						return D.apply(this, arguments)
					}

					function J() {
						J = c._asyncToGenerator(function*(V, U, W, M) {
							const {
								source: T
							} = yield V.load();
							if (!T.queryFeatureCount) throw new e(M, "Layer source does not support queryFeatureCount capability");
							return T.queryFeatureCount(l.from(U) ? ? V.createQuery(), W)
						});
						return J.apply(this, arguments)
					}

					function K() {
						K = c._asyncToGenerator(function*(V, U, W, M) {
							const {
								source: T
							} = yield V.load();
							if (!T.queryExtent) throw new e(M, "Layer source does not support queryExtent capability");
							return T.queryExtent(l.from(U) ? ? V.createQuery(), W)
						});
						return K.apply(this, arguments)
					}

					function H() {
						H = c._asyncToGenerator(function*(V, U, W, M) {
							({
								source: V
							} = yield V.load());
							if (!V.queryRelatedFeatures) throw new e(M, "Layer source does not support queryRelatedFeatures capability");
							return V.queryRelatedFeatures(r.from(U), W)
						});
						return H.apply(this, arguments)
					}

					function G() {
						G = c._asyncToGenerator(function*(V, U, W, M) {
							({
								source: V
							} = yield V.load());
							if (!V.queryRelatedFeaturesCount) throw new e(M, "Layer source does not support queryRelatedFeaturesCount capability");
							return V.queryRelatedFeaturesCount(r.from(U), W)
						});
						return G.apply(this, arguments)
					}

					function F() {
						F = c._asyncToGenerator(function*(V) {
							const U = V.source;
							if (U ? .refresh) try {
								const {
									dataChanged: W,
									updates: M
								} = yield U.refresh();
								v.isSome(M) && (V.sourceJSON = {
									...V.sourceJSON,
									...M
								}, V.read(M, {
									origin: "service",
									url: V.parsedUrl
								}));
								if (W) return !0
							} catch {}
							if (V.definitionExpression) try {
								return (yield m.parseWhereClause(V.definitionExpression, V.fieldsIndex))
									.hasDateFunctions
							} catch {}
							return !1
						});
						return F.apply(this, arguments)
					}

					function L(V) {
						return V.currentVersion ?
							V.currentVersion : V.hasOwnProperty("capabilities") || V.hasOwnProperty("drawingInfo") || V.hasOwnProperty("hasAttachments") || V.hasOwnProperty("htmlPopupType") || V.hasOwnProperty("relationships") || V.hasOwnProperty("timeInfo") || V.hasOwnProperty("typeIdField") || V.hasOwnProperty("types") ? 10 : 9.3
					}
					k = new k.JSONMap({
						esriGeometryPoint: "point",
						esriGeometryMultipoint: "multipoint",
						esriGeometryPolyline: "polyline",
						esriGeometryPolygon: "polygon",
						esriGeometryMultiPatch: "multipatch"
					});
					const R = {
						name: "supportsName",
						size: "supportsSize",
						contentType: "supportsContentType",
						keywords: "supportsKeywords",
						exifInfo: "supportsExifInfo"
					};
					b.addAttachment = function(V, U, W, M) {
						return y.apply(this, arguments)
					};
					b.applyEdits = function(V, U, W) {
						return B.apply(this, arguments)
					};
					b.createQuery = function(V) {
						const U = new l,
							W = V.get("capabilities.data"),
							M = V.get("capabilities.query");
						U.historicMoment = V.historicMoment;
						U.gdbVersion = V.gdbVersion;
						U.returnGeometry = !0;
						M && (U.compactGeometryEnabled = M.supportsCompactGeometry, U.defaultSpatialReferenceEnabled = M.supportsDefaultSpatialReference);
						W && (W.supportsZ && null != V.returnZ && (U.returnZ = V.returnZ), W.supportsM && null != V.returnM && (U.returnM = V.returnM));
						U.outFields = ["*"];
						const {
							timeOffset: T,
							timeExtent: Z
						} = V;
						U.timeExtent = null != T && null != Z ? Z.offset(-T.value, T.unit) : Z || null;
						U.multipatchOption = "multipatch" === V.geometryType ? "xyFootprint" : null;
						return U
					};
					b.deleteAttachments = function(V, U, W, M) {
						return E.apply(this, arguments)
					};
					b.fetchRecomputedExtents = function(V, U, W) {
						return z.apply(this, arguments)
					};
					b.geometryTypeKebabDict = k;
					b.getFeatureLayerCapabilities =
						function(V, U, W) {
							var M = {
									supportsCacheHint: h(U.advancedQueryCapabilities, "queryAnalytics")
								},
								T = q(U);
							var Z = {
								isVersioned: p(U, "isDataVersioned", !1),
								supportsAttachment: p(U, "hasAttachments", !1),
								supportsM: p(U, "hasM", !1),
								supportsZ: p(U, "hasZ", !1)
							};
							var oa = {
								supportsAdvancedFieldProperties: p(U, "supportsFieldDescriptionProperty", !1)
							};
							V = u(U.capabilities || V, U, W);
							W = x(U, W);
							var qa = U.advancedQueryCapabilities;
							var Aa = p(qa, "supportsAdvancedQueryRelated", !1);
							qa = {
								supportsPagination: p(qa, "supportsQueryRelatedPagination", !1),
								supportsCount: Aa,
								supportsOrderBy: Aa,
								supportsCacheHint: h(qa, "queryRelated")
							};
							Aa = {
								supportsCacheHint: h(U.advancedQueryCapabilities, "queryTopFilter")
							};
							const Ka = U.ownershipBasedAccessControlForFeatures;
							U = {
								supportsGeometryUpdate: p(U, "allowGeometryUpdates", !0),
								supportsGlobalId: p(U, "supportsApplyEditsWithGlobalIds", !1),
								supportsReturnServiceEditsInSourceSpatialReference: p(U, "supportsReturnServiceEditsInSourceSR", !1),
								supportsRollbackOnFailure: p(U, "supportsRollbackOnFailureParameter", !1),
								supportsUpdateWithoutM: p(U,
									"allowUpdateWithoutMValues", !1),
								supportsUploadWithItemId: p(U, "supportsAttachmentsByUploadId", !1),
								supportsDeleteByAnonymous: p(Ka, "allowAnonymousToDelete", !0),
								supportsDeleteByOthers: p(Ka, "allowOthersToDelete", !0),
								supportsUpdateByAnonymous: p(Ka, "allowAnonymousToUpdate", !0),
								supportsUpdateByOthers: p(Ka, "allowOthersToUpdate", !0)
							};
							return {
								analytics: M,
								attachment: T,
								data: Z,
								metadata: oa,
								operations: V,
								query: W,
								queryRelated: qa,
								queryTopFeatures: Aa,
								editing: U
							}
						};
					b.hasDataChanged = function(V) {
						return F.apply(this, arguments)
					};
					b.queryAttachments = function(V, U, W, M) {
						return C.apply(this, arguments)
					};
					b.queryExtent = function(V, U, W, M) {
						return K.apply(this, arguments)
					};
					b.queryFeatureCount = function(V, U, W, M) {
						return J.apply(this, arguments)
					};
					b.queryObjectIds = function(V, U, W, M) {
						return D.apply(this, arguments)
					};
					b.queryRelatedFeatures = function(V, U, W, M) {
						return H.apply(this, arguments)
					};
					b.queryRelatedFeaturesCount = function(V, U, W, M) {
						return G.apply(this, arguments)
					};
					b.readGlobalIdField = function(V) {
						const {
							globalIdField: U,
							fields: W
						} = V;
						if (U) return U;
						if (W)
							for (const M of W)
								if ("esriFieldTypeGlobalID" === M.type) return M.name
					};
					b.readObjectIdField = function(V) {
						const {
							objectIdField: U,
							fields: W
						} = V;
						if (U) return U;
						if (W)
							for (const M of W)
								if ("esriFieldTypeOID" === M.type) return M.name
					};
					b.readVersion = L;
					b.updateAttachment = function(V, U, W, M, T) {
						return A.apply(this, arguments)
					};
					Object.defineProperties(b, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/rest/support/AttachmentQuery": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					c = f = function(g) {
						function l(p) {
							p = g.call(this, p) || this;
							p.attachmentTypes = null;
							p.attachmentsWhere = null;
							p.cacheHint = void 0;
							p.keywords = null;
							p.globalIds = null;
							p.name = null;
							p.num = null;
							p.objectIds = null;
							p.returnMetadata = !1;
							p.size = null;
							p.start = null;
							p.where = null;
							return p
						}
						a._inheritsLoose(l, g);
						var r = l.prototype;
						r.writeStart = function(p, n) {
							n.resultOffset = this.start;
							n.resultRecordCount = this.num || 10
						};
						r.clone = function() {
							return new f(e.clone({
								attachmentTypes: this.attachmentTypes,
								attachmentsWhere: this.attachmentsWhere,
								cacheHint: this.cacheHint,
								keywords: this.keywords,
								where: this.where,
								globalIds: this.globalIds,
								name: this.name,
								num: this.num,
								objectIds: this.objectIds,
								returnMetadata: this.returnMetadata,
								size: this.size,
								start: this.start
							}))
						};
						return l
					}(c.JSONSupport);
					b.__decorate([d.property({
						type: [String],
						json: {
							write: !0
						}
					})], c.prototype, "attachmentTypes", void 0);
					b.__decorate([d.property({
							type: String,
							json: {
								read: {
									source: "attachmentsDefinitionExpression"
								},
								write: {
									target: "attachmentsDefinitionExpression"
								}
							}
						})], c.prototype, "attachmentsWhere",
						void 0);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], c.prototype, "cacheHint", void 0);
					b.__decorate([d.property({
						type: [String],
						json: {
							write: !0
						}
					})], c.prototype, "keywords", void 0);
					b.__decorate([d.property({
						type: [Number],
						json: {
							write: !0
						}
					})], c.prototype, "globalIds", void 0);
					b.__decorate([d.property({
						json: {
							write: !0
						}
					})], c.prototype, "name", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							read: {
								source: "resultRecordCount"
							}
						}
					})], c.prototype, "num", void 0);
					b.__decorate([d.property({
							type: [Number],
							json: {
								write: !0
							}
						})],
						c.prototype, "objectIds", void 0);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							default: !1,
							write: !0
						}
					})], c.prototype, "returnMetadata", void 0);
					b.__decorate([d.property({
						type: [Number],
						json: {
							write: !0
						}
					})], c.prototype, "size", void 0);
					b.__decorate([d.property({
						type: Number,
						json: {
							read: {
								source: "resultOffset"
							}
						}
					})], c.prototype, "start", void 0);
					b.__decorate([m.writer("start"), m.writer("num")], c.prototype, "writeStart", null);
					b.__decorate([d.property({
							type: String,
							json: {
								read: {
									source: "definitionExpression"
								},
								write: {
									target: "definitionExpression"
								}
							}
						})],
						c.prototype, "where", void 0);
					c = f = b.__decorate([v.subclass("esri.rest.support.AttachmentQuery")], c);
					c.from = k.ensureType(c);
					return c
				})
		},
		"esri/rest/support/RelationshipQuery": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../core/JSONSupport ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../layers/support/source/DataLayerSource ../../geometry/SpatialReference".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l) {
					var r;
					c = r = function(p) {
						function n(h) {
							h = p.call(this, h) || this;
							h.cacheHint = void 0;
							h.dynamicDataSource = void 0;
							h.gdbVersion = null;
							h.geometryPrecision = void 0;
							h.historicMoment = null;
							h.maxAllowableOffset = void 0;
							h.objectIds = null;
							h.orderByFields = null;
							h.outFields = null;
							h.outSpatialReference = null;
							h.relationshipId = void 0;
							h.start = void 0;
							h.num = void 0;
							h.returnGeometry = !1;
							h.returnM = void 0;
							h.returnZ = void 0;
							h.where = null;
							return h
						}
						a._inheritsLoose(n, p);
						var t = n.prototype;
						t._writeHistoricMoment =
							function(h, q) {
								q.historicMoment = h && h.getTime()
							};
						t.writeStart = function(h, q) {
							q.resultOffset = this.start;
							q.resultRecordCount = this.num || 10;
							0 < this.start && null == this.where && (q.definitionExpression = "1\x3d1")
						};
						t.clone = function() {
							return new r(d.clone({
								cacheHint: this.cacheHint,
								dynamicDataSource: this.dynamicDataSource,
								gdbVersion: this.gdbVersion,
								geometryPrecision: this.geometryPrecision,
								historicMoment: this.historicMoment && new Date(this.historicMoment.getTime()),
								maxAllowableOffset: this.maxAllowableOffset,
								objectIds: this.objectIds,
								orderByFields: this.orderByFields,
								outFields: this.outFields,
								outSpatialReference: this.outSpatialReference,
								relationshipId: this.relationshipId,
								start: this.start,
								num: this.num,
								returnGeometry: this.returnGeometry,
								where: this.where,
								returnZ: this.returnZ,
								returnM: this.returnM
							}))
						};
						return n
					}(e.JSONSupport);
					b.__decorate([k.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], c.prototype, "cacheHint", void 0);
					b.__decorate([k.property({
						type: g.DataLayerSource,
						json: {
							write: !0
						}
					})], c.prototype, "dynamicDataSource", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "gdbVersion", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0
						}
					})], c.prototype, "geometryPrecision", void 0);
					b.__decorate([k.property({
						type: Date
					})], c.prototype, "historicMoment", void 0);
					b.__decorate([f.writer("historicMoment")], c.prototype, "_writeHistoricMoment", null);
					b.__decorate([k.property({
						type: Number,
						json: {
							write: !0
						}
					})], c.prototype, "maxAllowableOffset", void 0);
					b.__decorate([k.property({
						type: [Number],
						json: {
							write: !0
						}
					})], c.prototype, "objectIds", void 0);
					b.__decorate([k.property({
						type: [String],
						json: {
							write: !0
						}
					})], c.prototype, "orderByFields", void 0);
					b.__decorate([k.property({
						type: [String],
						json: {
							write: !0
						}
					})], c.prototype, "outFields", void 0);
					b.__decorate([k.property({
						type: l,
						json: {
							read: {
								source: "outSR"
							},
							write: {
								target: "outSR"
							}
						}
					})], c.prototype, "outSpatialReference", void 0);
					b.__decorate([k.property({
						json: {
							write: !0
						}
					})], c.prototype, "relationshipId", void 0);
					b.__decorate([k.property({
						type: Number,
						json: {
							read: {
								source: "resultOffset"
							}
						}
					})], c.prototype, "start", void 0);
					b.__decorate([f.writer("start"), f.writer("num")],
						c.prototype, "writeStart", null);
					b.__decorate([k.property({
						type: Number,
						json: {
							read: {
								source: "resultRecordCount"
							}
						}
					})], c.prototype, "num", void 0);
					b.__decorate([k.property({
						json: {
							write: !0
						}
					})], c.prototype, "returnGeometry", void 0);
					b.__decorate([k.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(p) {
									return {
										enabled: p
									}
								}
							}
						}
					})], c.prototype, "returnM", void 0);
					b.__decorate([k.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(p) {
									return {
										enabled: p
									}
								}
							}
						}
					})], c.prototype, "returnZ", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							read: {
								source: "definitionExpression"
							},
							write: {
								target: "definitionExpression"
							}
						}
					})], c.prototype, "where", void 0);
					c = r = b.__decorate([m.subclass("esri.rest.support.RelationshipQuery")], c);
					c.from = v.ensureType(c);
					return c
				})
		},
		"esri/layers/support/GeometryFieldsInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/unitUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					c = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.shapeAreaField = null;
							r.shapeLengthField = null;
							r.units = null;
							return r
						}
						a._inheritsLoose(l, g);
						return l
					}(c.ClonableMixin(e.JSONSupport));
					b.__decorate([k.property({
						type: String,
						json: {
							read: {
								source: "shapeAreaFieldName"
							}
						}
					})], c.prototype, "shapeAreaField", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							read: {
								source: "shapeLengthFieldName"
							}
						}
					})], c.prototype, "shapeLengthField", void 0);
					b.__decorate([k.property({
						type: String,
						json: {
							read: g =>
								d.areaUnitsJSONMap.read(g) || d.lengthUnitsJSONMap.read(g)
						}
					})], c.prototype, "units", void 0);
					return c = b.__decorate([f.subclass("esri.layers.support.GeometryFieldsInfo")], c)
				})
		},
		"esri/layers/support/LayerFloorInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Collection ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					e = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.floorField = null;
							r.viewAllMode = !1;
							r.viewAllLevelIds = new c;
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								floorField: this.floorField,
								viewAllMode: this.viewAllMode,
								viewAllLevelIds: this.viewAllLevelIds
							})
						};
						return l
					}(e.JSONSupport);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "floorField", void 0);
					b.__decorate([d.property({
							json: {
								read: !1,
								write: !1
							}
						})], e.prototype, "viewAllMode",
						void 0);
					b.__decorate([d.property({
						json: {
							read: !1,
							write: !1
						}
					})], e.prototype, "viewAllLevelIds", void 0);
					return e = f = b.__decorate([m.subclass("esri.layers.support.LayerFloorInfo")], e)
				})
		},
		"esri/layers/support/Relationship": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/jsonMap ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					v = new e.JSONMap({
						esriRelCardinalityOneToOne: "one-to-one",
						esriRelCardinalityOneToMany: "one-to-many",
						esriRelCardinalityManyToMany: "many-to-many"
					});
					e = new e.JSONMap({
						esriRelRoleOrigin: "origin",
						esriRelRoleDestination: "destination"
					});
					c = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.cardinality = null;
							r.composite = null;
							r.id = null;
							r.keyField = null;
							r.keyFieldInRelationshipTable = null;
							r.name = null;
							r.relatedTableId = null;
							r.relationshipTableId = null;
							r.role = null;
							return r
						}
						a._inheritsLoose(l,
							g);
						return l
					}(c.ClonableMixin(d.JSONSupport));
					b.__decorate([k.property({
						json: {
							read: v.read,
							write: v.write
						}
					})], c.prototype, "cardinality", void 0);
					b.__decorate([k.property({
						json: {
							read: !0,
							write: !0
						}
					})], c.prototype, "composite", void 0);
					b.__decorate([k.property({
						json: {
							read: !0,
							write: !0
						}
					})], c.prototype, "id", void 0);
					b.__decorate([k.property({
						json: {
							read: !0,
							write: !0
						}
					})], c.prototype, "keyField", void 0);
					b.__decorate([k.property({
						json: {
							read: !0,
							write: !0
						}
					})], c.prototype, "keyFieldInRelationshipTable", void 0);
					b.__decorate([k.property({
						json: {
							read: !0,
							write: !0
						}
					})], c.prototype, "name", void 0);
					b.__decorate([k.property({
						json: {
							read: !0,
							write: !0
						}
					})], c.prototype, "relatedTableId", void 0);
					b.__decorate([k.property({
						json: {
							read: !0,
							write: !0
						}
					})], c.prototype, "relationshipTableId", void 0);
					b.__decorate([k.property({
						json: {
							read: e.read,
							write: e.write
						}
					})], c.prototype, "role", void 0);
					return c = b.__decorate([f.subclass("esri.layers.support.Relationship")], c)
				})
		},
		"esri/layers/mixins/FeatureReductionLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../support/AggregateField ../support/featureReductionUtils ../../views/2d/layers/support/clusterUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					a.FeatureReductionLayer = l => {
						l = function(r) {
							function p(...n) {
								var t = r.call(this, ...n) || this;
								t.own(t.watch("renderer", () => {
									if (t.featureReduction) {
										const h = t._normalizeFeatureReduction(t.featureReduction);
										t._set("featureReduction", h)
									}
								}, !0));
								return t
							}
							b._inheritsLoose(p, r);
							p.prototype._normalizeFeatureReduction = function(n) {
								if ("cluster" !== n ? .type) return n;
								const t = n.clone(),
									h = [new m({
										name: "cluster_count",
										isAutoGenerated: !0,
										statisticType: "count"
									})],
									q = (t.fields ? ? [])
									.filter(u => !u.isAutoGenerated);
								if (n.renderer && !n.renderer.authoringInfo ? .isAutoGenerated) return t.fields = [...h, ...q], t;
								if (n.symbol) return t.fields = [...h, ...q], t.renderer = null, t;
								if (!this.renderer) return n;
								n = g.createClusterRenderer(h, this.renderer, n, null, !1);
								t.fields = [...h, ...q];
								t.renderer = n;
								return t
							};
							b._createClass(p, [{
								key: "featureReduction",
								set: function(n) {
									n = this._normalizeFeatureReduction(n);
									this._set("featureReduction", n)
								}
							}, {
								key: "renderer",
								set: function(n) {}
							}]);
							return p
						}(l);
						c.__decorate([e.property(f.featureReductionProperty)],
							l.prototype, "featureReduction", null);
						return l = c.__decorate([v.subclass("esri.layers.mixins.FeatureReductionLayer")], l)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/AggregateField": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/lang ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./ExpressionInfo".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					c = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.isAutoGenerated = !1;
							r.name = null;
							r.alias = null;
							r.onStatisticField = null;
							r.onStatisticExpression = null;
							r.statisticType = null;
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								name: this.name,
								alias: this.alias,
								isAutoGenerated: this.isAutoGenerated,
								onStatisticExpression: e.clone(this.onStatisticExpression),
								onStatisticField: this.onStatisticField,
								statisticType: this.statisticType
							})
						};
						return l
					}(c.JSONSupport);
					b.__decorate([d.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], c.prototype, "isAutoGenerated", void 0);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "name", void 0);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "alias", void 0);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], c.prototype, "onStatisticField", void 0);
					b.__decorate([d.property({
						type: m,
						json: {
							write: !0
						}
					})], c.prototype, "onStatisticExpression", void 0);
					b.__decorate([d.property({
							type: String,
							json: {
								write: !0
							}
						})],
						c.prototype, "statisticType", void 0);
					return c = f = b.__decorate([v.subclass("esri.layers.support.AggregateField")], c)
				})
		},
		"esri/layers/support/ExpressionInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m) {
				c = function(f) {
					function g(l) {
						l = f.call(this,
							l) || this;
						l.expression = null;
						l.title = null;
						l.returnType = null;
						return l
					}
					a._inheritsLoose(g, f);
					return g
				}(c.ClonableMixin(e.JSONSupport));
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "expression", void 0);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "title", void 0);
				b.__decorate([d.property({
					type: String,
					json: {
						write: !0
					}
				})], c.prototype, "returnType", void 0);
				return c = b.__decorate([m.subclass("esri.layers.support.ExpressionInfo")], c)
			})
		},
		"esri/layers/support/featureReductionUtils": function() {
			define(["exports",
				"./FeatureReduction", "./FeatureReductionBinning", "./FeatureReductionCluster", "./FeatureReductionSelection"
			], function(a, b, c, e, d) {
				const k = {
					key: "type",
					base: b.FeatureReduction,
					typeMap: {
						cluster: e,
						binning: c
					}
				};
				a.featureReductionProperty = {
					types: {
						key: "type",
						base: b.FeatureReduction,
						typeMap: {
							selection: d,
							cluster: e,
							binning: c
						}
					},
					json: {
						name: "layerDefinition.featureReduction",
						write: {
							allowNull: !0
						},
						origins: {
							"web-map": {
								types: k
							},
							"portal-item": {
								types: k
							},
							"web-scene": {
								types: {
									key: "type",
									base: b.FeatureReduction,
									typeMap: {
										selection: d
									}
								}
							}
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/FeatureReduction": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m) {
				a.FeatureReduction = function(f) {
					function g() {
						var l = f.apply(this, arguments) ||
							this;
						l.type = null;
						return l
					}
					b._inheritsLoose(g, f);
					return g
				}(e.JSONSupport);
				c.__decorate([d.property({
					type: ["selection", "cluster", "binning"],
					readOnly: !0,
					json: {
						read: !1,
						write: !0
					}
				})], a.FeatureReduction.prototype, "type", void 0);
				a.FeatureReduction = c.__decorate([m.subclass("esri.layers.support.FeatureReduction")], a.FeatureReduction);
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/FeatureReductionBinning": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../PopupTemplate ../../renderers/ClassBreaksRenderer ../../renderers/DictionaryRenderer ../../renderers/DotDensityRenderer ../../renderers/HeatmapRenderer ../../renderers/PieChartRenderer ../../renderers/Renderer ../../renderers/SimpleRenderer ../../renderers/UniqueValueRenderer ../../renderers/support/jsonUtils ../../renderers/support/types ../../symbols ../../core/lang ../../core/object ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/enumeration ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../core/accessorSupport/extensions/serializableProperty/reader ./AggregateField ./commonProperties ./FeatureReduction ./LabelClass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D) {
					var J;
					const K = B.createTypeReader({
						types: n.symbolTypesRenderer
					});
					e = J = function(H) {
						function G(L) {
							L = H.call(this, L) || this;
							L.type = "binning";
							L.binType = "geohash";
							L.fixedBinLevel = 3;
							L.labelingInfo = null;
							L.labelsVisible = !0;
							L.popupEnabled = !0;
							L.popupTemplate = null;
							L.fields = [];
							L.renderer = null;
							return L
						}
						a._inheritsLoose(G, H);
						var F = G.prototype;
						F.writeFields = function(L, R, V) {
							L = L.filter(U => "avg_angle" !== U.statisticType)
								.map(U => U.toJSON());
							h.setDeepValue(V,
								L, R)
						};
						F.readRenderer = function(L, R, V) {
							return (L = R.drawingInfo ? .renderer) ? r.read(L, R, V) ? ? void 0 : R.defaultSymbol ? R.types && R.types.length ? new l({
								defaultSymbol: K(R.defaultSymbol, R, V),
								field: R.typeIdField,
								uniqueValueInfos: R.types.map(U => ({
									id: U.id,
									symbol: K(U.symbol, U, V)
								}))
							}) : new g({
								symbol: K(R.defaultSymbol, R, V)
							}) : null
						};
						F.clone = function() {
							return new J({
								fields: t.clone(this.fields),
								fixedBinLevel: this.fixedBinLevel,
								labelingInfo: t.clone(this.labelingInfo),
								labelsVisible: this.labelsVisible,
								popupEnabled: this.popupEnabled,
								popupTemplate: t.clone(this.popupTemplate),
								renderer: t.clone(this.renderer)
							})
						};
						return G
					}(C.FeatureReduction);
					b.__decorate([x.enumeration({
						binning: "binning"
					})], e.prototype, "type", void 0);
					b.__decorate([x.enumeration({
						geohash: "geohash"
					})], e.prototype, "binType", void 0);
					b.__decorate([q.property({
						type: Number,
						range: {
							min: 1,
							max: 9
						},
						json: {
							write: !0
						}
					})], e.prototype, "fixedBinLevel", void 0);
					b.__decorate([q.property({
							type: [D],
							json: {
								read: {
									source: "drawingInfo.labelingInfo"
								},
								write: {
									target: "drawingInfo.labelingInfo"
								}
							}
						})],
						e.prototype, "labelingInfo", void 0);
					b.__decorate([q.property(z.labelsVisible)], e.prototype, "labelsVisible", void 0);
					b.__decorate([q.property(z.popupEnabled)], e.prototype, "popupEnabled", void 0);
					b.__decorate([q.property({
						type: c,
						json: {
							name: "popupInfo",
							write: !0
						}
					})], e.prototype, "popupTemplate", void 0);
					b.__decorate([q.property({
						type: [E],
						json: {
							write: !0
						}
					})], e.prototype, "fields", void 0);
					b.__decorate([A.writer("fields")], e.prototype, "writeFields", null);
					b.__decorate([q.property({
							types: p.rendererTypes,
							json: {
								write: {
									target: "drawingInfo.renderer"
								}
							}
						})],
						e.prototype, "renderer", void 0);
					b.__decorate([y.reader("renderer", ["drawingInfo.renderer"])], e.prototype, "readRenderer", null);
					return e = J = b.__decorate([w.subclass("esri.layers.support.FeatureReductionBinning")], e)
				})
		},
		"esri/layers/support/LabelClass": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../symbols ../../core/jsonMap ../../core/JSONSupport ../../core/lang ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./LabelExpressionInfo ./labelUtils ../../symbols/support/defaults ../../symbols/support/jsonUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h) {
					function q(y) {
						return y ? "service" === y.origin ? !1 : "map-image" !== y.layer ? .type : !0
					}

					function u(y) {
						return "map-image" === y ? .type ? !!y.capabilities ? .exportMap ? .supportsArcadeExpressionForLabeling : !1
					}
					var x;
					e = new e.JSONMap({
						esriServerPointLabelPlacementAboveCenter: "above-center",
						esriServerPointLabelPlacementAboveLeft: "above-left",
						esriServerPointLabelPlacementAboveRight: "above-right",
						esriServerPointLabelPlacementBelowCenter: "below-center",
						esriServerPointLabelPlacementBelowLeft: "below-left",
						esriServerPointLabelPlacementBelowRight: "below-right",
						esriServerPointLabelPlacementCenterCenter: "center-center",
						esriServerPointLabelPlacementCenterLeft: "center-left",
						esriServerPointLabelPlacementCenterRight: "center-right",
						esriServerLinePlacementAboveAfter: "above-after",
						esriServerLinePlacementAboveAlong: "above-along",
						esriServerLinePlacementAboveBefore: "above-before",
						esriServerLinePlacementAboveStart: "above-start",
						esriServerLinePlacementAboveEnd: "above-end",
						esriServerLinePlacementBelowAfter: "below-after",
						esriServerLinePlacementBelowAlong: "below-along",
						esriServerLinePlacementBelowBefore: "below-before",
						esriServerLinePlacementBelowStart: "below-start",
						esriServerLinePlacementBelowEnd: "below-end",
						esriServerLinePlacementCenterAfter: "center-after",
						esriServerLinePlacementCenterAlong: "center-along",
						esriServerLinePlacementCenterBefore: "center-before",
						esriServerLinePlacementCenterStart: "center-start",
						esriServerLinePlacementCenterEnd: "center-end",
						esriServerPolygonPlacementAlwaysHorizontal: "always-horizontal"
					}, {
						ignoreUnknown: !0
					});
					d = x = function(y) {
						function w(B) {
							B = y.call(this, B) || this;
							B.type = "label";
							B.name = null;
							B.allowOverrun = !1;
							B.deconflictionStrategy = "static";
							B.labelExpression = null;
							B.labelExpressionInfo = null;
							B.labelPlacement = null;
							B.labelPosition = "curved";
							B.maxScale = 0;
							B.minScale = 0;
							B.repeatLabel = !0;
							B.repeatLabelDistance = null;
							B.symbol = t.defaultTextSymbol2D;
							B.useCodedValues = void 0;
							B.where = null;
							return B
						}
						a._inheritsLoose(w, y);
						w.evaluateWhere = function(B, E) {
							const z = (C, D, J) => {
								switch (D) {
									case "\x3d":
										return C == J ? !0 :
											!1;
									case "\x3c\x3e":
										return C != J ? !0 : !1;
									case "\x3e":
										return C > J ? !0 : !1;
									case "\x3e\x3d":
										return C >= J ? !0 : !1;
									case "\x3c":
										return C < J ? !0 : !1;
									case "\x3c\x3d":
										return C <= J ? !0 : !1
								}
								return !1
							};
							try {
								if (null == B) return !0;
								const C = B.split(" ");
								if (3 === C.length) return z(E[C[0]], C[1], C[2]);
								if (7 === C.length) {
									const D = z(E[C[0]], C[1], C[2]),
										J = C[3],
										K = z(E[C[4]], C[5], C[6]);
									switch (J) {
										case "AND":
											return D && K;
										case "OR":
											return D || K
									}
								}
								return !1
							} catch (C) {
								console.log("Error.: can't parse \x3d " + B)
							}
						};
						var A = w.prototype;
						A.readLabelExpression = function(B,
							E) {
							E = E.labelExpressionInfo;
							if (!E || !E.value && !E.expression) return B
						};
						A.writeLabelExpression = function(B, E, z) {
							if (this.labelExpressionInfo)
								if (null != this.labelExpressionInfo.value) B = n.templateStringToSql(this.labelExpressionInfo.value);
								else if (null != this.labelExpressionInfo.expression) {
								const C = n.getSingleFieldArcadeExpression(this.labelExpressionInfo.expression);
								C && (B = "[" + C + "]")
							}
							null != B && (E[z] = B)
						};
						A.writeLabelExpressionInfo = function(B, E, z, C) {
							if (null == B && null != this.labelExpression && q(C)) B = new p({
								expression: this.getLabelExpressionArcade()
							});
							else if (!B) return;
							B = B.toJSON(C);
							B.expression && (E[z] = B)
						};
						A.writeMaxScale = function(B, E) {
							if (B || this.minScale) E.maxScale = B
						};
						A.writeMinScale = function(B, E) {
							if (B || this.maxScale) E.minScale = B
						};
						A.getLabelExpression = function() {
							return n.getLabelExpression(this)
						};
						A.getLabelExpressionArcade = function() {
							return n.getLabelExpressionArcade(this)
						};
						A.getLabelExpressionSingleField = function() {
							return n.getLabelExpressionSingleField(this)
						};
						A.hash = function() {
							return JSON.stringify(this)
						};
						A.clone = function() {
							return new x({
								allowOverrun: this.allowOverrun,
								deconflictionStrategy: this.deconflictionStrategy,
								labelExpression: this.labelExpression,
								labelExpressionInfo: k.clone(this.labelExpressionInfo),
								labelPosition: this.labelPosition,
								labelPlacement: this.labelPlacement,
								maxScale: this.maxScale,
								minScale: this.minScale,
								name: this.name,
								repeatLabel: this.repeatLabel,
								repeatLabelDistance: this.repeatLabelDistance,
								symbol: k.clone(this.symbol),
								where: this.where,
								useCodedValues: this.useCodedValues
							})
						};
						return w
					}(d.JSONSupport);
					b.__decorate([m.property({
							type: String,
							json: {
								write: !0
							}
						})],
						d.prototype, "name", void 0);
					b.__decorate([m.property({
						type: Boolean,
						json: {
							write: !0,
							default: !1,
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], d.prototype, "allowOverrun", void 0);
					b.__decorate([m.property({
						type: String,
						json: {
							write: !0,
							default: "static",
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], d.prototype, "deconflictionStrategy", void 0);
					b.__decorate([m.property({
							type: String,
							json: {
								write: {
									overridePolicy(y, w, A) {
										return this.labelExpressionInfo && "service" === A ? .origin && u(A.layer) ? {
											enabled: !1
										} : {
											allowNull: !0
										}
									}
								}
							}
						})], d.prototype,
						"labelExpression", void 0);
					b.__decorate([g.reader("labelExpression")], d.prototype, "readLabelExpression", null);
					b.__decorate([r.writer("labelExpression")], d.prototype, "writeLabelExpression", null);
					b.__decorate([m.property({
						type: p,
						json: {
							write: {
								overridePolicy(y, w, A) {
									return q(A) || u(A.layer) ? {
										allowNull: !0
									} : {
										enabled: !1
									}
								}
							}
						}
					})], d.prototype, "labelExpressionInfo", void 0);
					b.__decorate([r.writer("labelExpressionInfo")], d.prototype, "writeLabelExpressionInfo", null);
					b.__decorate([m.property({
						type: e.apiValues,
						json: {
							type: e.jsonValues,
							read: e.read,
							write: e.write
						}
					})], d.prototype, "labelPlacement", void 0);
					b.__decorate([m.property({
						type: ["curved", "parallel"],
						json: {
							write: !0,
							origins: {
								"web-map": {
									write: !1
								},
								"web-scene": {
									write: !1
								},
								"portal-item": {
									write: !1
								}
							}
						}
					})], d.prototype, "labelPosition", void 0);
					b.__decorate([m.property({
						type: Number
					})], d.prototype, "maxScale", void 0);
					b.__decorate([r.writer("maxScale")], d.prototype, "writeMaxScale", null);
					b.__decorate([m.property({
						type: Number
					})], d.prototype, "minScale", void 0);
					b.__decorate([r.writer("minScale")],
						d.prototype, "writeMinScale", null);
					b.__decorate([m.property({
						type: Boolean,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1
								},
								"portal-item": {
									write: !1
								}
							}
						}
					})], d.prototype, "repeatLabel", void 0);
					b.__decorate([m.property({
						type: Number,
						cast: v.toPt,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], d.prototype, "repeatLabelDistance", void 0);
					b.__decorate([m.property({
							types: c.symbolTypesLabel,
							json: {
								origins: {
									"web-scene": {
										types: c.symbolTypesLabel3D,
										write: h.writeLabelSymbol,
										default: null
									}
								},
								write: h.writeLabelSymbol,
								default: null
							}
						})],
						d.prototype, "symbol", void 0);
					b.__decorate([m.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], d.prototype, "useCodedValues", void 0);
					b.__decorate([m.property({
						type: String,
						json: {
							write: !0
						}
					})], d.prototype, "where", void 0);
					return d = x = b.__decorate([l.subclass("esri.layers.support.LabelClass")], d)
				})
		},
		"esri/layers/support/LabelExpressionInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./labelUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					c = l = function(r) {
						function p() {
							var t = r.apply(this, arguments) || this;
							t.expression = null;
							t.title = null;
							t.value = null;
							return t
						}
						a._inheritsLoose(p, r);
						var n = p.prototype;
						n.readExpression = function(t, h) {
							return h.value ? g.convertTemplatedStringToArcade(h.value) : t
						};
						n.writeExpression = function(t, h, q) {
							null != this.value && (t = g.convertTemplatedStringToArcade(this.value));
							null != t && (h[q] = t)
						};
						n.clone = function() {
							return new l({
								expression: this.expression,
								title: this.title,
								value: this.value
							})
						};
						return p
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String,
						json: {
							write: {
								writerEnsuresNonNull: !0
							}
						}
					})], c.prototype, "expression", void 0);
					b.__decorate([v.reader("expression", ["expression", "value"])], c.prototype, "readExpression", null);
					b.__decorate([f.writer("expression")], c.prototype, "writeExpression", null);
					b.__decorate([e.property({
						type: String,
						json: {
							write: !0,
							origins: {
								"web-scene": {
									write: !1
								}
							}
						}
					})], c.prototype, "title", void 0);
					b.__decorate([e.property({
						json: {
							read: !1,
							write: !1
						}
					})], c.prototype, "value", void 0);
					return c = l = b.__decorate([m.subclass("esri.layers.support.LabelExpressionInfo")], c)
				})
		},
		"esri/layers/support/labelUtils": function() {
			define(["exports", "../../core/string"], function(a, b) {
				function c(h) {
					return h.replace(RegExp("\\[", "g"), "{")
						.replace(RegExp("\\]", "g"), "}")
				}

				function e(h) {
					const q = {
						expression: "",
						type: "none"
					};
					h.labelExpressionInfo ? h.labelExpressionInfo.value ? (q.expression = h.labelExpressionInfo.value, q.type = "conventional") : h.labelExpressionInfo.expression && (q.expression = h.labelExpressionInfo.expression,
						q.type = "arcade") : null != h.labelExpression && (q.expression = c(h.labelExpression), q.type = "conventional");
					return q
				}

				function d(h) {
					h ? (h = b.replace(h, q => '__begin__$feature["' + q + '"]__end__'), h = g.test(h) ? h.replace(g, "") : '"' + h, h = l.test(h) ? h.replace(l, "") : h + '"', h = h.replace(m, '" + ')
						.replace(f, ' + "')) : h = '""';
					return h
				}

				function k(h) {
					return (h = h.match(r)) && h[1].trim() || null
				}

				function v(h) {
					if (!h) return null;
					let q = p.exec(h) || n.exec(h);
					return q ? q[1] || q[3] : (q = t.exec(h)) ? q[2] : null
				}
				const m = RegExp("__begin__", "ig"),
					f = RegExp("__end__",
						"ig"),
					g = RegExp("^__begin__", "i"),
					l = RegExp("__end__$", "i"),
					r = /^\s*\{([^}]+)\}\s*$/i,
					p = /^\s*(?:(?:\$feature\.(\w+))|(?:\$feature\[(["'])([\w\s]+)(\2)\]));?\s*$/i,
					n = /^\s*(?:(?:\$feature\.(\w+))|(?:\$feature\[(["'])([\w\s]+)(\2)\]));?\s*(?:DomainName\(\s*\$feature\s*,\s*(["'])(\1|\3)(\5)\s*\));?\s*$/i,
					t = /^\s*(?:DomainName\(\s*\$feature\s*,\s*(["'])([\w\s]+)(\1)\s*\));?\s*$/i;
				a.convertTemplatedStringToArcade = d;
				a.getLabelExpression = e;
				a.getLabelExpressionArcade = function(h) {
					h = e(h);
					if (!h) return null;
					switch (h.type) {
						case "conventional":
							return d(h.expression);
						case "arcade":
							return h.expression
					}
					return null
				};
				a.getLabelExpressionSingleField = function(h) {
					h = e(h);
					if (!h) return null;
					switch (h.type) {
						case "conventional":
							return k(h.expression);
						case "arcade":
							return v(h.expression)
					}
					return null
				};
				a.getSingleFieldArcadeExpression = v;
				a.getSingleFieldTemplatedString = k;
				a.sqlToTemplateString = c;
				a.templateStringToSql = function(h) {
					return h.replace(RegExp("\\{", "g"), "[")
						.replace(RegExp("\\}", "g"), "]")
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/support/defaults": function() {
			define("exports ../../core/has ../../core/maybe ../SimpleFillSymbol ../SimpleLineSymbol ../SimpleMarkerSymbol ../TextSymbol ./defaultsJSON".split(" "), function(a, b, c, e, d, k, v, m) {
				const f = k.fromJSON(m.defaultPointSymbolJSON),
					g = d.fromJSON(m.defaultPolylineSymbolJSON),
					l = e.fromJSON(m.defaultPolygonSymbolJSON);
				b = v.fromJSON(m.defaultTextSymbolJSON);
				k = k.fromJSON(m.errorPointSymbolJSON);
				d = d.fromJSON(m.errorPolylineSymbolJSON);
				e = e.fromJSON(m.errorPolygonSymbolJSON);
				a.defaultPointSymbol2D = f;
				a.defaultPolygonSymbol2D = l;
				a.defaultPolylineSymbol2D = g;
				a.defaultTextSymbol2D = b;
				a.errorPointSymbol2D = k;
				a.errorPolygonSymbol2D = e;
				a.errorPolylineSymbol2D = d;
				a.getDefaultSymbol2D = function(r) {
					if (c.isNone(r)) return null;
					switch (r.type) {
						case "point":
						case "multipoint":
							return f;
						case "polyline":
							return g;
						case "polygon":
						case "extent":
							return l
					}
					return null
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/symbols/support/defaultsJSON": function() {
			define(["exports"],
				function(a) {
					const b = [252, 146, 31, 255],
						c = {
							type: "esriSMS",
							style: "esriSMSCircle",
							size: 6,
							color: b,
							outline: {
								type: "esriSLS",
								style: "esriSLSSolid",
								width: .75,
								color: [153, 153, 153, 255]
							}
						},
						e = {
							type: "esriSLS",
							style: "esriSLSSolid",
							width: .75,
							color: b
						};
					a.defaultColor = b;
					a.defaultOutlineColor = [153, 153, 153, 255];
					a.defaultPointSymbolJSON = c;
					a.defaultPolygonSymbolJSON = {
						type: "esriSFS",
						style: "esriSFSSolid",
						color: [252, 146, 31, 196],
						outline: {
							type: "esriSLS",
							style: "esriSLSSolid",
							width: .75,
							color: [255, 255, 255, 191]
						}
					};
					a.defaultPolylineSymbolJSON =
						e;
					a.defaultTextSymbolJSON = {
						type: "esriTS",
						color: [255, 255, 255, 255],
						font: {
							family: "arial-unicode-ms",
							size: 10,
							weight: "bold"
						},
						horizontalAlignment: "center",
						kerning: !0,
						haloColor: [0, 0, 0, 255],
						haloSize: 1,
						rotated: !1,
						text: "",
						xoffset: 0,
						yoffset: 0,
						angle: 0
					};
					a.errorPointSymbolJSON = {
						type: "esriSMS",
						style: "esriSMSCircle",
						color: [0, 0, 0, 255],
						outline: null,
						size: 10.5
					};
					a.errorPolygonSymbolJSON = {
						type: "esriSFS",
						style: "esriSFSSolid",
						color: [0, 0, 0, 255],
						outline: null
					};
					a.errorPolylineSymbolJSON = {
						type: "esriSLS",
						style: "esriSLSSolid",
						color: [0, 0, 0, 255],
						width: 1.5
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/FeatureReductionCluster": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../PopupTemplate ../../renderers/ClassBreaksRenderer ../../renderers/DictionaryRenderer ../../renderers/DotDensityRenderer ../../renderers/HeatmapRenderer ../../renderers/PieChartRenderer ../../renderers/Renderer ../../renderers/SimpleRenderer ../../renderers/UniqueValueRenderer ../../renderers/support/jsonUtils ../../renderers/support/types ../../symbols ../../core/JSONSupport ../../core/lang ../../core/object ../../core/screenUtils ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../core/accessorSupport/extensions/serializableProperty/reader ./AggregateField ./commonProperties ./LabelClass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D) {
					var J;
					const K = E.createTypeReader({
						types: n.symbolTypesRenderer
					});
					e = J = function(H) {
						function G(L) {
							L = H.call(this, L) || this;
							L.type = "cluster";
							L.clusterRadius = u.toPt("80px");
							L.clusterMinSize = u.toPt("12px");
							L.clusterMaxSize = u.toPt("50px");
							L.popupEnabled = !0;
							L.popupTemplate = null;
							L.renderer = null;
							L.symbol = null;
							L.labelingInfo = null;
							L.labelsVisible = !0;
							L.fields = null;
							return L
						}
						a._inheritsLoose(G, H);
						var F = G.prototype;
						F.readRenderer = function(L, R, V) {
							L = R.drawingInfo ? .renderer;
							return L ? .authoringInfo ? .isAutoGenerated ? null : L ? "simple" !== L.type || L.visualVariables ? .length ? r.read(L, R, V) ? ? void 0 : null : R.defaultSymbol ? R.types && R.types.length ? new l({
								defaultSymbol: K(R.defaultSymbol, R, V),
								field: R.typeIdField,
								uniqueValueInfos: R.types.map(U => ({
									id: U.id,
									symbol: K(U.symbol, U, V)
								}))
							}) : new g({
								symbol: K(R.defaultSymbol, R, V)
							}) : null
						};
						F.readSymbol = function(L, R, V) {
							L = R.drawingInfo ? .renderer;
							return L ? .authoringInfo ? .isAutoGenerated ? null : L && "simple" === L.type && !L.visualVariables ? .length ? r.read(L, R, V) ? .symbol :
								null
						};
						F.writeSymbol = function(L, R, V, U) {
							V = this.renderer ? .authoringInfo ? .isAutoGenerated;
							if (!this.renderer || V) L = new g({
								symbol: L
							}), R.drawingInfo = {
								renderer: L.write({}, U)
							}
						};
						F.writeFields = function(L, R, V) {
							L = L.filter(U => "avg_angle" !== U.statisticType)
								.map(U => U.toJSON());
							q.setDeepValue(V, L, R)
						};
						F.readFields = function(L, R, V) {
							return L.filter(U => !U.isAutoGenerated)
								.map(U => z.fromJSON(U))
						};
						F.clone = function() {
							return new J({
								clusterRadius: this.clusterRadius,
								clusterMinSize: this.clusterMinSize,
								clusterMaxSize: this.clusterMaxSize,
								labelingInfo: h.clone(this.labelingInfo),
								labelsVisible: this.labelsVisible,
								fields: h.clone(this.fields),
								renderer: h.clone(this.renderer),
								symbol: h.clone(this.symbol),
								popupEnabled: this.popupEnabled,
								popupTemplate: h.clone(this.popupTemplate)
							})
						};
						return G
					}(t.JSONSupport);
					b.__decorate([x.property({
						type: ["cluster"],
						readOnly: !0,
						json: {
							write: !0
						}
					})], e.prototype, "type", void 0);
					b.__decorate([x.property({
						type: Number,
						cast: H => "auto" === H ? H : u.toPt(H),
						json: {
							write: !0
						}
					})], e.prototype, "clusterRadius", void 0);
					b.__decorate([x.property({
						type: Number,
						cast: u.toPt,
						json: {
							write: !0
						}
					})], e.prototype, "clusterMinSize", void 0);
					b.__decorate([x.property({
						type: Number,
						cast: u.toPt,
						json: {
							write: !0
						}
					})], e.prototype, "clusterMaxSize", void 0);
					b.__decorate([x.property(C.popupEnabled)], e.prototype, "popupEnabled", void 0);
					b.__decorate([x.property({
						type: c,
						json: {
							read: {
								source: "popupInfo"
							},
							write: {
								target: "popupInfo"
							}
						}
					})], e.prototype, "popupTemplate", void 0);
					b.__decorate([x.property({
							types: p.rendererTypes,
							json: {
								write: {
									target: "drawingInfo.renderer"
								}
							}
						})], e.prototype, "renderer",
						void 0);
					b.__decorate([w.reader("renderer", ["drawingInfo.renderer"])], e.prototype, "readRenderer", null);
					b.__decorate([x.property({
						types: n.symbolTypesCluster
					})], e.prototype, "symbol", void 0);
					b.__decorate([w.reader("symbol", ["drawingInfo.renderer"])], e.prototype, "readSymbol", null);
					b.__decorate([B.writer("symbol")], e.prototype, "writeSymbol", null);
					b.__decorate([x.property({
						type: [D],
						json: {
							read: {
								source: "drawingInfo.labelingInfo"
							},
							write: {
								target: "drawingInfo.labelingInfo"
							}
						}
					})], e.prototype, "labelingInfo", void 0);
					b.__decorate([x.property(C.labelsVisible)], e.prototype, "labelsVisible", void 0);
					b.__decorate([x.property({
						type: [z],
						json: {
							write: !0
						}
					})], e.prototype, "fields", void 0);
					b.__decorate([B.writer("fields")], e.prototype, "writeFields", null);
					b.__decorate([w.reader("fields")], e.prototype, "readFields", null);
					return e = J = b.__decorate([A.subclass("esri.layers.support.FeatureReductionCluster")], e)
				})
		},
		"esri/layers/support/FeatureReductionSelection": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./FeatureReduction".split(" "),
				function(a, b, c, e, d, k, v) {
					var m;
					e = m = function(f) {
						function g(l) {
							l = f.call(this, l) || this;
							l.type = "selection";
							return l
						}
						a._inheritsLoose(g, f);
						g.prototype.clone = function() {
							return new m
						};
						return g
					}(v.FeatureReduction);
					b.__decorate([c.property({
						type: ["selection"]
					})], e.prototype, "type", void 0);
					return e = m = b.__decorate([k.subclass("esri.layers.support.FeatureReductionSelection")], e)
				})
		},
		"esri/views/2d/layers/support/clusterUtils": function() {
			define("exports ../../../../core/Error ../../../../core/has ../../../../core/Logger ../../../../core/maybe ../../../../core/MD5 ../../../../layers/support/AggregateField ../../../../layers/support/ExpressionInfo ../../../../renderers/support/AuthoringInfo ../../../../renderers/visualVariables/SizeVariable ../../../../renderers/visualVariables/support/SizeStop ../../engine/LevelDependentSizeVariable".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					function p(A, B, E) {
						switch (A) {
							case "sum":
								return `cluster_sum_${B}`;
							case "avg":
							case "avg_angle":
								return `cluster_avg_${B}`;
							case "mode":
								return `cluster_type_${B}`;
							case "avg_norm":
								return A = B.toLowerCase() + ",norm:field," + E.toLowerCase(), "cluster_avg_" + k.createMD5Hash(A)
						}
					}

					function n(A, B, E, z) {
						const C = k.createMD5Hash(B),
							D = "mode" === E ? `cluster_type_${C}` : "sum" === E ? `cluster_sum_${C}` : `cluster_avg_${C}`;
						A.some(J => J.name === D) || A.push(new v({
							name: D,
							isAutoGenerated: !0,
							onStatisticExpression: new m({
								expression: B,
								returnType: z
							}),
							statisticType: E
						}));
						return D
					}

					function t(A, B, E, z, C) {
						if ("cluster_count" === B || A.some(J => J.name === B)) return B;
						const D = p(E, B, C);
						A.some(J => J.name === D) || ("avg_norm" === E ? A.push(new v({
							name: D,
							isAutoGenerated: !0,
							onStatisticExpression: new m({
								expression: `$feature.${B} / $feature.${C}`,
								returnType: z
							}),
							statisticType: "avg"
						})) : A.push(new v({
							name: D,
							isAutoGenerated: !0,
							onStatisticField: B,
							statisticType: E
						})));
						return D
					}
					const h = e.getLogger("esri.views.2d.layers.support.clusterUtils");
					c.add("esri-cluster-arcade-enabled",
						!0);
					const q = c("esri-cluster-arcade-enabled"),
						u = A => {
							for (const B of A)
								if ("size" === B.type) return B;
							return null
						},
						x = A => {
							for (const B of A)
								if ("cluster_count" === B.field) return !0;
							return !1
						},
						y = (A, B) => {
							const E = [new l({
								value: 0,
								size: 0
							}), new l({
								value: 1
							})];
							if (d.isNone(B)) return new g({
								field: "cluster_count",
								stops: [...E, new l({
									value: 2,
									size: 0
								})]
							});
							const z = Object.keys(B)
								.reduce((C, D) => ({
									...C,
									[D]: [...E, new l({
										value: Math.max(2, B[D].minValue),
										size: A.clusterMinSize
									}), new l({
										value: Math.max(3, B[D].maxValue),
										size: A.clusterMaxSize
									})]
								}), {});
							return new r.LevelDependentSizeVariable({
								field: "cluster_count",
								levels: z
							})
						},
						w = A => {
							const B = E => h.error(new b("Unsupported-renderer", E, {
								renderer: A
							}));
							switch (A.type) {
								case "unique-value":
									if (A.field2 || A.field3) return B("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), !1;
									break;
								case "class-breaks":
									if (A.normalizationField) {
										const E = A.normalizationType;
										if ("field" !== E) return B(`FeatureReductionCluster does not support a normalizationType of ${E}`), !1;
										break
									}
								case "simple":
								case "pie-chart":
									break;
								default:
									return B(`FeatureReductionCluster does not support renderers of type ${A.type}`), !1
							}
							if (!q) {
								if ("valueExpression" in A && A.valueExpression) return B("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), !1;
								if (("visualVariables" in A && A.visualVariables || [])
									.some(E => !!("valueExpression" in E && E.valueExpression))) return B("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"),
									!1
							}
							return !0
						};
					a.createClusterCountSizeVariable = y;
					a.createClusterRenderer = (A, B, E, z, C) => {
						B = B.clone();
						if (!w(B)) return B;
						B.authoringInfo || (B.authoringInfo = new f);
						B.authoringInfo.isAutoGenerated = !0;
						if ("visualVariables" in B) {
							const D = (B.visualVariables || [])
								.filter(K => "$view.scale" !== K.valueExpression),
								J = u(D);
							D.forEach(K => {
								"rotation" === K.type ? K.field ? K.field = t(A, K.field, "avg_angle", "number") : K.valueExpression && (K.field = n(A, K.valueExpression, "avg_angle", "number"), K.valueExpression = null) : K.normalizationField ?
									(K.field = t(A, K.field, "avg_norm", "number", K.normalizationField), K.normalizationField = null) : K.field ? K.field = t(A, K.field, "avg", "number") : K.valueExpression && (K.field = n(A, K.valueExpression, "avg", "number"), K.valueExpression = null)
							});
							d.isNone(J) && !x(D) && C && (D.push(y(E, z)), B.dynamicClusterSize = !0);
							B.visualVariables = D
						}
						switch (B.type) {
							case "pie-chart":
								for (const D of B.attributes) D.field ? D.field = t(A, D.field, "sum", "number") : D.valueExpression && (D.field = n(A, D.valueExpression, "sum", "number"), D.valueExpression = null);
								break;
							case "unique-value":
								B.field ? B.field = t(A, B.field, "mode", "string") : B.valueExpression && (B.field = n(A, B.valueExpression, "mode", "string"), B.valueExpression = null);
								break;
							case "class-breaks":
								B.normalizationField ? (B.field = t(A, B.field, "avg_norm", "number", B.normalizationField), B.normalizationField = null) : B.field ? B.field = t(A, B.field, "avg", "number") : B.valueExpression && (B.field = n(A, B.valueExpression, "avg", "number"), B.valueExpression = null)
						}
						return B
					};
					a.findSizeVV = u;
					a.hasClusterCountVV = x;
					a.injectDynamicLevelDependentSizeVisualVariable =
						function(A, B, E) {
							A = A.clone();
							let z = !1;
							if ("visualVariables" in A) {
								var C = (A.visualVariables || [])
									.filter(D => "$view.scale" !== D.valueExpression);
								C = u(C);
								d.isNone(C) && (A.visualVariables || (A.visualVariables = []), A.visualVariables.push(y(B, E)), z = A.dynamicClusterSize = !0)
							}
							return {
								renderer: A,
								didInject: z
							}
						};
					a.isClusterCompatibleRenderer = w;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/MD5": function() {
			define(["exports"], function(a) {
				function b(m, f) {
					const g = (m & 65535) +
						(f & 65535);
					return (m >> 16) + (f >> 16) + (g >> 16) << 16 | g & 65535
				}

				function c(m, f, g, l, r, p) {
					m = b(b(f, m), b(l, p));
					return b(m << r | m >>> 32 - r, g)
				}

				function e(m, f, g, l, r, p, n) {
					return c(f & g | ~f & l, m, f, r, p, n)
				}

				function d(m, f, g, l, r, p, n) {
					return c(f & l | g & ~l, m, f, r, p, n)
				}

				function k(m, f, g, l, r, p, n) {
					return c(g ^ (f | ~l), m, f, r, p, n)
				}
				const v = {
					Base64: 0,
					Hex: 1,
					String: 2,
					Raw: 3
				};
				a.createMD5Hash = function(m, f = v.Hex) {
					f = f || v.Base64;
					var g = [];
					for (let n = 0, t = 8 * m.length; n < t; n += 8) g[n >> 5] |= (m.charCodeAt(n / 8) & 255) << n % 32;
					m = 8 * m.length;
					g[m >> 5] |= 128 << m % 32;
					g[(m + 64 >>> 9 <<
						4) + 14] = m;
					m = 1732584193;
					var l = -271733879;
					let r = -1732584194,
						p = 271733878;
					for (let n = 0; n < g.length; n += 16) {
						const t = m,
							h = l,
							q = r,
							u = p;
						m = e(m, l, r, p, g[n + 0], 7, -680876936);
						p = e(p, m, l, r, g[n + 1], 12, -389564586);
						r = e(r, p, m, l, g[n + 2], 17, 606105819);
						l = e(l, r, p, m, g[n + 3], 22, -1044525330);
						m = e(m, l, r, p, g[n + 4], 7, -176418897);
						p = e(p, m, l, r, g[n + 5], 12, 1200080426);
						r = e(r, p, m, l, g[n + 6], 17, -1473231341);
						l = e(l, r, p, m, g[n + 7], 22, -45705983);
						m = e(m, l, r, p, g[n + 8], 7, 1770035416);
						p = e(p, m, l, r, g[n + 9], 12, -1958414417);
						r = e(r, p, m, l, g[n + 10], 17, -42063);
						l = e(l, r, p, m,
							g[n + 11], 22, -1990404162);
						m = e(m, l, r, p, g[n + 12], 7, 1804603682);
						p = e(p, m, l, r, g[n + 13], 12, -40341101);
						r = e(r, p, m, l, g[n + 14], 17, -1502002290);
						l = e(l, r, p, m, g[n + 15], 22, 1236535329);
						m = d(m, l, r, p, g[n + 1], 5, -165796510);
						p = d(p, m, l, r, g[n + 6], 9, -1069501632);
						r = d(r, p, m, l, g[n + 11], 14, 643717713);
						l = d(l, r, p, m, g[n + 0], 20, -373897302);
						m = d(m, l, r, p, g[n + 5], 5, -701558691);
						p = d(p, m, l, r, g[n + 10], 9, 38016083);
						r = d(r, p, m, l, g[n + 15], 14, -660478335);
						l = d(l, r, p, m, g[n + 4], 20, -405537848);
						m = d(m, l, r, p, g[n + 9], 5, 568446438);
						p = d(p, m, l, r, g[n + 14], 9, -1019803690);
						r =
							d(r, p, m, l, g[n + 3], 14, -187363961);
						l = d(l, r, p, m, g[n + 8], 20, 1163531501);
						m = d(m, l, r, p, g[n + 13], 5, -1444681467);
						p = d(p, m, l, r, g[n + 2], 9, -51403784);
						r = d(r, p, m, l, g[n + 7], 14, 1735328473);
						l = d(l, r, p, m, g[n + 12], 20, -1926607734);
						m = c(l ^ r ^ p, m, l, g[n + 5], 4, -378558);
						p = c(m ^ l ^ r, p, m, g[n + 8], 11, -2022574463);
						r = c(p ^ m ^ l, r, p, g[n + 11], 16, 1839030562);
						l = c(r ^ p ^ m, l, r, g[n + 14], 23, -35309556);
						m = c(l ^ r ^ p, m, l, g[n + 1], 4, -1530992060);
						p = c(m ^ l ^ r, p, m, g[n + 4], 11, 1272893353);
						r = c(p ^ m ^ l, r, p, g[n + 7], 16, -155497632);
						l = c(r ^ p ^ m, l, r, g[n + 10], 23, -1094730640);
						m = c(l ^ r ^ p,
							m, l, g[n + 13], 4, 681279174);
						p = c(m ^ l ^ r, p, m, g[n + 0], 11, -358537222);
						r = c(p ^ m ^ l, r, p, g[n + 3], 16, -722521979);
						l = c(r ^ p ^ m, l, r, g[n + 6], 23, 76029189);
						m = c(l ^ r ^ p, m, l, g[n + 9], 4, -640364487);
						p = c(m ^ l ^ r, p, m, g[n + 12], 11, -421815835);
						r = c(p ^ m ^ l, r, p, g[n + 15], 16, 530742520);
						l = c(r ^ p ^ m, l, r, g[n + 2], 23, -995338651);
						m = k(m, l, r, p, g[n + 0], 6, -198630844);
						p = k(p, m, l, r, g[n + 7], 10, 1126891415);
						r = k(r, p, m, l, g[n + 14], 15, -1416354905);
						l = k(l, r, p, m, g[n + 5], 21, -57434055);
						m = k(m, l, r, p, g[n + 12], 6, 1700485571);
						p = k(p, m, l, r, g[n + 3], 10, -1894986606);
						r = k(r, p, m, l, g[n + 10], 15,
							-1051523);
						l = k(l, r, p, m, g[n + 1], 21, -2054922799);
						m = k(m, l, r, p, g[n + 8], 6, 1873313359);
						p = k(p, m, l, r, g[n + 15], 10, -30611744);
						r = k(r, p, m, l, g[n + 6], 15, -1560198380);
						l = k(l, r, p, m, g[n + 13], 21, 1309151649);
						m = k(m, l, r, p, g[n + 4], 6, -145523070);
						p = k(p, m, l, r, g[n + 11], 10, -1120210379);
						r = k(r, p, m, l, g[n + 2], 15, 718787259);
						l = k(l, r, p, m, g[n + 9], 21, -343485551);
						m = b(m, t);
						l = b(l, h);
						r = b(r, q);
						p = b(p, u)
					}
					g = [m, l, r, p];
					switch (f) {
						case v.Raw:
							return g;
						case v.Hex:
							f = [];
							for (let n = 0, t = 4 * g.length; n < t; n++) f.push("0123456789abcdef".charAt(g[n >> 2] >> n % 4 * 8 + 4 & 15) + "0123456789abcdef".charAt(g[n >>
								2] >> n % 4 * 8 & 15));
							return f.join("");
						case v.String:
							f = [];
							for (let n = 0, t = 32 * g.length; n < t; n += 8) f.push(String.fromCharCode(g[n >> 5] >>> n % 32 & 255));
							return f.join("");
						case v.Base64:
							f = [];
							for (let n = 0, t = 4 * g.length; n < t; n += 3)
								for (m = (g[n >> 2] >> n % 4 * 8 & 255) << 16 | (g[n + 1 >> 2] >> (n + 1) % 4 * 8 & 255) << 8 | g[n + 2 >> 2] >> (n + 2) % 4 * 8 & 255, l = 0; 4 > l; l++) 8 * n + 6 * l > 32 * g.length ? f.push("\x3d") : f.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(m >> 6 * (3 - l) & 63));
							return f.join("")
					}
				};
				a.outputTypes = v;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/2d/engine/LevelDependentSizeVariable": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/lang ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../core/accessorSupport/decorators/writer ../../../renderers/visualVariables/SizeVariable ../../../renderers/visualVariables/support/sizeVariableUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					var l;
					a.LevelDependentSizeVariable = l = function(r) {
						function p() {
							return r.apply(this, arguments) || this
						}
						b._inheritsLoose(p, r);
						var n = p.prototype;
						n.writeLevels = function(t, h, q) {
							for (const u in t) {
								h.stops = this.levels[u];
								break
							}
						};
						n.clone = function() {
							return new l({
								axis: this.axis,
								field: this.field,
								valueExpression: this.valueExpression,
								valueExpressionTitle: this.valueExpressionTitle,
								maxDataValue: this.maxDataValue,
								maxSize: g.isSizeVariable(this.maxSize) ? this.maxSize.clone() : this.maxSize,
								minDataValue: this.minDataValue,
								minSize: g.isSizeVariable(this.minSize) ? this.minSize.clone() : this.minSize,
								normalizationField: this.normalizationField,
								stops: this.stops && this.stops.map(t => t.clone()),
								target: this.target,
								useSymbolValue: this.useSymbolValue,
								valueRepresentation: this.valueRepresentation,
								valueUnit: this.valueUnit,
								legendOptions: this.legendOptions && this.legendOptions.clone(),
								levels: e.clone(this.levels)
							})
						};
						return p
					}(f);
					c.__decorate([d.property()], a.LevelDependentSizeVariable.prototype, "levels", void 0);
					c.__decorate([m.writer("levels")], a.LevelDependentSizeVariable.prototype, "writeLevels", null);
					a.LevelDependentSizeVariable = l = c.__decorate([v.subclass("esri.views.2d.engine.LevelDependentSizeVariable")], a.LevelDependentSizeVariable);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/mixins/OrderedLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/object ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../support/OrderByInfo".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					function g(r, p, n) {
						if (!r) return null;
						r = r.find(t => !!t.field);
						if (!r) return null;
						p = new f;
						p.read(r, n);
						return [p]
					}

					function l(r, p, n, t) {
						(r = r.find(h => !!h.field)) && e.setDeepValue(n, [r.toJSON()], p)
					}
					a.OrderedLayer = r => {
						r = function(p) {
							function n() {
								var t = p.apply(this, arguments) || this;
								t.orderBy = null;
								return t
							}
							b._inheritsLoose(n, p);
							return n
						}(r);
						c.__decorate([d.property({
							type: [f],
							json: {
								origins: {
									"web-scene": {
										write: !1,
										read: !1
									}
								},
								read: {
									source: "layerDefinition.orderBy",
									reader: g
								},
								write: {
									target: "layerDefinition.orderBy",
									writer: l
								}
							}
						})], r.prototype, "orderBy", void 0);
						return r = c.__decorate([m.subclass("esri.layers.mixins.OrderedLayer")], r)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/OrderByInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/jsonMap ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					c = new c.JSONMap({
						asc: "ascending",
						desc: "descending"
					});
					e = f = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.field = null;
							r.valueExpression = null;
							r.order = "ascending";
							return r
						}
						a._inheritsLoose(l, g);
						l.prototype.clone = function() {
							return new f({
								field: this.field,
								valueExpression: this.valueExpression,
								order: this.order
							})
						};
						return l
					}(e.JSONSupport);
					b.__decorate([d.property({
						type: String,
						json: {
							write: !0
						}
					})], e.prototype, "field", void 0);
					b.__decorate([d.property({
							type: String,
							json: {
								write: !0
							}
						})],
						e.prototype, "valueExpression", void 0);
					b.__decorate([d.property({
						type: c.apiValues,
						json: {
							read: c.read,
							write: c.write
						}
					})], e.prototype, "order", void 0);
					return e = f = b.__decorate([m.subclass("esri.layers.support.OrderByInfo")], e)
				})
		},
		"esri/layers/mixins/PublishableLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../support/PublishingInfo".split(" "),
				function(a, b, c, e, d, k, v, m) {
					const f = Symbol("esri.layers.mixins.PublishableLayer");
					a.PublishableLayer = g => {
						g = function(l) {
							function r() {
								return l.apply(this, arguments) || this
							}
							b._inheritsLoose(r, l);
							r.prototype._checkPublishingStatus = function(p) {
								var n = this;
								let t = 0;
								const h = function() {
										var u = b._asyncToGenerator(function*(x) {
											p.updating = !0;
											let y;
											try {
												y = yield n.fetchPublishingStatus()
											} catch (w) {
												y = "unavailable"
											}
											if ("published" === y || "unavailable" === y) "publishing" === p.status && n.refresh(), q.remove();
											p.status = y;
											p.updating = !1;
											q.removed || (t = setTimeout(h, x, x + 125))
										});
										return function(x) {
											return u.apply(this, arguments)
										}
									}(),
									q = {
										removed: !1,
										remove() {
											this.removed = !0;
											clearTimeout(t)
										}
									};
								this.when()
									.catch(() => q.remove());
								h(250);
								this.own(q)
							};
							b._createClass(r, [{
								key: "publishingInfo",
								get: function() {
									if (this.destroyed) return null;
									var p = this._get("publishingInfo");
									if (p) return p;
									p = new m;
									this._checkPublishingStatus(p);
									return p
								}
							}]);
							return r
						}(g);
						c.__decorate([e.property({
							readOnly: !0,
							clonable: !1
						})], g.prototype, "publishingInfo", null);
						return g =
							c.__decorate([v.subclass("esri.layers.mixins.PublishableLayer")], g)
					};
					a.isPublishableLayer = function(g) {
						return g && "object" === typeof g && f in g
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/support/PublishingInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f() {
							var g = m.apply(this, arguments) || this;
							g.updating = !1;
							g.status = "unknown";
							return g
						}
						a._inheritsLoose(f, m);
						return f
					}(c);
					b.__decorate([e.property()], c.prototype, "updating", void 0);
					b.__decorate([e.property()], c.prototype, "status", void 0);
					return c = b.__decorate([v.subclass("esri.layers.support.PublishingInfo")], c)
				})
		},
		"esri/layers/mixins/TemporalLayer": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../TimeExtent ../../TimeInterval ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../support/fieldUtils ../support/TimeInfo ../../portal/timeUnitKebabDictionary".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					a.TemporalLayer = n => {
						n = function(t) {
							function h() {
								var q = t.apply(this, arguments) || this;
								q.timeExtent = null;
								q.timeOffset = null;
								q.useViewTime = !0;
								return q
							}
							b._inheritsLoose(h, t);
							h.prototype.readOffset = function(q, u) {
								u = u.timeInfo.exportOptions;
								if (!u) return null;
								q = u.timeOffset;
								u = p.timeUnitKebabDictionary.fromJSON(u.timeOffsetUnits);
								return q && u ? new d({
									value: q,
									unit: u
								}) : null
							};
							b._createClass(h, [{
								key: "timeInfo",
								set: function(q) {
									l.fixTimeInfoFields(q, this.fieldsIndex);
									this._set("timeInfo",
										q)
								}
							}]);
							return h
						}(n);
						c.__decorate([k.property({
							type: e,
							json: {
								write: !1
							}
						})], n.prototype, "timeExtent", void 0);
						c.__decorate([k.property({
							type: d
						})], n.prototype, "timeOffset", void 0);
						c.__decorate([f.reader("service", "timeOffset", ["timeInfo.exportOptions"])], n.prototype, "readOffset", null);
						c.__decorate([k.property({
							value: null,
							type: r,
							json: {
								write: !0,
								origins: {
									"web-document": {
										read: !1,
										write: !1
									},
									"portal-item": {
										read: !1,
										write: !1
									}
								}
							}
						})], n.prototype, "timeInfo", null);
						c.__decorate([k.property({
							type: Boolean,
							json: {
								read: {
									source: "timeAnimation"
								},
								write: {
									target: "timeAnimation"
								},
								origins: {
									"web-scene": {
										read: !1,
										write: !1
									}
								}
							}
						})], n.prototype, "useViewTime", void 0);
						return n = c.__decorate([g.subclass("esri.layers.mixins.TemporalLayer")], n)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/TimeInterval": function() {
			define("./chunks/_rollupPluginBabelHelpers ./chunks/tslib.es6 ./core/JSONSupport ./core/timeUtils ./core/accessorSupport/decorators/property ./core/arrayUtils ./core/accessorSupport/ensureType ./core/accessorSupport/decorators/subclass ./portal/timeUnitKebabDictionary".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					var g;
					c = g = function(l) {
						function r(n) {
							n = l.call(this, n) || this;
							n.value = 0;
							n.unit = "milliseconds";
							return n
						}
						a._inheritsLoose(r, l);
						var p = r.prototype;
						p.toMilliseconds = function() {
							return e.convertTime(this.value, this.unit, "milliseconds")
						};
						p.clone = function() {
							return new g({
								value: this.value,
								unit: this.unit
							})
						};
						return r
					}(c.JSONSupport);
					b.__decorate([d.property({
						type: Number,
						json: {
							write: !0
						},
						nonNullable: !0
					})], c.prototype, "value", void 0);
					b.__decorate([d.property({
						type: f.timeUnitKebabDictionary.apiValues,
						json: {
							type: f.timeUnitKebabDictionary.jsonValues,
							read: f.timeUnitKebabDictionary.read,
							write: f.timeUnitKebabDictionary.write
						},
						nonNullable: !0
					})], c.prototype, "unit", void 0);
					return c = g = b.__decorate([m.subclass("esri.TimeInterval")], c)
				})
		},
		"esri/portal/timeUnitKebabDictionary": function() {
			define(["exports", "../core/jsonMap"], function(a, b) {
				b = b.strict()({
					esriTimeUnitsMilliseconds: "milliseconds",
					esriTimeUnitsSeconds: "seconds",
					esriTimeUnitsMinutes: "minutes",
					esriTimeUnitsHours: "hours",
					esriTimeUnitsDays: "days",
					esriTimeUnitsWeeks: "weeks",
					esriTimeUnitsMonths: "months",
					esriTimeUnitsYears: "years",
					esriTimeUnitsDecades: "decades",
					esriTimeUnitsCenturies: "centuries",
					esriTimeUnitsUnknown: void 0
				});
				a.timeUnitKebabDictionary = b;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/TimeInfo": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../TimeExtent ../../TimeInterval ../../core/JSONSupport ../../core/lang ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./TimeReference ../../portal/timeUnitKebabDictionary".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					var t;
					d = t = function(h) {
						function q(x) {
							x = h.call(this, x) || this;
							x.cumulative = !1;
							x.endField = null;
							x.fullTimeExtent = null;
							x.hasLiveData = !1;
							x.interval = null;
							x.startField = null;
							x.timeReference = null;
							x.trackIdField = null;
							x.useTime = !0;
							return x
						}
						a._inheritsLoose(q, h);
						var u = q.prototype;
						u.readFullTimeExtent = function(x, y) {
							return y.timeExtent && Array.isArray(y.timeExtent) && 2 === y.timeExtent.length ? new c({
								start: new Date(y.timeExtent[0]),
								end: new Date(y.timeExtent[1])
							}) : null
						};
						u.writeFullTimeExtent =
							function(x, y) {
								x && v.isSome(x.start) && v.isSome(x.end) ? y.timeExtent = [x.start.getTime(), x.end.getTime()] : y.timeExtent = null
							};
						u.readInterval = function(x, y) {
							return y.timeInterval && y.timeIntervalUnits ? new e({
								value: y.timeInterval,
								unit: n.timeUnitKebabDictionary.fromJSON(y.timeIntervalUnits)
							}) : y.defaultTimeInterval && y.defaultTimeIntervalUnits ? new e({
								value: y.defaultTimeInterval,
								unit: n.timeUnitKebabDictionary.fromJSON(y.defaultTimeIntervalUnits)
							}) : null
						};
						u.writeInterval = function(x, y) {
							x ? (x = x.toJSON(), y.timeInterval =
								x.value, y.timeIntervalUnits = x.unit) : (y.timeInterval = null, y.timeIntervalUnits = null)
						};
						u.clone = function() {
							const {
								cumulative: x,
								endField: y,
								hasLiveData: w,
								interval: A,
								startField: B,
								timeReference: E,
								fullTimeExtent: z,
								trackIdField: C,
								useTime: D
							} = this;
							return new t({
								cumulative: x,
								endField: y,
								hasLiveData: w,
								interval: A,
								startField: B,
								timeReference: k.clone(E),
								fullTimeExtent: k.clone(z),
								trackIdField: C,
								useTime: D
							})
						};
						return q
					}(d.JSONSupport);
					b.__decorate([m.property({
						type: Boolean,
						json: {
							read: {
								source: "exportOptions.timeDataCumulative"
							},
							write: {
								target: "exportOptions.timeDataCumulative"
							}
						}
					})], d.prototype, "cumulative", void 0);
					b.__decorate([m.property({
						type: String,
						json: {
							read: {
								source: "endTimeField"
							},
							write: {
								target: "endTimeField",
								allowNull: !0
							}
						}
					})], d.prototype, "endField", void 0);
					b.__decorate([m.property({
						type: c,
						json: {
							write: {
								enabled: !0,
								allowNull: !0
							}
						}
					})], d.prototype, "fullTimeExtent", void 0);
					b.__decorate([g.reader("fullTimeExtent", ["timeExtent"])], d.prototype, "readFullTimeExtent", null);
					b.__decorate([r.writer("fullTimeExtent")], d.prototype, "writeFullTimeExtent",
						null);
					b.__decorate([m.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], d.prototype, "hasLiveData", void 0);
					b.__decorate([m.property({
						type: e,
						json: {
							write: {
								enabled: !0,
								allowNull: !0
							}
						}
					})], d.prototype, "interval", void 0);
					b.__decorate([g.reader("interval", ["timeInterval", "timeIntervalUnits", "defaultTimeInterval", "defaultTimeIntervalUnits"])], d.prototype, "readInterval", null);
					b.__decorate([r.writer("interval")], d.prototype, "writeInterval", null);
					b.__decorate([m.property({
						type: String,
						json: {
							read: {
								source: "startTimeField"
							},
							write: {
								target: "startTimeField",
								allowNull: !0
							}
						}
					})], d.prototype, "startField", void 0);
					b.__decorate([m.property({
						type: p,
						json: {
							write: {
								enabled: !0,
								allowNull: !0
							}
						}
					})], d.prototype, "timeReference", void 0);
					b.__decorate([m.property({
						type: String,
						json: {
							write: {
								enabled: !0,
								allowNull: !0
							}
						}
					})], d.prototype, "trackIdField", void 0);
					b.__decorate([m.property({
						type: Boolean,
						json: {
							read: {
								source: "exportOptions.useTime"
							},
							write: {
								target: "exportOptions.useTime"
							}
						}
					})], d.prototype, "useTime", void 0);
					return d = t = b.__decorate([l.subclass("esri.layers.support.TimeInfo")],
						d)
				})
		},
		"esri/layers/support/TimeReference": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m) {
				var f;
				c = f = function(g) {
					function l(p) {
						p = g.call(this, p) || this;
						p.respectsDaylightSaving = !1;
						p.timezone = null;
						return p
					}
					a._inheritsLoose(l,
						g);
					var r = l.prototype;
					r.readRespectsDaylightSaving = function(p, n) {
						return void 0 !== n.respectsDaylightSaving ? n.respectsDaylightSaving : void 0 !== n.respectDaylightSaving ? n.respectDaylightSaving : !1
					};
					r.clone = function() {
						const {
							respectsDaylightSaving: p,
							timezone: n
						} = this;
						return new f({
							respectsDaylightSaving: p,
							timezone: n
						})
					};
					return l
				}(c.JSONSupport);
				b.__decorate([e.property({
					type: Boolean,
					json: {
						write: !0
					}
				})], c.prototype, "respectsDaylightSaving", void 0);
				b.__decorate([v.reader("respectsDaylightSaving", ["respectsDaylightSaving",
					"respectDaylightSaving"
				])], c.prototype, "readRespectsDaylightSaving", null);
				b.__decorate([e.property({
					type: String,
					json: {
						read: {
							source: "timeZone"
						},
						write: {
							target: "timeZone"
						}
					}
				})], c.prototype, "timezone", void 0);
				return c = f = b.__decorate([m.subclass("esri.layers.support.TimeReference")], c)
			})
		},
		"esri/layers/support/FeatureTemplate": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/jsonMap ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					e = new e.JSONMap({
						esriFeatureEditToolAutoCompletePolygon: "auto-complete-polygon",
						esriFeatureEditToolCircle: "circle",
						esriFeatureEditToolEllipse: "ellipse",
						esriFeatureEditToolFreehand: "freehand",
						esriFeatureEditToolLine: "line",
						esriFeatureEditToolNone: "none",
						esriFeatureEditToolPoint: "point",
						esriFeatureEditToolPolygon: "polygon",
						esriFeatureEditToolRectangle: "rectangle",
						esriFeatureEditToolArrow: "arrow",
						esriFeatureEditToolTriangle: "triangle",
						esriFeatureEditToolLeftArrow: "left-arrow",
						esriFeatureEditToolRightArrow: "right-arrow",
						esriFeatureEditToolUpArrow: "up-arrow",
						esriFeatureEditToolDownArrow: "down-arrow"
					});
					c = function(g) {
						function l(r) {
							r = g.call(this, r) || this;
							r.name = null;
							r.description = null;
							r.drawingTool = null;
							r.prototype = null;
							r.thumbnail = null;
							return r
						}
						a._inheritsLoose(l, g);
						return l
					}(c.ClonableMixin(d.JSONSupport));
					b.__decorate([k.property({
						json: {
							write: !0
						}
					})], c.prototype, "name", void 0);
					b.__decorate([k.property({
						json: {
							write: !0
						}
					})], c.prototype, "description", void 0);
					b.__decorate([k.property({
						json: {
							read: e.read,
							write: e.write
						}
					})], c.prototype, "drawingTool", void 0);
					b.__decorate([k.property({
						json: {
							write: !0
						}
					})], c.prototype, "prototype", void 0);
					b.__decorate([k.property({
						json: {
							write: !0
						}
					})], c.prototype, "thumbnail", void 0);
					return c = b.__decorate([f.subclass("esri.layers.support.FeatureTemplate")], c)
				})
		},
		"esri/layers/support/FeatureType": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Clonable ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/reader ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ./domains ./FeatureTemplate".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r) {
					c = function(p) {
						function n(h) {
							h = p.call(this, h) || this;
							h.id = null;
							h.name = null;
							h.domains = null;
							h.templates = null;
							return h
						}
						a._inheritsLoose(n, p);
						var t = n.prototype;
						t.readDomains = function(h) {
							const q = {};
							for (const u of Object.keys(h)) q[u] = l.fromJSON(h[u]);
							return q
						};
						t.writeDomains = function(h, q) {
							const u = {};
							for (const x of Object.keys(h)) h[x] && (u[x] = h[x] ? .toJSON());
							q.domains = u
						};
						return n
					}(c.ClonableMixin(e.JSONSupport));
					b.__decorate([d.property({
							json: {
								write: !0
							}
						})], c.prototype, "id",
						void 0);
					b.__decorate([d.property({
						json: {
							write: !0
						}
					})], c.prototype, "name", void 0);
					b.__decorate([d.property({
						json: {
							write: !0
						}
					})], c.prototype, "domains", void 0);
					b.__decorate([m.reader("domains")], c.prototype, "readDomains", null);
					b.__decorate([g.writer("domains")], c.prototype, "writeDomains", null);
					b.__decorate([d.property({
						type: [r],
						json: {
							write: !0
						}
					})], c.prototype, "templates", void 0);
					return c = b.__decorate([f.subclass("esri.layers.support.FeatureType")], c)
				})
		},
		"esri/layers/support/fieldProperties": function() {
			define(["exports",
				"../../core/Logger", "./Field", "./FieldsIndex", "./fieldUtils"
			], function(a, b, c, e, d) {
				a.defineFieldProperties = function() {
					return {
						fields: {
							type: [c],
							value: null
						},
						fieldsIndex: {
							readOnly: !0,
							get() {
								return new e(this.fields || [])
							}
						},
						outFields: {
							type: [String],
							json: {
								read: !1
							},
							set: function(k) {
								this._userOutFields = k;
								this.notifyChange("outFields")
							},
							get: function() {
								const k = this._userOutFields;
								if (!k || !k.length) return null;
								if (k.includes("*")) return ["*"];
								if (!this.fields) return k;
								for (const v of k) this.fieldsIndex ? .has(v) || b.getLogger("esri.layers.support.fieldProperties")
									.error("field-attributes-layer:invalid-field",
										`Invalid field ${v} found in outFields`, {
											layer: this,
											outFields: k
										});
								return d.fixFields(this.fieldsIndex, k)
							}
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/FieldsIndex": function() {
			define(["../../chunks/_rollupPluginBabelHelpers", "./fieldUtils"], function(a, b) {
				function c(d) {
					return "oid" === d.type || "esriFieldTypeOID" === d.type
				}

				function e(d) {
					return "global-id" === d.type || "esriFieldTypeGlobalID" === d.type
				}
				return function() {
					function d(v = []) {
						this.fields = [];
						this._fieldsMap = new Map;
						this._normalizedFieldsMap = new Map;
						this._dateFieldsSet = new Set;
						this._numericFieldsSet = new Set;
						this.dateFields = [];
						this.numericFields = [];
						this._requiredFields = null;
						if (v) {
							this.fields = v;
							var m = [];
							for (const f of v)
								if (v = f && f.name) {
									const g = v.trim()
										.toLowerCase(),
										l = b.normalizeFieldName(v)
										.toLowerCase();
									this._fieldsMap.set(v, f);
									this._fieldsMap.set(g, f);
									this._normalizedFieldsMap.set(l, f);
									m.push(g);
									"date" === f.type || "esriFieldTypeDate" === f.type ? (this.dateFields.push(f), this._dateFieldsSet.add(f)) :
										b.isNumericField(f) && (this._numericFieldsSet.add(f), this.numericFields.push(f));
									c(f) || e(f) || (f.editable = null == f.editable ? !0 : !!f.editable, f.nullable = null == f.nullable ? !0 : !!f.nullable)
								} m.sort();
							this.uid = m.join(",")
						}
					}
					var k = d.prototype;
					k.destroy = function() {
						this._fieldsMap.clear()
					};
					k.has = function(v) {
						return null != this.get(v)
					};
					k.get = function(v) {
						if (v) {
							var m = this._fieldsMap.get(v);
							if (m) return m;
							(m = this._fieldsMap.get(v.trim()
								.toLowerCase()) ? ? this._normalizedFieldsMap.get(b.normalizeFieldName(v)
								.toLowerCase())) &&
							this._fieldsMap.set(v, m);
							return m
						}
					};
					k.isDateField = function(v) {
						return this._dateFieldsSet.has(this.get(v))
					};
					k.isNumericField = function(v) {
						return this._numericFieldsSet.has(this.get(v))
					};
					k.normalizeFieldName = function(v) {
						if (v = this.get(v)) return v.name ? ? void 0
					};
					a._createClass(d, [{
						key: "requiredFields",
						get: function() {
							if (!this._requiredFields) {
								this._requiredFields = [];
								for (const v of this.fields) c(v) || e(v) || v.nullable || void 0 !== b.getFieldDefaultValue(v) || this._requiredFields.push(v)
							}
							return this._requiredFields
						}
					}]);
					return d
				}()
			})
		},
		"esri/layers/support/labelingInfo": function() {
			define(["exports", "../../core/Error", "../../core/lang", "../../core/Logger", "./LabelClass"], function(a, b, c, e, d) {
				const k = e.getLogger("esri.layers.support.labelingInfo"),
					v = /\[([^\[\]]+)\]/gi,
					m = {
						esriGeometryPoint: "above-right above-center above-left center-center center-left center-right below-center below-left below-right".split(" "),
						esriGeometryPolygon: ["always-horizontal"],
						esriGeometryPolyline: ["center-along"],
						esriGeometryMultipoint: null
					};
				a.reader = function(f, g, l) {
					return f ? f.map(r => {
						const p = new d;
						p.read(r, l);
						if (p.labelExpression) {
							const n = g.fields || g.layerDefinition && g.layerDefinition.fields || this.fields;
							p.labelExpression = p.labelExpression.replace(v, (t, h) => {
								a: if (n) {
									t = h.toLowerCase();
									for (let q = 0; q < n.length; q++) {
										const u = n[q].name;
										if (u.toLowerCase() === t) {
											h = u;
											break a
										}
									}
								}return `[${h}]`
							})
						}
						return p
					}) : null
				};
				a.validateLabelingInfo = function(f, g) {
					f = c.clone(f);
					return f.some(l => {
						{
							const p = l.labelPlacement;
							var r = m[g];
							l.symbol ? r ? (r.includes(p) || (r = r[0],
								p && k.warn(`Found invalid label placement type ${p} for ${g}. Defaulting to ${r}`), l.labelPlacement = r), l = !1) : (k.error(new b("labeling:unsupported-geometry-type", `Unable to create labels for layer, geometry type '${g}' is not supported`)), l = !0) : (k.warn("No ILabelClass symbol specified."), l = !0)
						}
						return l
					}) ? [] : f
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/versionUtils": function() {
			define(["exports", "./arcgisLayerUrl"], function(a, b) {
				const c = [];
				c.push([10.91, () => {
					const e = new Set([9709, 9716, 9741, 9761, 9766]);
					for (var d = 9712; 9713 >= d; d++) e.add(d);
					for (d = 9748; 9749 >= d; d++) e.add(d);
					for (d = 20904; 20932 >= d; d++) e.add(d);
					for (d = 21004; 21032 >= d; d++) e.add(d);
					for (d = 21207; 21264 >= d; d++) e.add(d);
					for (d = 21307; 21364 >= d; d++) e.add(d);
					for (d = 102759; 102760 >= d; d++) e.add(d);
					for (d = 102901; 102955 >= d; d++) e.add(d);
					return e
				}]);
				c.push([10.9, () => {
					const e = new Set([9300, 9354, 9364, 9367, 9373, 9377, 9387, 9456, 9473, 9498, 9678, 9680, 29874, 103599, 103872, 104028]);
					for (var d = 9356; 9360 >= d; d++) e.add(d);
					for (d = 9404; 9407 >= d; d++) e.add(d);
					for (d = 9476; 9482 >= d; d++) e.add(d);
					for (d = 9487; 9494 >= d; d++) e.add(d);
					for (d = 9697; 9699 >= d; d++) e.add(d);
					return e
				}]);
				c.push([10.81, () => {
					const e = new Set([9265, 9333, 103598, 103699]);
					for (var d = 9248; 9254 >= d; d++) e.add(d);
					for (d = 9271; 9273 >= d; d++) e.add(d);
					for (d = 9284; 9285 >= d; d++) e.add(d);
					for (d = 21453; 21463 >= d; d++) e.add(d);
					return e
				}]);
				c.push([10.8, () => {
					const e = new Set([8088, 8395, 8428, 8433, 8531, 8687, 8692, 8694, 8699, 8900, 9003, 9006, 9009, 9012, 9017, 9191]);
					for (var d = 8035; 8036 >= d; d++) e.add(d);
					for (d = 8455; 8456 >= d; d++) e.add(d);
					for (d = 8518; 8529 >= d; d++) e.add(d);
					for (d = 8533; 8536 >= d; d++) e.add(d);
					for (d = 8538; 8540 >= d; d++) e.add(d);
					for (d = 8677; 8679 >= d; d++) e.add(d);
					for (d = 8902; 8903 >= d; d++) e.add(d);
					for (d = 8907; 8910 >= d; d++) e.add(d);
					for (d = 8949; 8951 >= d; d++) e.add(d);
					for (d = 8972; 8987 >= d; d++) e.add(d);
					for (d = 9039; 9040 >= d; d++) e.add(d);
					for (d = 9068; 9069 >= d; d++) e.add(d);
					for (d = 9140; 9141 >= d; d++) e.add(d);
					for (d = 9148; 9150 >= d; d++) e.add(d);
					for (d = 9153; 9159 >= d; d++) e.add(d);
					for (d = 9205; 9218 >= d; d++) e.add(d);
					for (d = 9221; 9222 >= d; d++) e.add(d);
					for (d = 54098; 54101 >= d; d++) e.add(d);
					return e
				}]);
				c.push([10.71, () => {
					const e = new Set([6316]);
					for (var d = 8351; 8353 >= d; d++) e.add(d);
					for (d = 9294; 9297 >= d; d++) e.add(d);
					for (d = 103586; 103594 >= d; d++) e.add(d);
					for (d = 103696; 103698 >= d; d++) e.add(d);
					return e
				}]);
				c.push([10.7, () => {
					const e = new Set([8387, 8391, 8427, 8545, 8682, 8685, 8818, 31370, 104022, 104024, 104975]);
					for (var d = 8065; 8068 >= d; d++) e.add(d);
					for (d = 8082; 8083 >= d; d++) e.add(d);
					for (d = 8379; 8385 >= d; d++) e.add(d);
					for (d = 8836; 8840 >= d; d++) e.add(d);
					for (d = 8857; 8860 >= d; d++) e.add(d);
					for (d = 53035; 53037 >= d; d++) e.add(d);
					for (d = 54090; 54091 >= d; d++) e.add(d);
					for (d = 102498; 102499 >= d; d++) e.add(d);
					return e
				}]);
				c.push([10.61, () => new Set([102497])]);
				c.push([10.6, () => {
					const e = new Set([7803, 7805, 7887, 8086, 8232, 8237, 8240, 8246, 8249, 8252, 8255, 9019, 9391]);
					for (var d = 7755; 7787 >= d; d++) e.add(d);
					for (d = 7791; 7795 >= d; d++) e.add(d);
					for (d = 7799; 7801 >= d; d++) e.add(d);
					for (d = 7825; 7831 >= d; d++) e.add(d);
					for (d = 7877; 7878 >= d; d++) e.add(d);
					for (d = 7882; 7883 >= d; d++) e.add(d);
					for (d = 7991; 7992 >= d; d++) e.add(d);
					for (d = 8042; 8043 >=
						d; d++) e.add(d);
					for (d = 8058; 8059 >= d; d++) e.add(d);
					for (d = 8311; 8348 >= d; d++) e.add(d);
					for (d = 9060; 9067 >= d; d++) e.add(d);
					for (d = 102562; 102568 >= d; d++) e.add(d);
					for (d = 102799; 102900 >= d; d++) e.add(d);
					return e
				}]);
				c.push([10.51, () => {
					const e = new Set([7683, 7881, 7886, 7899, 8888, 9E3]);
					for (var d = 8013; 8032 >= d; d++) e.add(d);
					for (d = 9053; 9057 >= d; d++) e.add(d);
					for (d = 104017; 104018 >= d; d++) e.add(d);
					for (d = 104971; 104974 >= d; d++) e.add(d);
					return e
				}]);
				c.push([10.5, () => {
					const e = new Set([6962, 7035, 7037, 7039, 7041, 7084, 7086, 7133, 7798, 102399]);
					for (var d = 4087; 4088 >= d; d++) e.add(d);
					for (d = 5896; 5899 >= d; d++) e.add(d);
					for (d = 7005; 7007 >= d; d++) e.add(d);
					for (d = 7057; 7070 >= d; d++) e.add(d);
					for (d = 7073; 7082 >= d; d++) e.add(d);
					for (d = 7109; 7128 >= d; d++) e.add(d);
					for (d = 7844; 7859 >= d; d++) e.add(d);
					return e
				}]);
				a.serviceSupportsSpatialReference = function(e, d) {
					if (b.isHostedAgolService(e.url ? ? "")) return !0;
					({
						wkid: d
					} = d);
					for (const k of c) {
						if ((e.version ? ? 0) >= k[0]) break;
						"function" === typeof k[1] && (k[1] = k[1]());
						if (k[1].has(d)) return !1
					}
					return !0
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/support/TopFeaturesQuery": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../geometry ../../TimeExtent ../../core/jsonMap ../../core/JSONSupport ../../core/lang ../../core/maybe ../../core/accessorSupport/decorators/property ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../core/accessorSupport/decorators/writer ../../geometry/support/jsonUtils ./TopFilter ../../geometry/SpatialReference".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					var h;
					const q = new d.JSONMap({
						esriSpatialRelIntersects: "intersects",
						esriSpatialRelContains: "contains",
						esriSpatialRelCrosses: "crosses",
						esriSpatialRelDisjoint: "disjoint",
						esriSpatialRelEnvelopeIntersects: "envelope-intersects",
						esriSpatialRelIndexIntersects: "index-intersects",
						esriSpatialRelOverlaps: "overlaps",
						esriSpatialRelTouches: "touches",
						esriSpatialRelWithin: "within",
						esriSpatialRelRelation: "relation"
					});
					d = new d.JSONMap({
						esriSRUnit_Meter: "meters",
						esriSRUnit_Kilometer: "kilometers",
						esriSRUnit_Foot: "feet",
						esriSRUnit_StatuteMile: "miles",
						esriSRUnit_NauticalMile: "nautical-miles",
						esriSRUnit_USNauticalMile: "us-nautical-miles"
					});
					k = h = function(u) {
						function x(w) {
							w = u.call(this, w) || this;
							w.cacheHint = void 0;
							w.distance = void 0;
							w.geometry = null;
							w.geometryPrecision = void 0;
							w.maxAllowableOffset = void 0;
							w.num = void 0;
							w.objectIds = null;
							w.orderByFields = null;
							w.outFields = null;
							w.outSpatialReference = null;
							w.resultType = null;
							w.returnGeometry = !1;
							w.returnM = void 0;
							w.returnZ = void 0;
							w.start = void 0;
							w.spatialRelationship =
								"intersects";
							w.timeExtent = null;
							w.topFilter = void 0;
							w.units = null;
							w.where = "1\x3d1";
							return w
						}
						a._inheritsLoose(x, u);
						var y = x.prototype;
						y.writeStart = function(w, A) {
							A.resultOffset = this.start;
							A.resultRecordCount = this.num || 10
						};
						y.clone = function() {
							return new h(v.clone({
								cacheHint: this.cacheHint,
								distance: this.distance,
								geometry: this.geometry,
								geometryPrecision: this.geometryPrecision,
								maxAllowableOffset: this.maxAllowableOffset,
								num: this.num,
								objectIds: this.objectIds,
								orderByFields: this.orderByFields,
								outFields: this.outFields,
								outSpatialReference: this.outSpatialReference,
								resultType: this.resultType,
								returnGeometry: this.returnGeometry,
								returnZ: this.returnZ,
								returnM: this.returnM,
								start: this.start,
								spatialRelationship: this.spatialRelationship,
								timeExtent: this.timeExtent,
								topFilter: this.topFilter,
								units: this.units,
								where: this.where
							}))
						};
						return x
					}(k.JSONSupport);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: !0
						}
					})], k.prototype, "cacheHint", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							write: {
								overridePolicy(u) {
									return {
										enabled: 0 <
											u
									}
								}
							}
						}
					})], k.prototype, "distance", void 0);
					b.__decorate([f.property({
						types: c.geometryTypes,
						json: {
							read: p.fromJSON,
							write: !0
						}
					})], k.prototype, "geometry", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "geometryPrecision", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							write: !0
						}
					})], k.prototype, "maxAllowableOffset", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							read: {
								source: "resultRecordCount"
							}
						}
					})], k.prototype, "num", void 0);
					b.__decorate([f.property({
							json: {
								write: !0
							}
						})],
						k.prototype, "objectIds", void 0);
					b.__decorate([f.property({
						type: [String],
						json: {
							write: !0
						}
					})], k.prototype, "orderByFields", void 0);
					b.__decorate([f.property({
						type: [String],
						json: {
							write: !0
						}
					})], k.prototype, "outFields", void 0);
					b.__decorate([f.property({
						type: t,
						json: {
							read: {
								source: "outSR"
							},
							write: {
								target: "outSR"
							}
						}
					})], k.prototype, "outSpatialReference", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "resultType", void 0);
					b.__decorate([f.property({
							json: {
								write: !0
							}
						})], k.prototype, "returnGeometry",
						void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(u) {
									return {
										enabled: u
									}
								}
							}
						}
					})], k.prototype, "returnM", void 0);
					b.__decorate([f.property({
						type: Boolean,
						json: {
							write: {
								overridePolicy(u) {
									return {
										enabled: u
									}
								}
							}
						}
					})], k.prototype, "returnZ", void 0);
					b.__decorate([f.property({
						type: Number,
						json: {
							read: {
								source: "resultOffset"
							}
						}
					})], k.prototype, "start", void 0);
					b.__decorate([r.writer("start"), r.writer("num")], k.prototype, "writeStart", null);
					b.__decorate([f.property({
						type: String,
						json: {
							read: {
								source: "spatialRel",
								reader: q.read
							},
							write: {
								target: "spatialRel",
								writer: q.write
							}
						}
					})], k.prototype, "spatialRelationship", void 0);
					b.__decorate([f.property({
						type: e,
						json: {
							write: !0
						}
					})], k.prototype, "timeExtent", void 0);
					b.__decorate([f.property({
						type: n,
						json: {
							write: !0
						}
					})], k.prototype, "topFilter", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							read: d.read,
							write: {
								writer: d.write,
								overridePolicy(u) {
									return {
										enabled: m.isSome(u) && m.isSome(this.distance) && 0 < this.distance
									}
								}
							}
						}
					})], k.prototype, "units", void 0);
					b.__decorate([f.property({
						type: String,
						json: {
							write: !0
						}
					})], k.prototype, "where", void 0);
					k = h = b.__decorate([l.subclass("esri.rest.support.TopFeaturesQuery")], k);
					k.from = g.ensureType(k);
					return k
				})
		},
		"esri/rest/support/TopFilter": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/JSONSupport ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v) {
				var m;
				c = m = function(f) {
					function g(l) {
						l =
							f.call(this, l) || this;
						l.groupByFields = void 0;
						l.topCount = void 0;
						l.orderByFields = void 0;
						return l
					}
					a._inheritsLoose(g, f);
					g.prototype.clone = function() {
						return new m({
							groupByFields: this.groupByFields,
							topCount: this.topCount,
							orderByFields: this.orderByFields
						})
					};
					return g
				}(c.JSONSupport);
				b.__decorate([e.property({
					type: [String],
					json: {
						write: !0
					}
				})], c.prototype, "groupByFields", void 0);
				b.__decorate([e.property({
					type: Number,
					json: {
						write: !0
					}
				})], c.prototype, "topCount", void 0);
				b.__decorate([e.property({
						type: [String],
						json: {
							write: !0
						}
					})],
					c.prototype, "orderByFields", void 0);
				return c = m = b.__decorate([v.subclass("esri.rest.support.TopFilter")], c)
			})
		},
		"esri/support/popupUtils": function() {
			define("exports ../PopupTemplate ../layers/support/fieldUtils ../popup/content/AttachmentsContent ../popup/content/Content ../popup/content/CustomContent ../popup/content/ExpressionContent ../popup/content/FieldsContent ../popup/content/MediaContent ../popup/content/RelationshipContent ../popup/content/TextContent ../popup/FieldInfo ../popup/support/FieldInfoFormat".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					function n(D, J) {
						const K = D;
						J && (D = D.filter(H => !J.includes(H.type)));
						D === K && (D = D.slice());
						D.sort(t);
						return D
					}

					function t(D, J) {
						return "oid" === D.type ? -1 : "oid" === J.type ? 1 : w(D) ? -1 : w(J) ? 1 : (D.alias || D.name)
							.toLocaleLowerCase()
							.localeCompare((J.alias || J.name)
								.toLocaleLowerCase())
					}

					function h(D, J) {
						if (!D || !J) return !1;
						const {
							creationDateField: K,
							creatorField: H,
							editDateField: G,
							editorField: F
						} = J;
						return [K && K.toLowerCase(), H && H.toLowerCase(), G && G.toLowerCase(), F && F.toLowerCase()].includes(D.toLowerCase())
					}

					function q({
						editFieldsInfo: D,
						fields: J,
						objectIdField: K
					}, H) {
						return n(J ? ? [], H ? .ignoreFieldTypes || C)
							.map(G => {
								var F = G.name;
								var L = G.editable && !B.includes(G.type) && !h(G.name, D);
								return new r({
									fieldName: F,
									isEditable: L,
									label: G.alias,
									format: y(G),
									visible: z(G, {
										editFieldsInfo: D,
										objectIdField: K,
										visibleFieldNames: H ? .visibleFieldNames
									})
								})
							})
					}

					function u(D, J) {
						return D.map(K => new r({
							fieldName: K.name,
							isEditable: !1,
							label: K.alias,
							format: x(K, J),
							visible: !0
						}))
					}

					function x(D, J) {
						const {
							onStatisticField: K,
							onStatisticExpression: H,
							statisticType: G
						} = D;
						return K && (D = J.find(F => K === F.name)) ? y(D) : "number" === H ? .returnType ? new p({
							digitSeparator: !0,
							places: 2
						}) : "count" === G ? new p({
							digitSeparator: !0,
							places: 0
						}) : null
					}

					function y(D) {
						switch (D.type) {
							case "small-integer":
							case "integer":
							case "single":
								return new p({
									digitSeparator: !0,
									places: 0
								});
							case "double":
								return new p({
									digitSeparator: !0,
									places: 2
								});
							case "date":
								return new p({
									dateFormat: "long-month-day-year"
								});
							default:
								return "string" === D.type && c.isRasterPixelValueField(D.name) ? new p({
									digitSeparator: !0,
									places: 0
								}) : null
						}
					}

					function w(D) {
						return "name" === (D.name && D.name.toLowerCase()) || "name" === (D.alias && D.alias.toLowerCase()) ? !0 : !1
					}
					const A = ["oid", "global-id"],
						B = ["oid", "global-id", "guid"],
						E = [/^fnode_$/i, /^tnode_$/i, /^lpoly_$/i, /^rpoly_$/i, /^poly_$/i, /^subclass$/i, /^subclass_$/i, /^rings_ok$/i, /^rings_nok$/i, /shape/i, /perimeter/i, /objectid/i, /_i$/i],
						z = (D, {
							editFieldsInfo: J,
							objectIdField: K,
							visibleFieldNames: H
						}) => H ? H.has(D.name) : h(D.name, J) ? !1 : K && D.name === K ? !1 : A.includes(D.type) ? !1 : !E.some(G => G.test(D.name)),
						C = ["geometry", "blob", "raster", "guid", "xml"];
					a.createFieldInfos = q;
					a.createFieldsContent = function(D, J) {
						return new m({
							fieldInfos: q(D, J)
								.filter(K => K.visible)
						})
					};
					a.createPopupTemplate = function({
						displayField: D,
						editFieldsInfo: J,
						fields: K,
						objectIdField: H,
						title: G
					}, F) {
						if (!K) return null;
						J = q({
							editFieldsInfo: J,
							fields: K,
							objectIdField: H
						}, F);
						if (!J.length) return null;
						K = {
							titleBase: G,
							fields: K,
							displayField: D
						};
						D = c.getDisplayFieldName(K);
						({
							titleBase: K
						} = K);
						D = D ? `${K}: {${D.trim()}}` : K ? ? "";
						K = [new m, new e];
						return new b({
							title: D,
							content: K,
							fieldInfos: J
						})
					};
					a.createPopupTemplateForFeatureReduction = function(D) {
						const {
							fields: J,
							featureReduction: K,
							title: H
						} = D;
						D = K.fields;
						if (!D) return null;
						D = u(D, J);
						if (!D.length) return null;
						var G = [new m];
						return new b({
							title: H,
							content: G,
							fieldInfos: D
						})
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/graphics/sources/FeatureLayerSource": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../geometry ../../../Graphic ../../../request ../../../TimeExtent ../../../core/Error ../../../core/has ../../../core/jsonMap ../../../core/Loadable ../../../core/maybe ../../../core/object ../../../core/promiseUtils ../../../core/urlUtils ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../geometry/Extent ../../../geometry/support/jsonUtils ../assetEditingSupport ./support/clientSideDefaults ./support/QueryTask ../../support/arcgisLayerUrl ../../../rest/query/operations/editsZScale ../../../rest/query/operations/queryAttachments ../../../geometry/SpatialReference".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D) {
					function J(L) {
						return K.apply(this, arguments)
					}

					function K() {
						K = a._asyncToGenerator(function*(L) {
							if ("string" === typeof L) {
								const R = n.dataComponents(L);
								return R ? R : {
									data: L
								}
							}
							return new Promise((R, V) => {
								const U = new FileReader;
								U.readAsDataURL(L);
								U.onload = () => R(n.dataComponents(U.result));
								U.onerror = W => V(W)
							})
						});
						return K.apply(this, arguments)
					}
					const H = new f.JSONMap({
							originalAndCurrentFeatures: "original-and-current-features",
							none: "none"
						}),
						G = new Set(["Feature Layer",
							"Table"
						]),
						F = new f.JSONMap({
							Started: "published",
							Publishing: "publishing",
							Stopped: "unavailable"
						});
					c = function(L) {
						function R() {
							var U = L.apply(this, arguments) || this;
							U.type = "feature-layer";
							U.refresh = p.debounce(a._asyncToGenerator(function*() {
								yield U.load();
								var W = U.sourceJSON.editingInfo ? .lastEditDate;
								if (null == W) return {
									dataChanged: !0,
									updates: {}
								};
								try {
									yield U._fetchService(null)
								} catch {
									return {
										dataChanged: !0,
										updates: {}
									}
								}
								W = W !== U.sourceJSON.editingInfo ? .lastEditDate;
								return {
									dataChanged: W,
									updates: W ? {
										editingInfo: U.sourceJSON.editingInfo,
										extent: U.sourceJSON.extent
									} : null
								}
							}));
							return U
						}
						a._inheritsLoose(R, L);
						var V = R.prototype;
						V.load = function(U) {
							U = l.isSome(U) ? U.signal : null;
							this.addResolvingPromise(this._fetchService(this.layer.sourceJSON, U));
							return Promise.resolve(this)
						};
						V.addAttachment = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								W = W.attributes[this.layer.objectIdField];
								const T = this.layer.parsedUrl.path + "/" + W + "/addAttachment",
									Z = this._getLayerRequestOptions();
								M = this._getFormDataForAttachment(M, Z.query);
								try {
									const oa =
										yield d(T, {
											body: M
										});
									return this._createFeatureEditResult(oa.data.addAttachmentResult)
								} catch (oa) {
									throw this._createAttachmentErrorResult(W, oa);
								}
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.updateAttachment = function() {
							var U = a._asyncToGenerator(function*(W, M, T) {
								yield this.load();
								W = W.attributes[this.layer.objectIdField];
								const Z = this.layer.parsedUrl.path + "/" + W + "/updateAttachment";
								M = this._getLayerRequestOptions({
									query: {
										attachmentId: M
									}
								});
								T = this._getFormDataForAttachment(T, M.query);
								try {
									const oa =
										yield d(Z, {
											body: T
										});
									return this._createFeatureEditResult(oa.data.updateAttachmentResult)
								} catch (oa) {
									throw this._createAttachmentErrorResult(W, oa);
								}
							});
							return function(W, M, T) {
								return U.apply(this, arguments)
							}
						}();
						V.applyEdits = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								const T = this.layer.infoFor3D;
								var Z = l.isSome(T),
									oa = Z || M ? .globalIdUsed,
									qa = W.addFeatures.map(N => this._serializeFeature(N, T)),
									Aa = W.updateFeatures.map(N => this._serializeFeature(N, T));
								const Ka = this._getFeatureIds(W.deleteFeatures,
									oa);
								z.unapplyEditsZUnitScaling(qa, Aa, this.layer.spatialReference);
								var da = [],
									ja = [],
									sa = [...W.deleteAttachments];
								for (const N of W.addAttachments) da.push(yield this._serializeAttachment(N));
								for (const N of W.updateAttachments) ja.push(yield this._serializeAttachment(N));
								ja = da.length || ja.length || sa.length ? {
									adds: da,
									updates: ja,
									deletes: sa
								} : null;
								sa = void 0;
								da = null;
								if (Z) {
									da = new Map;
									sa = [];
									for (const N of W.addAssets) sa.push(this._serializeAssetMapEditAndUploadAssets(N, da));
									W = yield Promise.all(sa);
									sa = W.length ? {
										adds: W,
										updates: [],
										deletes: []
									} : void 0
								}
								W = {
									gdbVersion: M ? .gdbVersion || this.layer.gdbVersion,
									rollbackOnFailure: M ? .rollbackOnFailureEnabled,
									useGlobalIds: oa,
									returnEditMoment: M ? .returnEditMoment,
									usePreviousEditMoment: M ? .usePreviousEditMoment,
									sessionId: M ? .sessionId
								};
								M ? .returnServiceEditsOption ? (W.edits = JSON.stringify([{
										id: this.layer.layerId,
										adds: qa,
										updates: Aa,
										deletes: Ka,
										attachments: ja,
										assetMaps: l.unwrap(sa)
									}]), W.returnServiceEditsOption = H.toJSON(M ? .returnServiceEditsOption), W.returnServiceEditsInSourceSR = M ? .returnServiceEditsInSourceSR) :
									(W.adds = qa.length ? JSON.stringify(qa) : null, W.updates = Aa.length ? JSON.stringify(Aa) : null, W.deletes = Ka.length ? oa ? JSON.stringify(Ka) : Ka.join(",") : null, W.attachments = ja && JSON.stringify(ja), W.assetMaps = l.isSome(sa) ? JSON.stringify(sa) : void 0);
								qa = this._getLayerRequestOptions({
									method: "post",
									query: W
								});
								oa = M ? .returnServiceEditsOption ? this.layer.url : this.layer.parsedUrl.path;
								M = yield d(oa + "/applyEdits", qa);
								if (Z && null != M.data && null != M.data.assetMaps) {
									Aa = M.data;
									Z = this.layer.objectIdField;
									qa = [];
									for (var I of Aa.addResults) I.success &&
										qa.push(I.objectId);
									for (const N of Aa.updateResults) N.success && qa.push(N.objectId);
									I = this._createRequestQueryOptions();
									if ((I = yield d(oa + "/query", {
										...I,
										query: {
											f: "json",
											formatOf3DObjects: "3D_glb",
											where: `OBJECTID IN (${qa.join(",")})`,
											outFields: `${Z}`
										}
									})) && I.data && I.data.assetMaps && l.isSome(da)) {
										I = I.data.assetMaps;
										for (const N of I) I = da.get(N.parentGlobalId)
											.geometry, l.isSome(I) && "mesh" === I.type && I.updateExternalSource({
												source: [{
													name: N.assetName,
													source: N.assetName
												}],
												extent: I.extent
											})
									}
								}
								return this._createEditsResult(M)
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.deleteAttachments = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								W = W.attributes[this.layer.objectIdField];
								const T = this.layer.parsedUrl.path + "/" + W + "/deleteAttachments";
								try {
									return (yield d(T, this._getLayerRequestOptions({
											query: {
												attachmentIds: M.join(",")
											},
											method: "post"
										})))
										.data.deleteAttachmentResults.map(this._createFeatureEditResult)
								} catch (Z) {
									throw this._createAttachmentErrorResult(W, Z);
								}
							});
							return function(W, M) {
								return U.apply(this,
									arguments)
							}
						}();
						V.fetchRecomputedExtents = function(U = {}) {
							var W = this;
							return this.load({
									signal: U.signal
								})
								.then(a._asyncToGenerator(function*() {
									var M = W._getLayerRequestOptions({
										...U,
										query: {
											returnUpdates: !0
										}
									});
									const {
										layerId: T,
										url: Z
									} = W.layer;
									({
										data: M
									} = yield d(`${Z}/${T}`, M));
									const {
										id: oa,
										extent: qa,
										fullExtent: Aa,
										timeExtent: Ka
									} = M;
									M = qa || Aa;
									return {
										id: oa,
										fullExtent: M && x.fromJSON(M),
										timeExtent: Ka && k.fromJSON({
											start: Ka[0],
											end: Ka[1]
										})
									}
								}))
						};
						V.queryAttachments = function() {
							var U = a._asyncToGenerator(function*(W, M = {}) {
								const {
									parsedUrl: T
								} =
								this.layer, Z = T.path;
								yield this.load();
								M = this._getLayerRequestOptions(M);
								if (!this.layer.get("capabilities.operations.supportsQueryAttachments")) {
									const {
										objectIds: oa
									} = W;
									W = [];
									for (const qa of oa) W.push(d(Z + "/" + qa + "/attachments", M));
									return Promise.all(W)
										.then(qa => oa.map((Aa, Ka) => ({
											parentObjectId: Aa,
											attachmentInfos: qa[Ka].data.attachmentInfos
										})))
										.then(qa => C.processAttachmentQueryResult(qa, Z))
								}
								return this.queryTask.executeAttachmentQuery(W, M)
							});
							return function(W) {
								return U.apply(this, arguments)
							}
						}();
						V.queryFeatures =
							function() {
								var U = a._asyncToGenerator(function*(W, M) {
									yield this.load();
									return this.queryTask.execute(W, {
										...M,
										query: this._createRequestQueryOptions(M)
									})
								});
								return function(W, M) {
									return U.apply(this, arguments)
								}
							}();
						V.queryFeaturesJSON = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeJSON(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryObjectIds = function() {
							var U = a._asyncToGenerator(function*(W,
								M) {
								yield this.load();
								return this.queryTask.executeForIds(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryFeatureCount = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeForCount(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryExtent = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeForExtent(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryRelatedFeatures = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeRelationshipQuery(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryRelatedFeaturesCount = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeRelationshipQueryForCount(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryTopFeatures = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeTopFeaturesQuery(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryTopObjectIds = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeForTopIds(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryTopExtents = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeForTopExtents(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V.queryTopCount = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								yield this.load();
								return this.queryTask.executeForTopCount(W, {
									...M,
									query: this._createRequestQueryOptions(M)
								})
							});
							return function(W, M) {
								return U.apply(this,
									arguments)
							}
						}();
						V.fetchPublishingStatus = function() {
							var U = a._asyncToGenerator(function*() {
								if (!E.isHostedAgolService(this.layer.url)) return "unavailable";
								var W = n.join(this.layer.url, "status");
								W = yield d(W, {
									query: {
										f: "json"
									}
								});
								return F.fromJSON(W.data.status)
							});
							return function() {
								return U.apply(this, arguments)
							}
						}();
						V._createRequestQueryOptions = function(U) {
							U = {
								...this.layer.customParameters,
								token: this.layer.apiKey,
								...U ? .query
							};
							this.layer.datesInUnknownTimezone && (U.timeReferenceUnknownClient = !0);
							return U
						};
						V._fetchService =
							function() {
								var U = a._asyncToGenerator(function*(W, M) {
									W || ({
										data: W
									} = yield d(this.layer.parsedUrl.path, this._getLayerRequestOptions({
										query: m("featurelayer-advanced-symbols") ? {
											returnAdvancedSymbols: !0
										} : {},
										signal: M
									})));
									this.sourceJSON = this._patchServiceJSON(W);
									W = W.type;
									if (!G.has(W)) throw new v("feature-layer-source:unsupported-type", `Source type "${W}" is not supported`);
								});
								return function(W, M) {
									return U.apply(this, arguments)
								}
							}();
						V._patchServiceJSON = function(U) {
							if ("Table" !== U.type && U.geometryType && !U ? .drawingInfo ? .renderer &&
								!U.defaultSymbol) {
								const W = A.createDrawingInfo(U.geometryType)
									.renderer;
								r.setDeepValue("drawingInfo.renderer", W, U)
							}
							"esriGeometryMultiPatch" === U.geometryType && U.infoFor3D && (U.geometryType = "mesh");
							return U
						};
						V._serializeFeature = function(U, W) {
							const {
								geometry: M,
								attributes: T
							} = U;
							if (l.isSome(W) && l.isSome(U.geometry) && "mesh" === U.geometry.type) {
								const oa = {
									...T
								};
								U = U.geometry;
								var Z = U.origin;
								U = U.transform;
								oa[W.transformFieldRoles.originX] = Z.x;
								oa[W.transformFieldRoles.originY] = Z.y;
								oa[W.transformFieldRoles.originZ] =
									Z.z;
								if (l.isSome(U)) {
									Z = U.translation;
									const qa = U.scale;
									U = U.rotation;
									oa[W.transformFieldRoles.translationX] = Z[0];
									oa[W.transformFieldRoles.translationY] = Z[1];
									oa[W.transformFieldRoles.translationZ] = Z[2];
									oa[W.transformFieldRoles.scaleX] = qa[0];
									oa[W.transformFieldRoles.scaleY] = qa[1];
									oa[W.transformFieldRoles.scaleZ] = qa[2];
									oa[W.transformFieldRoles.rotationX] = U[0];
									oa[W.transformFieldRoles.rotationY] = U[1];
									oa[W.transformFieldRoles.rotationZ] = U[2];
									oa[W.transformFieldRoles.rotationDeg] = U[3]
								}
								return {
									geometry: null,
									attributes: oa
								}
							}
							return l.isNone(M) ? {
								attributes: T
							} : "mesh" === M.type || "extent" === M.type ? null : {
								geometry: M.toJSON(),
								attributes: T
							}
						};
						V._serializeAttachment = function() {
							var U = a._asyncToGenerator(function*(W) {
								const {
									feature: M,
									attachment: T
								} = W, {
									globalId: Z,
									name: oa,
									contentType: qa,
									data: Aa,
									uploadId: Ka
								} = T;
								W = {
									globalId: Z,
									parentGlobalId: null,
									contentType: null,
									name: null,
									uploadId: null,
									data: null
								};
								M && (W.parentGlobalId = "attributes" in M ? M.attributes && M.attributes[this.layer.globalIdField] : M.globalId);
								if (Ka) W.uploadId = Ka;
								else if (Aa) {
									const da =
										yield J(Aa);
									W.contentType = da.mediaType;
									W.data = da.data;
									Aa instanceof File && (W.name = Aa.name)
								}
								oa && (W.name = oa);
								qa && (W.contentType = qa);
								return W
							});
							return function(W) {
								return U.apply(this, arguments)
							}
						}();
						V._serializeAssetMapEditAndUploadAssets = function() {
							var U = a._asyncToGenerator(function*(W, M) {
								var T = this.layer.url,
									Z = null;
								try {
									const oa = new Blob([W.data], {
											type: W.mimeType
										}),
										qa = new FormData;
									qa.append("f", "json");
									qa.append("file", oa, `${W.assetName}`);
									const {
										data: Aa
									} = yield d(`${T}/uploads/upload`, {
										body: qa,
										method: "post",
										responseType: "json"
									});
									if (!Aa.success) throw new v("feature-layer-source:upload-failure", "Expected upload to be successfull.");
									Z = {
										assetType: W.assetType,
										assetUploadId: Aa.item.itemID
									}
								} catch (oa) {
									Z = null
								}
								if (l.isNone(Z)) {
									T = yield J(new Blob([W.data]));
									if (!T.isBase64) throw new v("feature-layer-source:uploadAssets-failure", "Expected gltf data in base64 format after conversion.");
									Z = {
										assetType: W.assetType,
										assetData: T.data
									}
								}
								if (l.isNone(Z)) throw new v("feature-layer-source:uploadAssets-failure", "Unable to prepare uploadAsset request options.");
								T = {
									method: "post",
									query: {
										f: "json",
										assets: JSON.stringify([Z])
									},
									responseType: "json"
								};
								T = yield d(n.join(this.layer.parsedUrl.path, "uploadAssets"), T);
								if (1 !== T.data.uploadResults.length || !T.data.uploadResults[0].success) throw new v("feature-layer-source:uploadAssets-failure", "Bad response.");
								T = T.data.uploadResults[0].assetHash;
								Z = [];
								W.flags & w.AssetMapEditFlags.PROJECT_VERTICES && Z.push("PROJECT_VERTICES");
								T = {
									globalId: W.assetMapGlobalId,
									parentGlobalId: W.featureGlobalId,
									assetName: W.assetName,
									assetHash: T,
									flags: Z
								};
								M.set(W.featureGlobalId, W.feature);
								return T
							});
							return function(W, M) {
								return U.apply(this, arguments)
							}
						}();
						V._getFeatureIds = function(U, W) {
							const M = U[0];
							return M ? this._canUseGlobalIds(W, U) ? this._getGlobalIdsFromFeatureIdentifier(U) : "objectId" in M ? this._getObjectIdsFromFeatureIdentifier(U) : this._getIdsFromFeatures(U) : []
						};
						V._getIdsFromFeatures = function(U) {
							const W = this.layer.objectIdField;
							return U.map(M => M.attributes && M.attributes[W])
						};
						V._canUseGlobalIds = function(U, W) {
							return U && "globalId" in W[0]
						};
						V._getObjectIdsFromFeatureIdentifier =
							function(U) {
								return U.map(W => W.objectId)
							};
						V._getGlobalIdsFromFeatureIdentifier = function(U) {
							return U.map(W => W.globalId)
						};
						V._createEditsResult = function(U) {
							const W = U.data,
								{
									layerId: M
								} = this.layer;
							U = [];
							let T = null;
							if (Array.isArray(W))
								for (var Z of W) U.push({
									id: Z.id,
									editedFeatures: Z.editedFeatures
								}), Z.id === M && (T = {
									addResults: Z.addResults,
									updateResults: Z.updateResults,
									deleteResults: Z.deleteResults,
									attachments: Z.attachments,
									editMoment: Z.editMoment
								});
							else T = W;
							Z = T ? .attachments;
							Z = {
								addFeatureResults: T.addResults ?
									T.addResults.map(this._createFeatureEditResult, this) : [],
								updateFeatureResults: T.updateResults ? T.updateResults.map(this._createFeatureEditResult, this) : [],
								deleteFeatureResults: T.deleteResults ? T.deleteResults.map(this._createFeatureEditResult, this) : [],
								addAttachmentResults: Z && Z.addResults ? Z.addResults.map(this._createFeatureEditResult, this) : [],
								updateAttachmentResults: Z && Z.updateResults ? Z.updateResults.map(this._createFeatureEditResult, this) : [],
								deleteAttachmentResults: Z && Z.deleteResults ? Z.deleteResults.map(this._createFeatureEditResult,
									this) : []
							};
							T.editMoment && (Z.editMoment = T.editMoment);
							if (0 < U.length) {
								Z.editedFeatureResults = [];
								for (const oa of U) {
									const {
										adds: qa,
										updates: Aa,
										deletes: Ka,
										spatialReference: da
									} = oa.editedFeatures, ja = da ? new D(da) : null;
									Z.editedFeatureResults.push({
										layerId: oa.id,
										editedFeatures: {
											adds: qa ? .map(sa => this._createEditedFeature(sa, ja)) || [],
											updates: Aa ? .map(sa => ({
												original: this._createEditedFeature(sa[0], ja),
												current: this._createEditedFeature(sa[1], ja)
											})) || [],
											deletes: Ka ? .map(sa => this._createEditedFeature(sa, ja)) || [],
											spatialReference: ja
										}
									})
								}
							}
							return Z
						};
						V._createEditedFeature = function(U, W) {
							return new e({
								attributes: U.attributes,
								geometry: y.fromJSON({
									...U.geometry,
									spatialReference: W
								})
							})
						};
						V._createFeatureEditResult = function(U) {
							const W = !0 === U.success ? null : U.error || {
								code: void 0,
								description: void 0
							};
							return {
								objectId: U.objectId,
								globalId: U.globalId,
								error: W ? new v("feature-layer-source:edit-failure", W.description, {
									code: W.code
								}) : null
							}
						};
						V._createAttachmentErrorResult = function(U, W) {
							return {
								objectId: U,
								globalId: null,
								error: new v("feature-layer-source:attachment-failure",
									W.details.messages && W.details.messages[0] || W.message, {
										code: W.details.httpStatus || W.details.messageCode
									})
							}
						};
						V._getFormDataForAttachment = function(U, W) {
							if (U = U instanceof FormData ? U : U && U.elements ? new FormData(U) : null)
								for (const M in W) {
									const T = W[M];
									null != T && (U.set ? U.set(M, T) : U.append(M, T))
								}
							return U
						};
						V._getLayerRequestOptions = function(U = {}) {
							const {
								parsedUrl: W,
								gdbVersion: M,
								dynamicDataSource: T
							} = this.layer;
							return {
								...U,
								query: {
									gdbVersion: M,
									layer: T ? JSON.stringify({
										source: T
									}) : void 0,
									...W.query,
									f: "json",
									...this._createRequestQueryOptions(U)
								},
								responseType: "json"
							}
						};
						a._createClass(R, [{
							key: "queryTask",
							get: function() {
								const {
									capabilities: {
										query: {
											supportsFormatPBF: U
										}
									},
									parsedUrl: W,
									dynamicDataSource: M,
									infoFor3D: T,
									gdbVersion: Z,
									spatialReference: oa,
									fieldsIndex: qa
								} = this.layer, Aa = m("featurelayer-pbf") && U && l.isNone(T) ? "pbf" : "json";
								return new B({
									url: W.path,
									format: Aa,
									fieldsIndex: qa,
									infoFor3D: T,
									dynamicDataSource: M,
									gdbVersion: Z,
									sourceSpatialReference: oa
								})
							}
						}]);
						return R
					}(g);
					b.__decorate([t.property()], c.prototype, "type", void 0);
					b.__decorate([t.property({
							constructOnly: !0
						})],
						c.prototype, "layer", void 0);
					b.__decorate([t.property({
						readOnly: !0
					})], c.prototype, "queryTask", null);
					return c = b.__decorate([u.subclass("esri.layers.graphics.sources.FeatureLayerSource")], c)
				})
		},
		"esri/layers/graphics/assetEditingSupport": function() {
			define(["exports"], function(a) {
				a.AssetMapEditFlags = void 0;
				var b = a.AssetMapEditFlags || (a.AssetMapEditFlags = {});
				b[b.PROJECT_VERTICES = 1] = "PROJECT_VERTICES";
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/graphics/sources/support/clientSideDefaults": function() {
			define(["exports",
				"../../../../core/has", "../../../../core/lang", "../../data/QueryEngineCapabilities", "../../../../symbols/support/defaultsJSON"
			], function(a, b, c, e, d) {
				const k = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/;
				let v = 1;
				a.createCapabilities = function(m, f) {
					return {
						analytics: {
							supportsCacheHint: !1
						},
						attachment: null,
						data: {
							isVersioned: !1,
							supportsAttachment: !1,
							supportsM: !1,
							supportsZ: m
						},
						metadata: {
							supportsAdvancedFieldProperties: !1
						},
						operations: {
							supportsCalculate: !1,
							supportsTruncate: !1,
							supportsValidateSql: !1,
							supportsAdd: f,
							supportsDelete: f,
							supportsEditing: f,
							supportsChangeTracking: !1,
							supportsQuery: !0,
							supportsQueryAnalytics: !1,
							supportsQueryAttachments: !1,
							supportsQueryTopFeatures: !1,
							supportsResizeAttachments: !1,
							supportsSync: !1,
							supportsUpdate: f,
							supportsExceedsLimitStatistics: !0
						},
						query: e.queryCapabilities,
						queryRelated: {
							supportsCount: !0,
							supportsOrderBy: !0,
							supportsPagination: !0,
							supportsCacheHint: !1
						},
						queryTopFeatures: {
							supportsCacheHint: !1
						},
						editing: {
							supportsGeometryUpdate: f,
							supportsGlobalId: !1,
							supportsReturnServiceEditsInSourceSpatialReference: !1,
							supportsRollbackOnFailure: !1,
							supportsUpdateWithoutM: !1,
							supportsUploadWithItemId: !1,
							supportsDeleteByAnonymous: !1,
							supportsDeleteByOthers: !1,
							supportsUpdateByAnonymous: !1,
							supportsUpdateByOthers: !1
						}
					}
				};
				a.createDefaultAttributesFunction = function(m, f) {
					if (b("esri-csp-restrictions")) return () => ({
						[f]: null,
						...m
					});
					try {
						let g = `this.${f} = null;`;
						for (const r in m) {
							const p = k.test(r) ? `.${r}` : `["${r}"]`;
							g += `this${p} = ${JSON.stringify(m[r])};`
						}
						const l = (new Function(`\n      return class AttributesClass$${v++} {\n        constructor() {\n          ${g};\n        }\n      }\n    `))();
						return () => new l
					} catch (g) {
						return () => ({
							[f]: null,
							...m
						})
					}
				};
				a.createDefaultTemplate = function(m = {}) {
					return [{
						name: "New Feature",
						description: "",
						prototype: {
							attributes: c.clone(m)
						}
					}]
				};
				a.createDrawingInfo = function(m) {
					return {
						renderer: {
							type: "simple",
							symbol: "esriGeometryPoint" === m || "esriGeometryMultipoint" === m ? d.defaultPointSymbolJSON : "esriGeometryPolyline" === m ? d.defaultPolylineSymbolJSON : d.defaultPolygonSymbolJSON
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/graphics/data/QueryEngineCapabilities": function() {
			define(["exports"],
				function(a) {
					a.queryCapabilities = {
						supportsStatistics: !0,
						supportsPercentileStatistics: !0,
						supportsSpatialAggregationStatistics: !1,
						supportedSpatialAggregationStatistics: {
							envelope: !1,
							centroid: !1,
							convexHull: !1
						},
						supportsCentroid: !0,
						supportsCacheHint: !1,
						supportsDistance: !0,
						supportsDistinct: !0,
						supportsExtent: !0,
						supportsGeometryProperties: !1,
						supportsHavingClause: !0,
						supportsOrderBy: !0,
						supportsPagination: !0,
						supportsQuantization: !0,
						supportsQuantizationEditMode: !1,
						supportsQueryGeometry: !0,
						supportsResultType: !1,
						supportsSqlExpression: !0,
						supportsMaxRecordCountFactor: !1,
						supportsStandardizedQueriesOnly: !0,
						supportsTopFeaturesQuery: !1,
						supportsQueryByOthers: !0,
						supportsHistoricMoment: !1,
						supportsFormatPBF: !1,
						supportsDisjointSpatialRelationship: !0,
						supportsDefaultSpatialReference: !1,
						supportsFullTextSearch: !1,
						supportsCompactGeometry: !1,
						maxRecordCountFactor: void 0,
						maxRecordCount: void 0,
						standardMaxRecordCount: void 0,
						tileMaxRecordCount: void 0
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/graphics/sources/support/QueryTask": function() {
			define("require ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../core/Error ../../../../core/has ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../support/source/DataLayerSource ../../../../rest/query/executeQueryJSON ../../../../rest/query/executeQueryPBF ../../../../rest/support/FeatureSet ../../../../rest/support/Query ../../../../rest/query/executeAttachmentQuery ../../../../rest/query/executeForCount ../../../../rest/query/executeForExtent ../../../../rest/query/executeForIds ../../../../rest/query/executeRelationshipQuery ../../../../rest/query/executeTopFeaturesQuery ../../../../rest/query/executeForTopIds ../../../../rest/query/executeForTopExtents ../../../../rest/query/executeForTopCount ../../../../rest/support/RelationshipQuery ../../../../tasks/Task".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D) {
					f = function(J) {
						function K(G) {
							G = J.call(this, G) || this;
							G.dynamicDataSource = null;
							G.fieldsIndex = null;
							G.format = "json";
							G.gdbVersion = null;
							G.infoFor3D = null;
							G.sourceSpatialReference = null;
							return G
						}
						b._inheritsLoose(K, J);
						var H = K.prototype;
						H.execute = function() {
							var G = b._asyncToGenerator(function*(F, L) {
								const R = yield this.executeJSON(F, L);
								return this.featureSetFromJSON(F, R, L)
							});
							return function(F, L) {
								return G.apply(this, arguments)
							}
						}();
						H.executeJSON = function() {
							var G =
								b._asyncToGenerator(function*(F, L) {
									L = {
										...this.requestOptions,
										...L
									};
									const R = this._normalizeQuery(F);
									F = null != F.outStatistics ? . [0];
									const V = d("featurelayer-pbf-statistics");
									F = !F || V;
									let U;
									if ("pbf" === this.format && F) try {
										U = yield n.executeRawQueryPBF(this.url, R, L)
									} catch (W) {
										if ("query:parsing-pbf" === W.name) this.format = "json";
										else throw W;
									}
									"json" !== this.format && F || (U = yield p.executeRawQueryJSON(this.url, R, L));
									this._normalizeFields(U.fields);
									return U
								});
							return function(F, L) {
								return G.apply(this, arguments)
							}
						}();
						H.featureSetFromJSON =
							function() {
								var G = b._asyncToGenerator(function*(F, L, R) {
									if (!this._queryIs3DObjectFormat(F) || k.isNone(this.infoFor3D) || !L.assetMaps || !L.features || !L.features.length) return t.fromJSON(L);
									({
										meshFeatureSetFromJSON: R
									} = yield v.whenOrAbort(new Promise((V, U) => a(["../../../../rest/support/meshFeatureSet"], V, U)), R));
									return R(F, this.infoFor3D, L)
								});
								return function(F, L, R) {
									return G.apply(this, arguments)
								}
							}();
						H.executeForCount = function(G, F) {
							F = {
								...this.requestOptions,
								...F
							};
							G = this._normalizeQuery(G);
							return u.executeForCount(this.url,
								G, F)
						};
						H.executeForExtent = function(G, F) {
							F = {
								...this.requestOptions,
								...F
							};
							G = this._normalizeQuery(G);
							return x.executeForExtent(this.url, G, F)
						};
						H.executeForIds = function(G, F) {
							F = {
								...this.requestOptions,
								...F
							};
							G = this._normalizeQuery(G);
							return y.executeForIds(this.url, G, F)
						};
						H.executeRelationshipQuery = function(G, F) {
							G = C.from(G);
							F = {
								...this.requestOptions,
								...F
							};
							if (this.gdbVersion || this.dynamicDataSource) G = G.clone(), G.gdbVersion = G.gdbVersion || this.gdbVersion, G.dynamicDataSource = G.dynamicDataSource || this.dynamicDataSource;
							return w.executeRelationshipQuery(this.url, G, F)
						};
						H.executeRelationshipQueryForCount = function(G, F) {
							G = C.from(G);
							F = {
								...this.requestOptions,
								...F
							};
							if (this.gdbVersion || this.dynamicDataSource) G = G.clone(), G.gdbVersion = G.gdbVersion || this.gdbVersion, G.dynamicDataSource = G.dynamicDataSource || this.dynamicDataSource;
							return w.executeRelationshipQueryForCount(this.url, G, F)
						};
						H.executeAttachmentQuery = function(G, F) {
							return q.executeAttachmentQuery(this.url, G, {
								...this.requestOptions,
								...F
							})
						};
						H.executeTopFeaturesQuery =
							function(G, F) {
								return A.executeTopFeaturesQuery(this.parsedUrl, G, this.sourceSpatialReference, {
									...this.requestOptions,
									...F
								})
							};
						H.executeForTopIds = function(G, F) {
							return B.executeForTopIds(this.parsedUrl, G, {
								...this.requestOptions,
								...F
							})
						};
						H.executeForTopExtents = function(G, F) {
							return E.executeForTopExtents(this.parsedUrl, G, {
								...this.requestOptions,
								...F
							})
						};
						H.executeForTopCount = function(G, F) {
							return z.executeForTopCount(this.parsedUrl, G, {
								...this.requestOptions,
								...F
							})
						};
						H._normalizeQuery = function(G) {
							let F = h.from(G);
							F.sourceSpatialReference = F.sourceSpatialReference || this.sourceSpatialReference;
							if (this.gdbVersion || this.dynamicDataSource) F = F === G ? F.clone() : F, F.gdbVersion = G.gdbVersion || this.gdbVersion, F.dynamicDataSource = G.dynamicDataSource ? r.DataLayerSource.from(G.dynamicDataSource) : this.dynamicDataSource;
							if (k.isSome(this.infoFor3D) && this._queryIs3DObjectFormat(G)) {
								F = F === G ? F.clone() : F;
								F.formatOf3DObjects = null;
								for (const L of this.infoFor3D.queryFormats) {
									if ("3D_glb" === L) {
										F.formatOf3DObjects = L;
										break
									}
									"3D_gltf" !== L ||
										F.formatOf3DObjects || (F.formatOf3DObjects = L)
								}
								if (!F.formatOf3DObjects) throw new e("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
								if (k.isNone(F.outFields) || !F.outFields.includes("*")) {
									F = F === G ? F.clone() : F;
									k.isNone(F.outFields) && (F.outFields = []);
									const {
										originX: L,
										originY: R,
										originZ: V,
										translationX: U,
										translationY: W,
										translationZ: M,
										scaleX: T,
										scaleY: Z,
										scaleZ: oa,
										rotationX: qa,
										rotationY: Aa,
										rotationZ: Ka,
										rotationDeg: da
									} = this.infoFor3D.transformFieldRoles;
									F.outFields.push(L, R, V, U, W, M, T, Z, oa, qa, Aa, Ka, da)
								}
							}
							return F
						};
						H._normalizeFields = function(G) {
							if (k.isSome(this.fieldsIndex) && k.isSome(G))
								for (const F of G)(G = this.fieldsIndex.get(F.name)) && Object.assign(F, G.toJSON())
						};
						H._queryIs3DObjectFormat = function(G) {
							return k.isSome(this.infoFor3D) && G.returnGeometry && "xyFootprint" !== G.multipatchOption && !G.outStatistics
						};
						return K
					}(D);
					c.__decorate([m.property({
						type: r.DataLayerSource
					})], f.prototype, "dynamicDataSource", void 0);
					c.__decorate([m.property()], f.prototype,
						"fieldsIndex", void 0);
					c.__decorate([m.property()], f.prototype, "format", void 0);
					c.__decorate([m.property()], f.prototype, "gdbVersion", void 0);
					c.__decorate([m.property()], f.prototype, "infoFor3D", void 0);
					c.__decorate([m.property()], f.prototype, "sourceSpatialReference", void 0);
					return f = c.__decorate([l.subclass("esri.tasks.QueryTask")], f)
				})
		},
		"esri/rest/query/executeQueryJSON": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../utils ./operations/query ../support/FeatureSet ../support/Query".split(" "),
				function(a, b, c, e, d, k) {
					function v() {
						v = b._asyncToGenerator(function*(g, l, r) {
							g = yield m(g, l, r);
							return d.fromJSON(g)
						});
						return v.apply(this, arguments)
					}

					function m(g, l, r) {
						return f.apply(this, arguments)
					}

					function f() {
						f = b._asyncToGenerator(function*(g, l, r) {
							g = c.parseUrl(g);
							r = {
								...r
							};
							l = k.from(l);
							({
								data: l
							} = yield e.executeQuery(g, l, l.sourceSpatialReference, r));
							return l
						});
						return f.apply(this, arguments)
					}
					a.executeQueryJSON = function(g, l, r) {
						return v.apply(this, arguments)
					};
					a.executeRawQueryJSON = m;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/rest/utils": function() {
			define("exports ../config ../kernel ../core/lang ../core/urlUtils ../support/apiKeyUtils".split(" "), function(a, b, c, e, d, k) {
				function v(m, f, g) {
					const l = {};
					for (const p in m)
						if ("declaredClass" !== p) {
							var r = m[p];
							if (null != r && "function" !== typeof r)
								if (Array.isArray(r)) {
									l[p] = [];
									for (let n = 0; n < r.length; n++) l[p][n] = v(r[n])
								} else "object" === typeof r ? r.toJSON ? (r = r.toJSON(g && g[p]), l[p] = f ? r : JSON.stringify(r)) : l[p] = f ? r : JSON.stringify(r) :
									l[p] = r
						} return l
				}
				a.asValidOptions = function(m, f) {
					return f ? {
						...f,
						query: {
							...m,
							...f.query
						}
					} : {
						query: m
					}
				};
				a.encode = v;
				a.getToken = function(m, f) {
					return k.supportsApiKey(m) && (f || b.apiKey) ? f || b.apiKey : c.id ? .findCredential(m) ? .token
				};
				a.parseUrl = function(m) {
					return "string" === typeof m ? d.urlToObject(m) : e.clone(m)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/operations/query": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../request ../../../core/maybe ../../../core/urlUtils ../../../geometry/support/jsonUtils ../../../geometry/support/normalizeUtils ../../operations/urlUtils ./pbfQueryUtils ./queryZScale".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					function l(q, u) {
						if (u && "extent" === q.type) return `${q.xmin},${q.ymin},${q.xmax},${q.ymax}`;
						if (u && "point" === q.type) return `${q.x},${q.y}`;
						q = q.toJSON();
						delete q.spatialReference;
						return JSON.stringify(q)
					}

					function r(q, u) {
						const x = q.geometry,
							y = q.toJSON();
						delete y.compactGeometryEnabled;
						delete y.defaultSpatialReferenceEnabled;
						let w, A, B;
						e.isSome(x) && (A = x.spatialReference, B = x.spatialReference.wkid || JSON.stringify(x.spatialReference), y.geometryType = k.getJsonType(x), y.geometry = l(x,
							q.compactGeometryEnabled), y.inSR = B);
						y.groupByFieldsForStatistics && (y.groupByFieldsForStatistics = y.groupByFieldsForStatistics.join(","));
						y.objectIds && (y.objectIds = y.objectIds.join(","));
						y.orderByFields && (y.orderByFields = y.orderByFields.join(","));
						!y.outFields || !y.returnDistinctValues && (u ? .returnCountOnly || u ? .returnExtentOnly || u ? .returnIdsOnly) ? delete y.outFields : y.outFields.includes("*") ? y.outFields = "*" : y.outFields = y.outFields.join(",");
						y.outSR ? (y.outSR = y.outSR.wkid || JSON.stringify(y.outSR), w = q.outSpatialReference) :
							x && (y.returnGeometry || y.returnCentroid) && (y.outSR = y.inSR, w = A);
						y.returnGeometry && delete y.returnGeometry;
						y.outStatistics && (y.outStatistics = JSON.stringify(y.outStatistics));
						y.fullText && (y.fullText = JSON.stringify(y.fullText));
						y.pixelSize && (y.pixelSize = JSON.stringify(y.pixelSize));
						y.quantizationParameters && (q.defaultSpatialReferenceEnabled && e.isSome(A) && e.isSome(q.quantizationParameters) && e.isSome(q.quantizationParameters.extent) && A.equals(q.quantizationParameters.extent.spatialReference) && delete y.quantizationParameters.extent.spatialReference,
							y.quantizationParameters = JSON.stringify(y.quantizationParameters));
						y.parameterValues && (y.parameterValues = JSON.stringify(y.parameterValues));
						y.rangeValues && (y.rangeValues = JSON.stringify(y.rangeValues));
						y.dynamicDataSource && (y.layer = JSON.stringify({
							source: y.dynamicDataSource
						}), delete y.dynamicDataSource);
						if (y.timeExtent) {
							const {
								start: E,
								end: z
							} = y.timeExtent;
							if (null != E || null != z) y.time = E === z ? E : `${null==E?"null":E},${null==z?"null":z}`;
							delete y.timeExtent
						}
						q.defaultSpatialReferenceEnabled && e.isSome(A) && e.isSome(w) &&
							A.equals(w) && (y.defaultSR = y.inSR, delete y.inSR, delete y.outSR);
						return y
					}

					function p() {
						p = b._asyncToGenerator(function*(q, u, x, y) {
							q = e.isSome(u.timeExtent) && u.timeExtent.isEmpty ? {
								data: {
									features: []
								}
							} : yield h(q, u, "json", y);
							g.applyFeatureSetZUnitScaling(u, x, q.data);
							return q
						});
						return p.apply(this, arguments)
					}

					function n() {
						n = b._asyncToGenerator(function*(q, u, x, y) {
							if (e.isSome(u.timeExtent) && u.timeExtent.isEmpty) return {
								data: x.createFeatureResult()
							};
							q = yield t(q, u, y);
							q.data = f.parsePBFFeatureQuery(q.data, x);
							return q
						});
						return n.apply(this, arguments)
					}

					function t(q, u, x) {
						return h(q, u, "pbf", x)
					}

					function h(q, u, x, y = {}, w = {}) {
						const A = "string" === typeof q ? d.urlToObject(q) : q;
						q = u.geometry ? [u.geometry] : [];
						y.responseType = "pbf" === x ? "array-buffer" : "json";
						return v.normalizeCentralMeridian(q, null, y)
							.then(B => {
								B = B && B[0];
								e.isSome(B) && (u = u.clone(), u.geometry = B);
								B = m.mapParameters({
									...A.query,
									f: x,
									...w,
									...r(u, w)
								});
								return c(d.join(A.path, "query"), {
									...y,
									query: {
										...B,
										...y.query
									}
								})
							})
					}
					a.encodeGeometry = l;
					a.executeQuery = function(q, u, x, y) {
						return p.apply(this,
							arguments)
					};
					a.executeQueryForCount = function(q, u, x) {
						return e.isSome(u.timeExtent) && u.timeExtent.isEmpty ? Promise.resolve({
							data: {
								count: 0
							}
						}) : h(q, u, "json", x, {
							returnIdsOnly: !0,
							returnCountOnly: !0
						})
					};
					a.executeQueryForExtent = function(q, u, x) {
						return e.isSome(u.timeExtent) && u.timeExtent.isEmpty ? Promise.resolve({
								data: {
									count: 0,
									extent: null
								}
							}) : h(q, u, "json", x, {
								returnExtentOnly: !0,
								returnCountOnly: !0
							})
							.then(y => {
								const w = y.data;
								if (w.hasOwnProperty("extent")) return y;
								if (w.features) throw Error("Layer does not support extent calculation.");
								if (w.hasOwnProperty("count")) throw Error("Layer does not support extent calculation.");
								return y
							})
					};
					a.executeQueryForIds = function(q, u, x) {
						return e.isSome(u.timeExtent) && u.timeExtent.isEmpty ? Promise.resolve({
							data: {
								objectIds: []
							}
						}) : h(q, u, "json", x, {
							returnIdsOnly: !0
						})
					};
					a.executeQueryPBF = function(q, u, x, y) {
						return n.apply(this, arguments)
					};
					a.executeQueryPBFBuffer = t;
					a.queryToQueryStringParameters = r;
					a.runQuery = h;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/geometry/support/normalizeUtils": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../config ../../core/Error ../../core/Logger ../../core/maybe ../Polygon ../Polyline ./normalizeUtilsCommon ./spatialReferenceUtils ./webMercatorUtils ../../rest/geometryService/cut ../../rest/geometryService/simplify".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					function n(A) {
						const B = [];
						let E = 0,
							z = 0;
						for (let C = 0; C < A.length; C++) {
							const D = A[C];
							let J = null;
							for (let K = 0; K < D.length; K++) J = D[K], B.push(J), 0 === K ? z = E = J[0] : (E = Math.min(E, J[0]), z = Math.max(z, J[0]));
							J && B.push([(E + z) / 2, 0])
						}
						return B
					}

					function t(A, B) {
						if (!(A instanceof m || A instanceof v)) throw w.error("straightLineDensify: the input geometry is neither polyline nor polygon"), new e("straightLineDensify: the input geometry is neither polyline nor polygon");
						var E = f.getGeometryParts(A);
						const z = [];
						for (const D of E) {
							E = [];
							z.push(E);
							E.push([D[0][0], D[0][1]]);
							for (let J = 0; J < D.length - 1; J++) {
								const K = D[J][0],
									H = D[J][1],
									G = D[J + 1][0],
									F = D[J + 1][1];
								var C = Math.sqrt((G - K) * (G - K) + (F - H) * (F - H));
								const L = (F - H) / C,
									R = (G - K) / C,
									V = C / B;
								if (1 < V) {
									for (let U = 1; U <= V - 1; U++) {
										const W = U * B;
										E.push([R * W + K, L * W + H])
									}
									C = (C + Math.floor(V - 1) * B) / 2;
									E.push([R * C + K, L * C + H])
								}
								E.push([G, F])
							}
						}
						return "polygon" === A.type ? new v({
							rings: z,
							spatialReference: A.spatialReference
						}) : new m({
							paths: z,
							spatialReference: A.spatialReference
						})
					}

					function h(A, B, E) {
						B &&
							(A = t(A, 1E6), A = l.webMercatorToGeographic(A, !0));
						E && (A = f.updatePolyGeometry(A, E));
						return A
					}

					function q(A, B, E) {
						if (Array.isArray(A)) {
							var z = A[0];
							z > B ? (E = f.offsetMagnitude(z, B), A[0] = z + -2 * E * B) : z < E && (B = f.offsetMagnitude(z, E), A[0] = z + -2 * B * E)
						} else z = A.x, z > B ? (E = f.offsetMagnitude(z, B), A = A.clone()
							.offset(-2 * E * B, 0)) : z < E && (B = f.offsetMagnitude(z, E), A = A.clone()
							.offset(-2 * B * E, 0));
						return A
					}

					function u(A, B) {
						let E = -1;
						for (let z = 0; z < B.cutIndexes.length; z++) {
							const C = B.cutIndexes[z],
								D = B.geometries[z],
								J = f.getGeometryParts(D);
							for (let K = 0; K < J.length; K++) {
								const H = J[K];
								H.some(G => {
									if (180 > G[0]) return !0;
									G = 0;
									for (var F = 0; F < H.length; F++) {
										var L = H[F][0];
										G = L > G ? L : G
									}
									G = Number(G.toFixed(9));
									G = -360 * f.offsetMagnitude(G, 180);
									for (F = 0; F < H.length; F++) L = D.getPoint(K, F), D.setPoint(K, F, L.clone()
										.offset(G, 0));
									return !0
								})
							}
							if (C === E)
								if ("polygon" === A[0].type)
									for (const K of f.getGeometryParts(D)) A[C] = A[C].addRing(K);
								else {
									if ("polyline" === A[0].type)
										for (const K of f.getGeometryParts(D)) A[C] = A[C].addPath(K)
								}
							else E = C, A[C] = D
						}
						return A
					}

					function x(A, B, E) {
						return y.apply(this,
							arguments)
					}

					function y() {
						y = b._asyncToGenerator(function*(A, B, E) {
							if (!Array.isArray(A)) return x([A], B);
							B && "string" !== typeof B && w.warn("normalizeCentralMeridian()", "The url object is deprecated, use the url string instead");
							var z = "string" === typeof B ? B : B ? .url ? ? c.geometryServiceUrl;
							let C, D, J;
							let K = 0;
							var H = [];
							B = [];
							for (var G of A)
								if (k.isNone(G)) B.push(G);
								else {
									if (!F) {
										var F = G.spatialReference;
										var L = g.getInfo(F);
										var R = (C = F.isWebMercator) ? 102100 : 4326;
										D = f.cutParams[R].maxX;
										J = f.cutParams[R].minX;
										var V = f.cutParams[R].plus180Line;
										R = f.cutParams[R].minus180Line
									}
									if (L)
										if ("mesh" === G.type) B.push(G);
										else if ("point" === G.type) B.push(q(G.clone(), D, J));
									else if ("multipoint" === G.type) {
										var U = G.clone();
										U.points = U.points.map(W => q(W, D, J));
										B.push(U)
									} else if ("extent" === G.type) U = G.clone()
										._normalize(!1, !1, L), B.push(U.rings ? new v(U) : U);
									else if (G.extent) {
										U = G.extent;
										const W = 2 * f.offsetMagnitude(U.xmin, J) * D;
										let M = 0 === W ? G.clone() : f.updatePolyGeometry(G.clone(), W);
										U.offset(W, 0);
										U.intersects(V) && U.xmax !== D ? (K = U.xmax > K ? U.xmax : K, M = h(M, C), H.push(M), B.push("cut")) :
											U.intersects(R) && U.xmin !== J ? (K = 2 * U.xmax * D > K ? 2 * U.xmax * D : K, M = h(M, C, 360), H.push(M), B.push("cut")) : B.push(M)
									} else B.push(G.clone());
									else B.push(G)
								} F = f.offsetMagnitude(K, D);
							L = -90;
							V = F;
							for (G = new m; 0 < F;) R = -180 + 360 * F, G.addPath([
								[R, L],
								[R, -1 * L]
							]), L *= -1, F--;
							if (0 < H.length && 0 < V) {
								F = yield r.cut(z, H, G, E);
								F = u(H, F);
								L = [];
								H = [];
								for (V = 0; V < B.length; V++) G = B[V], "cut" !== G ? H.push(G) : (G = F.shift(), R = A[V], k.isSome(R) && "polygon" === R.type && R.rings && 1 < R.rings.length && G.rings.length >= R.rings.length ? (L.push(G), H.push("simplify")) : H.push(C ?
									l.geographicToWebMercator(G) : G));
								if (!L.length) return H;
								B = yield p.simplify(z, L, E);
								A = [];
								for (E = 0; E < H.length; E++) z = H[E], "simplify" !== z ? A.push(z) : A.push(C ? l.geographicToWebMercator(B.shift()) : B.shift());
								return A
							}
							A = [];
							for (E = 0; E < B.length; E++) z = B[E], "cut" !== z ? A.push(z) : (z = H.shift(), A.push(!0 === C ? l.geographicToWebMercator(z) : z));
							return A
						});
						return y.apply(this, arguments)
					}
					const w = d.getLogger("esri.geometry.support.normalizeUtils");
					a.getDenormalizedExtent = function(A) {
						if (!A) return null;
						const B = A.extent;
						if (!B) return null;
						var E = A.spatialReference && g.getInfo(A.spatialReference);
						if (!E) return B;
						const [z, C] = E.valid;
						({
							width: E
						} = B);
						let {
							xmin: D,
							xmax: J
						} = B;
						[D, J] = [J, D];
						if ("extent" === A.type || 0 === E || E <= C || E > 2 * C || D < z || J > C) return B;
						let K;
						switch (A.type) {
							case "polygon":
								if (1 < A.rings.length) K = n(A.rings);
								else return B;
								break;
							case "polyline":
								if (1 < A.paths.length) K = n(A.paths);
								else return B;
								break;
							case "multipoint":
								K = A.points
						}
						A = B.clone();
						for (let H = 0; H < K.length; H++) {
							let G = K[H][0];
							0 > G ? (G += C, J = Math.max(G, J)) : (G -= C, D = Math.min(G, D))
						}
						A.xmin = D;
						A.xmax =
							J;
						return A.width < E ? (A.xmin -= C, A.xmax -= C, A) : B
					};
					a.normalizeCentralMeridian = x;
					a.normalizeMapX = function(A, B) {
						if (B = g.getInfo(B)) {
							const [E, z] = B.valid;
							B = z - E;
							if (A < E)
								for (; A < E;) A += B;
							if (A > z)
								for (; A > z;) A -= B
						}
						return A
					};
					a.straightLineDensify = t;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/geometry/support/normalizeUtilsCommon": function() {
			define(["exports", "../Polyline", "../SpatialReference", "./jsonUtils"], function(a, b, c, e) {
				function d(k) {
					return e.isPolygon(k) ? k.rings :
						k.paths
				}
				b = {
					102100: {
						maxX: 2.0037508342788905E7,
						minX: -2.0037508342788905E7,
						plus180Line: new b({
							paths: [
								[
									[2.0037508342788905E7, -2.0037508342788905E7],
									[2.0037508342788905E7, 2.0037508342788905E7]
								]
							],
							spatialReference: c.WebMercator
						}),
						minus180Line: new b({
							paths: [
								[
									[-2.0037508342788905E7, -2.0037508342788905E7],
									[-2.0037508342788905E7, 2.0037508342788905E7]
								]
							],
							spatialReference: c.WebMercator
						})
					},
					4326: {
						maxX: 180,
						minX: -180,
						plus180Line: new b({
							paths: [
								[
									[180, -180],
									[180, 180]
								]
							],
							spatialReference: c.WGS84
						}),
						minus180Line: new b({
							paths: [
								[
									[-180,
										-180
									],
									[-180, 180]
								]
							],
							spatialReference: c.WGS84
						})
					}
				};
				a.cutParams = b;
				a.getGeometryParts = d;
				a.offsetMagnitude = function(k, v) {
					return Math.ceil((k - v) / (2 * v))
				};
				a.updatePolyGeometry = function(k, v) {
					const m = d(k);
					for (const f of m)
						for (const g of f) g[0] += v;
					return k
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/geometryService/cut": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../geometry ../../request ../../geometry/support/jsonUtils ../utils".split(" "),
				function(a, b, c, e, d, k) {
					function v() {
						v = b._asyncToGenerator(function*(m, f, g, l) {
							m = k.parseUrl(m);
							const r = f[0].spatialReference;
							f = {
								...l,
								query: {
									...m.query,
									f: "json",
									sr: JSON.stringify(r),
									target: JSON.stringify({
										geometryType: d.getJsonType(f[0]),
										geometries: f
									}),
									cutter: JSON.stringify(g)
								}
							};
							f = yield e(m.path + "/cut", f);
							const {
								cutIndexes: p,
								geometries: n = []
							} = f.data;
							return {
								cutIndexes: p,
								geometries: n.map(t => {
									t = d.fromJSON(t);
									t.spatialReference = r;
									return t
								})
							}
						});
						return v.apply(this, arguments)
					}
					a.cut = function(m, f, g, l) {
						return v.apply(this,
							arguments)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/rest/geometryService/simplify": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../request ../../core/urlUtils ../../geometry/support/jsonUtils ./utils".split(" "), function(a, b, c, e, d, k) {
				function v() {
					v = b._asyncToGenerator(function*(m, f, g) {
						const l = "string" === typeof m ? e.urlToObject(m) : m;
						m = f[0].spatialReference;
						const r = d.getJsonType(f[0]);
						f = {
							...g,
							query: {
								...l.query,
								f: "json",
								sr: m.wkid ? m.wkid : JSON.stringify(m),
								geometries: JSON.stringify(k.encodeGeometries(f))
							}
						};
						({
							data: f
						} = yield c(l.path + "/simplify", f));
						return k.decodeGeometries(f.geometries, r, m)
					});
					return v.apply(this, arguments)
				}
				a.simplify = function(m, f, g) {
					return v.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/geometryService/utils": function() {
			define(["exports", "../../geometry/support/jsonUtils"], function(a, b) {
				a.decodeGeometries = function(c, e, d) {
					const k =
						b.getGeometryType(e);
					return c.map(v => {
						v = k.fromJSON(v);
						v.spatialReference = d;
						return v
					})
				};
				a.encodeGeometries = function(c) {
					return {
						geometryType: b.getJsonType(c[0]),
						geometries: c.map(e => e.toJSON())
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/operations/urlUtils": function() {
			define(["exports"], function(a) {
				function b(c) {
					const e = {};
					for (const d in c) {
						if ("declaredClass" === d) continue;
						const k = c[d];
						if (null != k && "function" !== typeof k)
							if (Array.isArray(k)) {
								e[d] = [];
								for (let v = 0; v < k.length; v++) e[d][v] = b(k[v])
							} else "object" === typeof k ? k.toJSON && (e[d] = JSON.stringify(k)) : e[d] = k
					}
					return e
				}
				a.mapParameters = b;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/operations/pbfQueryUtils": function() {
			define(["exports", "./pbfFeatureServiceParser"], function(a, b) {
				a.parsePBFFeatureQuery = function(c, e) {
					var d = b.parseFeatureQuery(c, e);
					c = d.queryResult.featureResult;
					e = d.queryResult.queryGeometry;
					d = d.queryResult.queryGeometryType;
					if (c && c.features && c.features.length && c.objectIdFieldName) {
						const k = c.objectIdFieldName;
						for (const v of c.features) v.attributes && (v.objectId = v.attributes[k])
					}
					c && (c.queryGeometry = e, c.queryGeometryType = d);
					return c
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/operations/pbfFeatureServiceParser": function() {
			define("exports ../../../core/Error ../../../core/maybe ../../../core/pbf ../../../layers/graphics/OptimizedGeometry ./pbfOptimizedFeatureSet".split(" "),
				function(a, b, c, e, d, k) {
					function v(z) {
						return z >= A.length ? null : A[z]
					}

					function m(z, C, D) {
						z = z.asUnsafe();
						for (D = C.createPointGeometry(D); z.next();) switch (z.tag()) {
							case 3:
								var J = z.getUInt32();
								J = z.pos() + J;
								let K = 0;
								for (; z.pos() < J;) C.addCoordinatePoint(D, z.getSInt64(), K++);
								break;
							default:
								z.skip()
						}
						return D
					}

					function f(z, C, D) {
						z = z.asUnsafe();
						const J = C.createGeometry(D);
						for (D = 2 + (D.hasZ ? 1 : 0) + (D.hasM ? 1 : 0); z.next();) switch (z.tag()) {
							case 2:
								var K = z.getUInt32();
								K = z.pos() + K;
								for (var H = 0; z.pos() < K;) C.addLength(J, z.getUInt32(),
									H++);
								break;
							case 3:
								K = z.getUInt32();
								K = z.pos() + K;
								H = 0;
								for (C.allocateCoordinates(J); z.pos() < K;) C.addCoordinate(J, z.getSInt64(), H), H++, H === D && (H = 0);
								break;
							default:
								z.skip()
						}
						return J
					}

					function g(z) {
						z = z.asUnsafe();
						const C = new d;
						let D = "esriGeometryPoint";
						for (; z.next();) switch (z.tag()) {
							case 2:
								var J = z.getUInt32();
								for (J = z.pos() + J; z.pos() < J;) C.lengths.push(z.getUInt32());
								break;
							case 3:
								J = z.getUInt32();
								for (J = z.pos() + J; z.pos() < J;) C.coords.push(z.getSInt64());
								break;
							case 1:
								D = k.OPTIMIZED_GEOMETRY_TYPES[z.getEnum()];
								break;
							default:
								z.skip()
						}
						return {
							queryGeometry: C,
							queryGeometryType: D
						}
					}

					function l(z) {
						for (z = z.asUnsafe(); z.next();) switch (z.tag()) {
							case 1:
								return z.getString();
							case 2:
								return z.getFloat();
							case 3:
								return z.getDouble();
							case 4:
								return z.getSInt32();
							case 5:
								return z.getUInt32();
							case 6:
								return z.getInt64();
							case 7:
								return z.getUInt64();
							case 8:
								return z.getSInt64();
							case 9:
								return z.getBool();
							default:
								return z.skip(), null
						}
						return null
					}

					function r(z) {
						z = z.asUnsafe();
						const C = {
							type: v(0)
						};
						for (; z.next();) switch (z.tag()) {
							case 1:
								C.name =
									z.getString();
								break;
							case 2:
								C.type = v(z.getEnum());
								break;
							case 3:
								C.alias = z.getString();
								break;
							case 4:
								var D = z.getEnum();
								D = D >= B.length ? null : B[D];
								C.sqlType = D;
								break;
							case 5:
								z.skip();
								break;
							case 6:
								C.defaultValue = z.getString();
								break;
							default:
								z.skip()
						}
						return C
					}

					function p(z) {
						const C = {};
						for (z = z.asUnsafe(); z.next();) switch (z.tag()) {
							case 1:
								C.name = z.getString();
								break;
							case 2:
								C.isSystemMaintained = z.getBool();
								break;
							default:
								z.skip()
						}
						return C
					}

					function n(z, C, D, J) {
						const K = C.createFeature(D);
						let H = 0;
						for (; z.next();) switch (z.tag()) {
							case 1:
								const G =
									J[H++].name;
								K.attributes[G] = z.processMessage(l);
								break;
							case 2:
								K.geometry = z.processMessageWithArgs(f, C, D);
								break;
							case 4:
								K.centroid = z.processMessageWithArgs(m, C, D);
								break;
							default:
								z.skip()
						}
						return K
					}

					function t(z) {
						const C = [1, 1, 1, 1];
						for (z = z.asUnsafe(); z.next();) switch (z.tag()) {
							case 1:
								C[0] = z.getDouble();
								break;
							case 2:
								C[1] = z.getDouble();
								break;
							case 4:
								C[2] = z.getDouble();
								break;
							case 3:
								C[3] = z.getDouble();
								break;
							default:
								z.skip()
						}
						return C
					}

					function h(z) {
						const C = [0, 0, 0, 0];
						for (z = z.asUnsafe(); z.next();) switch (z.tag()) {
							case 1:
								C[0] =
									z.getDouble();
								break;
							case 2:
								C[1] = z.getDouble();
								break;
							case 4:
								C[2] = z.getDouble();
								break;
							case 3:
								C[3] = z.getDouble();
								break;
							default:
								z.skip()
						}
						return C
					}

					function q(z) {
						const C = {
							originPosition: 0 >= E.length ? null : E[0]
						};
						for (z = z.asUnsafe(); z.next();) switch (z.tag()) {
							case 1:
								var D = z.getEnum();
								C.originPosition = D >= E.length ? null : E[D];
								break;
							case 2:
								C.scale = z.processMessage(t);
								break;
							case 3:
								C.translate = z.processMessage(h);
								break;
							default:
								z.skip()
						}
						return C
					}

					function u(z) {
						const C = {};
						for (z = z.asUnsafe(); z.next();) switch (z.tag()) {
							case 1:
								C.shapeAreaFieldName =
									z.getString();
								break;
							case 2:
								C.shapeLengthFieldName = z.getString();
								break;
							case 3:
								C.units = z.getString();
								break;
							default:
								z.skip()
						}
						return C
					}

					function x(z, C) {
						for (C = C.createSpatialReference(); z.next();) switch (z.tag()) {
							case 1:
								C.wkid = z.getUInt32();
								break;
							case 5:
								C.wkt = z.getString();
								break;
							case 2:
								C.latestWkid = z.getUInt32();
								break;
							case 3:
								C.vcsWkid = z.getUInt32();
								break;
							case 4:
								C.latestVcsWkid = z.getUInt32();
								break;
							default:
								z.skip()
						}
						return C
					}

					function y(z, C) {
						const D = C.createFeatureResult();
						z = z.asUnsafe();
						D.geometryType = 0 >= C.geometryTypes.length ?
							null : C.geometryTypes[0];
						let J = !1;
						for (; z.next();) switch (z.tag()) {
							case 1:
								D.objectIdFieldName = z.getString();
								break;
							case 3:
								D.globalIdFieldName = z.getString();
								break;
							case 4:
								D.geohashFieldName = z.getString();
								break;
							case 5:
								D.geometryProperties = z.processMessage(u);
								break;
							case 7:
								var K = z.getEnum();
								D.geometryType = K >= C.geometryTypes.length ? null : C.geometryTypes[K];
								break;
							case 8:
								D.spatialReference = z.processMessageWithArgs(x, C);
								break;
							case 10:
								D.hasZ = z.getBool();
								break;
							case 11:
								D.hasM = z.getBool();
								break;
							case 12:
								D.transform =
									z.processMessage(q);
								break;
							case 9:
								K = z.getBool();
								D.exceededTransferLimit = K;
								break;
							case 13:
								C.addField(D, z.processMessage(r));
								break;
							case 15:
								J || (C.prepareFeatures(D), J = !0);
								C.addFeature(D, z.processMessageWithArgs(n, C, D, D.fields));
								break;
							case 2:
								D.uniqueIdField = z.processMessage(p);
								break;
							default:
								z.skip()
						}
						C.finishFeatureResult(D);
						return D
					}

					function w(z, C) {
						const D = {};
						let J = null;
						for (; z.next();) switch (z.tag()) {
							case 4:
								J = z.processMessageWithArgs(g);
								break;
							case 1:
								D.featureResult = z.processMessageWithArgs(y, C);
								break;
							default:
								z.skip()
						}
						c.isSome(J) &&
							D.featureResult && C.addQueryGeometry(D, J);
						return D
					}
					const A = "esriFieldTypeSmallInteger esriFieldTypeInteger esriFieldTypeSingle esriFieldTypeDouble esriFieldTypeString esriFieldTypeDate esriFieldTypeOID esriFieldTypeGeometry esriFieldTypeBlob esriFieldTypeRaster esriFieldTypeGUID esriFieldTypeGlobalID esriFieldTypeXML".split(" "),
						B = "sqlTypeBigInt sqlTypeBinary sqlTypeBit sqlTypeChar sqlTypeDate sqlTypeDecimal sqlTypeDouble sqlTypeFloat sqlTypeGeometry sqlTypeGUID sqlTypeInteger sqlTypeLongNVarchar sqlTypeLongVarbinary sqlTypeLongVarchar sqlTypeNChar sqlTypeNVarchar sqlTypeOther sqlTypeReal sqlTypeSmallInt sqlTypeSqlXml sqlTypeTime sqlTypeTimestamp sqlTypeTimestamp2 sqlTypeTinyInt sqlTypeVarbinary sqlTypeVarchar".split(" "),
						E = ["upperLeft", "lowerLeft"];
					a.parseFeatureQuery = function(z, C) {
						try {
							const D = new e(new Uint8Array(z), new DataView(z));
							for (z = {}; D.next();) switch (D.tag()) {
								case 2:
									z.queryResult = D.processMessageWithArgs(w, C);
									break;
								default:
									D.skip()
							}
							return z
						} catch (D) {
							throw new b("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", {
								error: D
							});
						}
					};
					a.parseFieldType = v;
					a.parseTransform = q;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/core/pbf": function() {
			define(["./has",
				"./ObjectPool"
			], function(a, b) {
				var c;
				(function(k) {
					k[k.varint = 0] = "varint";
					k[k.fixed64 = 1] = "fixed64";
					k[k.delimited = 2] = "delimited";
					k[k.fixed32 = 5] = "fixed32";
					k[k.unknown = 99] = "unknown"
				})(c || (c = {}));
				const e = new TextDecoder("utf-8"),
					d = a("safari") || a("ios") ? 6 : a("ff") ? 12 : 32;
				a = function() {
					function k(m, f, g = 0, l = m ? m.byteLength : 0) {
						this._tag = 0;
						this._dataType = c.unknown;
						this._init(m, f, g, l)
					}
					var v = k.prototype;
					v._init = function(m, f, g, l) {
						this._data = m;
						this._dataView = f;
						this._pos = g;
						this._end = l
					};
					v.asUnsafe = function() {
						return this
					};
					v.clone = function() {
						return new k(this._data, this._dataView, this._pos, this._end)
					};
					v.pos = function() {
						return this._pos
					};
					v.move = function(m) {
						this._pos = m
					};
					v.nextTag = function(m) {
						for (;;) {
							if (this._pos === this._end) return !1;
							const f = this._decodeVarint();
							this._tag = f >> 3;
							this._dataType = f & 7;
							if (!m || m === this._tag) break;
							this.skip()
						}
						return !0
					};
					v.next = function() {
						if (this._pos === this._end) return !1;
						const m = this._decodeVarint();
						this._tag = m >> 3;
						this._dataType = m & 7;
						return !0
					};
					v.empty = function() {
						return this._pos >= this._end
					};
					v.tag =
						function() {
							return this._tag
						};
					v.getInt32 = function() {
						return this._decodeVarint()
					};
					v.getInt64 = function() {
						return this._decodeVarint()
					};
					v.getUInt32 = function() {
						let m = 4294967295;
						m = (this._data[this._pos] & 127) >>> 0;
						if (128 > this._data[this._pos++]) return m;
						m = (m | (this._data[this._pos] & 127) << 7) >>> 0;
						if (128 > this._data[this._pos++]) return m;
						m = (m | (this._data[this._pos] & 127) << 14) >>> 0;
						if (128 > this._data[this._pos++]) return m;
						m = (m | (this._data[this._pos] & 127) << 21) >>> 0;
						if (128 > this._data[this._pos++]) return m;
						m = (m | (this._data[this._pos] &
							15) << 28) >>> 0;
						if (128 > this._data[this._pos++]) return m
					};
					v.getUInt64 = function() {
						return this._decodeVarint()
					};
					v.getSInt32 = function() {
						const m = this.getUInt32();
						if (void 0 !== m) return m >>> 1 ^ -(m & 1) | 0
					};
					v.getSInt64 = function() {
						return this._decodeSVarint()
					};
					v.getBool = function() {
						const m = 0 !== this._data[this._pos];
						this._skip(1);
						return m
					};
					v.getEnum = function() {
						return this._decodeVarint()
					};
					v.getFixed64 = function() {
						var m = this._dataView;
						const f = this._pos;
						m = m.getUint32(f, !0) + 4294967296 * m.getUint32(f + 4, !0);
						this._skip(8);
						return m
					};
					v.getSFixed64 = function() {
						var m = this._dataView;
						const f = this._pos;
						m = m.getUint32(f, !0) + 4294967296 * m.getInt32(f + 4, !0);
						this._skip(8);
						return m
					};
					v.getDouble = function() {
						const m = this._dataView.getFloat64(this._pos, !0);
						this._skip(8);
						return m
					};
					v.getFixed32 = function() {
						const m = this._dataView.getUint32(this._pos, !0);
						this._skip(4);
						return m
					};
					v.getSFixed32 = function() {
						const m = this._dataView.getInt32(this._pos, !0);
						this._skip(4);
						return m
					};
					v.getFloat = function() {
						const m = this._dataView.getFloat32(this._pos, !0);
						this._skip(4);
						return m
					};
					v.getString = function() {
						const m = this._getLength();
						var f = this._pos;
						f = this._toString(this._data, f, f + m);
						this._skip(m);
						return f
					};
					v.getBytes = function() {
						const m = this._getLength();
						var f = this._pos;
						f = this._toBytes(this._data, f, f + m);
						this._skip(m);
						return f
					};
					v.getLength = function() {
						return this._getLengthUnsafe()
					};
					v.processMessageWithArgs = function(m, f, g, l) {
						const r = this.getMessage();
						m = m(r, f, g, l);
						r.release();
						return m
					};
					v.processMessage = function(m) {
						const f = this.getMessage();
						m = m(f);
						f.release();
						return m
					};
					v.getMessage = function() {
						const m = this._getLength(),
							f = k.pool.acquire();
						f._init(this._data, this._dataView, this._pos, this._pos + m);
						this._skip(m);
						return f
					};
					v.release = function() {
						k.pool.release(this)
					};
					v.dataType = function() {
						return this._dataType
					};
					v.skip = function() {
						switch (this._dataType) {
							case c.varint:
								this._decodeVarint();
								break;
							case c.fixed64:
								this._skip(8);
								break;
							case c.delimited:
								this._skip(this._getLength());
								break;
							case c.fixed32:
								this._skip(4);
								break;
							default:
								throw Error("Invalid data type!");
						}
					};
					v.skipLen =
						function(m) {
							this._skip(m)
						};
					v._skip = function(m) {
						if (this._pos + m > this._end) throw Error("Attempt to skip past the end of buffer!");
						this._pos += m
					};
					v._decodeVarint = function() {
						const m = this._data;
						let f = this._pos,
							g = 0,
							l = 0;
						if (10 <= this._end - f) {
							if (l = m[f++], g |= l & 127, 0 !== (l & 128) && (l = m[f++], g |= (l & 127) << 7, 0 !== (l & 128) && (l = m[f++], g |= (l & 127) << 14, 0 !== (l & 128) && (l = m[f++], g |= (l & 127) << 21, 0 !== (l & 128) && (l = m[f++], g += 268435456 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 34359738368 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 4398046511104 * (l & 127),
								0 !== (l & 128) && (l = m[f++], g += 562949953421312 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 72057594037927936 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 0x7fffffffffffffff * (l & 127), 0 !== (l & 128))))))))))) throw Error("Varint too long!");
						} else {
							let r = 1;
							for (; f !== this._end;) {
								l = m[f];
								if (0 === (l & 128)) break;
								++f;
								g += (l & 127) * r;
								r *= 128
							}
							if (f === this._end) throw Error("Varint overrun!");
							++f;
							g += l * r
						}
						this._pos = f;
						return g
					};
					v._decodeSVarint = function() {
						const m = this._data;
						let f = this._pos,
							g = 0,
							l = 0;
						const r = m[f] & 1;
						if (10 <= this._end - f) {
							if (l = m[f++], g |= l & 127,
								0 !== (l & 128) && (l = m[f++], g |= (l & 127) << 7, 0 !== (l & 128) && (l = m[f++], g |= (l & 127) << 14, 0 !== (l & 128) && (l = m[f++], g |= (l & 127) << 21, 0 !== (l & 128) && (l = m[f++], g += 268435456 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 34359738368 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 4398046511104 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 562949953421312 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 72057594037927936 * (l & 127), 0 !== (l & 128) && (l = m[f++], g += 0x7fffffffffffffff * (l & 127), 0 !== (l & 128))))))))))) throw Error("Varint too long!");
						} else {
							let p = 1;
							for (; f !== this._end;) {
								l = m[f];
								if (0 === (l & 128)) break;
								++f;
								g += (l & 127) * p;
								p *= 128
							}
							if (f === this._end) throw Error("Varint overrun!");
							++f;
							g += l * p
						}
						this._pos = f;
						return r ? -(g + 1) / 2 : g / 2
					};
					v._getLength = function() {
						if (this._dataType !== c.delimited) throw Error("Not a delimited data type!");
						return this._decodeVarint()
					};
					v._getLengthUnsafe = function() {
						return this.getUInt32()
					};
					v._toString = function(m, f, g) {
						g = Math.min(this._end, g);
						if (g - f > d) return m = m.subarray(f, g), e.decode(m);
						let l = "",
							r = "";
						for (; f < g; ++f) {
							const p = m[f];
							p & 128 ? r += "%" + p.toString(16) : (l += decodeURIComponent(r) +
								String.fromCharCode(p), r = "")
						}
						r.length && (l += decodeURIComponent(r));
						return l
					};
					v._toBytes = function(m, f, g) {
						g = Math.min(this._end, g);
						return new Uint8Array(m.buffer, f, g - f)
					};
					return k
				}();
				a.pool = new b(a, void 0, k => {
					k._data = null;
					k._dataView = null
				});
				return a
			})
		},
		"esri/layers/graphics/OptimizedGeometry": function() {
			define(["../../chunks/_rollupPluginBabelHelpers"], function(a) {
				return function() {
					function b(e = [], d = [], k = !1) {
						this.lengths = e ? ? [];
						this.coords = d ? ? [];
						this.hasIndeterminateRingOrder = k
					}
					b.fromRect = function(e) {
						const [d,
							k, v, m
						] = e;
						e = v - d;
						const f = m - k;
						return new b([5], [d, k, e, 0, 0, f, -e, 0, 0, -f])
					};
					var c = b.prototype;
					c.forEachVertex = function(e) {
						let d = 0;
						this.lengths.length || e(this.coords[0], this.coords[1]);
						for (let k = 0; k < this.lengths.length; k++) {
							const v = this.lengths[k];
							for (let m = 0; m < v; m++) e(this.coords[2 * (m + d)], this.coords[2 * (m + d) + 1]);
							d += v
						}
					};
					c.clone = function(e) {
						return e ? (e.set(this.coords), new b(this.lengths.slice(), e, this.hasIndeterminateRingOrder)) : new b(this.lengths.slice(), this.coords.slice(), this.hasIndeterminateRingOrder)
					};
					a._createClass(b, [{
						key: "isPoint",
						get: function() {
							return 0 === this.lengths.length
						}
					}, {
						key: "maxLength",
						get: function() {
							return Math.max(...this.lengths)
						}
					}, {
						key: "size",
						get: function() {
							return this.lengths.reduce((e, d) => e + d)
						}
					}]);
					return b
				}()
			})
		},
		"esri/rest/query/operations/pbfOptimizedFeatureSet": function() {
			define("exports ../../../core/unitUtils ../../../geometry/support/spatialReferenceUtils ../../../layers/graphics/OptimizedFeature ../../../layers/graphics/OptimizedFeatureSet ../../../layers/graphics/OptimizedGeometry".split(" "),
				function(a, b, c, e, d, k) {
					const v = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"];
					let m = function() {
						function f(l) {
							this._options = l;
							this.geometryTypes = v;
							this._vertexDimension = this._coordinatePtr = 0
						}
						var g = f.prototype;
						g.createFeatureResult = function() {
							return new d
						};
						g.prepareFeatures = function(l) {
							this._vertexDimension = 2;
							l.hasZ && this._vertexDimension++;
							l.hasM && this._vertexDimension++
						};
						g.finishFeatureResult = function(l) {
							if (l && l.features && l.hasZ && this._options.sourceSpatialReference &&
								l.spatialReference && !c.equals(l.spatialReference, this._options.sourceSpatialReference) && !l.spatialReference.vcsWkid) {
								var r = b.getMetersPerVerticalUnitForSR(this._options.sourceSpatialReference),
									p = b.getMetersPerVerticalUnitForSR(l.spatialReference);
								r /= p;
								if (1 !== r)
									for (const n of l.features)
										if (e.hasGeometry(n))
											for (l = n.geometry.coords, p = 2; p < l.length; p += 3) l[p] *= r
							}
						};
						g.addFeature = function(l, r) {
							l.features.push(r)
						};
						g.createFeature = function() {
							return new e.OptimizedFeature
						};
						g.createSpatialReference = function() {
							return {
								wkid: 0
							}
						};
						g.createGeometry = function() {
							return new k
						};
						g.addField = function(l, r) {
							l.fields.push(r)
						};
						g.allocateCoordinates = function(l) {
							l.coords.length = l.lengths.reduce((r, p) => r + p, 0) * this._vertexDimension;
							this._coordinatePtr = 0
						};
						g.addCoordinate = function(l, r) {
							l.coords[this._coordinatePtr++] = r
						};
						g.addCoordinatePoint = function(l, r) {
							l.coords.push(r)
						};
						g.addLength = function(l, r) {
							l.lengths.push(r)
						};
						g.addQueryGeometry = function(l, r) {
							l.queryGeometry = r.queryGeometry;
							l.queryGeometryType = r.queryGeometryType
						};
						g.createPointGeometry =
							function() {
								return new k
							};
						return f
					}();
					a.OPTIMIZED_GEOMETRY_TYPES = v;
					a.OptimizedFeatureSetParserContext = m;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/layers/graphics/OptimizedFeature": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../core/maybe"], function(a, b, c) {
				let e = function() {
						function k(v = null, m = {}, f, g) {
							this.geometry = v;
							this.attributes = m;
							this.centroid = f;
							this.objectId = g;
							this.geohashY = this.geohashX = this.displayId = 0
						}
						k.prototype.weakClone =
							function() {
								const v = new k(this.geometry, this.attributes, this.centroid, this.objectId);
								v.displayId = this.displayId;
								v.geohashX = this.geohashX;
								v.geohashY = this.geohashY;
								return v
							};
						return k
					}(),
					d = function(k) {
						function v() {
							return k.apply(this, arguments) || this
						}
						b._inheritsLoose(v, k);
						return v
					}(e);
				a.OptimizedFeature = e;
				a.OptimizedFeatureWithGeometry = d;
				a.hasGeometry = function(k) {
					return !(c.isNone(k.geometry) || !k.geometry.coords || !k.geometry.coords.length)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/graphics/OptimizedFeatureSet": function() {
			define(function() {
				return function() {
					function a() {
						this.spatialReference = this.geometryType = this.geometryProperties = this.geohashFieldName = this.globalIdFieldName = this.objectIdFieldName = null;
						this.hasM = this.hasZ = !1;
						this.features = [];
						this.fields = [];
						this.transform = null;
						this.exceededTransferLimit = !1;
						this.queryGeometry = this.queryGeometryType = this.uniqueIdField = null
					}
					a.prototype.weakClone = function() {
						const b = new a;
						b.objectIdFieldName = this.objectIdFieldName;
						b.globalIdFieldName = this.globalIdFieldName;
						b.geohashFieldName = this.geohashFieldName;
						b.geometryProperties = this.geometryProperties;
						b.geometryType = this.geometryType;
						b.spatialReference = this.spatialReference;
						b.hasZ = this.hasZ;
						b.hasM = this.hasM;
						b.features = this.features;
						b.fields = this.fields;
						b.transform = this.transform;
						b.exceededTransferLimit = this.exceededTransferLimit;
						b.uniqueIdField = this.uniqueIdField;
						b.queryGeometry = this.queryGeometry;
						b.queryGeometryType = this.queryGeometryType;
						return b
					};
					return a
				}()
			})
		},
		"esri/rest/query/executeQueryPBF": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../utils ./operations/pbfJSONFeatureSet ./operations/query ../support/FeatureSet ../support/Query".split(" "),
				function(a, b, c, e, d, k, v) {
					function m() {
						m = b._asyncToGenerator(function*(l, r, p) {
							l = yield f(l, v.from(r), p);
							return k.fromJSON(l)
						});
						return m.apply(this, arguments)
					}

					function f(l, r, p) {
						return g.apply(this, arguments)
					}

					function g() {
						g = b._asyncToGenerator(function*(l, r, p) {
							l = c.parseUrl(l);
							p = {
								...p
							};
							r = v.from(r);
							({
								data: r
							} = yield d.executeQueryPBF(l, r, new e.JSONFeatureSetParserContext({
								sourceSpatialReference: r.sourceSpatialReference,
								applyTransform: !r.quantizationParameters
							}), p));
							return r
						});
						return g.apply(this, arguments)
					}
					a.executeQueryPBF = function(l, r, p) {
						return m.apply(this, arguments)
					};
					a.executeRawQueryPBF = f;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/rest/query/operations/pbfJSONFeatureSet": function() {
			define(["exports", "../../../core/maybe", "../../../geometry/support/zscale", "../../../layers/graphics/featureConversionUtils"], function(a, b, c, e) {
				function d(p, n) {
					return n
				}

				function k(p, n, t, h) {
					switch (t) {
						case 0:
							return g(p, n + h, 0);
						case 1:
							return "lowerLeft" === p.originPosition ?
								g(p, n + h, 1) : l(p, n + h, 1)
					}
				}

				function v(p, n, t, h) {
					switch (t) {
						case 2:
							return g(p, n, 2);
						default:
							return k(p, n, t, h)
					}
				}

				function m(p, n, t, h) {
					switch (t) {
						case 2:
							return g(p, n, 3);
						default:
							return k(p, n, t, h)
					}
				}

				function f(p, n, t, h) {
					switch (t) {
						case 3:
							return g(p, n, 3);
						default:
							return v(p, n, t, h)
					}
				}

				function g({
					translate: p,
					scale: n
				}, t, h) {
					return p[h] + t * n[h]
				}

				function l({
					translate: p,
					scale: n
				}, t, h) {
					return p[h] - t * n[h]
				}
				let r = function() {
					function p(t) {
						this._options = t;
						this.geometryTypes = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline",
							"esriGeometryPolygon"
						];
						this._previousCoordinate = [0, 0];
						this._transform = null;
						this._applyTransform = d;
						this._lengths = [];
						this._vertexDimension = this._toAddInCurrentPath = this._currentLengthIndex = 0;
						this._coordinateBuffer = null;
						this._coordinateBufferPtr = 0;
						this._attributesConstructor = function() {
							return function() {}
						}()
					}
					var n = p.prototype;
					n.createFeatureResult = function() {
						return {
							fields: [],
							features: []
						}
					};
					n.finishFeatureResult = function(t) {
						this._options.applyTransform && (t.transform = null);
						this._attributesConstructor = function() {
							return function() {}
						}();
						this._coordinateBuffer = null;
						this._lengths.length = 0;
						if (t.hasZ) {
							var h = c.getGeometryZScaler(t.geometryType, this._options.sourceSpatialReference, t.spatialReference);
							if (!b.isNone(h))
								for (const q of t.features) h(q.geometry)
						}
					};
					n.createSpatialReference = function() {
						return {}
					};
					n.addField = function(t, h) {
						t = t.fields;
						b.assertIsSome(t);
						t.push(h);
						const q = t.map(u => u.name);
						this._attributesConstructor = function() {
							for (const u of q) this[u] = null
						}
					};
					n.addFeature = function(t, h) {
						t.features.push(h)
					};
					n.prepareFeatures = function(t) {
						this._transform =
							t.transform;
						this._options.applyTransform && t.transform && (this._applyTransform = this._deriveApplyTransform(t));
						this._vertexDimension = 2;
						t.hasZ && this._vertexDimension++;
						t.hasM && this._vertexDimension++;
						switch (t.geometryType) {
							case "esriGeometryPoint":
								this.addCoordinate = (h, q, u) => this.addCoordinatePoint(h, q, u);
								this.createGeometry = h => this.createPointGeometry(h);
								break;
							case "esriGeometryPolygon":
								this.addCoordinate = (h, q, u) => this._addCoordinatePolygon(h, q, u);
								this.createGeometry = h => this._createPolygonGeometry(h);
								break;
							case "esriGeometryPolyline":
								this.addCoordinate = (h, q, u) => this._addCoordinatePolyline(h, q, u);
								this.createGeometry = h => this._createPolylineGeometry(h);
								break;
							case "esriGeometryMultipoint":
								this.addCoordinate = (h, q, u) => this._addCoordinateMultipoint(h, q, u), this.createGeometry = h => this._createMultipointGeometry(h)
						}
					};
					n.createFeature = function() {
						this._currentLengthIndex = this._lengths.length = 0;
						this._previousCoordinate[0] = 0;
						this._previousCoordinate[1] = 0;
						this._coordinateBuffer = null;
						this._coordinateBufferPtr =
							0;
						return {
							attributes: new this._attributesConstructor
						}
					};
					n.allocateCoordinates = function() {};
					n.addLength = function(t, h, q) {
						0 === this._lengths.length && (this._toAddInCurrentPath = h);
						this._lengths.push(h)
					};
					n.addQueryGeometry = function(t, h) {
						const {
							queryGeometry: q,
							queryGeometryType: u
						} = h;
						h = e.unquantizeOptimizedGeometry(q.clone(), q, !1, !1, this._transform);
						h = e.convertToGeometry(h, u, !1, !1);
						t.queryGeometryType = u;
						t.queryGeometry = {
							...h
						}
					};
					n.createPointGeometry = function(t) {
						const h = {
							x: 0,
							y: 0,
							spatialReference: t.spatialReference
						};
						t.hasZ && (h.z = 0);
						t.hasM && (h.m = 0);
						return h
					};
					n.addCoordinatePoint = function(t, h, q) {
						const u = b.unwrapOrThrow(this._transform, "transform");
						h = this._applyTransform(u, h, q, 0);
						switch (q) {
							case 0:
								t.x = h;
								break;
							case 1:
								t.y = h;
								break;
							case 2:
								"z" in t ? t.z = h : t.m = h;
								break;
							case 3:
								t.m = h
						}
					};
					n._transformPathLikeValue = function(t, h) {
						let q = 0;
						1 >= h && (q = this._previousCoordinate[h], this._previousCoordinate[h] += t);
						const u = b.unwrapOrThrow(this._transform, "transform");
						return this._applyTransform(u, t, h, q)
					};
					n._addCoordinatePolyline = function(t,
						h, q) {
						this._dehydratedAddPointsCoordinate(t.paths, h, q)
					};
					n._addCoordinatePolygon = function(t, h, q) {
						this._dehydratedAddPointsCoordinate(t.rings, h, q)
					};
					n._addCoordinateMultipoint = function(t, h, q) {
						0 === q && t.points.push([]);
						h = this._transformPathLikeValue(h, q);
						t.points[t.points.length - 1].push(h)
					};
					n._createPolygonGeometry = function(t) {
						return {
							rings: [
								[]
							],
							spatialReference: t.spatialReference,
							hasZ: !!t.hasZ,
							hasM: !!t.hasM
						}
					};
					n._createPolylineGeometry = function(t) {
						return {
							paths: [
								[]
							],
							spatialReference: t.spatialReference,
							hasZ: !!t.hasZ,
							hasM: !!t.hasM
						}
					};
					n._createMultipointGeometry = function(t) {
						return {
							points: [],
							spatialReference: t.spatialReference,
							hasZ: !!t.hasZ,
							hasM: !!t.hasM
						}
					};
					n._dehydratedAddPointsCoordinate = function(t, h, q) {
						0 === q && 0 === this._toAddInCurrentPath-- && (t.push([]), this._toAddInCurrentPath = this._lengths[++this._currentLengthIndex] - 1, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0);
						h = this._transformPathLikeValue(h, q);
						t = t[t.length - 1];
						0 === q && (this._coordinateBufferPtr = 0, this._coordinateBuffer = Array(this._vertexDimension),
							t.push(this._coordinateBuffer));
						this._coordinateBuffer[this._coordinateBufferPtr++] = h
					};
					n._deriveApplyTransform = function(t) {
						const {
							hasZ: h,
							hasM: q
						} = t;
						return h && q ? f : h ? v : q ? m : k
					};
					return p
				}();
				a.JSONFeatureSetParserContext = r;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/graphics/featureConversionUtils": function() {
			define("exports ../../core/Error ../../core/Logger ../../core/maybe ../../geometry/support/jsonUtils ./OptimizedFeature ./OptimizedFeatureSet ./OptimizedGeometry".split(" "),
				function(a, b, c, e, d, k, v, m) {
					function f(S, ba) {
						return S ? ba ? 4 : 3 : ba ? 3 : 2
					}

					function g(S, ba, la, ha) {
						if (S) {
							if (la) return ba && ha ? N : sa;
							if (ba && ha) return I
						} else if (ba && ha) return sa;
						return ja
					}

					function l({
						scale: S,
						translate: ba
					}, la) {
						return Math.round((la - ba[0]) / S[0])
					}

					function r({
						scale: S,
						translate: ba
					}, la) {
						return Math.round((ba[1] - la) / S[1])
					}

					function p({
						scale: S,
						translate: ba
					}, la, ha) {
						return la * S[ha] + ba[ha]
					}

					function n(S) {
						S = S.coords;
						return {
							x: S[0],
							y: S[1]
						}
					}

					function t(S, ba) {
						S.coords[0] = ba.x;
						S.coords[1] = ba.y;
						return S
					}

					function h(S) {
						S =
							S.coords;
						return {
							x: S[0],
							y: S[1],
							z: S[2]
						}
					}

					function q(S, ba) {
						S.coords[0] = ba.x;
						S.coords[1] = ba.y;
						S.coords[2] = ba.z;
						return S
					}

					function u(S) {
						S = S.coords;
						return {
							x: S[0],
							y: S[1],
							m: S[2]
						}
					}

					function x(S, ba) {
						S.coords[0] = ba.x;
						S.coords[1] = ba.y;
						S.coords[2] = ba.m;
						return S
					}

					function y(S) {
						S = S.coords;
						return {
							x: S[0],
							y: S[1],
							z: S[2],
							m: S[3]
						}
					}

					function w(S, ba) {
						S.coords[0] = ba.x;
						S.coords[1] = ba.y;
						S.coords[2] = ba.z;
						S.coords[3] = ba.m;
						return S
					}

					function A(S, ba) {
						return S && ba ? w : S ? q : ba ? x : t
					}

					function B(S, ba, la, ha, P) {
						la = A(la, ha);
						for (const {
							geometry: ca,
							attributes: ka
						} of ba) ba = e.isSome(ca) ? la(new m, ca) : null, S.push(new k.OptimizedFeature(ba, ka, null, P ? ka[P] : void 0));
						return S
					}

					function E(S, ba, la, ha) {
						for (const {
							geometry: P,
							attributes: ca
						} of ba) S.push({
							attributes: ca,
							geometry: e.isSome(P) ? z(P, la, ha) : null
						});
						return S
					}

					function z(S, ba, la) {
						if (e.isNone(S)) return null;
						const ha = f(ba, la),
							P = [];
						for (let ca = 0; ca < S.coords.length; ca += ha) {
							const ka = [];
							for (let va = 0; va < ha; va++) ka.push(S.coords[ca + va]);
							P.push(ka)
						}
						return ba ? la ? {
							points: P,
							hasZ: ba,
							hasM: la
						} : {
							points: P,
							hasZ: ba
						} : la ? {
							points: P,
							hasM: la
						} : {
							points: P
						}
					}

					function C(S, ba, la, ha, P) {
						la = f(la, ha);
						for (const {
							geometry: ca,
							attributes: ka
						} of ba) ba = e.isSome(ca) ? D(new m, ca, la) : null, S.push(new k.OptimizedFeature(ba, ka, null, P ? ka[P] : void 0));
						return S
					}

					function D(S, ba, la = f(ba.hasZ, ba.hasM)) {
						S.lengths[0] = ba.points.length;
						const ha = S.coords;
						let P = 0;
						for (const ca of ba.points)
							for (ba = 0; ba < la; ba++) ha[P++] = ca[ba];
						return S
					}

					function J(S, ba, la) {
						if (!S) return null;
						const ha = f(ba, la),
							{
								coords: P,
								lengths: ca
							} = S;
						S = [];
						let ka = 0;
						for (const va of ca) {
							const Ca = [];
							for (let ma =
								0; ma < va; ma++) {
								const Q = [];
								for (let aa = 0; aa < ha; aa++) Q.push(P[ka++]);
								Ca.push(Q)
							}
							S.push(Ca)
						}
						return ba ? la ? {
							paths: S,
							hasZ: ba,
							hasM: la
						} : {
							paths: S,
							hasZ: ba
						} : la ? {
							paths: S,
							hasM: la
						} : {
							paths: S
						}
					}

					function K(S, ba, la, ha, P) {
						la = f(la, ha);
						for (const {
							geometry: ca,
							attributes: ka
						} of ba) ba = e.isSome(ca) ? H(new m, ca, la) : null, S.push(new k.OptimizedFeature(ba, ka, null, P ? ka[P] : void 0));
						return S
					}

					function H(S, ba, la = f(ba.hasZ, ba.hasM)) {
						const {
							lengths: ha,
							coords: P
						} = S;
						let ca = 0;
						for (const ka of ba.paths) {
							for (const va of ka)
								for (ba = 0; ba < la; ba++) P[ca++] =
									va[ba];
							ha.push(ka.length)
						}
						return S
					}

					function G(S, ba, la) {
						if (!S) return null;
						const ha = f(ba, la),
							{
								coords: P,
								lengths: ca
							} = S;
						S = [];
						let ka = 0;
						for (const va of ca) {
							const Ca = [];
							for (let ma = 0; ma < va; ma++) {
								const Q = [];
								for (let aa = 0; aa < ha; aa++) Q.push(P[ka++]);
								Ca.push(Q)
							}
							S.push(Ca)
						}
						return ba ? la ? {
							rings: S,
							hasZ: ba,
							hasM: la
						} : {
							rings: S,
							hasZ: ba
						} : la ? {
							rings: S,
							hasM: la
						} : {
							rings: S
						}
					}

					function F(S, ba, la, ha, P) {
						for (const {
							geometry: ca,
							centroid: ka,
							attributes: va
						} of ba) {
							ba = e.isSome(ca) ? L(new m, ca, la, ha) : null;
							const Ca = P ? va[P] : void 0;
							e.isSome(ka) ?
								S.push(new k.OptimizedFeature(ba, va, t(new m, ka), Ca)) : S.push(new k.OptimizedFeature(ba, va, null, Ca))
						}
						return S
					}

					function L(S, ba, la = ba.hasZ, ha = ba.hasM) {
						R(S, ba.rings, la, ha);
						return S
					}

					function R(S, ba, la, ha) {
						la = f(la, ha);
						const {
							lengths: P,
							coords: ca
						} = S;
						ha = 0;
						qa(S);
						for (const ka of ba) {
							for (const va of ka)
								for (ba = 0; ba < la; ba++) ca[ha++] = va[ba];
							P.push(ka.length)
						}
						return S
					}

					function V(S, ba, la, ha, P, ca) {
						Aa(S);
						if (!la) {
							for (const ka of ba) S.push(new k.OptimizedFeature(null, ka.attributes, null, ca ? ka.attributes[ca] : void 0));
							return S
						}
						switch (la) {
							case "esriGeometryPoint":
								return B(S,
									ba, ha, P, ca);
							case "esriGeometryMultipoint":
								return C(S, ba, ha, P, ca);
							case "esriGeometryPolyline":
								return K(S, ba, ha, P, ca);
							case "esriGeometryPolygon":
								return F(S, ba, ha, P, ca);
							default:
								Ka.error("convertToFeatureSet:unknown-geometry", new b(`Unable to parse unknown geometry type '${la}'`)), Aa(S)
						}
						return S
					}

					function U(S, ba, la, ha) {
						S = S && ("coords" in S ? S : S.geometry);
						if (e.isNone(S)) return null;
						switch (ba) {
							case "esriGeometryPoint":
								return ba = n, la && ha ? ba = y : la ? ba = h : ha && (ba = u), ba(S);
							case "esriGeometryMultipoint":
								return z(S,
									la, ha);
							case "esriGeometryPolyline":
								return J(S, la, ha);
							case "esriGeometryPolygon":
								return G(S, la, ha);
							default:
								return Ka.error("convertToGeometry:unknown-geometry", new b(`Unable to parse unknown geometry type '${ba}'`)), null
						}
					}

					function W(S, ba, la, ha, P) {
						Aa(S);
						if (e.isNone(la)) {
							for (const ka of ba) S.push({
								attributes: ka.attributes
							});
							return S
						}
						switch (la) {
							case "esriGeometryPoint":
								la = n;
								ha && P ? la = y : ha ? la = h : P && (la = u);
								for (var ca of ba) {
									const {
										geometry: ka,
										attributes: va
									} = ca;
									ha = e.isSome(ka) ? la(ka) : null;
									S.push({
										attributes: va,
										geometry: ha
									})
								}
								break;
							case "esriGeometryMultipoint":
								return E(S, ba, ha, P);
							case "esriGeometryPolyline":
								for (const {
									geometry: ka,
									attributes: va
								} of ba) S.push({
									attributes: va,
									geometry: e.isSome(ka) ? J(ka, ha, P) : null
								});
								break;
							case "esriGeometryPolygon":
								for (const {
									geometry: ka,
									attributes: va,
									centroid: Ca
								} of ba) ca = e.isSome(ka) ? G(ka, ha, P) : null, e.isSome(Ca) ? (ba = n(Ca), S.push({
									attributes: va,
									centroid: ba,
									geometry: ca
								})) : S.push({
									attributes: va,
									geometry: ca
								});
								break;
							default:
								Ka.error("convertToFeatureSet:unknown-geometry", new b(`Unable to parse unknown geometry type '${la}'`))
						}
						return S
					}

					function M(S, ba, la, ha, P, ca, ka = la, va = ha) {
						qa(S);
						if (e.isNone(ba) || !ba.coords.length) return null;
						P = da[P];
						const {
							coords: Ca,
							lengths: ma
						} = ba;
						ba = f(la, ha);
						const Q = f(la && ka, ha && va);
						la = g(la, ha, ka, va);
						if (!ma.length) return la(S.coords, Ca, 0, 0, l(ca, Ca[0]), r(ca, Ca[1])), qa(S, ba, 0), S;
						let aa, ta = 0,
							Da, Ga = 0;
						for (const Na of ma) {
							if (Na < P) continue;
							let Ma = 0;
							Da = Ga;
							va = ha = l(ca, Ca[ta]);
							aa = ka = r(ca, Ca[ta + 1]);
							la(S.coords, Ca, Da, ta, va, aa);
							Ma++;
							ta += ba;
							Da += Q;
							for (let Ta = 1; Ta < Na; Ta++, ta += ba)
								if (va = l(ca, Ca[ta]), aa = r(ca, Ca[ta + 1]), va !== ha ||
									aa !== ka) la(S.coords, Ca, Da, ta, va - ha, aa - ka), Da += Q, Ma++, ha = va, ka = aa;
							Ma >= P && (S.lengths.push(Ma), Ga = Da)
						}
						Aa(S.coords, Ga);
						return S.coords.length ? S : null
					}

					function T(S, ba, la, ha, P, ca, ka) {
						let va = ha,
							Ca = 0;
						for (let Q = ca + la; Q < ka; Q += la) {
							var ma = ba[Q];
							const aa = ba[Q + 1],
								ta = ba[ka],
								Da = ba[ka + 1];
							let Ga = ba[ca],
								Na = ba[ca + 1],
								Ma = ta - Ga,
								Ta = Da - Na;
							if (0 !== Ma || 0 !== Ta) {
								const Ra = ((ma - Ga) * Ma + (aa - Na) * Ta) / (Ma * Ma + Ta * Ta);
								1 < Ra ? (Ga = ta, Na = Da) : 0 < Ra && (Ga += Ma * Ra, Na += Ta * Ra)
							}
							Ma = ma - Ga;
							Ta = aa - Na;
							ma = Ma * Ma + Ta * Ta;
							ma > va && (Ca = Q, va = ma)
						}
						va > ha && (Ca - ca > la && T(S,
							ba, la, ha, P, ca, Ca), P(S, ba, S.length, Ca, ba[Ca], ba[Ca + 1]), ka - Ca > la && T(S, ba, la, ha, P, Ca, ka))
					}

					function Z(S, ba, la, ha, P) {
						const {
							coords: ca,
							lengths: ka
						} = ba;
						la = f(la, ha);
						if (!ca.length) return S !== ba && qa(S), S;
						e.assertIsSome(P);
						const {
							originPosition: va,
							scale: Ca,
							translate: ma
						} = P;
						P = xa;
						P.originPosition = va;
						ha = P.scale;
						ha[0] = Ca[0] ? ? 1;
						ha[1] = -(Ca[1] ? ? 1);
						ha[2] = Ca[2] ? ? 1;
						ha[3] = Ca[3] ? ? 1;
						var Q = P.translate;
						Q[0] = ma[0] ? ? 0;
						Q[1] = ma[1] ? ? 0;
						Q[2] = ma[2] ? ? 0;
						Q[3] = ma[3] ? ? 0;
						if (!ka.length) {
							for (ha = 0; ha < la; ++ha) S.coords[ha] = p(P, ca[ha], ha);
							S !==
								ba && qa(S, la, 0);
							return S
						}
						Q = 0;
						for (let ta = 0; ta < ka.length; ta++) {
							const Da = ka[ta];
							S.lengths[ta] = Da;
							for (var aa = 0; aa < la; ++aa) S.coords[Q + aa] = p(P, ca[Q + aa], aa);
							aa = S.coords[Q];
							let Ga = S.coords[Q + 1];
							Q += la;
							for (let Na = 1; Na < Da; Na++, Q += la) {
								aa += ca[Q] * ha[0];
								Ga += ca[Q + 1] * ha[1];
								S.coords[Q] = aa;
								S.coords[Q + 1] = Ga;
								for (let Ma = 2; Ma < la; ++Ma) S.coords[Q + Ma] = p(P, ca[Q + Ma], Ma)
							}
						}
						S !== ba && qa(S, ca.length, ka.length);
						return S
					}

					function oa(S, ba, la, ha) {
						let P = 0,
							ca = S[ha * ba],
							ka = S[ha * (ba + 1)];
						for (let va = 1; va < la; va++) {
							const Ca = ca + S[ha * (ba + va)],
								ma =
								ka + S[ha * (ba + va) + 1],
								Q = (Ca - ca) * (ma + ka);
							ca = Ca;
							ka = ma;
							P += Q
						}
						return .5 * P
					}

					function qa(S, ba = 0, la = 0) {
						Aa(S.lengths, la);
						Aa(S.coords, ba)
					}

					function Aa(S, ba = 0) {
						S.length !== ba && (S.length = ba)
					}
					const Ka = c.getLogger("esri.layers.graphics.featureConversionUtils"),
						da = {
							esriGeometryPoint: 0,
							esriGeometryPolyline: 2,
							esriGeometryPolygon: 3,
							esriGeometryMultipoint: 0
						},
						ja = (S, ba, la, ha, P, ca) => {
							S[la] = P;
							S[la + 1] = ca
						},
						sa = (S, ba, la, ha, P, ca) => {
							S[la] = P;
							S[la + 1] = ca;
							S[la + 2] = ba[ha + 2]
						},
						I = (S, ba, la, ha, P, ca) => {
							S[la] = P;
							S[la + 1] = ca;
							S[la + 2] = ba[ha + 3]
						},
						N = (S,
							ba, la, ha, P, ca) => {
							S[la] = P;
							S[la + 1] = ca;
							S[la + 2] = ba[ha + 2];
							S[la + 3] = ba[ha + 3]
						},
						ea = [],
						pa = [],
						xa = {
							originPosition: "lowerLeft",
							scale: [1, 1, 1, 1],
							translate: [0, 0, 0, 0]
						};
					a.convertFromFeature = function(S, ba, la, ha, P) {
						ea[0] = S;
						[S] = V(pa, ea, ba, la, ha, P);
						Aa(ea);
						Aa(pa);
						return S
					};
					a.convertFromFeatureSet = function(S, ba) {
						const la = new v,
							{
								hasM: ha,
								hasZ: P,
								features: ca,
								objectIdFieldName: ka,
								spatialReference: va,
								geometryType: Ca,
								exceededTransferLimit: ma,
								transform: Q,
								fields: aa
							} = S;
						aa && (la.fields = aa);
						la.geometryType = Ca ? ? null;
						la.objectIdFieldName =
							ka ? ? ba ? ? null;
						la.spatialReference = va ? ? null;
						if (!la.objectIdFieldName) return Ka.error(new b("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), la;
						ca && V(la.features, ca, Ca, P, ha, la.objectIdFieldName);
						ma && (la.exceededTransferLimit = ma);
						ha && (la.hasM = ha);
						P && (la.hasZ = P);
						Q && (la.transform = Q);
						return la
					};
					a.convertFromFeatures = V;
					a.convertFromGeometry = function(S, ba, la) {
						if (e.isNone(S)) return null;
						const ha = new m;
						"hasZ" in S && null == ba && (ba = S.hasZ);
						"hasM" in S && null == la && (la = S.hasM);
						if (d.isPoint(S)) return A(null !=
							ba ? ba : null != S.z, null != la ? la : null != S.m)(ha, S);
						if (d.isPolygon(S)) return L(ha, S, ba, la);
						if (d.isPolyline(S)) return H(ha, S, f(ba, la));
						if (d.isMultipoint(S)) return D(ha, S, f(ba, la));
						Ka.error("convertFromGeometry:unknown-geometry", new b(`Unable to parse unknown geometry type '${S}'`))
					};
					a.convertFromGraphics = function(S, ba, la, ha, P, ca) {
						const ka = S.length;
						switch (la) {
							case "esriGeometryPoint":
								B(S, ba, ha, P, ca);
								break;
							case "esriGeometryMultipoint":
								C(S, ba, ha, P, ca);
								break;
							case "esriGeometryPolyline":
								K(S, ba, ha, P, ca);
								break;
							case "esriGeometryPolygon":
								F(S, ba, ha, P, ca);
								break;
							default:
								Ka.error("convertToFeatureSet:unknown-geometry", new b(`Unable to parse unknown geometry type '${la}'`))
						}
						for (ha = 0; ha < ba.length; ha++) S[ha + ka].geometryType = la, S[ha + ka].insertAfter = ba[ha].insertAfter, S[ha + ka].groupId = ba[ha].groupId;
						return S
					};
					a.convertFromMultipoint = D;
					a.convertFromMultipointFeatures = C;
					a.convertFromNestedArray = R;
					a.convertFromPoint = function(S, ba, la = A(null != ba.z, null != ba.m)) {
						return la(S, ba)
					};
					a.convertFromPointFeatures = B;
					a.convertFromPolygon =
						L;
					a.convertFromPolyline = H;
					a.convertFromPolylineFeatures = K;
					a.convertToFeature = function(S, ba, la, ha) {
						pa[0] = S;
						W(ea, pa, ba, la, ha);
						S = ea[0];
						Aa(ea);
						Aa(pa);
						return S
					};
					a.convertToFeatureSet = function(S) {
						const {
							objectIdFieldName: ba,
							spatialReference: la,
							transform: ha,
							fields: P,
							hasM: ca,
							hasZ: ka,
							features: va,
							geometryType: Ca,
							exceededTransferLimit: ma,
							uniqueIdField: Q,
							queryGeometry: aa,
							queryGeometryType: ta
						} = S;
						S = W([], va, Ca, ka, ca);
						const Da = U(aa, ta, !1, !1);
						S = {
							features: S,
							fields: P,
							geometryType: Ca,
							objectIdFieldName: ba,
							spatialReference: la,
							uniqueIdField: Q,
							queryGeometry: Da
						};
						ha && (S.transform = ha);
						ma && (S.exceededTransferLimit = ma);
						ca && (S.hasM = ca);
						ka && (S.hasZ = ka);
						return S
					};
					a.convertToFeatures = W;
					a.convertToGeometry = U;
					a.convertToMultipoint = z;
					a.convertToMultipointFeatures = E;
					a.convertToPoint = function(S, ba, la) {
						return S ? ba ? la ? y(S) : h(S) : la ? u(S) : n(S) : null
					};
					a.convertToPolygon = G;
					a.convertToPolyline = J;
					a.deltaDecodeGeometry = function(S, ba) {
						if (e.isNone(S)) return null;
						const la = S.clone(),
							ha = S.coords;
						S = S.lengths;
						let P = 0;
						for (let va = 0; va < S.length; va++) {
							const Ca =
								S[va];
							var ca = ha[ba * P],
								ka = ha[ba * P + 1];
							for (let ma = 1; ma < Ca; ma++) ca += ha[ba * (P + ma)], ka += ha[ba * (P + ma) + 1], la.coords[ba * (P + ma)] = ca, la.coords[ba * (P + ma) + 1] = ka;
							P += Ca
						}
						return la
					};
					a.deltaEncodeGeometry = function(S, ba) {
						const la = S.clone(),
							ha = S.coords;
						S = S.lengths;
						let P = 0;
						for (let ka = 0; ka < S.length; ka++) {
							const va = S[ka];
							let Ca = ha[ba * P];
							var ca = ha[ba * P + 1];
							for (let ma = 1; ma < va; ma++) {
								const Q = ha[ba * (P + ma)],
									aa = ha[ba * (P + ma) + 1];
								ca = aa - ca;
								la.coords[ba * (P + ma)] = Q - Ca;
								la.coords[ba * (P + ma) + 1] = ca;
								Ca = Q;
								ca = aa
							}
							P += va
						}
						return la
					};
					a.generalizeOptimizedGeometry =
						function(S, ba, la, ha, P, ca, ka = la, va = ha) {
							qa(S);
							if (!ba || !ba.coords.length) return null;
							P = da[P];
							const {
								coords: Ca,
								lengths: ma
							} = ba;
							ba = f(la, ha);
							const Q = f(la && ka, ha && va);
							la = g(la, ha, ka, va);
							if (!ma.length) return la(S.coords, Ca, 0, 0, Ca[0], Ca[1]), qa(S, ba, 0), S;
							ha = 0;
							ca *= ca;
							for (const aa of ma) {
								if (aa < P) {
									ha += aa * ba;
									continue
								}
								ka = S.coords.length / Q;
								va = ha;
								const ta = ha + (aa - 1) * ba;
								la(S.coords, Ca, S.coords.length, va, Ca[va], Ca[va + 1]);
								T(S.coords, Ca, ba, ca, la, va, ta);
								la(S.coords, Ca, S.coords.length, ta, Ca[ta], Ca[ta + 1]);
								va = S.coords.length /
									Q - ka;
								va >= P ? S.lengths.push(va) : Aa(S.coords, ka * Q);
								ha += aa * ba
							}
							return S.coords.length ? S : null
						};
					a.getBoundsOptimizedGeometry = function(S, ba, la, ha) {
						if (e.isNone(ba) || !ba.coords || !ba.coords.length) return null;
						la = f(la, ha);
						let P = ha = Number.POSITIVE_INFINITY,
							ca = Number.NEGATIVE_INFINITY,
							ka = Number.NEGATIVE_INFINITY;
						if (ba && ba.coords) {
							ba = ba.coords;
							for (let va = 0; va < ba.length; va += la) {
								const Ca = ba[va],
									ma = ba[va + 1];
								ha = Math.min(ha, Ca);
								ca = Math.max(ca, Ca);
								P = Math.min(P, ma);
								ka = Math.max(ka, ma)
							}
						}
						S[0] = ha;
						S[1] = P;
						S[2] = ca;
						S[3] = ka;
						return S
					};
					a.getQuantizedArea = function(S, ba) {
						const {
							coords: la,
							lengths: ha
						} = S;
						let P = S = 0;
						for (let ca = 0; ca < ha.length; ca++) {
							const ka = ha[ca];
							P += oa(la, S, ka, ba);
							S += ka
						}
						return Math.abs(P)
					};
					a.getQuantizedBoundsOptimizedGeometry = function(S, ba, la, ha) {
						la = f(la, ha);
						const {
							lengths: P,
							coords: ca
						} = ba;
						ha = ba = Number.POSITIVE_INFINITY;
						let ka = Number.NEGATIVE_INFINITY,
							va = Number.NEGATIVE_INFINITY,
							Ca = 0;
						for (const ma of P) {
							let Q = ca[Ca],
								aa = ca[Ca + 1];
							ba = Math.min(Q, ba);
							ha = Math.min(aa, ha);
							ka = Math.max(Q, ka);
							va = Math.max(aa, va);
							Ca += la;
							for (let ta =
								1; ta < ma; ta++, Ca += la) {
								const Da = ca[Ca],
									Ga = ca[Ca + 1];
								Q += Da;
								aa += Ga;
								0 > Da && (ba = Math.min(ba, Q));
								0 < Da && (ka = Math.max(ka, Q));
								0 > Ga ? ha = Math.min(ha, aa) : 0 < Ga && (va = Math.max(va, aa))
							}
						}
						S[0] = ba;
						S[1] = ha;
						S[2] = ka;
						S[3] = va;
						return S
					};
					a.getSignedQuantizedRingArea = oa;
					a.quantizeOptimizedFeatureSet = function(S, ba) {
						const {
							geometryType: la,
							features: ha,
							hasM: P,
							hasZ: ca
						} = ba;
						if (!S) return ba;
						for (let ka = 0; ka < ha.length; ka++) {
							const va = ha[ka],
								Ca = va.weakClone();
							Ca.geometry = new m;
							M(Ca.geometry, va.geometry, P, ca, la, S);
							va.centroid && (Ca.centroid =
								new m, M(Ca.centroid, va.centroid, P, ca, "esriGeometryPoint", S));
							ha[ka] = Ca
						}
						ba.transform = S;
						return ba
					};
					a.quantizeOptimizedGeometry = M;
					a.quantizeX = l;
					a.quantizeY = r;
					a.removeCollinearVectices = function(S, ba, la, ha, P) {
						if (!ba || !ba.coords || !ba.coords.length) return null;
						la = da[la];
						const {
							coords: ca,
							lengths: ka
						} = ba;
						ba = g(ha, P, ha, P);
						ha = f(ha, P);
						let va = P = 0,
							Ca = 0,
							ma = 0;
						for (const ta of ka) {
							va = ma;
							ba(S.coords, ca, va, P, ca[P], ca[P + 1]);
							P += ha;
							var Q = ca[P];
							let Da = ca[P + 1],
								Ga = Q,
								Na = Da;
							var aa = Da / Q;
							va += ha;
							ba(S.coords, ca, va, P, Ga, Na);
							P += ha;
							for (let Ma = 2; Ma < ta; Ma++) {
								Q = ca[P];
								Da = ca[P + 1];
								const Ta = Da / Q,
									Ra = aa === Ta || !isFinite(aa) && !isFinite(Ta);
								aa = Ra && isFinite(Ta) ? 0 <= aa && 0 <= Ta || 0 >= aa && 0 >= Ta : 0 <= Na && 0 <= Da || 0 >= Na && 0 >= Da;
								Ra && aa ? (Ga += Q, Na += Da) : (Ga = Q, Na = Da, va += ha);
								ba(S.coords, ca, va, P, Ga, Na);
								P += ha;
								aa = Ta
							}
							va += ha;
							Q = (va - ma) / ha;
							Q >= la && (S.lengths[Ca] = Q, ma = va, Ca++)
						}
						S.coords.length > ma && (S.coords.length = ma);
						S.lengths.length > Ca && (S.lengths.length = Ca);
						return S.coords.length && S.lengths.length ? S : null
					};
					a.removeZMValues = function(S, ba, la, ha, P, ca) {
						qa(S);
						S.lengths.push(...ba.lengths);
						if (la === P && ha === ca)
							for (var ka = 0; ka < ba.coords.length; ka++) S.coords.push(ba.coords[ka]);
						else
							for (ka = f(la, ha), la = g(la, ha, P, ca), ba = ba.coords, ha = 0; ha < ba.length; ha += ka) la(S.coords, ba, S.coords.length, ha, ba[ha], ba[ha + 1]);
						return S
					};
					a.unquantizeOptimizedFeatureSet = function(S) {
						const {
							transform: ba,
							features: la,
							hasM: ha,
							hasZ: P
						} = S;
						if (!ba) return S;
						for (const ca of la) e.isSome(ca.geometry) && Z(ca.geometry, ca.geometry, ha, P, ba), e.isSome(ca.centroid) && Z(ca.centroid, ca.centroid, ha, P, ba);
						S.transform = null;
						return S
					};
					a.unquantizeOptimizedGeometry =
						Z;
					a.unquantizeValue = p;
					a.unquantizeX = function(S, ba) {
						return p(S, ba, 0)
					};
					a.unquantizeY = function(S, ba) {
						return p(S, -ba, 1)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/rest/query/executeAttachmentQuery": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../utils", "./operations/queryAttachments", "../support/AttachmentQuery"], function(a, b, c, e, d) {
				function k() {
					k = b._asyncToGenerator(function*(v, m, f) {
						const g = c.parseUrl(v);
						return e.executeAttachmentQuery(g,
								d.from(m), {
									...f
								})
							.then(l => e.processAttachmentQueryResult(l.data.attachmentGroups, g.path))
					});
					return k.apply(this, arguments)
				}
				a.executeAttachmentQuery = function(v, m, f) {
					return k.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/operations/queryAttachments": function() {
			define("exports ../../../kernel ../../../request ../../../core/urlUtils ../../operations/urlUtils ../support/AttachmentInfo".split(" "), function(a, b, c, e, d, k) {
				a.executeAttachmentQuery =
					function(v, m, f) {
						var g = d.mapParameters,
							l = {
								...v.query
							};
						m = m.toJSON();
						m.attachmentTypes && (m.attachmentTypes = m.attachmentTypes.join(","));
						m.keywords && (m.keywords = m.keywords.join(","));
						m.globalIds && (m.globalIds = m.globalIds.join(","));
						m.objectIds && (m.objectIds = m.objectIds.join(","));
						m.size && (m.size = m.size.join(","));
						g = {
							query: g.call(d, {
								...l,
								f: "json",
								...m
							})
						};
						f && (g = {
							...f,
							...g,
							query: {
								...f.query,
								...g.query
							}
						});
						return c(v.path + "/queryAttachments", g)
					};
				a.processAttachmentQueryResult = function(v, m) {
					const f = {};
					for (const g of v) {
						const {
							parentObjectId: l,
							parentGlobalId: r,
							attachmentInfos: p
						} = g;
						for (const n of p) {
							({
								id: v
							} = n);
							v = e.addProxy(b.addTokenParameter(`${m}/${l}/attachments/${v}`));
							const t = k.fromJSON(n);
							t.set({
								url: v,
								parentObjectId: l,
								parentGlobalId: r
							});
							f[l] ? f[l].push(t) : f[l] = [t]
						}
					}
					return f
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/support/AttachmentInfo": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/JSONSupport ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../layers/support/exifUtils".split(" "),
				function(a, b, c, e, d, k, v, m) {
					var f;
					const g = {
						1: {
							id: 1,
							rotation: 0,
							mirrored: !1
						},
						2: {
							id: 2,
							rotation: 0,
							mirrored: !0
						},
						3: {
							id: 3,
							rotation: 180,
							mirrored: !1
						},
						4: {
							id: 4,
							rotation: 180,
							mirrored: !0
						},
						5: {
							id: 5,
							rotation: -90,
							mirrored: !0
						},
						6: {
							id: 6,
							rotation: 90,
							mirrored: !1
						},
						7: {
							id: 7,
							rotation: 90,
							mirrored: !0
						},
						8: {
							id: 8,
							rotation: -90,
							mirrored: !1
						}
					};
					c = f = function(l) {
						function r(p) {
							p = l.call(this, p) || this;
							p.contentType = null;
							p.exifInfo = null;
							p.id = null;
							p.globalId = null;
							p.keywords = null;
							p.name = null;
							p.parentGlobalId = null;
							p.parentObjectId = null;
							p.size =
								null;
							p.url = null;
							return p
						}
						a._inheritsLoose(r, l);
						r.prototype.clone = function() {
							return new f({
								contentType: this.contentType,
								exifInfo: this.exifInfo,
								id: this.id,
								globalId: this.globalId,
								keywords: this.keywords,
								name: this.name,
								parentGlobalId: this.parentGlobalId,
								parentObjectId: this.parentObjectId,
								size: this.size,
								url: this.url
							})
						};
						a._createClass(r, [{
							key: "orientationInfo",
							get: function() {
								var {
									exifInfo: p
								} = this;
								p = m.getExifValue({
									exifName: "Exif IFD0",
									tagName: "Orientation",
									exifInfo: p
								});
								return g[p] || null
							}
						}]);
						return r
					}(c.JSONSupport);
					b.__decorate([e.property({
						type: String
					})], c.prototype, "contentType", void 0);
					b.__decorate([e.property()], c.prototype, "exifInfo", void 0);
					b.__decorate([e.property({
						readOnly: !0
					})], c.prototype, "orientationInfo", null);
					b.__decorate([e.property({
						type: k.Integer
					})], c.prototype, "id", void 0);
					b.__decorate([e.property({
						type: String
					})], c.prototype, "globalId", void 0);
					b.__decorate([e.property({
						type: String
					})], c.prototype, "keywords", void 0);
					b.__decorate([e.property({
						type: String
					})], c.prototype, "name", void 0);
					b.__decorate([e.property({
							json: {
								read: !1
							}
						})],
						c.prototype, "parentGlobalId", void 0);
					b.__decorate([e.property({
						json: {
							read: !1
						}
					})], c.prototype, "parentObjectId", void 0);
					b.__decorate([e.property({
						type: k.Integer
					})], c.prototype, "size", void 0);
					b.__decorate([e.property({
						json: {
							read: !1
						}
					})], c.prototype, "url", void 0);
					return c = f = b.__decorate([v.subclass("esri.layers.support.AttachmentInfo")], c)
				})
		},
		"esri/layers/support/exifUtils": function() {
			define(["exports"], function(a) {
				function b(c) {
					const {
						tagName: e,
						tags: d
					} = c;
					return d && e ? (c = d.find(k => k.name === e)) && c.value ||
						null : null
				}
				a.getExifValue = function(c) {
					const {
						exifInfo: e,
						exifName: d,
						tagName: k
					} = c;
					return e && d && k ? (c = e.find(v => v.name === d)) ? b({
						tagName: k,
						tags: c.tags
					}) : null : null
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/executeForCount": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../utils", "./operations/query", "../support/Query"], function(a, b, c, e, d) {
				function k() {
					k = b._asyncToGenerator(function*(v, m, f) {
						v = c.parseUrl(v);
						return e.executeQueryForCount(v,
								d.from(m), {
									...f
								})
							.then(g => g.data.count)
					});
					return k.apply(this, arguments)
				}
				a.executeForCount = function(v, m, f) {
					return k.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/executeForExtent": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../geometry ../utils ./operations/query ../support/Query ../../geometry/Extent".split(" "), function(a, b, c, e, d, k, v) {
				function m() {
					m = b._asyncToGenerator(function*(f, g, l) {
						f =
							e.parseUrl(f);
						return d.executeQueryForExtent(f, k.from(g), {
								...l
							})
							.then(r => ({
								count: r.data.count,
								extent: v.fromJSON(r.data.extent)
							}))
					});
					return m.apply(this, arguments)
				}
				a.executeForExtent = function(f, g, l) {
					return m.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/executeForIds": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../utils", "./operations/query", "../support/Query"], function(a, b, c, e, d) {
				function k() {
					k =
						b._asyncToGenerator(function*(v, m, f) {
							v = c.parseUrl(v);
							return e.executeQueryForIds(v, d.from(m), {
									...f
								})
								.then(g => g.data.objectIds)
						});
					return k.apply(this, arguments)
				}
				a.executeForIds = function(v, m, f) {
					return k.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/executeRelationshipQuery": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../utils ./operations/queryRelatedRecords ../support/FeatureSet ../support/RelationshipQuery".split(" "),
				function(a, b, c, e, d, k) {
					function v() {
						v = b._asyncToGenerator(function*(f, g, l) {
							g = k.from(g);
							f = c.parseUrl(f);
							return e.executeRelationshipQuery(f, g, l)
								.then(r => {
									const p = r.data,
										n = {};
									Object.keys(p)
										.forEach(t => n[t] = d.fromJSON(p[t]));
									return n
								})
						});
						return v.apply(this, arguments)
					}

					function m() {
						m = b._asyncToGenerator(function*(f, g, l) {
							g = k.from(g);
							f = c.parseUrl(f);
							return e.executeRelationshipQueryForCount(f, g, {
									...l
								})
								.then(r => r.data)
						});
						return m.apply(this, arguments)
					}
					a.executeRelationshipQuery = function(f, g, l) {
						return v.apply(this,
							arguments)
					};
					a.executeRelationshipQueryForCount = function(f, g, l) {
						return m.apply(this, arguments)
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/rest/query/operations/queryRelatedRecords": function() {
			define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../request", "../../operations/urlUtils"], function(a, b, c, e) {
				function d(g, l) {
					g = g.toJSON();
					g.objectIds && (g.objectIds = g.objectIds.join(","));
					g.orderByFields && (g.orderByFields = g.orderByFields.join(","));
					g.outFields && !l ? .returnCountOnly ? g.outFields.includes("*") ? g.outFields = "*" : g.outFields = g.outFields.join(",") : delete g.outFields;
					g.outSpatialReference && (g.outSR = g.outSR.wkid || JSON.stringify(g.outSR.toJSON()), delete g.outSpatialReference);
					g.dynamicDataSource && (g.layer = JSON.stringify({
						source: g.dynamicDataSource
					}), delete g.dynamicDataSource);
					return g
				}

				function k() {
					k = b._asyncToGenerator(function*(g, l, r) {
						g = yield m(g, l, r);
						l = g.data;
						r = l.geometryType;
						const p = l.spatialReference,
							n = {};
						for (const t of l.relatedRecordGroups) {
							const h = {
								fields: void 0,
								objectIdFieldName: void 0,
								geometryType: r,
								spatialReference: p,
								hasZ: !!l.hasZ,
								hasM: !!l.hasM,
								features: t.relatedRecords
							};
							if (null != t.objectId) n[t.objectId] = h;
							else
								for (const q in t) t.hasOwnProperty(q) && "relatedRecords" !== q && (n[t[q]] = h)
						}
						return {
							...g,
							data: n
						}
					});
					return k.apply(this, arguments)
				}

				function v() {
					v = b._asyncToGenerator(function*(g, l, r) {
						g = yield m(g, l, r, {
							returnCountOnly: !0
						});
						l = g.data;
						r = {};
						for (const p of l.relatedRecordGroups) null != p.objectId && (r[p.objectId] = p.count);
						return {
							...g,
							data: r
						}
					});
					return v.apply(this,
						arguments)
				}

				function m(g, l) {
					return f.apply(this, arguments)
				}

				function f() {
					f = b._asyncToGenerator(function*(g, l, r = {}, p) {
						l = e.mapParameters({
							...g.query,
							f: "json",
							...p,
							...d(l, p)
						});
						return c(g.path + "/queryRelatedRecords", {
							...r,
							query: {
								...r.query,
								...l
							}
						})
					});
					return f.apply(this, arguments)
				}
				a.executeRelationshipQuery = function(g, l, r) {
					return k.apply(this, arguments)
				};
				a.executeRelationshipQueryForCount = function(g, l, r) {
					return v.apply(this, arguments)
				};
				a.toQueryStringParameters = d;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/executeTopFeaturesQuery": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../utils ./operations/queryTopFeatures ../support/FeatureSet ../support/TopFeaturesQuery".split(" "), function(a, b, c, e, d, k) {
				function v() {
					v = b._asyncToGenerator(function*(m, f, g, l) {
						m = c.parseUrl(m);
						l = {
							...l
						};
						({
							data: f
						} = yield e.executeTopFeaturesQuery(m, k.from(f), g, l));
						return d.fromJSON(f)
					});
					return v.apply(this, arguments)
				}
				a.executeTopFeaturesQuery = function(m,
					f, g, l) {
					return v.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/operations/queryTopFeatures": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../request ../../../core/maybe ../../../core/urlUtils ../../../geometry/support/jsonUtils ../../../geometry/support/normalizeUtils ../../operations/urlUtils ./queryZScale".split(" "), function(a, b, c, e, d, k, v, m, f) {
				function g(t, h) {
					const q = t.geometry;
					t = t.toJSON();
					e.isSome(q) && (t.geometry = JSON.stringify(q), t.geometryType = k.getJsonType(q), t.inSR = q.spatialReference.wkid || JSON.stringify(q.spatialReference));
					t.topFilter ? .groupByFields && (t.topFilter.groupByFields = t.topFilter.groupByFields.join(","));
					t.topFilter ? .orderByFields && (t.topFilter.orderByFields = t.topFilter.orderByFields.join(","));
					t.topFilter && (t.topFilter = JSON.stringify(t.topFilter));
					t.objectIds && (t.objectIds = t.objectIds.join(","));
					t.orderByFields && (t.orderByFields = t.orderByFields.join(","));
					!t.outFields ||
						h ? .returnCountOnly || h ? .returnExtentOnly || h ? .returnIdsOnly ? delete t.outFields : t.outFields.includes("*") ? t.outFields = "*" : t.outFields = t.outFields.join(",");
					t.outSR ? t.outSR = t.outSR.wkid || JSON.stringify(t.outSR) : q && t.returnGeometry && (t.outSR = t.inSR);
					t.returnGeometry && delete t.returnGeometry;
					if (t.timeExtent) {
						const {
							start: u,
							end: x
						} = t.timeExtent;
						if (null != u || null != x) t.time = u === x ? u : `${null==u?"null":u},${null==x?"null":x}`;
						delete t.timeExtent
					}
					return t
				}

				function l() {
					l = b._asyncToGenerator(function*(t, h, q, u) {
						t =
							yield n(t, h, "json", u);
						f.applyFeatureSetZUnitScaling(h, q, t.data);
						return t
					});
					return l.apply(this, arguments)
				}

				function r() {
					r = b._asyncToGenerator(function*(t, h, q) {
						return e.isSome(h.timeExtent) && h.timeExtent.isEmpty ? {
							data: {
								objectIds: []
							}
						} : n(t, h, "json", q, {
							returnIdsOnly: !0
						})
					});
					return r.apply(this, arguments)
				}

				function p() {
					p = b._asyncToGenerator(function*(t, h, q) {
						return e.isSome(h.timeExtent) && h.timeExtent.isEmpty ? {
								data: {
									count: 0,
									extent: null
								}
							} : n(t, h, "json", q, {
								returnExtentOnly: !0,
								returnCountOnly: !0
							})
							.then(u => {
								const x =
									u.data;
								if (x.hasOwnProperty("extent")) return u;
								if (x.features) throw Error("Layer does not support extent calculation.");
								if (x.hasOwnProperty("count")) throw Error("Layer does not support extent calculation.");
								return u
							})
					});
					return p.apply(this, arguments)
				}

				function n(t, h, q, u = {}, x = {}) {
					const y = "string" === typeof t ? d.urlToObject(t) : t;
					t = h.geometry ? [h.geometry] : [];
					u.responseType = "pbf" === q ? "array-buffer" : "json";
					return v.normalizeCentralMeridian(t, null, u)
						.then(w => {
							w = w && w[0];
							e.isSome(w) && (h = h.clone(), h.geometry = w);
							w = m.mapParameters({
								...y.query,
								f: q,
								...x,
								...g(h, x)
							});
							return c(d.join(y.path, "queryTopFeatures"), {
								...u,
								query: {
									...w,
									...u.query
								}
							})
						})
				}
				a.executeQueryForTopCount = function(t, h, q) {
					return e.isSome(h.timeExtent) && h.timeExtent.isEmpty ? Promise.resolve({
						data: {
							count: 0
						}
					}) : n(t, h, "json", q, {
						returnIdsOnly: !0,
						returnCountOnly: !0
					})
				};
				a.executeQueryForTopExtents = function(t, h, q) {
					return p.apply(this, arguments)
				};
				a.executeQueryForTopIds = function(t, h, q) {
					return r.apply(this, arguments)
				};
				a.executeTopFeaturesQuery = function(t, h, q, u) {
					return l.apply(this,
						arguments)
				};
				a.queryToQueryStringParameters = g;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/executeForTopIds": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../utils", "./operations/queryTopFeatures", "../support/TopFeaturesQuery"], function(a, b, c, e, d) {
				function k() {
					k = b._asyncToGenerator(function*(v, m, f) {
						v = c.parseUrl(v);
						return (yield e.executeQueryForTopIds(v, d.from(m), {
								...f
							}))
							.data.objectIds
					});
					return k.apply(this, arguments)
				}
				a.executeForTopIds = function(v, m, f) {
					return k.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/executeForTopExtents": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../geometry ../utils ./operations/queryTopFeatures ../support/TopFeaturesQuery ../../geometry/Extent".split(" "), function(a, b, c, e, d, k, v) {
				function m() {
					m = b._asyncToGenerator(function*(f, g, l) {
						f = e.parseUrl(f);
						g = yield d.executeQueryForTopExtents(f,
							k.from(g), {
								...l
							});
						return {
							count: g.data.count,
							extent: v.fromJSON(g.data.extent)
						}
					});
					return m.apply(this, arguments)
				}
				a.executeForTopExtents = function(f, g, l) {
					return m.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/rest/query/executeForTopCount": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../utils", "./operations/queryTopFeatures", "../support/TopFeaturesQuery"], function(a, b, c, e, d) {
				function k() {
					k = b._asyncToGenerator(function*(v,
						m, f) {
						v = c.parseUrl(v);
						return (yield e.executeQueryForTopCount(v, d.from(m), {
								...f
							}))
							.data.count
					});
					return k.apply(this, arguments)
				}
				a.executeForTopCount = function(v, m, f) {
					return k.apply(this, arguments)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/tasks/Task": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/urlUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m) {
					c = function(f) {
						function g(...r) {
							r = f.call(this, ...r) || this;
							r.requestOptions = null;
							r.url = null;
							return r
						}
						a._inheritsLoose(g, f);
						var l = g.prototype;
						l.normalizeCtorArgs = function(r, p) {
							return "string" !== typeof r ? r : {
								url: r,
								...p
							}
						};
						l._parseUrl = function(r) {
							return e.urlToObject(r)
						};
						l._encode = function(r, p, n) {
							const t = {};
							for (const q in r)
								if ("declaredClass" !== q) {
									var h = r[q];
									if (null != h && "function" !== typeof h)
										if (Array.isArray(h)) {
											t[q] = [];
											for (let u = 0; u < h.length; u++) t[q][u] = this._encode(h[u])
										} else "object" ===
											typeof h ? h.toJSON ? (h = h.toJSON(n && n[q]), t[q] = p ? h : JSON.stringify(h)) : t[q] = p ? h : JSON.stringify(h) : t[q] = h
								} return t
						};
						a._createClass(g, [{
							key: "parsedUrl",
							get: function() {
								return this._parseUrl(this.url)
							}
						}]);
						return g
					}(c);
					b.__decorate([d.property({
						readOnly: !0
					})], c.prototype, "parsedUrl", null);
					b.__decorate([d.property()], c.prototype, "requestOptions", void 0);
					b.__decorate([d.property({
						type: String
					})], c.prototype, "url", void 0);
					return c = b.__decorate([m.subclass("esri.tasks.Task")], c)
				})
		},
		"esri/views/View": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Map ../TimeExtent ../core/Accessor ../core/asyncUtils ../core/Collection ../core/CollectionFlattener ../core/Error ../core/Evented ../core/HandleOwner ../core/handleUtils ../core/Loadable ../core/Logger ../core/maybe ../core/Promise ../core/promiseUtils ../core/reactiveUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../core/support/OwningCollection ../geometry/Extent ../geometry/HeightModelInfo ../geometry/SpatialReference ../geometry/support/spatialReferenceUtils ../support/AnalysesCollection ../support/GraphicsCollection ./BasemapView ./LayerViewManager ./Magnifier ./ToolViewManager ./input/Input ./input/ViewEvents ./navigation/Navigation ./support/DefaultsFromMap".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D, J, K, H, G, F, L, R, V, U, W) {
					var M;
					d = M = function(T) {
						function Z(qa) {
							var Aa = T.call(this, qa) || this;
							Aa._userSpatialReference = null;
							Aa._cursor = null;
							Aa.allLayerViews = new m({
								getCollections: () => [Aa.basemapView ? .baseLayerViews, Aa.groundView ? .layerViews, Aa.layerViews, Aa.basemapView ? .referenceLayerViews],
								getChildrenFunction: Ka => Ka.layerViews
							});
							Aa.groundView = null;
							Aa.basemapView = null;
							Aa.fatalError = null;
							Aa.graphics = new K.GraphicsCollection;
							Aa.analyses = new J.AnalysesCollection;
							Aa.typeSpecificPreconditionsReady = !0;
							Aa.layerViews = new v;
							Aa.magnifier = new F;
							Aa.padding = {
								left: 0,
								top: 0,
								right: 0,
								bottom: 0
							};
							Aa.ready = !1;
							Aa.spatialReferenceWarningDelay = 1E3;
							Aa.supportsGround = !0;
							Aa.timeExtent = null;
							Aa.type = null;
							Aa.scale = null;
							Aa.updating = !1;
							Aa.initialExtentRequired = !0;
							Aa.input = new R;
							Aa.navigation = new U;
							Aa.layerViewManager = null;
							Aa.analysisViewManager = null;
							Aa.isHeightModelInfoRequired = !1;
							Aa.width = null;
							Aa.height = null;
							Aa.resizing = !1;
							Aa.suspended = !1;
							Aa.viewEvents = new V.ViewEvents(a._assertThisInitialized(Aa));
							Aa.persistableViewModels = new v;
							Aa._isValid = !1;
							Aa._readyCycleForced = !1;
							Aa.handles.add(u.watch(() => Aa.preconditionsReady, Ka => {
								Ka ? (Aa._currentSpatialReference = Aa.spatialReference, M.views.add(a._assertThisInitialized(Aa))) : (Aa._currentSpatialReference = null, M.views.remove(a._assertThisInitialized(Aa)));
								Aa.notifyChange("spatialReference");
								!Ka && Aa.ready ? (Aa.toolViewManager ? .detach(), t.isSome(Aa.analysisViewManager) && Aa.analysisViewManager.detach(), Aa.layerViewManager ? .clear(), Aa._teardown()) : Ka && !Aa.ready &&
									(Aa._startup(), t.isSome(Aa.analysisViewManager) && Aa.analysisViewManager.attach(), Aa.toolViewManager.attach())
							}, u.sync));
							return Aa
						}
						a._inheritsLoose(Z, T);
						var oa = Z.prototype;
						oa.initialize = function() {
							this.addResolvingPromise(this.validate()
								.then(() => {
									this._isValid = !0;
									return u.whenOnce(() => this.ready)
								}));
							this.basemapView = new H.BasemapView({
								view: this
							});
							this.layerViewManager = new G({
								view: this,
								layerViewImporter: {
									importLayerView: qa => this.importLayerView(qa),
									hasLayerViewModule: qa => this.hasLayerViewModule(qa)
								},
								supportsGround: this.supportsGround
							});
							this.toolViewManager = new L({
								view: this
							});
							this._setupSpatialReferenceLogger();
							this.handles.add([u.watch(() => this.initialExtentRequired, qa => this.defaultsFromMap.required = {
								...this.defaultsFromMap.required,
								extent: qa
							}, {
								sync: !0,
								initial: !0
							}), u.watch(() => this.ready, qa => {
								this.defaultsFromMap && (this.defaultsFromMap.suspended = qa, this.defaultsFromMap.userSpatialReference = qa ? this.spatialReference : this._userSpatialReference)
							}, {
								sync: !0
							}), u.watch(() => this._userSpatialReference,
								qa => {
									this.defaultsFromMap && (this.defaultsFromMap.userSpatialReference = qa)
								}, {
									sync: !0,
									initial: !0
								})])
						};
						oa._setupSpatialReferenceLogger = function() {
							var qa = this;
							let Aa = null;
							this.handles.add([u.watch(() => this.defaultsFromMap ? .ready, Ka => {
								const da = 0 < this.map ? .allLayers.length;
								Ka && !this.spatialReference && da ? t.isSome(Aa) || (Ka = r.makeHandle(() => Aa = t.abortMaybe(Aa)), Aa = k.createTask(function() {
									var ja = a._asyncToGenerator(function*(sa) {
										try {
											yield q.after(qa.spatialReferenceWarningDelay, null, sa)
										} catch {
											return
										} finally {
											Aa =
												null
										}
										n.getLogger(qa.declaredClass)
											.warn("#spatialReference", "no spatial reference could be derived from the currently added map layers")
									});
									return function(sa) {
										return ja.apply(this, arguments)
									}
								}()), this.handles.add(Ka, "spatial-reference-logger-task")) : this.handles.remove("spatial-reference-logger-task")
							}, {
								sync: !0
							})])
						};
						oa.destroy = function() {
							if (!this.destroyed) {
								this.viewEvents.destroy();
								this.allLayerViews.destroy();
								this.navigation && (this.navigation.destroy(), this._set("navigation", null));
								this.graphics =
									t.destroyMaybe(this.graphics);
								this.analyses = t.destroyMaybe(this.analyses);
								this.handles.remove("defaultsFromMap");
								this.defaultsFromMap.destroy();
								this._set("defaultsFromMap", null);
								t.destroyMaybe(this.analysisViewManager);
								this.toolViewManager = t.destroyMaybe(this.toolViewManager);
								this.layerViewManager = t.destroyMaybe(this.layerViewManager);
								this.basemapView = t.destroyMaybe(this.basemapView);
								this.invalidate();
								this._emitter.clear();
								this.handles.removeAll();
								var qa = this.map;
								this.map = null;
								qa ? .destroy()
							}
						};
						oa._startup =
							function() {
								this._set("ready", !0)
							};
						oa._teardown = function() {
							this._set("ready", !1)
						};
						oa.whenReady = function() {
							return Promise.resolve(this)
						};
						oa.toMap = function() {
							n.getLogger(this.declaredClass)
								.error("#toMap()", "Not implemented on this instance of View");
							return null
						};
						oa._spatialReferenceChanged = function(qa) {};
						oa.whenLayerView = function(qa) {
							return this.layerViewManager.whenLayerView(qa)
						};
						oa.getDefaultSpatialReference = function() {
							return this.defaultsFromMap ? .spatialReference
						};
						oa.getDefaultHeightModelInfo = function() {
							return (this.map &&
								"heightModelInfo" in this.map ? this.map.heightModelInfo : void 0) ? ? this.defaultsFromMap ? .heightModelInfo ? ? null
						};
						oa.importLayerView = function(qa) {
							throw new f("importLayerView() not implemented");
						};
						oa.hasLayerViewModule = function(qa) {
							return !1
						};
						oa.validate = function() {
							var qa = a._asyncToGenerator(function*() {});
							return function() {
								return qa.apply(this, arguments)
							}
						}();
						oa.invalidate = function() {
							this._isValid = !1
						};
						oa.getSpatialReferenceSupport = function() {
							return {
								constraints: null
							}
						};
						oa._validateSpatialReference = function(qa) {
							return t.isSome(this.getSpatialReferenceSupport({
								spatialReference: qa
							}))
						};
						oa.when = function(qa, Aa) {
							this.isResolved() && !this.ready && n.getLogger(this.declaredClass)
								.warn("#when()", "Calling view.when() while the view is no longer ready but was already resolved once will resolve immediately. Use reactiveUtils.whenOnce(() \x3d\x3e view.ready).then(...) instead.");
							return T.prototype.when.call(this, qa, Aa)
						};
						oa.forceReadyCycle = function() {
							this.ready && (u.when(() => !1 === this.preconditionsReady, () => this._readyCycleForced = !1, {
								once: !0
							}), this._readyCycleForced = !0)
						};
						oa.addAndActivateTool =
							function(qa) {
								this.toolViewManager.tools.add(qa);
								this.activeTool = qa
							};
						oa.tryFatalErrorRecovery = function() {
							this.fatalError = null
						};
						a._createClass(Z, [{
								key: "activeTool",
								get: function() {
									return this.toolViewManager ? .activeTool
								},
								set: function(qa) {
									this.toolViewManager && (this.toolViewManager.activeTool = qa)
								}
							}, {
								key: "animation",
								get: function() {
									return this._get("animation")
								},
								set: function(qa) {
									this._set("animation", qa)
								}
							}, {
								key: "_defaultsFromMapSettings",
								get: function() {
									return {}
								}
							}, {
								key: "defaultsFromMap",
								get: function() {
									return new W.DefaultsFromMap({
										required: {
											tileInfo: !1,
											heightModelInfo: !1,
											extent: !1
										},
										map: () => this.map,
										getSpatialReferenceSupport: qa => this.getSpatialReferenceSupport(qa),
										...this._defaultsFromMapSettings
									})
								}
							}, {
								key: "extent",
								get: function() {
									return this._get("extent")
								},
								set: function(qa) {
									this._set("extent", qa)
								}
							}, {
								key: "heightModelInfo",
								get: function() {
									return this.getDefaultHeightModelInfo()
								}
							}, {
								key: "interacting",
								get: function() {
									return this.navigating
								}
							}, {
								key: "navigating",
								get: function() {
									return !1
								}
							}, {
								key: "preconditionsReady",
								get: function() {
									return !(this.fatalError || !this._isValid ||
										this._readyCycleForced || !this.map || p.isLoadable(this.map) && !this.map.loaded || 0 === this.width || 0 === this.height || !this.spatialReference || !this._validateSpatialReference(this.spatialReference) || !this._currentSpatialReference && !this.defaultsFromMap ? .ready || !this.typeSpecificPreconditionsReady)
								}
							}, {
								key: "map",
								set: function(qa) {
									const Aa = this._get("map");
									qa !== Aa && (qa ? .destroyed && (n.getLogger(this.declaredClass)
											.warn("#map", "The provided map is already destroyed", {
												map: qa
											}), qa = null), p.isLoadable(qa) && qa.load()
										.catch(() => {}), this.constructed && (this.forceReadyCycle(), this._currentSpatialReference = null), this._set("map", qa))
								}
							}, {
								key: "spatialReference",
								get: function() {
									let qa = this._userSpatialReference || this._currentSpatialReference || this.getDefaultSpatialReference() || null;
									qa && this.defaultsFromMap ? .required ? .heightModelInfo && (qa = qa.clone(), qa.vcsWkid = this.defaultsFromMap.vcsWkid, qa.latestVcsWkid = this.defaultsFromMap.latestVcsWkid);
									return qa
								},
								set: function(qa) {
									const Aa = !D.equals(qa, this._get("spatialReference"));
									this._set("_userSpatialReference",
										qa);
									Aa && (this._set("spatialReference", qa), this._spatialReferenceChanged(qa))
								}
							}, {
								key: "stationary",
								get: function() {
									return !this.animation && !this.navigating && !this.resizing
								}
							}, {
								key: "tools",
								get: function() {
									return this.toolViewManager ? .tools
								}
							}, {
								key: "initialExtent",
								get: function() {
									return this.defaultsFromMap ? .extent
								}
							}, {
								key: "cursor",
								get: function() {
									const qa = this.toolViewManager ? this.toolViewManager.cursor : null;
									return t.isSome(qa) ? qa : this._cursor || "default"
								},
								set: function(qa) {
									this._cursor = qa;
									this.notifyChange("cursor")
								}
							},
							{
								key: "size",
								get: function() {
									return [this.width, this.height]
								}
							}
						]);
						return Z
					}(l.HandleOwnerMixin(g.EventedMixin(h.EsriPromiseMixin(d))));
					d.views = new v;
					b.__decorate([x.property()], d.prototype, "_userSpatialReference", void 0);
					b.__decorate([x.property()], d.prototype, "activeTool", null);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "allLayerViews", void 0);
					b.__decorate([x.property()], d.prototype, "groundView", void 0);
					b.__decorate([x.property()], d.prototype, "animation", null);
					b.__decorate([x.property()], d.prototype,
						"basemapView", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "_defaultsFromMapSettings", null);
					b.__decorate([x.property()], d.prototype, "defaultsFromMap", null);
					b.__decorate([x.property()], d.prototype, "fatalError", void 0);
					b.__decorate([x.property({
						type: E
					})], d.prototype, "extent", null);
					b.__decorate([x.property(B.owningCollectionProperty(K.GraphicsCollection, "graphics"))], d.prototype, "graphics", void 0);
					b.__decorate([x.property(B.owningCollectionProperty(J.AnalysesCollection, "analyses"))],
						d.prototype, "analyses", void 0);
					b.__decorate([x.property({
						readOnly: !0,
						type: z
					})], d.prototype, "heightModelInfo", null);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "interacting", null);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "navigating", null);
					b.__decorate([x.property({
							readOnly: !0,
							dependsOn: "fatalError _isValid _readyCycleForced map map.loaded? width height spatialReference _currentSpatialReference defaultsFromMap.ready typeSpecificPreconditionsReady".split(" ")
						})], d.prototype, "preconditionsReady",
						null);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "typeSpecificPreconditionsReady", void 0);
					b.__decorate([x.property({
						type: v,
						readOnly: !0
					})], d.prototype, "layerViews", void 0);
					b.__decorate([x.property({
						type: F
					})], d.prototype, "magnifier", void 0);
					b.__decorate([x.property({
						value: null,
						type: c
					})], d.prototype, "map", null);
					b.__decorate([x.property()], d.prototype, "padding", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "ready", void 0);
					b.__decorate([x.property({
							type: C
						})], d.prototype, "spatialReference",
						null);
					b.__decorate([x.property()], d.prototype, "spatialReferenceWarningDelay", void 0);
					b.__decorate([x.property()], d.prototype, "stationary", null);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "supportsGround", void 0);
					b.__decorate([x.property({
						type: e
					})], d.prototype, "timeExtent", void 0);
					b.__decorate([x.property()], d.prototype, "tools", null);
					b.__decorate([x.property()], d.prototype, "toolViewManager", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "type", void 0);
					b.__decorate([x.property({
							type: Number
						})],
						d.prototype, "scale", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "updating", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "initialExtentRequired", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "initialExtent", null);
					b.__decorate([x.property()], d.prototype, "cursor", null);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "input", void 0);
					b.__decorate([x.property({
						type: U,
						nonNullable: !0
					})], d.prototype, "navigation", void 0);
					b.__decorate([x.property()], d.prototype,
						"layerViewManager", void 0);
					b.__decorate([x.property()], d.prototype, "analysisViewManager", void 0);
					b.__decorate([x.property()], d.prototype, "width", void 0);
					b.__decorate([x.property()], d.prototype, "height", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "resizing", void 0);
					b.__decorate([x.property({
						value: null,
						readOnly: !0
					})], d.prototype, "size", null);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "suspended", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "viewEvents", void 0);
					b.__decorate([x.property({
						readOnly: !0
					})], d.prototype, "persistableViewModels", void 0);
					b.__decorate([x.property()], d.prototype, "_isValid", void 0);
					b.__decorate([x.property()], d.prototype, "_readyCycleForced", void 0);
					b.__decorate([x.property()], d.prototype, "_currentSpatialReference", void 0);
					return d = M = b.__decorate([A.subclass("esri.views.View")], d)
				})
		},
		"esri/core/support/OwningCollection": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../Collection ../collectionUtils ../HandleOwner ../has ../Logger ../maybe ../accessorSupport/decorators/property ../arrayUtils ../accessorSupport/ensureType ../accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					a.OwningCollection = function(n) {
						function t(q) {
							var u = n.call(this, q) || this;
							u.handles.add([u.on("before-add", x => {
								f.isNone(x.item) && x.preventDefault()
							}), u.on("after-add", x => u._own(x.item)), u.on("after-remove", x => u._release(x.item))]);
							return u
						}
						b._inheritsLoose(t, n);
						var h = t.prototype;
						h._ownAll = function() {
							for (const q of this.items) this._own(q)
						};
						h._releaseAll = function() {
							for (const q of this.items) this._release(q)
						};
						h._createNewInstance = function(q) {
							return this.itemType ? new(e.ofType(this.itemType.Type))(q) :
								new e(q)
						};
						b._createClass(t, [{
							key: "owner",
							get: function() {
								return this._get("owner")
							},
							set: function(q) {
								q !== this._get("owner") && (this._releaseAll(), this._set("owner", q), this._ownAll())
							}
						}]);
						return t
					}(k.HandleOwnerMixin(e));
					c.__decorate([g.property()], a.OwningCollection.prototype, "owner", null);
					a.OwningCollection = c.__decorate([p.subclass("esri.core.support.OwningCollection")], a.OwningCollection);
					a.owningCollectionProperty = function(n, t) {
						return {
							type: n,
							cast: d.castForReferenceSetter,
							set(h) {
								h = d.referenceSetter(h,
									this._get(t), n);
								h.owner = this;
								this._set(t, h)
							}
						}
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/support/AnalysesCollection": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Logger ../core/maybe ../core/accessorSupport/ensureType ../core/arrayUtils ../core/Error ../core/has ../core/accessorSupport/decorators/subclass ../core/support/OwningCollection".split(" "), function(a, b, c, e, d, k, v, m, f, g, l) {
				a.AnalysesCollection =
					function(r) {
						function p(t) {
							var h = r.call(this, t) || this;
							h.handles.add(h.on("before-add", q => {
								d.isNone(q.item) || q.item.parent !== h.owner || (e.getLogger(h.declaredClass)
									.warn("Analysis inside the collection must be unique. Not adding this element again."), q.preventDefault())
							}));
							return h
						}
						b._inheritsLoose(p, r);
						var n = p.prototype;
						n._own = function(t) {
							t.parent = this.owner
						};
						n._release = function(t) {
							t.parent = null
						};
						return p
					}(l.OwningCollection);
				a.AnalysesCollection = c.__decorate([g.subclass("esri.support.AnalysesCollection")],
					a.AnalysesCollection);
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/GraphicsCollection": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../Graphic ../core/Logger ../core/accessorSupport/ensureType ../core/arrayUtils ../core/Error ../core/has ../core/accessorSupport/decorators/shared ../core/accessorSupport/decorators/subclass ../core/support/OwningCollection".split(" "), function(a, b, c, e, d, k, v, m, f, g, l, r) {
				a.GraphicsCollection =
					function(p) {
						function n() {
							return p.apply(this, arguments) || this
						}
						b._inheritsLoose(n, p);
						var t = n.prototype;
						t._own = function(h) {
							h.layer && "remove" in h.layer && h.layer !== this.owner && h.layer.remove(h);
							h.layer = this.owner
						};
						t._release = function(h) {
							h.layer === this.owner && (h.layer = null)
						};
						return n
					}(r.OwningCollection);
				c.__decorate([g.shared({
					Type: e,
					ensureType: k.ensureType(e)
				})], a.GraphicsCollection.prototype, "itemType", void 0);
				a.GraphicsCollection = c.__decorate([l.subclass("esri.support.GraphicsCollection")], a.GraphicsCollection);
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/BasemapView": function() {
			define("exports ../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/Collection ../core/reactiveUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m, f, g) {
				a.BasemapView = function(l) {
					function r(p) {
						var n = l.call(this, p) ||
							this;
						n.view = null;
						n.baseLayerViews = new d;
						n.referenceLayerViews = new d;
						n._loadingHandle = k.watch(() => n.view ? .map ? .basemap, t => {
							t && t.load()
								.catch(() => {})
						}, k.initial);
						return n
					}
					b._inheritsLoose(r, l);
					r.prototype.destroy = function() {
						this._set("view", null);
						this._loadingHandle && (this._loadingHandle.remove(), this._loadingHandle = null)
					};
					b._createClass(r, [{
						key: "suspended",
						get: function() {
							return this.view ? this.view.suspended : !0
						}
					}, {
						key: "updating",
						get: function() {
							if (this.view && this.view.suspended) return !1;
							const p = this.view ? .map ? .basemap;
							return p && p.loaded ? this.baseLayerViews.some(n => n.updating) || this.referenceLayerViews.some(n => n.updating) : !1
						}
					}]);
					return r
				}(e);
				c.__decorate([v.property({
					constructOnly: !0
				})], a.BasemapView.prototype, "view", void 0);
				c.__decorate([v.property({
					readOnly: !0
				})], a.BasemapView.prototype, "baseLayerViews", void 0);
				c.__decorate([v.property({
					readOnly: !0
				})], a.BasemapView.prototype, "referenceLayerViews", void 0);
				c.__decorate([v.property({
					readOnly: !0
				})], a.BasemapView.prototype, "suspended", null);
				c.__decorate([v.property({
					type: Boolean,
					readOnly: !0
				})], a.BasemapView.prototype, "updating", null);
				a.BasemapView = c.__decorate([g.subclass("esri.views.BasemapView")], a.BasemapView);
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/LayerViewManager": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/Error ../core/Logger ../core/MapUtils ../core/maybe ../core/promiseUtils ../core/reactiveUtils ../core/scheduling ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ../core/support/WatchUpdatingTracking".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					let h = function() {
						function q(x, y, w) {
							this.layer = x;
							this.view = y;
							this.layerViewImporter = w;
							this._controller = new AbortController;
							this._deferred = m.createDeferred();
							this.done = this._started = !1;
							m.onAbort(this._controller.signal, () => {
								const A = new e("cancelled:layerview-create", "layerview creation cancelled", {
									layer: x
								});
								this._deferred.reject(A)
							})
						}
						var u = q.prototype;
						u.destroy = function() {
							this._controller.abort();
							const {
								layerView: x
							} = this;
							if (x) {
								var {
									layer: y,
									view: w
								} = this;
								y.emit("layerview-destroy", {
									view: w,
									layerView: x
								});
								w.emit("layerview-destroy", {
									layer: y,
									layerView: x
								});
								this.done = !0;
								this.layerViewImporter = this.view = this.layerView = this.layer = null
							}
						};
						u.start = function() {
							var x = a._asyncToGenerator(function*() {
								if (!this._started) {
									this._started = !0;
									var {
										_controller: {
											signal: y
										},
										layer: w,
										view: A
									} = this;
									this._map = A.map;
									try {
										yield w.load({
											signal: y
										});
										"prefetchResources" in w && (yield w.prefetchResources({
											signal: y
										}));
										let E;
										if (w.createLayerView) E = yield w.createLayerView(A, {
											signal: y
										});
										else {
											if (!this.layerViewImporter.hasLayerViewModule(w)) throw new e("layer:view-not-supported",
												"No layerview implementation was found");
											var B = yield this.layerViewImporter.importLayerView(w);
											m.throwIfAborted(y);
											E = "default" in B ? new B.default({
												layer: w,
												view: A
											}) : new B({
												layer: w,
												view: A
											})
										}
										let z;
										B = () => {
											z = v.removeMaybe(z);
											E.destroyed || E.destroy();
											E.layer = null;
											E.parent = null;
											E.view = null;
											this.done = !0
										};
										z = m.onAbort(y, B);
										m.throwIfAborted(y);
										try {
											yield E.when()
										} catch (C) {
											throw B(), C;
										}
										this._map ? .allLayers ? .includes(w) ? (this.layerView = E, w.emit("layerview-create", {
											view: A,
											layerView: E
										}), A.emit("layerview-create", {
											layer: w,
											layerView: E
										}), this.done = !0, this._deferred.resolve(E)) : (B(), this._deferred.reject(new e("view:no-layerview-for-layer", "The layer has been removed from the map", {
											layer: w
										})))
									} catch (E) {
										w.emit("layerview-create-error", {
											view: A,
											error: E
										}), A.emit("layerview-create-error", {
											layer: w,
											error: E
										}), this.done = !0, this._deferred.reject(new e("layerview:create-error", "layerview creation failed", {
											layer: w,
											error: E
										}))
									}
								}
							});
							return function() {
								return x.apply(this, arguments)
							}
						}();
						a._createClass(q, [{
							key: "promise",
							get: function() {
								return this._deferred.promise
							}
						}]);
						return q
					}();
					c = function(q) {
						function u(y) {
							var w = q.call(this, y) || this;
							w._layerLayerViewInfoMap = new Map;
							w._watchUpdatingTracking = new t.WatchUpdatingTracking;
							w.supportsGround = !0;
							w._preloadLayerViewModules = () => {
								const A = w.view.map ? .allLayers;
								if (A)
									for (const B of A) w.layerViewImporter.hasLayerViewModule(B) && w.layerViewImporter.importLayerView(B)
							};
							w._reschedule = () => {
								v.isNone(w._workPromise) && (w._workPromise = m.createDeferred(), w._workPromise.promise.catch(() => {}));
								w.removeHandles("reschedule");
								w.addHandles(g.schedule(w._doWork),
									"reschedule");
								return w._workPromise.promise
							};
							w._doWork = () => {
								var A = w.view.map;
								w._map !== A && (w.clear(), w._map = A);
								if (v.isNone(w._workPromise)) w.notifyChange("updating");
								else {
									w.removeHandles("reschedule");
									w.removeHandles("collection-change");
									var B = [],
										E = C => {
											if (!v.isNone(C))
												for (const D of C) D && (B.push(D), w._createLayerView(D), "layers" in D && D.layers && E(D.layers))
										};
									for (var z of w._rootCollectionNames) E(w.get(z));
									w._refreshCollections();
									for (const [C, D] of w._layerLayerViewInfoMap) B.includes(C) || (w._layerLayerViewInfoMap.delete(D.layer),
										D.destroy());
									z = B.filter(C => "group" === C.type)
										.map(C => C.layers);
									A = [A ? .ground ? .layers, A ? .basemap ? .baseLayers, A ? .basemap ? .referenceLayers, A ? .layers, ...z].filter(C => !!C);
									w.addHandles(A.map(C => w._watchUpdatingTracking.addOnCollectionChange(() => C, w._reschedule)), "collection-change");
									w._workPromise.resolve();
									w._workPromise = null
								}
							};
							return w
						}
						a._inheritsLoose(u, q);
						var x = u.prototype;
						x.initialize = function() {
							this.own([f.on(() => this.view ? .map ? .allLayers, "change", this._preloadLayerViewModules, {
									onListenerAdd: this._preloadLayerViewModules
								}),
								f.watch(() => {
									const y = this.view,
										w = y ? .map;
									return [w ? .basemap, w ? .ground, w ? .layers, y ? .ready]
								}, () => this._reschedule(), f.syncAndInitial)
							]);
							this._preloadLayerViewModules();
							this._reschedule()
						};
						x.destroy = function() {
							this.clear();
							this._watchUpdatingTracking.destroy();
							this._map = null;
							v.isSome(this._workPromise) && (this._workPromise.reject(m.createAbortError()), this._workPromise = null)
						};
						x.clear = function() {
							if (!this.destroyed) {
								for (const y of this._layerLayerViewInfoMap.values()) y.destroy();
								this._layerLayerViewInfoMap.clear();
								this._refreshCollections()
							}
						};
						x.whenLayerView = function() {
							var y = a._asyncToGenerator(function*(w) {
								yield this._reschedule();
								if (!this._layerLayerViewInfoMap.has(w)) throw new e("view:no-layerview-for-layer", "No layerview has been found for the layer", {
									layer: w
								});
								return this._layerLayerViewInfoMap.get(w)
									.promise
							});
							return function(w) {
								return y.apply(this, arguments)
							}
						}();
						x._refreshCollections = function() {
							for (const [y, w] of this._layersToLayerViews) this._populateLayerViewsOwners(this.get(y), this.get(w), this.view);
							this.notifyChange("updating");
							this.notifyChange("updatingRemaining")
						};
						x._populateLayerViewsOwners = function(y, w, A) {
							if (y && w) {
								var B = 0;
								for (const E of y)(y = this._layerLayerViewInfoMap.get(E)) && y.layerView && (y = y.layerView, y.layer = E, y.parent = A, w.getItemAt(B) !== y && w.splice(B, 0, y), E.layers && this._populateLayerViewsOwners(E.layers, y.layerViews, y), B += 1);
								B < w.length && w.splice(B, w.length)
							} else w && w.removeAll()
						};
						x._createLayerView = function(y) {
							if (this._layerLayerViewInfoMap.has(y)) this.view.ready && this._layerLayerViewInfoMap.get(y)
								.start();
							else {
								y.load()
									.catch(() => {});
								this.layerViewImporter.hasLayerViewModule(y) && this.layerViewImporter.importLayerView(y);
								var w = new h(y, this.view, this.layerViewImporter);
								w.promise.then(() => this._refreshCollections(), A => {
									A && (m.isAbortError(A) || "cancelled:layerview-create" === A.name) || d.getLogger(this.declaredClass)
										.error(`Failed to create layerview for layer title:'${y.title??"no title"}', id:'${y.id??"no id"}' of type '${y.type}'.`, {
											layer: y,
											error: A
										});
									this._refreshCollections()
								});
								this._layerLayerViewInfoMap.set(y,
									w);
								this.view.ready && w.start()
							}
							this.notifyChange("updating");
							this.notifyChange("updatingRemaining")
						};
						a._createClass(u, [{
								key: "_layersToLayerViews",
								get: function() {
									const y = [
										["view.map.basemap.baseLayers", "view.basemapView.baseLayerViews"],
										["view.map.layers", "view.layerViews"],
										["view.map.basemap.referenceLayers", "view.basemapView.referenceLayerViews"]
									];
									this.supportsGround && y.push(["view.map.ground.layers", "view.groundView.layerViews"]);
									return new Map(y)
								}
							}, {
								key: "_rootCollectionNames",
								get: function() {
									return Array.from(this._layersToLayerViews.keys())
								}
							},
							{
								key: "updating",
								get: function() {
									return v.isSome(this._workPromise) || this._watchUpdatingTracking.updating || k.someMap(this._layerLayerViewInfoMap, y => !y.done)
								}
							}, {
								key: "updatingRemaining",
								get: function() {
									let y = 0;
									for (const w of this._layerLayerViewInfoMap.values()) w.done || ++y;
									return y
								}
							}
						]);
						return u
					}(c);
					b.__decorate([l.property()], c.prototype, "_workPromise", void 0);
					b.__decorate([l.property({
						readOnly: !0
					})], c.prototype, "_watchUpdatingTracking", void 0);
					b.__decorate([l.property({
							readOnly: !0
						})], c.prototype, "_layersToLayerViews",
						null);
					b.__decorate([l.property({
						readOnly: !0
					})], c.prototype, "_rootCollectionNames", null);
					b.__decorate([l.property()], c.prototype, "layerViewImporter", void 0);
					b.__decorate([l.property()], c.prototype, "supportsGround", void 0);
					b.__decorate([l.property({
						readOnly: !0
					})], c.prototype, "updating", null);
					b.__decorate([l.property({
						readOnly: !0
					})], c.prototype, "updatingRemaining", null);
					b.__decorate([l.property({
						constructOnly: !0
					})], c.prototype, "view", void 0);
					return c = b.__decorate([n.subclass("esri.views.LayerViewManager")],
						c)
				})
		},
		"esri/views/Magnifier": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/screenUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "), function(a, b, c, e, d, k, v, m) {
				c = function(f) {
					function g(l) {
						l = f.call(this, l) || this;
						l.factor = 1.5;
						l.offset = e.createScreenPoint(0, 0);
						l.position = null;
						l.size = 120;
						l.maskUrl = null;
						l.maskEnabled = !0;
						l.overlayUrl = null;
						l.overlayEnabled = !0;
						l.visible = !0;
						return l
					}
					a._inheritsLoose(g, f);
					a._createClass(g, [{
						key: "version",
						get: function() {
							this.commitProperty("factor");
							this.commitProperty("offset");
							this.commitProperty("position");
							this.commitProperty("visible");
							this.commitProperty("size");
							this.commitProperty("maskUrl");
							this.commitProperty("maskEnabled");
							this.commitProperty("overlayUrl");
							this.commitProperty("overlayEnabled");
							return (this._get("version") || 0) + 1
						}
					}]);
					return g
				}(c);
				b.__decorate([d.property({
					type: Number
				})], c.prototype, "factor", void 0);
				b.__decorate([d.property({
					nonNullable: !0
				})], c.prototype, "offset", void 0);
				b.__decorate([d.property()], c.prototype, "position", void 0);
				b.__decorate([d.property({
					type: Number,
					range: {
						min: 0
					}
				})], c.prototype, "size", void 0);
				b.__decorate([d.property()], c.prototype, "maskUrl", void 0);
				b.__decorate([d.property()], c.prototype, "maskEnabled", void 0);
				b.__decorate([d.property()], c.prototype, "overlayUrl", void 0);
				b.__decorate([d.property()], c.prototype, "overlayEnabled", void 0);
				b.__decorate([d.property({
						readOnly: !0
					})],
					c.prototype, "version", null);
				b.__decorate([d.property({
					type: Boolean
				})], c.prototype, "visible", void 0);
				return c = b.__decorate([m.subclass("esri.views.Magnifier")], c)
			})
		},
		"esri/views/ToolViewManager": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Accessor ../core/Collection ../core/HandleOwner ../core/handleUtils ../core/has ../core/Logger ../core/maybe ../core/reactiveUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass ./3d/support/TextureCollection ./input/InputManager ./input/ViewEvents ./interactive/interactiveToolUtils ./interactive/interfaces ./interactive/ToolViewManagerManipulatorState".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y) {
					d = function(w) {
						function A(E) {
							var z = w.call(this, E) || this;
							z._manipulatorState = new y.ToolViewManagerManipulatorState;
							z.tools = new e;
							z.cursor = null;
							z._forEachTool = C => {
								for (const D of z.tools.items)
									if (C(D)) break
							};
							return z
						}
						a._inheritsLoose(A, w);
						var B = A.prototype;
						B.initialize = function() {
							this.handles.add([this.view.on(q.eventTypes, E => {
								this._handleInputEvent(E)
							}, h.ViewEventPriorities.TOOL), ...u.getToolCollectionHandles(this.tools), this.tools.on("before-add", ({
								item: E
							}) => {
								this._updateToolEditableFlag(E)
							}), this.tools.on("before-remove", ({
								item: E
							}) => {
								this._manipulatorState.clearPointers(E, this._manipulatorStateEventArgs);
								this._updateCursor()
							}), this.tools.on("change", () => {
								this._refreshToolWatchers()
							})])
						};
						B.destroy = function() {
							this.detach();
							this.handles.removeAll()
						};
						B.attach = function() {
							"3d" === this.view.type ? (this._set("textures", new t.TextureCollection(this.view._stage, this.view.resourceController.scheduler)), this.handles.add([g.watch(() => {
								const {
									state: E
								} = this.view;
								return "camera" in
									E && E.camera
							}, () => {
								this._forEachManipulator(E => {
									if (null != E.onViewChange) E.onViewChange()
								})
							}), this.view.elevationProvider.on("elevation-change", E => {
								this._forEachManipulator(z => {
									if (null != z.onElevationChange) z.onElevationChange(E)
								})
							}), k.makeHandle(() => this._set("textures", f.destroyMaybe(this.textures)))], "attached")) : this.handles.add(g.watch(() => this.view.extent, () => {
								this._forEachManipulator(E => {
									if (null != E.onViewChange) E.onViewChange()
								})
							}))
						};
						B.detach = function() {
							f.isSome(this.activeTool) && (this.activeTool =
								null);
							this.tools.removeAll();
							this.handles.remove("attached")
						};
						B._forEachManipulator = function(E) {
							this._forEachTool(z => {
								z.manipulators && z.manipulators.forEach(({
									manipulator: C
								}) => E(C, z))
							})
						};
						B._handleInputEvent = function(E) {
							let z = !1;
							const C = {
								...E,
								stopPropagation: () => {
									z = !0;
									E.stopPropagation()
								}
							};
							f.isSome(this.activeTool) ? this.activeTool.handleInputEvent && this.activeTool.handleInputEvent(C) : this._forEachTool(D => {
								!z && D.visible && D.handleInputEvent(C)
							});
							!z && "key-down" === E.type && "Escape" === E.key && this.activeTool &&
								(E.stopPropagation(), this.activeTool = null);
							this._manipulatorState.handleInputEvent(C, this._manipulatorStateEventArgs);
							!z && f.isSome(this.activeTool) && this.activeTool.handleInputEventAfter(C);
							this._manipulatorState.handleHoverEvent(C, this._forEachTool);
							this._updateCursor()
						};
						B._refreshToolWatchers = function() {
							this.handles.remove("tools");
							this._forEachTool(E => {
								if (E instanceof c) {
									const z = g.watch(() => [E.cursor, E.visible, E.editable], () => {
										u.areToolManipulatorsEditable(E) || this._manipulatorState.clearPointers(E,
											this._manipulatorStateEventArgs);
										this._updateCursor()
									});
									this.handles.add(z, "tools")
								}
								E.manipulators && this.handles.add([E.manipulators.on("after-remove", z => {
									this._manipulatorState.clearPointers(E, this._manipulatorStateEventArgs, !0, z.item.manipulator)
								}), E.manipulators.on("change", () => {
									this._manipulatorState.updateHoveredStateFromKnownPointers(this._forEachTool);
									this._updateCursor()
								})], "tools")
							});
							this._manipulatorState.updateHoveredStateFromKnownPointers(this._forEachTool);
							this._updateCursor()
						};
						B._updateToolEditableFlag =
							function(E) {
								E.setEditableFlag(x.EditableFlag.MANAGER, f.isNone(this.activeTool) || E === this.activeTool)
							};
						B._updateCursor = function() {
							let E = this._manipulatorState.cursor;
							f.isNone(E) && this._forEachTool(z => f.isSome(z.cursor) && z.visible ? (E = z.cursor, !0) : !1);
							this._get("cursor") !== E && this._set("cursor", E)
						};
						B._removeIncompleteTools = function(E) {
							this.tools.filter(z => (f.isNone(E) || z !== E) && !z.created && z.removeIncompleteOnCancel)
								.forEach(z => {
									this.tools.remove(z)
								})
						};
						a._createClass(A, [{
							key: "_manipulatorStateEventArgs",
							get: function() {
								return {
									forEachTool: this._forEachTool,
									activeTool: this.activeTool,
									setActiveTool: E => {
										this.activeTool = E
									},
									view: this.view
								}
							}
						}, {
							key: "activeTool",
							set: function(E) {
								if (f.isSome(E) && !this.view.ready) m.getLogger(this.declaredClass)
									.error("Cannot set active tool while view is not ready.");
								else if (E !== this.activeTool) {
									var z = this.activeTool;
									this._set("activeTool", E);
									f.isSome(z) && z.deactivate();
									f.isSome(E) && E.activate();
									this._removeIncompleteTools(E);
									for (const C of this.tools) this._updateToolEditableFlag(C),
										E = u.areToolManipulatorsEditable(C), !f.isNone(this.activeTool) && E || this._manipulatorState.clearPointers(C, this._manipulatorStateEventArgs, !E);
									this._updateCursor()
								}
							}
						}, {
							key: "updating",
							get: function() {
								return this.updatingHandles.updating || this.tools.some(E => E.updating) || (this.textures ? .updating ? ? !1)
							}
						}]);
						return A
					}(d.HandleOwner);
					b.__decorate([l.property({
						constructOnly: !0,
						nonNullable: !0
					})], d.prototype, "view", void 0);
					b.__decorate([l.property({
						readOnly: !0,
						nonNullable: !0
					})], d.prototype, "textures", void 0);
					b.__decorate([l.property({
							value: null
						})],
						d.prototype, "activeTool", null);
					b.__decorate([l.property({
						readOnly: !0,
						type: e
					})], d.prototype, "tools", void 0);
					b.__decorate([l.property({
						readOnly: !0
					})], d.prototype, "cursor", void 0);
					b.__decorate([l.property({
						readOnly: !0
					})], d.prototype, "updating", null);
					return d = b.__decorate([n.subclass("esri.views.ToolViewManager")], d)
				})
		},
		"esri/views/3d/support/TextureCollection": function() {
			define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/maybe ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../support/Scheduler".split(" "),
				function(a, b, c, e, d, k, v, m, f, g) {
					a.TextureCollection = function(l) {
						function r(n, t) {
							var h = l.call(this, {}) || this;
							h._stage = n;
							h._textureRequests = new Map;
							h._frameTask = t ? .registerTask(g.TaskPriority.TEXTURE_UNLOAD) ? ? g.ImmediateTask;
							return h
						}
						b._inheritsLoose(r, l);
						var p = r.prototype;
						p.normalizeCtorArgs = function() {
							return {}
						};
						p.destroy = function() {
							l.prototype.destroy.call(this);
							this._frameTask.remove();
							this._textureRequests.forEach(n => this._releaseTextureRequest(n));
							this._textureRequests.clear()
						};
						p.fromData = function(n,
							t, h) {
							const q = this.makeUid(n);
							n = this._textureRequests.get(q);
							n || (n = {
								referenceCount: 0,
								texture: t(),
								textureAsync: null,
								abortController: null,
								onRemove: h
							}, this._stage && (this._stage.add(n.texture), this._stage.loadImmediate(n.texture)), this._textureRequests.set(q, n));
							n.referenceCount++;
							return {
								uid: q,
								texture: n.texture,
								release: () => this._release(q)
							}
						};
						p._release = function(n) {
							const t = this._textureRequests.get(n);
							t ? (1 > t.referenceCount && console.warn("TextureCollection: reference count is \x3c 1 for " + n), t.referenceCount--,
								1 > t.referenceCount && this._frameTask.schedule(() => this._releaseNow(n))) : console.warn(`TextureCollection: texture doesn't exist: '${n}'`)
						};
						p._releaseNow = function(n) {
							if (this._textureRequests) {
								var t = this._textureRequests.get(n);
								!t || 0 < t.referenceCount || (this._releaseTextureRequest(t), this._textureRequests.delete(n))
							}
						};
						p._releaseTextureRequest = function(n) {
							if (n.onRemove) n.onRemove();
							n.texture ? this._stage ? .remove(n.texture) : n.abortController && (n.abortController.abort(), n.abortController = null)
						};
						p.makeUid =
							function(n, t = null) {
								return d.isSome(t) ? `${n}.${t}px` : n
							};
						b._createClass(r, [{
							key: "updating",
							get: function() {
								return this._frameTask.updating
							}
						}, {
							key: "test",
							get: function() {
								return {
									textureRequests: this._textureRequests
								}
							}
						}]);
						return r
					}(e);
					c.__decorate([k.property()], a.TextureCollection.prototype, "_frameTask", void 0);
					c.__decorate([k.property()], a.TextureCollection.prototype, "updating", null);
					a.TextureCollection = c.__decorate([f.subclass("esri.views.3d.support.TextureCollection")], a.TextureCollection);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/views/support/Scheduler": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/Handles ../../core/Logger ../../core/maybe ../../core/PerformanceSampler ../../core/PooledArray ../../core/promiseUtils ../../core/reactiveUtils ../../core/time ../../core/accessorSupport/tracking/ObservableValue ../../layers/support/PromiseQueue ./debugFlags ./RenderState".split(" "), function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
				function t(z) {
					return h.has(z) ?
						h.get(z) : "number" === typeof z ? z : 1
				}
				a.TaskPriority = void 0;
				(function(z) {
					z.RESOURCE_CONTROLLER = "schedule";
					z.SLIDE = "slide";
					z.STREAM_DATA_LOADER = "stream loader";
					z.ELEVATION_QUERY = "elevation query";
					z.TERRAIN_SURFACE = "terrain";
					z.SURFACE_GEOMETRY_UPDATES = "surface geometry updates";
					z.GRAPHICS_CORE = "Graphics3D";
					z.I3S_CONTROLLER = "I3S";
					z.POINT_CLOUD_LAYER = "point cloud";
					z.FEATURE_TILE_FETCHER = "feature fetcher";
					z.OVERLAY = "overlay";
					z.STAGE = "stage";
					z.GRAPHICS_DECONFLICTOR = "graphics deconflictor";
					z.FILTER_VISIBILITY =
						"Graphics3D filter visibility";
					z.SCALE_VISIBILITY = "Graphics3D scale visibility";
					z.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility";
					z.POINT_OF_INTEREST_FREQUENT = "POI frequent";
					z.POINT_OF_INTEREST_INFREQUENT = "POI infrequent";
					z.LABELER = "labeler";
					z.FEATURE_QUERY_ENGINE = "feature query";
					z.FEATURE_TILE_TREE = "feature tile tree";
					z.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree";
					z.ELEVATION_ALIGNMENT = "elevation alignment";
					z.TEXT_TEXTURE_ATLAS = "text texture atlas";
					z.TEXTURE_UNLOAD = "texture unload";
					z.LINE_OF_SIGHT_TOOL =
						"line of sight tool";
					z.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool";
					z.ELEVATION_PROFILE = "elevation profile";
					z.SNAPPING = "snapping";
					z.SHADOW_ACCUMULATOR = "shadow accumulator";
					z.CLOUDS_GENERATOR = "cloud generator";
					z[z.TEST_PRIO = 1] = "TEST_PRIO"
				})(a.TaskPriority || (a.TaskPriority = {}));
				const h = new Map([
						[a.TaskPriority.RESOURCE_CONTROLLER, 0],
						[a.TaskPriority.SLIDE, 0],
						[a.TaskPriority.STREAM_DATA_LOADER, 0],
						[a.TaskPriority.ELEVATION_QUERY, 0],
						[a.TaskPriority.TERRAIN_SURFACE, 1],
						[a.TaskPriority.SURFACE_GEOMETRY_UPDATES,
							1
						],
						[a.TaskPriority.GRAPHICS_CORE, 2],
						[a.TaskPriority.I3S_CONTROLLER, 2],
						[a.TaskPriority.POINT_CLOUD_LAYER, 2],
						[a.TaskPriority.FEATURE_TILE_FETCHER, 2],
						[a.TaskPriority.OVERLAY, 4],
						[a.TaskPriority.STAGE, 4],
						[a.TaskPriority.GRAPHICS_DECONFLICTOR, 4],
						[a.TaskPriority.FILTER_VISIBILITY, 4],
						[a.TaskPriority.SCALE_VISIBILITY, 4],
						[a.TaskPriority.FRUSTUM_VISIBILITY, 4],
						[a.TaskPriority.CLOUDS_GENERATOR, 4],
						[a.TaskPriority.POINT_OF_INTEREST_FREQUENT, 6],
						[a.TaskPriority.POINT_OF_INTEREST_INFREQUENT, 30],
						[a.TaskPriority.LABELER,
							8
						],
						[a.TaskPriority.FEATURE_QUERY_ENGINE, 8],
						[a.TaskPriority.FEATURE_TILE_TREE, 16],
						[a.TaskPriority.FEATURE_TILE_TREE_ACTIVE, 0],
						[a.TaskPriority.ELEVATION_ALIGNMENT, 12],
						[a.TaskPriority.TEXT_TEXTURE_ATLAS, 12],
						[a.TaskPriority.TEXTURE_UNLOAD, 12],
						[a.TaskPriority.LINE_OF_SIGHT_TOOL, 16],
						[a.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE, 0],
						[a.TaskPriority.SNAPPING, 0],
						[a.TaskPriority.SHADOW_ACCUMULATOR, 30]
					]),
					q = g.Milliseconds(6.5),
					u = g.Milliseconds(1),
					x = g.Milliseconds(30),
					y = g.Milliseconds(1E3 / 30),
					w = g.Milliseconds(100);
				var A;
				(function(z) {
					let C = function() {
						function K() {
							this._updating = new l.ObservableValue(!0);
							this._microTaskQueued = !1;
							this._frameNumber = 0;
							this.performanceInfo = {
								total: new k("total"),
								tasks: new Map
							};
							this._frameTaskTimes = new Map;
							this._budget = new J;
							this._state = n.RenderState.INTERACTING;
							this._tasks = new v;
							this._runQueue = new v;
							this._load = 0;
							this._idleStateCallbacks = new v;
							this._idleUpdatesStartFired = !1;
							this._maxReschedule = 32;
							this._debug = this._forceTask = !1;
							this._debugHandle = f.watch(() => p.SCHEDULER_LOG_SLOW_TASKS,
								F => this._debug = F, f.initial);
							for (const F of Object.keys(a.TaskPriority)) this.performanceInfo.tasks.set(a.TaskPriority[F], new k(a.TaskPriority[F]));
							const G = this;
							this._test = {
								FRAME_SAFETY_BUDGET: q,
								INTERACTING_BUDGET: y,
								IDLE_BUDGET: w,
								get availableBudget() {
									return G._budget.budget
								},
								usedBudget: 0,
								getBudget: () => G._budget,
								setBudget: F => G._budget = F,
								updateTask: F => this._updateTask(F),
								getState: F => this._getState(F),
								getRuntime: F => this._getRuntime(F),
								frameTaskTimes: this._frameTaskTimes,
								resetRuntimes: () => this._resetRuntimes(),
								getRunning: () => this._getRunning()
							}
						}
						var H = K.prototype;
						H.destroy = function() {
							this._tasks.toArray()
								.forEach(G => G.remove());
							this._tasks.clear();
							d.removeMaybe(this._debugHandle);
							this._microTaskQueued = !1;
							this._updating.set(!1)
						};
						H.activate = function() {
							this._budget.done || this._microTaskQueued || (this._microTaskQueued = !0, queueMicrotask(() => {
								this._microTaskQueued && (this._microTaskQueued = !1, this._budget.done || (this._maxReschedule = 32, this._schedule(), this.frame()))
							}))
						};
						H.registerTask = function(G, F) {
							const L = t(G);
							F = new D(this, G, F, L);
							this._tasks.push(F);
							this.performanceInfo.tasks.has(G) || this.performanceInfo.tasks.set(G, new k(G));
							return F
						};
						H.registerIdleStateCallbacks = function(G, F) {
							const L = {
								idleBegin: G,
								idleEnd: F
							};
							this._idleStateCallbacks.push(L);
							this.state === n.RenderState.IDLE && this._idleUpdatesStartFired && L.idleBegin();
							const R = this;
							return {
								remove: () => this._removeIdleStateCallbacks(L),
								set idleBegin(V) {
									R._idleUpdatesStartFired && (L.idleEnd(), R._state === n.RenderState.IDLE && V());
									L.idleBegin = V
								},
								set idleEnd(V) {
									L.idleEnd =
										V
								}
							}
						};
						H.updateBudget = function(G) {
							this._test.usedBudget = 0;
							++this._frameNumber;
							let F = q,
								L = G.frameDuration,
								R = u;
							switch (this.state) {
								case n.RenderState.IDLE:
									F = g.Milliseconds(0);
									L = g.Milliseconds(Math.max(w, G.frameDuration));
									R = x;
									break;
								case n.RenderState.INTERACTING:
									L = g.Milliseconds(Math.max(y, G.frameDuration))
							}
							L = g.Milliseconds(L - G.elapsedFrameTime - F);
							if (this.state !== n.RenderState.IDLE && L < u && !this._forceTask) return this._forceTask = !0, !1;
							L = g.Milliseconds(Math.max(L, R));
							this._budget.reset(L, this.state);
							this._maxReschedule =
								32;
							this._updateLoad();
							return this._schedule()
						};
						H.frame = function() {
							this._microTaskQueued = this._forceTask = !1;
							switch (this.state) {
								case n.RenderState.IDLE:
									this._idleUpdatesStartFired || (this._idleUpdatesStartFired = !0, this._idleStateCallbacks.forAll(G => G.idleBegin()));
									this._runIdle();
									break;
								case n.RenderState.INTERACTING:
									this._runInteracting();
									break;
								default:
									this._runAnimating()
							}
							this._test.usedBudget = this._budget.elapsed
						};
						H.stopFrame = function() {
							this._budget.reset(g.Milliseconds(0), this._state);
							this._budget.madeProgress()
						};
						H._removeIdleStateCallbacks = function(G) {
							this._idleUpdatesStartFired && G.idleEnd();
							this._idleStateCallbacks.removeUnordered(G)
						};
						H.removeTask = function(G) {
							this._tasks.removeUnordered(G);
							this._runQueue.removeUnordered(G)
						};
						H._updateTask = function(G) {
							this._tasks.forAll(F => {
								F.name === G && F.setPriority(G)
							})
						};
						H._getState = function(G) {
							if (this._runQueue.some(L => L.name === G)) return a.TaskState.SCHEDULED;
							let F = a.TaskState.IDLE;
							this._tasks.forAll(L => {
								L.name === G && L.needsUpdate && (1 >= L.schedulePriority ? F = a.TaskState.READY :
									F !== a.TaskState.READY && (F = a.TaskState.WAITING))
							});
							return F
						};
						H._getRuntime = function(G) {
							let F = 0;
							this._tasks.forAll(L => {
								L.name === G && (F += L.runtime)
							});
							return F
						};
						H._resetRuntimes = function() {
							this._tasks.forAll(G => G.runtime = 0)
						};
						H._getRunning = function() {
							const G = new Map;
							this._tasks.forAll(L => {
								L.needsUpdate && G.set(L.name, (G.get(L.name) || 0) + 1)
							});
							if (0 === G.size) return null;
							let F = "";
							G.forEach((L, R) => {
								F = 1 < L ? F + ` ${L}x ${R}` : F + ` ${R}`
							});
							return F
						};
						H._runIdle = function() {
							this._run()
						};
						H._runInteracting = function() {
							this._run()
						};
						H._runAnimating = function() {
							this._run()
						};
						H._updateLoad = function() {
							const G = this._tasks.reduce((F, L) => L.needsUpdate ? ++F : F, 0);
							this._load = .9 * this._load + G * (1 - .9)
						};
						H._schedule = function() {
							if (0 >= this._maxReschedule) return !1;
							this._runQueue.filterInPlace(G => {
								if (G.needsUpdate) return !0;
								G.schedulePriority = G.basePriority;
								return !1
							});
							for (this._tasks.forAll(G => {
								0 === G.basePriority && G.needsUpdate && !this._runQueue.includes(G) && this._runQueue.unshift(G)
							}); 0 === this._runQueue.length;) {
								let G = !1;
								this._tasks.forAll(F => {
									if (F.needsUpdate &&
										0 !== F.schedulePriority && 0 !== F.basePriority && (!F.task.runOncePerFrame || F.lastFrameRun !== this._frameNumber)) switch (G = !0, F.schedulePriority) {
										case 1:
											F.schedulePriority = 0;
											this._runQueue.push(F);
											break;
										default:
											--F.schedulePriority
									}
								});
								if (!G) return this._updating.set(!1), !1;
								--this._maxReschedule
							}
							this._updating.set(!0);
							return !0
						};
						H._run = function() {
							const G = this._budget.now();
							this._startFrameTaskTimes();
							do
								for (; 0 < this._runQueue.length;) {
									var F = this._budget.now();
									const L = this._runQueue.pop();
									this._budget.resetProgress();
									try {
										L.task.runTask(this._budget)
									} catch (R) {
										e.getLogger("esri.views.support.Scheduler")
											.error(`Exception in task "${L.name}"`, R)
									}
									L.schedulePriority = L.basePriority;
									L.lastFrameRun = this._frameNumber;
									F = this._budget.now() - F;
									L.runtime += F;
									this._frameTaskTimes.set(L.priority, this._frameTaskTimes.get(L.priority) + F);
									this._debug && this._budget.elapsed > 2 * this._budget.budget && console.log("Task", L.name, "used", this._budget.elapsed, "of max", this._budget.budget, "ms");
									if (0 >= this._budget.remaining) {
										this._updating.set(this._tasks.some(R =>
											R.needsUpdate));
										this._recordFrameTaskTimes(this._budget.now() - G);
										return
									}
								}
							while (this._schedule());
							this._updating.set(this._tasks.some(L => L.needsUpdate));
							this._recordFrameTaskTimes(this._budget.now() - G)
						};
						H._startFrameTaskTimes = function() {
							for (const G of Object.keys(a.TaskPriority)) this._frameTaskTimes.set(a.TaskPriority[G], 0)
						};
						H._recordFrameTaskTimes = function(G) {
							this._frameTaskTimes.forEach((F, L) => this.performanceInfo.tasks.get(L)
								.record(F));
							this.performanceInfo.total.record(G)
						};
						b._createClass(K, [{
							key: "updating",
							get: function() {
								return this._updating.get()
							},
							set: function(G) {
								this._updating.set(G)
							}
						}, {
							key: "load",
							get: function() {
								return this._load
							}
						}, {
							key: "state",
							get: function() {
								return this._state
							},
							set: function(G) {
								this._state !== G && (this._state = G, this.state !== n.RenderState.IDLE && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = !1, this._idleStateCallbacks.forAll(F => F.idleEnd())))
							}
						}, {
							key: "test",
							get: function() {
								return this._test
							}
						}]);
						return K
					}();
					z.Scheduler = C;
					let D = function() {
							function K(G, F, L, R) {
								this._scheduler =
									G;
								this.name = F;
								this._basePriority = R;
								this.runtime = this.lastFrameRun = 0;
								this._queue = new r.PromiseQueue;
								this._handles = new c;
								this.schedulePriority = this._basePriority;
								this._task = new l.ObservableValue(d.isSome(L) ? L : this._queue);
								this._handles.add(f.when(() => this.task.running, () => G.activate()))
							}
							var H = K.prototype;
							H.remove = function() {
								this.processQueue(B);
								this._scheduler.removeTask(this);
								this.schedule = E.schedule;
								this.reschedule = E.reschedule;
								this._handles.destroy()
							};
							H.setPriority = function(G) {
								this.name = G;
								G = t(G);
								if (0 === this._basePriority || 0 !== this.schedulePriority) this.schedulePriority = G;
								this._basePriority = G
							};
							H.schedule = function(G, F, L) {
								return this._queue.push(G, F, L)
							};
							H.reschedule = function(G, F, L) {
								return this._queue.unshift(G, F, L)
							};
							H.processQueue = function(G) {
								this._queue.runTask(G)
							};
							b._createClass(K, [{
								key: "task",
								get: function() {
									return this._task.get()
								}
							}, {
								key: "updating",
								get: function() {
									return this._queue.running
								}
							}, {
								key: "basePriority",
								get: function() {
									return this._basePriority
								}
							}, {
								key: "priority",
								get: function() {
									return this.name
								},
								set: function(G) {
									this.setPriority(G)
								}
							}, {
								key: "needsUpdate",
								get: function() {
									return this.updating || this.task.running
								}
							}]);
							return K
						}(),
						J = function() {
							function K() {
								this._begin = "undefined" !== typeof performance ? performance.now() : 0;
								this._budget = 0;
								this._state = n.RenderState.IDLE;
								this._done = !1;
								this._enabled = !0
							}
							var H = K.prototype;
							H.run = function(G) {
								if (this.done) return !1;
								!0 === G() && this.madeProgress();
								return !0
							};
							H.madeProgress = function() {
								this._done = this.elapsed >= this._budget && this._enabled
							};
							H.reset = function(G, F) {
								this._begin =
									this.now();
								this._budget = G;
								this._state = F;
								this._done = !1
							};
							H.now = function() {
								return performance.now()
							};
							H.resetProgress = function() {
								this._done = !1
							};
							b._createClass(K, [{
								key: "done",
								get: function() {
									return this._done
								}
							}, {
								key: "budget",
								get: function() {
									return this._budget
								}
							}, {
								key: "state",
								get: function() {
									return this._state
								}
							}, {
								key: "enabled",
								get: function() {
									return this._enabled
								},
								set: function(G) {
									this._enabled = G
								}
							}, {
								key: "remaining",
								get: function() {
									return Math.max(this._budget - this.elapsed, 0)
								}
							}, {
								key: "elapsed",
								get: function() {
									return performance.now() -
										this._begin
								}
							}, {
								key: "hasProgressed",
								get: function() {
									return this._done
								}
							}]);
							return K
						}();
					z.Budget = J
				})(A || (A = {}));
				a.TaskState = void 0;
				(function(z) {
					z.SCHEDULED = "s";
					z.READY = "r";
					z.WAITING = "w";
					z.IDLE = "i"
				})(a.TaskState || (a.TaskState = {}));
				const B = (() => {
						const z = new A.Budget;
						z.enabled = !1;
						return z
					})(),
					E = new(function() {
						function z() {}
						var C = z.prototype;
						C.remove = function() {};
						C.processQueue = function() {};
						C.schedule = function(D, J, K) {
							try {
								if (m.isAborted(J)) {
									const H = m.createAbortError();
									return K ? Promise.resolve(K(H)) : Promise.reject(H)
								}
								return m.when(D(B))
							} catch (H) {
								return Promise.reject(H)
							}
						};
						C.reschedule = function(D, J, K) {
							return this.schedule(D, J, K)
						};
						return z
					}());
				a.ImmediateTask = E;
				a.getTaskPriority = t;
				a.newScheduler = function() {
					return new A.Scheduler
				};
				a.noBudget = B;
				a.taskPriorities = h;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/accessorSupport/tracking/ObservableValue": function() {
			define(["exports", "../tracking", "./SimpleObservable"], function(a, b, c) {
				let e = function() {
					function d(v) {
						this._observable = new c.SimpleObservable;
						this._value = v
					}
					var k = d.prototype;
					k.get = function() {
						b.trackAccess(this._observable);
						return this._value
					};
					k.set = function(v) {
						v !== this._value && (this._value = v, this._observable.notify())
					};
					return d
				}();
				a.ObservableValue = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/layers/support/PromiseQueue": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../core/promiseUtils", "../../core/accessorSupport/tracking/ObservableValue"], function(a, b, c, e) {
				let d = function() {
						function v() {
							this._tasks = [];
							this._running = new e.ObservableValue(!1)
						}
						var m = v.prototype;
						m.destroy = function() {
							this.cancelAll()
						};
						m.runTask = function(f) {
							for (; !f.done && this._process(f);) f.madeProgress()
						};
						m.push = function(f, g, l) {
							this._running.set(!0);
							return new Promise((r, p) => this._tasks.push(new k(r, p, f, g, l)))
						};
						m.unshift = function(f, g, l) {
							this._running.set(!0);
							return new Promise((r, p) => this._tasks.unshift(new k(r, p, f, g, l)))
						};
						m._process = function(f) {
							if (0 === this._tasks.length) return !1;
							const g = this._tasks.shift();
							try {
								const l = c.isAborted(g.signal);
								if (l && !g.abortCallback) g.reject(c.createAbortError());
								else {
									const r = l ? g.abortCallback ? .(c.createAbortError()) : g.callback(f);
									c.isPromiseLike(r) ? r.then(g.resolve, g.reject) : g.resolve(r)
								}
							} catch (l) {
								g.reject(l)
							}
							this._running.set(0 < this._tasks.length);
							return !0
						};
						m.cancelAll = function() {
							const f = c.createAbortError();
							for (const g of this._tasks)
								if (g.abortCallback) {
									const l = g.abortCallback(f);
									g.resolve(l)
								} else g.reject(f);
							this._tasks.length = 0;
							this._running.set(!1)
						};
						b._createClass(v, [{
								key: "length",
								get: function() {
									return this._tasks.length
								}
							},
							{
								key: "running",
								get: function() {
									return this._running.get()
								}
							}
						]);
						return v
					}(),
					k = function(v, m, f, g, l) {
						this.resolve = v;
						this.reject = m;
						this.callback = f;
						this.signal = g;
						this.abortCallback = l
					};
				a.PromiseQueue = d;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/support/debugFlags": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(m) {
						function f() {
							var g = m.apply(this, arguments) || this;
							g.SCHEDULER_LOG_SLOW_TASKS = !1;
							g.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES = !1;
							return g
						}
						a._inheritsLoose(f, m);
						return f
					}(c);
					b.__decorate([e.property()], c.prototype, "SCHEDULER_LOG_SLOW_TASKS", void 0);
					b.__decorate([e.property()], c.prototype, "FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES", void 0);
					c = b.__decorate([v.subclass("esri.views.support.DebugFlags")], c);
					return new c
				})
		},
		"esri/views/support/RenderState": function() {
			define(["exports"],
				function(a) {
					a.RenderState = void 0;
					var b = a.RenderState || (a.RenderState = {});
					b[b.ANIMATING = 0] = "ANIMATING";
					b[b.INTERACTING = 1] = "INTERACTING";
					b[b.IDLE = 2] = "IDLE";
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/views/input/InputManager": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/Logger ../../core/maybe ../../core/Queue ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../3d/support/PropertiesPool ./keys ./handlers/LatestPointer ./handlers/MultiTouch".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t) {
					a.InputManager = function(y) {
						function w(B) {
							var E = y.call(this, B) || this;
							E._pointerCaptures = new Map;
							E._nameToGroup = {};
							E._handlers = [];
							E._handlersPriority = [];
							E._currentPropagation = null;
							E._updateDependenciesAfterPropagation = !1;
							E._sourceEvents = new Set;
							E._keyModifiers = new Set;
							E._activeKeyModifiers = new Set;
							E._stoppedPropagationEventIds = new Set;
							E.primaryKey = p.primaryKey;
							E._latestPointerType = "mouse";
							E._propertiesPool = new r.PropertiesPool({
								latestPointerLocation: x
							}, b._assertThisInitialized(E));
							E.latestPointerLocation = null;
							E.test = {
								timestamp: void 0,
								hasCurrentPropagation: () => !!E._currentPropagation
							};
							return E
						}
						b._inheritsLoose(w, y);
						var A = w.prototype;
						A.initialize = function() {
							this.eventSource.onEventReceived = this._onEventReceived.bind(this);
							this._installRecognizers()
						};
						A.destroy = function() {
							const B = Object.keys(this._nameToGroup);
							for (const E of B) this.uninstallHandlers(E);
							this.eventSource.destroy();
							this._currentPropagation = null;
							this._propertiesPool.destroy()
						};
						A.installHandlers = function(B, E, z = u.INTERNAL) {
							if (this._nameToGroup[B]) d.getLogger(this.declaredClass)
								.error("There is already an InputHandler group registered under the name `" +
									B + "`");
							else if (0 === E.length) d.getLogger(this.declaredClass)
								.error("Can't register a group of zero handlers");
							else {
								var C = {
									name: B,
									handlers: E.map(D => ({
										handler: D,
										active: !0,
										removed: !1,
										priorityIndex: 0,
										groupPriority: z,
										eventCallback: null,
										uninstallCallback: null
									}))
								};
								this._nameToGroup[B] = C;
								for (B = C.handlers.length - 1; 0 <= B; B--) {
									const D = C.handlers[B];
									this._handlers.push(D);
									D.handler.onInstall({
										updateDependencies: () => {
											this.updateDependencies()
										},
										emit: (J, K, H, G, F) => {
											this._emitInputEvent(D.priorityIndex + 1, J, K, H, F, G)
										},
										setPointerCapture: (J, K) => {
											this._setPointerCapture(C, D, J, K)
										},
										setEventCallback: J => {
											D.eventCallback = J
										},
										setUninstallCallback: J => {
											D.uninstallCallback = J
										},
										refreshHasPendingInputs: () => {
											this.notifyChange("hasPendingInputs")
										}
									})
								}
								this.updateDependencies()
							}
						};
						A.uninstallHandlers = function(B) {
							const E = this._nameToGroup[B];
							E ? (E.handlers.forEach(z => {
									z.removed = !0;
									z.uninstallCallback ? .()
								}), delete this._nameToGroup[B], this._currentPropagation ? this._currentPropagation.needsHandlerGarbageCollect = !0 : this._garbageCollectRemovedHandlers()) :
								d.getLogger(this.declaredClass)
								.error("There is no InputHandler group registered under the name `" + B + "`")
						};
						A.hasHandlers = function(B) {
							return void 0 !== this._nameToGroup[B]
						};
						A.updateDependencies = function() {
							if (this._currentPropagation) this._updateDependenciesAfterPropagation = !0;
							else {
								this._updateDependenciesAfterPropagation = !1;
								var B = new Set,
									E = new Set;
								this._handlersPriority = [];
								for (var z = this._handlers.length - 1; 0 <= z; z--) {
									var C = this._handlers[z];
									C.priorityIndex = z;
									this._handlersPriority.push(C)
								}
								this._handlersPriority =
									this._sortHandlersPriority(this._handlersPriority);
								for (z = this._handlersPriority.length - 1; 0 <= z; z--) {
									C = this._handlersPriority[z];
									C.priorityIndex = z;
									let D = C.handler.hasSideEffects;
									if (!D)
										for (const J of C.handler.outgoingEventTypes)
											if (B.has(J)) {
												D = !0;
												break
											} if (D)
										for (const J of C.handler.incomingEventMatches) {
											B.add(J.eventType);
											for (const K of J.keyModifiers) p.isSystemModifier(K) || E.add(K)
										}
									C.active = D
								}
								this._sourceEvents = B;
								this._keyModifiers = E;
								0 < this._pointerCaptures.size && this._sourceEvents.add("pointer-capture-lost");
								0 < this._keyModifiers.size && (this._sourceEvents.add("key-down"), this._sourceEvents.add("key-up"));
								this.eventSource && (this.eventSource.activeEvents = this._sourceEvents)
							}
						};
						A._setLatestPointer = function(B, E, z) {
							this._latestPointerType = B;
							B = this._get("latestPointerLocation");
							if (k.isNone(B) || B.x !== E || B.y !== z) B = this._propertiesPool.get("latestPointerLocation"), B.x = E, B.y = z, this._set("latestPointerLocation", B)
						};
						A._onEventReceived = function(B, E) {
							"pointer-capture-lost" === B && this._pointerCaptures.delete(E.native.pointerId);
							this._updateKeyModifiers(B, E);
							this._emitInputEventFromSource(B, E, null != this.test.timestamp ? this.test.timestamp : E.native ? E.native.timestamp : void 0, E.native ? E.native.cancelable : void 0)
						};
						A._updateKeyModifiers = function(B, E) {
							if (E) {
								var z = !1,
									C = () => {
										if (!z) {
											const J = new Set;
											this._activeKeyModifiers.forEach(K => {
												J.add(K)
											});
											this._activeKeyModifiers = J;
											z = !0
										}
									},
									D = (J, K) => {
										K && !this._activeKeyModifiers.has(J) ? (C(), this._activeKeyModifiers.add(J)) : !K && this._activeKeyModifiers.has(J) && (C(), this._activeKeyModifiers.delete(J))
									};
								if ("key-down" === B || "key-up" === B) {
									const J = E.key;
									this._keyModifiers.has(J) && D(J, "key-down" === B)
								}
								B = E.native;
								D("Alt", !(!B || !B.altKey));
								D("Ctrl", !(!B || !B.ctrlKey));
								D("Shift", !(!B || !B.shiftKey));
								D("Meta", !(!B || !B.metaKey));
								D("Primary", this._activeKeyModifiers.has(this.primaryKey))
							}
						};
						A._installRecognizers = function() {
							this._latestPointerHandler = new n.LatestPointer((B, E, z) => this._setLatestPointer(B, E, z));
							this._multiTouchHandler = new t.MultiTouch;
							this.installHandlers("input-manager-logic", [this._latestPointerHandler,
								this._multiTouchHandler
							], u.ALWAYS);
							0 < this.recognizers.length && this.installHandlers("default", this.recognizers, u.INTERNAL)
						};
						A._setPointerCapture = function(B, E, z, C) {
							B = B.name + "-" + E.priorityIndex;
							E = this._pointerCaptures.get(z.pointerId) || new Set;
							this._pointerCaptures.set(z.pointerId, E);
							C ? (E.add(B), 1 === E.size && this.eventSource && this.eventSource.setPointerCapture(z, !0)) : E.has(B) && (E.delete(B), 0 === E.size && (this._pointerCaptures.delete(z.pointerId), this.eventSource && this.eventSource.setPointerCapture(z, !1)))
						};
						A._garbageCollectRemovedHandlers = function() {
							this._handlers = this._handlers.filter(B => !B.removed);
							this.updateDependencies()
						};
						A._emitInputEventFromSource = function(B, E, z, C) {
							this._emitInputEvent(0, B, E, z, C)
						};
						A._emitInputEvent = function(B, E, z, C, D, J) {
							C = void 0 !== C ? C : this._currentPropagation ? this._currentPropagation.timestamp : performance.now();
							B = {
								event: new h(E, z, C, J || this._activeKeyModifiers, void 0 !== D ? D : !1),
								priorityIndex: B
							};
							this._currentPropagation ? this._currentPropagation.events.push(B) : this._doNewPropagation(B)
						};
						A._doNewPropagation = function(B) {
							this._currentPropagation = {
								events: new v,
								currentHandler: null,
								needsHandlerGarbageCollect: !1,
								timestamp: B.event.timestamp
							};
							this._currentPropagation.events.push(B);
							this._continuePropagation()
						};
						A._continuePropagation = function() {
							const B = k.unwrapOrThrow(this._currentPropagation);
							for (; 0 < B.events.length;) {
								const {
									event: E,
									priorityIndex: z
								} = B.events.pop(), C = E.data && E.data.eventId;
								if (null == C || !this._stoppedPropagationEventIds.has(C))
									for (B.currentHandler = this._handlersPriority[z]; B.currentHandler;) {
										if (B.currentHandler.removed) B.needsHandlerGarbageCollect = !0;
										else {
											B.currentHandler.active && !E.shouldStopPropagation() && B.currentHandler.eventCallback ? .(E);
											if (E.shouldStopPropagation()) {
												null != C && this._stoppedPropagationEventIds.add(C);
												break
											}
											if (E.shouldPausePropagation(() => this._continuePropagation())) {
												this._pausePropagation({
													event: E,
													priorityIndex: B.currentHandler.priorityIndex + 1
												});
												return
											}
										}
										B.currentHandler = this._handlersPriority[B.currentHandler.priorityIndex + 1]
									}
							}
							B.needsHandlerGarbageCollect && this._garbageCollectRemovedHandlers();
							this.hasPendingInputs || this._stoppedPropagationEventIds.clear();
							this._currentPropagation = null;
							this._updateDependenciesAfterPropagation && this.updateDependencies()
						};
						A._pausePropagation = function(B) {
							const E = new v;
							E.push(B);
							if (B = this._currentPropagation) {
								for (; B.events.length;) E.push(B.events.pop());
								B.events = E;
								B.currentHandler = null
							}
						};
						A._compareHandlerPriority = function(B, E) {
							if (B.handler.hasSideEffects !== E.handler.hasSideEffects) return B.handler.hasSideEffects ? 1 : -1;
							if (B.groupPriority !== E.groupPriority) return B.groupPriority > E.groupPriority ? -1 : 1;
							for (const z of B.handler.incomingEventMatches)
								for (const C of E.handler.incomingEventMatches) {
									if (z.eventType !==
										C.eventType) continue;
									const D = z.keyModifiers.filter(J => C.keyModifiers.includes(J));
									if (D.length === z.keyModifiers.length !== (D.length === C.keyModifiers.length)) return z.keyModifiers.length > C.keyModifiers.length ? -1 : 1
								}
							return B.priorityIndex > E.priorityIndex ? -1 : 1
						};
						A._sortHandlersPriority = function(B) {
							const E = [];
							for (const z of B) {
								for (B = 0; B < E.length && 0 <= this._compareHandlerPriority(z, E[B]);) B++;
								E.splice(B, 0, z)
							}
							return E
						};
						b._createClass(w, [{
								key: "hasPendingInputs",
								get: function() {
									return this._handlers.some(B => B.handler.hasPendingInputs)
								}
							},
							{
								key: "latestPointerType",
								get: function() {
									return this._latestPointerType
								}
							}, {
								key: "multiTouchActive",
								get: function() {
									return this._multiTouchHandler.multiTouchActive
								}
							}, {
								key: "debug",
								get: function() {
									const B = E => {
										const z = this._setPointerCapture;
										this._setPointerCapture = () => {};
										E();
										this._setPointerCapture = z
									};
									return {
										injectEvent: (E, z) => {
											B(() => {
												this._onEventReceived(E, z)
											})
										},
										disablePointerCapture: B
									}
								}
							}
						]);
						return w
					}(e);
					c.__decorate([m.property({
						readOnly: !0
					})], a.InputManager.prototype, "hasPendingInputs", null);
					c.__decorate([m.property({
							constructOnly: !0
						})],
						a.InputManager.prototype, "eventSource", void 0);
					c.__decorate([m.property({
						constructOnly: !0
					})], a.InputManager.prototype, "recognizers", void 0);
					c.__decorate([m.property()], a.InputManager.prototype, "_latestPointerType", void 0);
					c.__decorate([m.property()], a.InputManager.prototype, "latestPointerType", null);
					c.__decorate([m.property()], a.InputManager.prototype, "multiTouchActive", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.InputManager.prototype, "latestPointerLocation", void 0);
					a.InputManager = c.__decorate([l.subclass("esri.views.input.InputManager")],
						a.InputManager);
					let h = function() {
						function y(A, B, E, z, C) {
							this.type = A;
							this.data = B;
							this.timestamp = E;
							this.modifiers = z;
							this.cancelable = C;
							this._propagationState = q.NONE;
							this._resumeCallback = null
						}
						var w = y.prototype;
						w.stopPropagation = function() {
							this._propagationState |= q.STOPPED
						};
						w.shouldStopPropagation = function() {
							return 0 !== (this._propagationState & q.STOPPED)
						};
						w.async = function(A) {
							this._propagationState |= q.PAUSED;
							const B = (E, z) => {
								this._propagationState &= ~q.PAUSED;
								const C = this._resumeCallback;
								this._resumeCallback =
									null;
								C && C();
								if (z) throw E;
								return E
							};
							return ("function" === typeof A ? A() : A)
								.then(E => B(E, !1), E => B(E, !0))
						};
						w.shouldPausePropagation = function(A) {
							return this._propagationState & q.PAUSED ? (this._resumeCallback = A, !0) : !1
						};
						w.preventDefault = function() {
							this.data.native.preventDefault()
						};
						return y
					}();
					var q;
					(function(y) {
						y[y.NONE = 0] = "NONE";
						y[y.STOPPED = 1] = "STOPPED";
						y[y.PAUSED = 2] = "PAUSED"
					})(q || (q = {}));
					const u = {
						ALWAYS: 1,
						DEFAULT: 0,
						TOOL: -1,
						WIDGET: -2,
						INTERNAL: -3
					};
					let x = function() {};
					a.ViewEventPriorities = u;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/views/3d/support/PropertiesPool": function() {
			define(["exports", "../../../core/ReentrantObjectPool", "../../../core/accessorSupport/watch"], function(a, b, c) {
				let e = function() {
					function d(v, m) {
						this._owner = m;
						this._properties = {};
						this._afterDispatchHandle = null;
						for (const f in v) m = new b.ReentrantObjectPool(v[f], void 0, void 0, 2, 2), this._properties[f] = {
							pool: m,
							acquired: []
						};
						this._afterDispatchHandle = c.afterDispatch(() => this._release())
					}
					var k =
						d.prototype;
					k.destroy = function() {
						this._afterDispatchHandle && (this._afterDispatchHandle.remove(), this._afterDispatchHandle = null);
						for (const v in this._properties) {
							const m = this._properties[v];
							for (const f of m.acquired) c.isValueInUse(f) || m.pool.release(f);
							m.pool.destroy();
							m.pool = null;
							m.acquired = null
						}
						this._owner = this._properties = null
					};
					k.get = function(v) {
						const m = this._owner._get(v);
						v = this._properties[v];
						let f = v.pool.acquire();
						for (v.acquired.push(f); f === m;) v.acquired.push(f), f = v.pool.acquire();
						return f
					};
					k._release = function() {
						for (const v in this._properties) {
							const m = this._properties[v];
							let f = 0;
							for (const g of m.acquired) c.isValueInUse(g) ? m.acquired[f++] = g : m.pool.release(g);
							m.acquired.length = f
						}
					};
					return d
				}();
				a.PropertiesPool = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/input/keys": function() {
			define(["exports", "../../core/events", "../../core/has"], function(a, b, c) {
				c = c("mac") ? "Meta" : "Ctrl";
				const e = {
					8: "Backspace",
					9: "Tab",
					13: "Enter",
					27: "Escape",
					33: "PageUp",
					34: "PageDown",
					35: "End",
					36: "Home",
					37: "ArrowLeft",
					38: "ArrowUp",
					39: "ArrowRight",
					40: "ArrowDown",
					45: "Insert",
					46: "Delete"
				};
				for (var d = 48; 58 > d; d++) e[d] = String.fromCharCode(d);
				for (d = 1; 25 > d; d++) e[111 + d] = `F${d}`;
				for (d = 65; 91 > d; d++) e[d] = [String.fromCharCode(d + 32), String.fromCharCode(d)];
				a.eventKey = function(k) {
					if (void 0 !== k.key) return b.eventKey(k);
					const v = e[k.keyCode];
					return Array.isArray(v) ? k.shiftKey ? v[1] : v[0] : v
				};
				a.isSystemModifier = function(k) {
					switch (k) {
						case "Ctrl":
						case "Alt":
						case "Shift":
						case "Meta":
						case "Primary":
							return !0
					}
					return !1
				};
				a.primaryKey = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/input/handlers/LatestPointer": function() {
			define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../InputHandler"], function(a, b, c) {
				c = function(e) {
					function d(k) {
						var v = e.call(this, !0) || this;
						v._onChange = k;
						v._value = "mouse";
						v._x = null;
						v._y = null;
						v.registerIncoming("pointer-move", m => {
							v._update(m.data)
						});
						return v
					}
					b._inheritsLoose(d, e);
					d.prototype._update = function(k) {
						const v = "touch" ===
							k.native.pointerType ? "touch" : "mouse",
							{
								x: m,
								y: f
							} = k;
						if (v !== this._value || this._x !== m || this._y !== f) this._value = v, this._x = m, this._y = f, this._onChange(v, m, f)
					};
					return d
				}(c.InputHandler);
				a.LatestPointer = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/input/InputHandler": function() {
			define(["exports", "../../chunks/_rollupPluginBabelHelpers", "../../core/Logger", "./EventMatch"], function(a, b, c, e) {
				const d = c.getLogger("esri.views.input.InputHandler");
				c = function() {
					function m(g) {
						this._manager =
							null;
						this._incoming = {};
						this._outgoing = {};
						this._outgoingEventTypes = this._incomingEventTypes = this._incomingEventMatches = null;
						this._hasSideEffects = g
					}
					var f = m.prototype;
					f.onInstall = function(g) {
						this._manager ? d.error("This InputHandler has already been registered with an InputManager") : (g.setEventCallback(l => this._handleEvent(l)), g.setUninstallCallback(() => this._onUninstall()), this._manager = g)
					};
					f.onUninstall = function() {};
					f.registerIncoming = function(g, l, r) {
						"function" === typeof l ? (r = l, l = []) : l = l || [];
						g = "string" ===
							typeof g ? new e.EventMatch(g, l) : g;
						const p = () => {
							this._incomingEventMatches = this._incomingEventTypes = null
						};
						l = n => {
							const t = this._incoming[n.match.eventType];
							t && (n = t.indexOf(n), t.splice(n, 1), p(), this._manager && this._manager.updateDependencies())
						};
						r = new k(g, r, {
							onPause: l,
							onRemove: l,
							onResume: n => {
								const t = this._incoming[n.match.eventType];
								t && !t.includes(n) && (t.push(n), p(), this._manager && this._manager.updateDependencies())
							}
						});
						l = this._incoming[g.eventType];
						l || (l = [], this._incoming[g.eventType] = l);
						l.push(r);
						p();
						this._manager && this._manager.updateDependencies();
						return r
					};
					f.registerOutgoing = function(g) {
						if (this._outgoing[g]) throw Error("There is already a callback registered for this outgoing InputEvent: " + g);
						const l = new v(g, {
							onEmit: (r, p, n, t) => {
								this._manager ? .emit(r.eventType, p, n, t)
							},
							onRemove: r => {
								delete this._outgoing[r.eventType];
								this._manager ? .updateDependencies()
							}
						});
						this._outgoing[g] = l;
						this._outgoingEventTypes = null;
						this._manager && this._manager.updateDependencies();
						return l
					};
					f.startCapturingPointer = function(g) {
						this._manager ? .setPointerCapture(g,
							!0)
					};
					f.stopCapturingPointer = function(g) {
						this._manager ? .setPointerCapture(g, !1)
					};
					f.refreshHasPendingInputs = function() {
						this._manager ? .refreshHasPendingInputs()
					};
					f._onUninstall = function() {
						this._manager ? (this.onUninstall(), this._manager = null) : d.error("This InputHandler is not registered with an InputManager")
					};
					f._handleEvent = function(g) {
						const l = this._incoming[g.type];
						if (l)
							for (const r of l)
								if (r.match.matches(g) && (r.callback ? .(g), g.shouldStopPropagation())) break
					};
					b._createClass(m, [{
						key: "incomingEventMatches",
						get: function() {
							if (!this._incomingEventMatches) {
								this._incomingEventMatches = [];
								for (const g in this._incoming) {
									const l = this._incoming[g];
									for (const r of l) this._incomingEventMatches.push(r.match)
								}
							}
							return this._incomingEventMatches
						}
					}, {
						key: "incomingEventTypes",
						get: function() {
							this._incomingEventTypes || (this._incomingEventTypes = this.incomingEventMatches.map(g => g.eventType));
							return this._incomingEventTypes
						}
					}, {
						key: "outgoingEventTypes",
						get: function() {
							this._outgoingEventTypes || (this._outgoingEventTypes = Object.keys(this._outgoing));
							return this._outgoingEventTypes
						}
					}, {
						key: "hasSideEffects",
						get: function() {
							return this._hasSideEffects
						}
					}, {
						key: "hasPendingInputs",
						get: function() {
							return !1
						}
					}]);
					return m
				}();
				let k = function() {
						function m(g, l, r) {
							this.match = g;
							this._callback = l;
							this._handler = r
						}
						var f = m.prototype;
						f.pause = function() {
							this._handler.onPause(this)
						};
						f.resume = function() {
							this._handler.onResume(this)
						};
						f.remove = function() {
							this._handler.onRemove(this)
						};
						b._createClass(m, [{
							key: "callback",
							get: function() {
								return this._callback
							}
						}]);
						return m
					}(),
					v =
					function() {
						function m(g, l) {
							this.eventType = g;
							this._removed = !1;
							this._handler = l
						}
						var f = m.prototype;
						f.emit = function(g, l, r) {
							if (!this._removed) this._handler.onEmit(this, g, l, r)
						};
						f.remove = function() {
							this._removed = !0;
							this._handler.onRemove(this)
						};
						return m
					}();
				a.InputHandler = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/input/EventMatch": function() {
			define(["exports"], function(a) {
				let b = function() {
					function c(e, d = []) {
						this.eventType = e;
						this.keyModifiers =
							d
					}
					c.prototype.matches = function(e) {
						if (e.type !== this.eventType) return !1;
						if (0 === this.keyModifiers.length) return !0;
						e = e.modifiers;
						for (const d of this.keyModifiers)
							if (!e.has(d)) return !1;
						return !0
					};
					return c
				}();
				a.EventMatch = b;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/input/handlers/MultiTouch": function() {
			define(["exports", "../../../chunks/_rollupPluginBabelHelpers", "../../../core/accessorSupport/tracking/ObservableValue", "../InputHandler"], function(a,
				b, c, e) {
				e = function(d) {
					function k() {
						var v = d.call(this, !0) || this;
						v._activeTouchPointerIds = new Set;
						v._multiTouchActive = new c.ObservableValue(!1);
						v._onPointerAdd = ({
							data: m
						}) => {
							"touch" === m.pointerType && (v._activeTouchPointerIds.add(m.native.pointerId), v._update())
						};
						v._onPointerRemove = ({
							data: m
						}) => {
							"touch" === m.pointerType && (v._activeTouchPointerIds.delete(m.native.pointerId), v._update())
						};
						v.registerIncoming("pointer-down", v._onPointerAdd);
						v.registerIncoming("pointer-up", v._onPointerRemove);
						v.registerIncoming("pointer-capture-lost",
							v._onPointerRemove);
						v.registerIncoming("pointer-cancel", v._onPointerRemove);
						return v
					}
					b._inheritsLoose(k, d);
					k.prototype._update = function() {
						this._multiTouchActive.set(1 < this._activeTouchPointerIds.size)
					};
					b._createClass(k, [{
						key: "multiTouchActive",
						get: function() {
							return this._multiTouchActive.get()
						}
					}]);
					return k
				}(e.InputHandler);
				a.MultiTouch = e;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/input/ViewEvents": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/has ../../core/mathUtils ../../core/screenUtils ./InputHandler ./InputManager ./IViewEvents".split(" "),
				function(a, b, c, e, d, k, v, m) {
					function f(n) {
						return !!l[n]
					}

					function g(n) {
						for (const t of n)
							if (!f(t)) return !1;
						return !0
					}
					c = "click double-click immediate-click immediate-double-click hold drag key-down key-up pointer-down pointer-move pointer-up pointer-drag mouse-wheel pointer-enter pointer-leave gamepad focus blur".split(" ");
					const l = {};
					c.forEach(n => {
						l[n] = !0
					});
					let r = function() {
							function n(h) {
								this._handlers = new Map;
								this._counter = 0;
								this._handlerCounts = new Map;
								this.view = h;
								this.inputManager = null
							}
							var t = n.prototype;
							t.connect = function(h) {
								h && this.disconnect();
								this.inputManager = h;
								this._handlers.forEach(({
									handler: q,
									priority: u
								}, x) => this.inputManager.installHandlers(x, [q], u))
							};
							t.disconnect = function() {
								this.inputManager && this._handlers.forEach((h, q) => this.inputManager.uninstallHandlers(q));
								this.inputManager = null
							};
							t.destroy = function() {
								this.disconnect();
								this._handlers.clear();
								this.view = null
							};
							t.on = function(h, q, u, x) {
								const y = Array.isArray(h) ? h : h.split(",");
								if (!g(y)) return y.some(f) && console.error("Error: registering input events and other events on the view at the same time is not supported."),
									null;
								if (Array.isArray(q)) h = q;
								else {
									var w = q;
									h = []
								}
								"function" === typeof u ? w = u : x = u;
								x = null != x ? x : v.ViewEventPriorities.DEFAULT;
								const A = this._createUniqueGroupName();
								u = new p(this.view, y, h, w);
								this._handlers.set(A, {
									handler: u,
									priority: x
								});
								for (const B of y) w = this._handlerCounts.get(B) || 0, this._handlerCounts.set(B, w + 1);
								this.inputManager && this.inputManager.installHandlers(A, [u], x);
								return {
									remove: () => this._removeHandler(A, y)
								}
							};
							t.hasHandler = function(h) {
								return !!this._handlerCounts.get(h)
							};
							t._removeHandler = function(h,
								q) {
								if (this._handlers.has(h)) {
									this._handlers.delete(h);
									for (const u of q) q = this._handlerCounts.get(u), void 0 === q ? console.error("Trying to remove handler for event that has no handlers registered: ", u) : 1 === q ? this._handlerCounts.delete(u) : this._handlerCounts.set(u, q - 1)
								}
								this.inputManager && this.inputManager.uninstallHandlers(h)
							};
							t._createUniqueGroupName = function() {
								this._counter += 1;
								return `viewEvents_${this._counter}`
							};
							return n
						}(),
						p = function(n) {
							function t(q, u, x, y) {
								var w = n.call(this, !0) || this;
								w.view = q;
								for (const A of u) switch (A) {
									case "click":
										w.registerIncoming("click",
											x, B => y(w._wrapClick(B)));
										break;
									case "double-click":
										w.registerIncoming("double-click", x, B => y(w._wrapDoubleClick(B)));
										break;
									case "immediate-click":
										w.registerIncoming("immediate-click", x, B => y(w._wrapImmediateClick(B)));
										break;
									case "immediate-double-click":
										w.registerIncoming("immediate-double-click", x, B => y(w._wrapImmediateDoubleClick(B)));
										break;
									case "hold":
										w.registerIncoming("hold", x, B => y(w._wrapHold(B)));
										break;
									case "drag":
										w.registerIncoming("drag", x, B => {
											(B = w._wrapDrag(B)) && y(B)
										});
										break;
									case "key-down":
										w.registerIncoming("key-down",
											x, B => y(w._wrapKeyDown(B)));
										break;
									case "key-up":
										w.registerIncoming("key-up", x, B => y(w._wrapKeyUp(B)));
										break;
									case "pointer-down":
										w.registerIncoming("pointer-down", x, B => y(w._wrapPointer(B, "pointer-down")));
										break;
									case "pointer-move":
										w.registerIncoming("pointer-move", x, B => y(w._wrapPointer(B, "pointer-move")));
										break;
									case "pointer-up":
										w.registerIncoming("pointer-up", x, B => y(w._wrapPointer(B, "pointer-up")));
										break;
									case "pointer-drag":
										w.registerIncoming("pointer-drag", x, B => y(w._wrapPointerDrag(B)));
										break;
									case "mouse-wheel":
										w.registerIncoming("mouse-wheel",
											x, B => y(w._wrapMouseWheel(B)));
										break;
									case "pointer-enter":
										w.registerIncoming("pointer-enter", x, B => y(w._wrapPointer(B, "pointer-enter")));
										break;
									case "pointer-leave":
										w.registerIncoming("pointer-leave", x, B => y(w._wrapPointer(B, "pointer-leave")));
										break;
									case "gamepad":
										w.registerIncoming("gamepad", x, B => {
											y(w._wrapGamepad(B))
										});
										break;
									case "focus":
										w.registerIncoming("focus", x, B => {
											y(w._wrapFocus(B))
										});
										break;
									case "blur":
										w.registerIncoming("blur", x, B => {
											y(w._wrapBlur(B))
										})
								}
								return w
							}
							b._inheritsLoose(t, n);
							var h = t.prototype;
							h._wrapFocus = function(q) {
								return {
									type: "focus",
									timestamp: q.timestamp,
									native: q.data.native,
									cancelable: q.cancelable,
									stopPropagation: () => q.stopPropagation(),
									async: u => q.async(u),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapBlur = function(q) {
								return {
									type: "blur",
									timestamp: q.timestamp,
									native: q.data.native,
									cancelable: q.cancelable,
									stopPropagation: () => q.stopPropagation(),
									async: u => q.async(u),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapClick = function(q) {
								const {
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									eventId: E
								} = q.data, {
									cancelable: z,
									timestamp: C
								} = q, D = d.createScreenPoint(w, A), J = this._getMapPoint(w, A);
								return {
									type: "click",
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									timestamp: C,
									screenPoint: D,
									mapPoint: J,
									eventId: E,
									cancelable: z,
									stopPropagation: () => q.stopPropagation(),
									async: K => q.async(K),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapDoubleClick = function(q) {
								const {
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									eventId: E
								} = q.data, {
									cancelable: z,
									timestamp: C
								} = q;
								return {
									type: "double-click",
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									timestamp: C,
									mapPoint: this._getMapPoint(w, A),
									eventId: E,
									cancelable: z,
									stopPropagation: () => q.stopPropagation(),
									async: D => q.async(D),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapImmediateClick = function(q) {
								const {
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									eventId: E
								} = q.data, z = B.pointerId, {
									cancelable: C,
									timestamp: D
								} = q;
								return {
									type: "immediate-click",
									pointerId: z,
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									timestamp: D,
									mapPoint: this._getMapPoint(w, A),
									eventId: E,
									cancelable: C,
									stopPropagation: () => q.stopPropagation(),
									async: J => q.async(J),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapImmediateDoubleClick = function(q) {
								const {
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									eventId: E
								} = q.data, z = B.pointerId, {
									cancelable: C,
									timestamp: D
								} = q;
								return {
									type: "immediate-double-click",
									pointerId: z,
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									timestamp: D,
									mapPoint: this._getMapPoint(w, A),
									eventId: E,
									cancelable: C,
									stopPropagation: () => q.stopPropagation(),
									async: J => q.async(J),
									preventDefault: () =>
										q.preventDefault()
								}
							};
							h._wrapHold = function(q) {
								const {
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B
								} = q.data, {
									cancelable: E,
									timestamp: z
								} = q;
								return {
									type: "hold",
									pointerType: u,
									button: x,
									buttons: y,
									x: w,
									y: A,
									native: B,
									timestamp: z,
									mapPoint: this._getMapPoint(w, A),
									cancelable: E,
									stopPropagation: () => q.stopPropagation(),
									async: C => q.async(C),
									preventDefault: () => q.preventDefault()
								}
							};
							h._getMapPoint = function(q, u) {
								return this.view.toMap(d.createScreenPoint(q, u), {
									exclude: []
								})
							};
							h._wrapDrag = function(q) {
								const u = q.data,
									{
										x,
										y
									} =
									u.center,
									{
										action: w,
										pointerType: A,
										button: B
									} = u;
								"start" === w && (this._latestDragStart = u);
								if (this._latestDragStart) {
									var E = u.pointer.native,
										z = u.buttons,
										{
											cancelable: C,
											timestamp: D
										} = q,
										J = {
											x: this._latestDragStart.center.x,
											y: this._latestDragStart.center.y
										};
									"end" === w && (this._latestDragStart = void 0);
									return {
										type: "drag",
										action: w,
										x,
										y,
										origin: J,
										pointerType: A,
										button: B,
										buttons: z,
										radius: u.radius,
										angle: e.rad2deg(u.angle),
										native: E,
										timestamp: D,
										cancelable: C,
										stopPropagation: () => q.stopPropagation(),
										async: K => q.async(K),
										preventDefault: () =>
											q.preventDefault()
									}
								}
							};
							h._wrapKeyDown = function(q) {
								const {
									key: u,
									repeat: x,
									native: y
								} = q.data, {
									cancelable: w,
									timestamp: A
								} = q;
								return {
									type: "key-down",
									key: u,
									repeat: x,
									native: y,
									timestamp: A,
									cancelable: w,
									stopPropagation: () => q.stopPropagation(),
									async: B => q.async(B),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapKeyUp = function(q) {
								const {
									key: u,
									native: x
								} = q.data, {
									cancelable: y,
									timestamp: w
								} = q;
								return {
									type: "key-up",
									key: u,
									native: x,
									timestamp: w,
									cancelable: y,
									stopPropagation: () => q.stopPropagation(),
									async: A => q.async(A),
									preventDefault: () =>
										q.preventDefault()
								}
							};
							h._wrapPointer = function(q, u) {
								const {
									x,
									y,
									button: w,
									buttons: A,
									native: B,
									eventId: E
								} = q.data, z = B.pointerId, C = B.pointerType, {
									cancelable: D,
									timestamp: J
								} = q;
								return {
									type: u,
									x,
									y,
									pointerId: z,
									pointerType: C,
									button: w,
									buttons: A,
									native: B,
									timestamp: J,
									eventId: E,
									cancelable: D,
									stopPropagation: () => q.stopPropagation(),
									async: K => q.async(K),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapPointerDrag = function(q) {
								const {
									x: u,
									y: x,
									buttons: y,
									native: w,
									eventId: A
								} = q.data.currentEvent, {
										button: B
									} = q.data.startEvent, E = q.data.startEvent.native.pointerId,
									z = q.data.startEvent.native.pointerType, C = q.data.action, D = {
										x: q.data.startEvent.x,
										y: q.data.startEvent.y
									}, {
										cancelable: J,
										timestamp: K
									} = q;
								return {
									type: "pointer-drag",
									x: u,
									y: x,
									pointerId: E,
									pointerType: z,
									button: B,
									buttons: y,
									action: C,
									origin: D,
									native: w,
									timestamp: K,
									eventId: A,
									cancelable: J,
									stopPropagation: () => q.stopPropagation(),
									async: H => q.async(H),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapMouseWheel = function(q) {
								const {
									cancelable: u,
									data: x,
									timestamp: y
								} = q, {
									x: w,
									y: A,
									deltaY: B,
									native: E
								} = x;
								return {
									type: "mouse-wheel",
									x: w,
									y: A,
									deltaY: B,
									native: E,
									timestamp: y,
									cancelable: u,
									stopPropagation: () => q.stopPropagation(),
									async: z => q.async(z),
									preventDefault: () => q.preventDefault()
								}
							};
							h._wrapGamepad = function(q) {
								const {
									action: u,
									state: x,
									device: y
								} = q.data, {
									cancelable: w,
									timestamp: A
								} = q, {
									buttons: B,
									axes: E
								} = x;
								return {
									type: "gamepad",
									device: y,
									timestamp: A,
									action: u,
									buttons: B,
									axes: E,
									cancelable: w,
									stopPropagation: () => q.stopPropagation(),
									async: z => q.async(z),
									preventDefault: () => q.preventDefault()
								}
							};
							return t
						}(k.InputHandler);
					Object.defineProperty(a,
						"MouseButton", {
							enumerable: !0,
							get: () => m.MouseButton
						});
					a.ViewEvents = r;
					a.eventTypes = c;
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/views/input/IViewEvents": function() {
			define(["exports"], function(a) {
				a.MouseButton = void 0;
				var b = a.MouseButton || (a.MouseButton = {});
				b[b.Left = 0] = "Left";
				b[b.Middle = 1] = "Middle";
				b[b.Right = 2] = "Right";
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/interactive/interactiveToolUtils": function() {
			define(["exports",
				"../../core/Logger", "./interfaces"
			], function(a, b, c) {
				a.areToolManipulatorsEditable = function(e) {
					return e.visible && e.getEditableFlag(c.EditableFlag.USER) && e.getEditableFlag(c.EditableFlag.MANAGER)
				};
				a.getToolCollectionHandles = function(e) {
					return [e.on("before-add", d => {
						const k = d.item;
						if (null == k || e.includes(k)) b.getLogger("esri.views.interactive.interactiveToolUtils")
							.warn("Tool is either already in the list of tools or tool is `null`. Not adding tool."), d.preventDefault();
						else k.onAdd()
					}), e.on("after-remove",
						d => {
							d = d.item;
							d.active && (d.view.activeTool = null);
							d.destroy()
						})]
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/interactive/interfaces": function() {
			define(["exports"], function(a) {
				a.EditableFlag = void 0;
				(function(b) {
					b[b.USER = 0] = "USER";
					b[b.MANAGER = 1] = "MANAGER"
				})(a.EditableFlag || (a.EditableFlag = {}));
				a.ManipulatorStateFlags = void 0;
				(function(b) {
					b[b.None = 0] = "None";
					b[b.Unfocused = 1] = "Unfocused";
					b[b.Focused = 2] = "Focused";
					b[b.Unselected = 4] = "Unselected";
					b[b.Selected =
						8] = "Selected";
					b[b.All = 15] = "All"
				})(a.ManipulatorStateFlags || (a.ManipulatorStateFlags = {}));
				a.ManipulatorStateCustomFlags = void 0;
				(function(b) {
					b[b.None = 0] = "None";
					b[b.Custom1 = 16] = "Custom1";
					b[b.Custom2 = 32] = "Custom2";
					b[b.Custom3 = 64] = "Custom3";
					b[b.Custom4 = 128] = "Custom4";
					b[b.Custom5 = 256] = "Custom5";
					b[b.Custom6 = 512] = "Custom6";
					b[b.Custom7 = 1024] = "Custom7";
					b[b.Custom8 = 2048] = "Custom8";
					b[b.Custom9 = 4096] = "Custom9";
					b[b.Custom10 = 8192] = "Custom10";
					b[b.Custom11 = 16384] = "Custom11";
					b[b.Custom12 = 32768] = "Custom12";
					b[b.All =
						65520] = "All"
				})(a.ManipulatorStateCustomFlags || (a.ManipulatorStateCustomFlags = {}));
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/interactive/ToolViewManagerManipulatorState": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/iteratorUtils ../../core/MapUtils ../../core/mathUtils ../../core/maybe ../../core/screenUtils ./interactiveToolUtils ../support/screenUtils".split(" "), function(a, b, c, e, d, k, v, m, f) {
				let g = function() {
					function l() {
						this._pointerLocations =
							new Map;
						this._hoveredManipulators = new Map;
						this._grabbedManipulators = new Map;
						this._draggedManipulators = new Map;
						this._revertToNullActiveTool = this._stopDrag = !1;
						this._cursor = null
					}
					var r = l.prototype;
					r.handleInputEvent = function(p, n) {
						var t = () => p.stopPropagation();
						switch (p.type) {
							case "pointer-move":
								"mouse" === p.pointerType && this._pointerLocations.set(p.pointerId, {
									x: p.x,
									y: p.y,
									pointerType: p.pointerType
								});
								break;
							case "drag":
								0 < this._grabbedManipulators.size && (this._stopDrag = !0);
								this._stopDrag && (p.stopPropagation(),
									"end" === p.action && (this._stopDrag = !1));
								break;
							case "pointer-down":
								if ("mouse" === p.pointerType && 0 !== p.button) break;
								t = f.createScreenPointFromEvent(p);
								var h = this._intersect(t, p.pointerType, n.forEachTool);
								if (k.isNone(h)) break;
								var q = h.manipulator,
									u = h.tool;
								!(k.isSome(q) && k.isSome(u) && q.interactive) || q.grabbable && q.grabbableForEvent(p) || !q.grabbing || q.dragging || this._ungrabManipulatorBeforeDragging(q, p, n);
								k.isSome(q) && k.isSome(u) && q.interactive && q.grabbable && q.grabbableForEvent(p) && !q.grabbing && (this._grabbedManipulators.set(p.pointerId, {
									manipulator: q,
									tool: u,
									start: t,
									pointerType: p.pointerType
								}), 1 === this._grabbedManipulators.size && k.isNone(n.activeTool) && (this._revertToNullActiveTool = !0, n.setActiveTool(h.tool)), q.grabbing = !0, q.events.emit("grab-changed", {
									action: "start",
									pointerType: p.pointerType,
									screenPoint: t
								}), p.stopPropagation());
								break;
							case "pointer-up":
								this._draggedManipulators.has(p.pointerId) || this._handlePointerEnd(p, n);
								break;
							case "pointer-drag":
								if ("mouse" === p.pointerType && 0 !== p.button) break;
								u = this._grabbedManipulators.get(p.pointerId);
								t = k.applySome(u, ({
									manipulator: B
								}) => B);
								h = k.applySome(u, ({
									tool: B
								}) => B);
								if (k.isNone(t) || k.isNone(h)) break;
								q = f.createScreenPointFromEvent(p);
								q.x = d.clamp(q.x, 0, n.view.width);
								q.y = d.clamp(q.y, 0, n.view.height);
								u = k.unwrap(u)
									.start;
								const x = this._draggedManipulators.get(p.pointerId);
								switch (p.action) {
									case "start":
									case "update":
										if ("update" === p.action || 1 === this._grabbedManipulators.size) t.dragging = !0, x ? t.events.emit("drag", {
											action: "update",
											start: u,
											screenPoint: q
										}) : t.events.emit("drag", {
											action: "start",
											start: u,
											screenPoint: q,
											pointerType: p.pointerType
										}), this._draggedManipulators.set(p.pointerId, {
											tool: h,
											manipulator: t,
											start: u
										});
										break;
									case "end":
										t.dragging = !1, x && t.events.emit("drag", {
											action: "end",
											start: u,
											screenPoint: q
										}), this._draggedManipulators.delete(p.pointerId), this._handlePointerEnd(p, n)
								}
								p.stopPropagation();
								break;
							case "immediate-click":
								h = f.createScreenPointFromEvent(p);
								const y = this._intersect(h, p.pointerType, n.forEachTool);
								p.native.shiftKey || n.forEachTool(B => {
									if ((!k.isSome(y) || y.tool !== B || B.automaticManipulatorSelection) &&
										B.manipulators) {
										let E = !1;
										B.manipulators.forEach(({
											manipulator: z
										}) => {
											z.selected && (z.selected = !1, E = !0)
										});
										if (E && B.onManipulatorSelectionChanged) B.onManipulatorSelectionChanged()
									}
								});
								if (k.isNone(y)) break;
								const {
									manipulator: w,
									tool: A
								} = y;
								if (!w.interactive) break;
								if (w.selectable && A.automaticManipulatorSelection && (w.selected = !w.selected, A.onManipulatorSelectionChanged)) A.onManipulatorSelectionChanged();
								w.events.emit("immediate-click", {
									screenPoint: h,
									button: p.button,
									pointerType: p.pointerType,
									shiftKey: p.native.shiftKey,
									stopPropagation: t
								});
								break;
							case "click":
								t = f.createScreenPointFromEvent(p);
								h = this._intersect(t, p.pointerType, n.forEachTool);
								h = k.isSome(h) ? h.manipulator : null;
								if (k.isNone(h) || !h.interactive) break;
								h.events.emit(p.type, {
									screenPoint: t,
									button: p.button,
									pointerType: p.pointerType,
									shiftKey: p.native.shiftKey
								});
								p.stopPropagation();
								break;
							case "double-click":
								h = f.createScreenPointFromEvent(p);
								q = this._intersect(h, p.pointerType, n.forEachTool);
								q = k.isSome(q) ? q.manipulator : null;
								if (k.isNone(q) || !q.interactive) break;
								q.events.emit("double-click", {
									screenPoint: h,
									button: p.button,
									pointerType: p.pointerType,
									shiftKey: p.native.shiftKey,
									stopPropagation: t
								});
								break;
							case "immediate-double-click":
								h = f.createScreenPointFromEvent(p), q = this._intersect(h, p.pointerType, n.forEachTool), q = k.isSome(q) ? q.manipulator : null, !k.isNone(q) && q.interactive && q.events.emit("immediate-double-click", {
									screenPoint: h,
									button: p.button,
									pointerType: p.pointerType,
									shiftKey: p.native.shiftKey,
									stopPropagation: t
								})
						}
						this._onFocusChange(n.forEachTool)
					};
					r._ungrabManipulatorBeforeDragging = function(p,
						n, t) {
						p.grabbing = !1;
						p.events.emit("grab-changed", {
							action: "end",
							pointerType: n.pointerType,
							screenPoint: f.createScreenPointFromEvent(n)
						});
						this._grabbedManipulators.forEach(({
							manipulator: h
						}, q) => {
							h === p && this._grabbedManipulators.delete(q)
						});
						this._afterManipulatorUngrab(t.setActiveTool)
					};
					r._handlePointerEnd = function(p, n) {
						const t = k.applySome(this._grabbedManipulators.get(p.pointerId), ({
							manipulator: h
						}) => h);
						!k.isNone(t) && t.grabbing && (t.grabbing = !1, t.events.emit("grab-changed", {
							action: "end",
							pointerType: p.pointerType,
							screenPoint: f.createScreenPointFromEvent(p)
						}), this._grabbedManipulators.delete(p.pointerId), this._afterManipulatorUngrab(n.setActiveTool))
					};
					r._cursorFromMap = function(p) {
						let n = null;
						e.someMap(p, ({
							manipulator: t
						}) => {
							if (!k.isNone(t) && t.interactive) {
								if (t.grabbing && t.grabCursor) return n = t.grabCursor, !0;
								if (t.cursor) return n = t.cursor, !0
							}
							return !1
						});
						return n
					};
					r._onFocusChange = function(p) {
						this._updateCursor();
						this._updateFocusedManipulatorTools(p)
					};
					r._updateCursor = function() {
						this._cursor = 0 < this._grabbedManipulators.size ?
							this._cursorFromMap(this._grabbedManipulators) || "grabbing" : 0 < this._hoveredManipulators.size ? this._cursorFromMap(this._hoveredManipulators) || "pointer" : null
					};
					r._updateFocusedManipulatorTools = function(p) {
						const n = new Set,
							t = new Set;
						this._grabbedManipulators.forEach(({
							tool: h
						}) => {
							n.add(h)
						});
						this._hoveredManipulators.forEach(({
							tool: h
						}) => {
							t.add(h)
						});
						p(h => {
							h.hasGrabbedManipulators = n.has(h);
							h.hasHoveredManipulators = t.has(h);
							var q = this._grabbedManipulators.values();
							q = c.find(q, ({
								tool: u
							}) => u === h);
							h.firstGrabbedManipulator =
								k.isSome(q) ? q.manipulator : null
						})
					};
					r.clearPointers = function(p, {
						forEachTool: n,
						setActiveTool: t
					}, h = !0, q) {
						const u = (x, y) => x === p && (k.isNone(q) || q === y);
						this._grabbedManipulators.forEach(({
							tool: x,
							manipulator: y,
							pointerType: w
						}, A) => {
							u(x, y) && (this._grabbedManipulators.delete(A), y.grabbing = !1, y.events.emit("grab-changed", {
								action: "end",
								screenPoint: null,
								pointerType: w
							}))
						});
						this._draggedManipulators.forEach(({
							tool: x,
							manipulator: y
						}, w) => {
							u(x, y) && (this._draggedManipulators.delete(w), y.dragging = !1, y.events.emit("drag", {
								action: "cancel"
							}))
						});
						h && this._hoveredManipulators.forEach(({
							tool: x,
							manipulator: y
						}, w) => {
							u(x, y) && (this._hoveredManipulators.delete(w), y.hovering = !1)
						});
						this._afterManipulatorUngrab(t);
						this._onFocusChange(n)
					};
					r._intersect = function(p, n, t) {
						let h = null;
						t(q => {
							if (null == q.manipulators || !m.areToolManipulatorsEditable(q)) return !1;
							const u = q.manipulators.intersect(p, n);
							if (k.isNone(u)) return !1;
							h = {
								tool: q,
								manipulator: u
							};
							return !0
						});
						return h
					};
					r.updateHoveredStateFromKnownPointers = function(p) {
						this._pointerLocations.forEach((n,
							t) => {
							this._updateHoveredStateForPointerAtScreenPosition(v.createScreenPoint(n.x, n.y), t, n.pointerType, p)
						})
					};
					r.handleHoverEvent = function(p, n) {
						"pointer-up" !== p.type && "immediate-click" !== p.type && "pointer-move" !== p.type || "mouse" !== p.pointerType || this._updateHoveredStateForPointerAtScreenPosition(f.createScreenPointFromEvent(p), p.pointerId, p.pointerType, n)
					};
					r._updateHoveredStateForPointerAtScreenPosition = function(p, n, t, h) {
						p = this._intersect(p, t, h);
						t = k.applySome(this._hoveredManipulators.get(n), ({
								manipulator: q
							}) =>
							q);
						k.isSome(p) && !p.manipulator.interactive && (p = null);
						k.isSome(p) && t === p.manipulator || (k.isSome(t) && (t.hovering = !1), k.isSome(p) ? (p.manipulator.hovering = !0, this._hoveredManipulators.set(n, p)) : this._hoveredManipulators.delete(n), this._onFocusChange(h))
					};
					r._afterManipulatorUngrab = function(p) {
						0 === this._grabbedManipulators.size && this._revertToNullActiveTool && (p(null), this._revertToNullActiveTool = !1)
					};
					b._createClass(l, [{
						key: "cursor",
						get: function() {
							return this._cursor
						}
					}]);
					return l
				}();
				a.ToolViewManagerManipulatorState =
					g;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/support/screenUtils": function() {
			define(["exports", "../../core/has", "../../core/screenUtils"], function(a, b, c) {
				function e(k) {
					return c.createScreenPoint(k.x, k.y)
				}

				function d(k, v) {
					k = (k instanceof HTMLElement ? k : k.surface)
						.getBoundingClientRect();
					return c.createScreenPoint(v.clientX - k.left, v.clientY - k.top)
				}
				a.createScreenPointArrayFromEvent = function(k) {
					return c.createScreenPointArray(k.x, k.y)
				};
				a.createScreenPointFromEvent =
					e;
				a.createScreenPointFromNativeEvent = d;
				a.createScreenPointFromSupportedEvent = function(k, v) {
					return v instanceof Event ? d(k, v) : e(v)
				};
				a.isSupportedScreenPointEvent = function(k) {
					if (k instanceof Event) return !0;
					if ("object" === typeof k && "type" in k) switch (k.type) {
						case "click":
						case "double-click":
						case "pointer-down":
						case "pointer-drag":
						case "pointer-enter":
						case "pointer-leave":
						case "pointer-up":
						case "pointer-move":
						case "immediate-click":
						case "immediate-double-click":
						case "hold":
						case "drag":
						case "mouse-wheel":
							return !0
					}
					return !1
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/input/Input": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./gamepad/GamepadSettings".split(" "), function(a, b, c, e, d, k, v, m) {
				c = function(f) {
					function g() {
						var l = f.apply(this, arguments) || this;
						l.gamepad =
							new m;
						return l
					}
					a._inheritsLoose(g, f);
					return g
				}(c);
				b.__decorate([e.property({
					readOnly: !0
				})], c.prototype, "gamepad", void 0);
				return c = b.__decorate([v.subclass("esri.views.input.Input")], c)
			})
		},
		"esri/views/input/gamepad/GamepadSettings": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/Collection ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ./GamepadInputDevice".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					c = function(g) {
						function l(...r) {
							r = g.call(this, ...r) || this;
							r.devices = new e;
							r.enabledFocusMode = "document";
							return r
						}
						a._inheritsLoose(l, g);
						return l
					}(c);
					b.__decorate([d.property({
						type: e.ofType(f),
						readOnly: !0
					})], c.prototype, "devices", void 0);
					b.__decorate([d.property({
						type: ["document", "view", "none"]
					})], c.prototype, "enabledFocusMode", void 0);
					return c = b.__decorate([m.subclass("esri.views.input.gamepad.GamepadSettings")], c)
				})
		},
		"esri/views/input/gamepad/GamepadInputDevice": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v) {
					c = function(g) {
						function l(r) {
							var p = g.call(this) || this;
							p.nativeIndex = null;
							p._detectedDeviceType = "unknown";
							"standard" === r.mapping ? p._detectedDeviceType = "standard" : m.test(r.id) ? p._detectedDeviceType = "spacemouse" : p._detectedDeviceType = "unknown";
							p.nativeIndex = r.index;
							return p
						}
						a._inheritsLoose(l, g);
						a._createClass(l, [{
								key: "native",
								get: function() {
									const r = navigator.getGamepads ? navigator.getGamepads() : [];
									return null != this.nativeIndex && this.nativeIndex < r.length ? r[this.nativeIndex] : null
								}
							},
							{
								key: "deviceType",
								get: function() {
									return this._detectedDeviceType
								}
							}, {
								key: "axisThreshold",
								get: function() {
									return f[this.deviceType]
								}
							}
						]);
						return l
					}(c);
					b.__decorate([e.property({
						nonNullable: !0,
						readOnly: !0
					})], c.prototype, "nativeIndex", void 0);
					b.__decorate([e.property({
						type: String,
						readOnly: !0
					})], c.prototype, "deviceType", null);
					b.__decorate([e.property({
						type: Number,
						readOnly: !0
					})], c.prototype, "axisThreshold", null);
					c = b.__decorate([v.subclass("esri.views.input.gamepad.GamepadInputDevice")], c);
					const m = RegExp("^(3dconnexion|space(mouse|navigator|pilot|explorer))",
							"i"),
						f = {
							standard: .15,
							spacemouse: .025,
							unknown: 0
						};
					return c
				})
		},
		"esri/views/navigation/Navigation": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ./gamepad/GamepadSettings".split(" "), function(a, b, c, e, d, k, v, m) {
				c = function(f) {
					function g(l) {
						l = f.call(this, l) || this;
						l.browserTouchPanEnabled = !0;
						l.gamepad =
							new m;
						l.momentumEnabled = !0;
						l.mouseWheelZoomEnabled = !0;
						return l
					}
					a._inheritsLoose(g, f);
					return g
				}(c);
				b.__decorate([e.property({
					type: Boolean
				})], c.prototype, "browserTouchPanEnabled", void 0);
				b.__decorate([e.property({
					type: m,
					nonNullable: !0
				})], c.prototype, "gamepad", void 0);
				b.__decorate([e.property({
					type: Boolean
				})], c.prototype, "momentumEnabled", void 0);
				b.__decorate([e.property({
					type: Boolean
				})], c.prototype, "mouseWheelZoomEnabled", void 0);
				return c = b.__decorate([v.subclass("esri.views.navigation.Navigation")],
					c)
			})
		},
		"esri/views/navigation/gamepad/GamepadSettings": function() {
			define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/Accessor ../../../core/accessorSupport/decorators/property ../../../core/arrayUtils ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../input/gamepad/GamepadInputDevice".split(" "), function(a, b, c, e, d, k, v, m) {
				c = function(f) {
					function g(l) {
						l = f.call(this, l) || this;
						l.enabled = !0;
						l.device = null;
						l.mode = "pan";
						l.tiltDirection =
							"forward-down";
						l.velocityFactor = 1;
						return l
					}
					a._inheritsLoose(g, f);
					return g
				}(c);
				b.__decorate([e.property({
					type: Boolean,
					nonNullable: !0
				})], c.prototype, "enabled", void 0);
				b.__decorate([e.property({
					type: m
				})], c.prototype, "device", void 0);
				b.__decorate([e.property({
					type: ["pan", "zoom"],
					nonNullable: !0
				})], c.prototype, "mode", void 0);
				b.__decorate([e.property({
					type: ["forward-down", "forward-up"],
					nonNullable: !0
				})], c.prototype, "tiltDirection", void 0);
				b.__decorate([e.property({
						type: Number,
						nonNullable: !0
					})], c.prototype,
					"velocityFactor", void 0);
				return c = b.__decorate([v.subclass("esri.views.navigation.gamepad.GamepadSettings")], c)
			})
		},
		"esri/views/support/DefaultsFromMap": function() {
			define("exports ../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/asyncUtils ../../core/maybe ../../core/promiseUtils ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass ../../geometry/support/heightModelInfoUtils ../ViewingMode ./projectionUtils".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n) {
					a.DefaultsFromMap = function(t) {
						function h(u) {
							u = t.call(this, u) || this;
							u.required = {
								tileInfo: !1,
								heightModelInfo: !1,
								extent: !1
							};
							u.defaultSpatialReference = null;
							u.userSpatialReference = null;
							u.sourcePreloadCount = 10;
							u.priorityCollection = null;
							u.requiresExtentInSpatialReference = !0;
							u.suspended = !1;
							u._projectExtentTask = {
								task: null,
								input: null,
								output: null,
								spatialReference: null
							};
							return u
						}
						b._inheritsLoose(h, t);
						var q = h.prototype;
						q.destroy = function() {
							this._projectExtentTask.task && (this._projectExtentTask.task =
								k.abortMaybe(this._projectExtentTask.task));
							this._set("map", null)
						};
						q._narrowDownSpatialReferenceCandidates = function(u, x) {
							if (k.isNone(u)) return x;
							const y = [];
							for (const A of u)
								for (const B of x)
									if (A.spatialReference.equals(B.spatialReference)) {
										u = A.viewingMode;
										var w = B.viewingMode;
										u = k.isSome(u) ? k.isSome(w) ? u === w ? u : !1 : u : w;
										if (!1 !== u) {
											y.push({
												spatialReference: A.spatialReference,
												viewingMode: u
											});
											break
										}
									} return 0 < y.length ? y : null
						};
						q._pickSpatialReferenceCandidate = function(u) {
							const x = this.defaultSpatialReference;
							if (k.isNone(u) || 1 > u.length) return k.isSome(x) ? {
								spatialReference: x,
								viewingMode: null
							} : null;
							k.isSome(x) && 1 < u.length && u.some(({
								spatialReference: y
							}) => y.equals(x)) && (u = u.filter(({
								spatialReference: y
							}) => y.equals(x)));
							1 < u.length && u.some(({
								viewingMode: y
							}) => y !== p.ViewingMode.Local) && (u = u.filter(({
								viewingMode: y
							}) => y !== p.ViewingMode.Local));
							return u[0]
						};
						q._getSupportedSpatialReferences = function(u) {
							var x = "supportedSpatialReferences" in u && u.supportedSpatialReferences || (u.spatialReference ? [u.spatialReference] : []);
							if (0 === x.length) return [];
							const y = [];
							for (const w of x)
								if (x = this.getSpatialReferenceSupport({
									spatialReference: w,
									layer: u
								}), k.isSome(x)) {
									x = k.isSome(x.constraints) ? x.constraints : [{
										spatialReference: w,
										viewingMode: null
									}];
									for (const {
										spatialReference: A,
										viewingMode: B
									} of x)(!this.requiresExtentInSpatialReference || k.isNone(this.userSpatialReference) || A.equals(this.userSpatialReference)) && y.push({
										spatialReference: A,
										viewingMode: B
									})
								} return y
						};
						q._pickExtentCandidate = function(u) {
							const x = this.spatialReference;
							return u.find(({
									extent: y
								}) =>
								x.equals(y.spatialReference)) || u[0]
						};
						q._collectLayers = function(u) {
							if ("loaded" !== this._loadMaybe(this.map ? .())) return {
								layers: [],
								updating: !0
							};
							const x = {
								layers: [],
								preloading: -1,
								updating: !1
							};
							for (const y of u)
								if (this._collectCollection(y, x), x.preloading === this.sourcePreloadCount) break;
							return {
								layers: x.layers,
								updating: x.updating
							}
						};
						q._collectCollection = function(u, x) {
							if (u.layers) {
								switch (this._loadMaybe(u.parent)) {
									case "loading":
										x.updating = !0;
										++x.preloading;
										return;
									case "failed":
										return
								}
								for (const y of u.layers) {
									switch (this._loadMaybe(y)) {
										case "failed":
											continue;
										case "loading":
											x.updating = !0;
											++x.preloading;
											break;
										case "loaded":
											x.updating || x.layers.push(y), "layers" in y && this._collectCollection({
												layers: y.layers
											}, x)
									}
									if (x.preloading === this.sourcePreloadCount) break
								}
							}
						};
						q._loadMaybe = function(u) {
							return u && "loadStatus" in u ? "not-loaded" === u.loadStatus ? (u.load()
								.catch(() => {}), "loading") : u.loadStatus : "loaded"
						};
						b._createClass(h, [{
								key: "ready",
								get: function() {
									return !this._spatialReferenceTask.updating && !this._tileInfoTask.updating && !this._extentTask.updating
								}
							}, {
								key: "heightModelInfoReady",
								get: function() {
									return !this._heightModelInfoTask.updating
								}
							}, {
								key: "spatialReference",
								get: function() {
									return k.isSome(this.userSpatialReference) ? this.userSpatialReference : k.unwrap(this._spatialReferenceTask.spatialReference)
								}
							}, {
								key: "extent",
								get: function() {
									return k.unwrap(this._extentTask.extent)
								}
							}, {
								key: "heightModelInfo",
								get: function() {
									return k.unwrap(this._heightModelInfoTask.heightModelInfo)
								}
							}, {
								key: "vcsWkid",
								get: function() {
									return k.unwrap(this._heightModelInfoTask.vcsWkid)
								}
							}, {
								key: "latestVcsWkid",
								get: function() {
									return k.unwrap(this._heightModelInfoTask.latestVcsWkid)
								}
							},
							{
								key: "viewingMode",
								get: function() {
									return k.isNone(this.userSpatialReference) || this.userSpatialReference.equals(k.unwrap(this._spatialReferenceTask.spatialReference)) ? k.unwrap(this._spatialReferenceTask.viewingMode) : null
								}
							}, {
								key: "tileInfo",
								get: function() {
									return k.unwrap(this._tileInfoTask.tileInfo)
								}
							}, {
								key: "mapCollections",
								get: function() {
									const u = this.map ? .(),
										x = [];
									k.isSome(this.priorityCollection) && x.push(this.priorityCollection);
									x.push({
										parent: u ? .basemap,
										layers: u ? .basemap ? .baseLayers
									}, {
										layers: u ? .layers
									}, {
										parent: u ? .ground,
										layers: u ? .ground ? .layers
									}, {
										parent: u ? .basemap,
										layers: u ? .basemap ? .referenceLayers
									});
									return x
								}
							}, {
								key: "_allLayers",
								get: function() {
									return this._collectLayers(this.mapCollections)
								}
							}, {
								key: "_spatialReferenceTask",
								get: function() {
									if (this.suspended) return this._get("_spatialReferenceTask") ? ? {
										updating: !1
									};
									const {
										layers: u,
										updating: x
									} = this._allLayers;
									var y = null;
									for (const A of u) {
										var w = this._getSupportedSpatialReferences(A);
										0 < w.length && (w = this._narrowDownSpatialReferenceCandidates(y, w), k.isSome(w) &&
											(y = w));
										if (k.isSome(y) && 1 === y.length) break
									}
									if (x && (k.isNone(y) || 1 !== y.length)) return {
										updating: !0
									};
									y = this._pickSpatialReferenceCandidate(y);
									return {
										spatialReference: k.isSome(y) ? y.spatialReference : null,
										viewingMode: k.isSome(y) ? y.viewingMode : null,
										updating: !1
									}
								}
							}, {
								key: "_tileInfoTask",
								get: function() {
									if (!this.required.tileInfo) return this._get("_tileInfoTask") ? ? {
										updating: !1
									};
									if (!this.spatialReference) return {
										updating: this._spatialReferenceTask.updating
									};
									const {
										layers: u,
										updating: x
									} = this._collectLayers([{
										parent: this.map ? .() ? .basemap,
										layers: this.map ? .() ? .basemap ? .baseLayers
									}, {
										layers: this.map ? .() ? .layers
									}]);
									if (u && 0 < u.length && "tileInfo" in u[0]) {
										const y = u[0].tileInfo;
										return {
											tileInfo: y && y.spatialReference.equals(this.spatialReference) ? y : null,
											updating: !1
										}
									}
									return {
										updating: x
									}
								}
							}, {
								key: "_heightModelInfoTask",
								get: function() {
									if (!this.required.heightModelInfo || this.suspended && this._get("_heightModelInfoTask") ? .heightModelInfo) return this._get("_heightModelInfoTask") ? ? {
										updating: !1
									};
									const {
										layers: u,
										updating: x
									} = this._allLayers;
									for (const y of u)
										if (r.supportsHeightModelInfo(y)) {
											const w =
												r.deriveHeightModelInfoFromLayer(y);
											if (w) return {
												heightModelInfo: w,
												vcsWkid: y.spatialReference ? .vcsWkid,
												latestVcsWkid: y.spatialReference ? .latestVcsWkid,
												updating: !1
											}
										} return {
										updating: x
									}
								}
							}, {
								key: "_extentCandidatesTask",
								get: function() {
									if (this.suspended || !this.required.extent) return this._get("_extentCandidatesTask") ? ? {
										updating: !1
									};
									if (!this.spatialReference) return {
										updating: this._spatialReferenceTask.updating
									};
									var u = this._allLayers;
									const x = u.updating,
										y = [];
									for (const A of u.layers) {
										u = "fullExtents" in A && A.fullExtents ||
											(k.isSome(A.fullExtent) ? [A.fullExtent] : []);
										var w = this.requiresExtentInSpatialReference ? null : u[0];
										if (w = u.find(B => B.spatialReference.equals(this.spatialReference)) ? ? w) return {
											candidates: [{
												extent: w,
												layer: A
											}],
											updating: !1
										};
										if (0 < this._getSupportedSpatialReferences(A)
											.length)
											for (const B of u) y.push({
												extent: B,
												layer: A
											})
									}
									return {
										candidates: y,
										updating: x
									}
								}
							}, {
								key: "_extentTask",
								get: function() {
									var u = this;
									const {
										candidates: x,
										updating: y
									} = this._extentCandidatesTask;
									if (y) return {
										updating: y
									};
									if (k.isNone(x) || 0 === x.length) return {
										updating: !1
									};
									if (!this.spatialReference) return {
										updating: this._spatialReferenceTask.updating
									};
									const w = this._pickExtentCandidate(x),
										A = this.spatialReference;
									if (w.extent.equals(this._projectExtentTask.input) && A.equals(this._projectExtentTask.spatialReference)) return {
										extent: this._projectExtentTask.output,
										updating: k.isSome(this._projectExtentTask.task) && !this._projectExtentTask.task.finished
									};
									k.isSome(this._projectExtentTask.task) && (this._projectExtentTask.task = k.abortMaybe(this._projectExtentTask.task));
									this._projectExtentTask = {
										input: w.extent.clone(),
										output: null,
										spatialReference: A.clone(),
										task: d.createTask(function() {
											var B = b._asyncToGenerator(function*(E) {
												try {
													const z = yield n.projectWithEngineOrService(w.extent, A, w.layer.portalItem, E);
													u._projectExtentTask = {
														...u._projectExtentTask,
														task: null,
														output: z
													}
												} catch (z) {
													v.isAborted(E) || (u._projectExtentTask = {
														...u._projectExtentTask,
														task: null
													})
												}
											});
											return function(E) {
												return B.apply(this, arguments)
											}
										}())
									};
									return {
										updating: !0
									}
								}
							}
						]);
						return h
					}(e);
					c.__decorate([m.property()], a.DefaultsFromMap.prototype,
						"required", void 0);
					c.__decorate([m.property({
						constructOnly: !0
					})], a.DefaultsFromMap.prototype, "map", void 0);
					c.__decorate([m.property({
						constructOnly: !0
					})], a.DefaultsFromMap.prototype, "getSpatialReferenceSupport", void 0);
					c.__decorate([m.property()], a.DefaultsFromMap.prototype, "defaultSpatialReference", void 0);
					c.__decorate([m.property()], a.DefaultsFromMap.prototype, "userSpatialReference", void 0);
					c.__decorate([m.property()], a.DefaultsFromMap.prototype, "sourcePreloadCount", void 0);
					c.__decorate([m.property()],
						a.DefaultsFromMap.prototype, "priorityCollection", void 0);
					c.__decorate([m.property()], a.DefaultsFromMap.prototype, "requiresExtentInSpatialReference", void 0);
					c.__decorate([m.property()], a.DefaultsFromMap.prototype, "suspended", void 0);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "ready", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "heightModelInfoReady", null);
					c.__decorate([m.property({
							readOnly: !0
						})], a.DefaultsFromMap.prototype, "spatialReference",
						null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "extent", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "heightModelInfo", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "vcsWkid", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "latestVcsWkid", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "viewingMode", null);
					c.__decorate([m.property({
							readOnly: !0
						})], a.DefaultsFromMap.prototype,
						"tileInfo", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "mapCollections", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "_allLayers", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "_spatialReferenceTask", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "_tileInfoTask", null);
					c.__decorate([m.property({
						readOnly: !0
					})], a.DefaultsFromMap.prototype, "_heightModelInfoTask", null);
					c.__decorate([m.property({
							readOnly: !0
						})],
						a.DefaultsFromMap.prototype, "_extentCandidatesTask", null);
					c.__decorate([m.property()], a.DefaultsFromMap.prototype, "_extentTask", null);
					c.__decorate([m.property()], a.DefaultsFromMap.prototype, "_projectExtentTask", void 0);
					a.DefaultsFromMap = c.__decorate([l.subclass("esri.views.support.DefaultsFromMap")], a.DefaultsFromMap);
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/geometry/support/heightModelInfoUtils": function() {
			define("exports ../../core/has ../../core/Error ../../core/maybe ../HeightModelInfo ../../layers/support/arcgisLayerUrl".split(" "),
				function(a, b, c, e, d, k) {
					function v(t, h, q) {
						if (!m(t) || !m(h)) return p.Unsupported;
						if (null == t || null == h) return p.Ok;
						if (!q && t.heightUnit !== h.heightUnit) return p.Units;
						if (t.heightModel !== h.heightModel) return p.HeightModel;
						switch (t.heightModel) {
							case "gravity-related-height":
								return p.Ok;
							case "ellipsoidal":
								return t.vertCRS === h.vertCRS ? p.Ok : p.CRS;
							default:
								return p.Unsupported
						}
					}

					function m(t) {
						return null == t || null != t.heightModel && null != t.heightUnit
					}

					function f(t) {
						const h = t.url ? k.parse(t.url) : void 0;
						return (null != t.spatialReference ? .vcsWkid ||
							!e.isSome(h) || "ImageServer" !== h.serverType) && "heightModelInfo" in t && t.heightModelInfo ? t.heightModelInfo : l(t) ? d.deriveUnitFromSR(n, t.spatialReference) : null
					}

					function g(t) {
						if ("unknown" === t.type || !("capabilities" in t)) return !1;
						switch (t.type) {
							case "csv":
							case "feature":
							case "geojson":
							case "subtype-group":
							case "ogc-feature":
							case "oriented-imagery":
							case "wfs":
								return !0;
							case "imagery":
							case "map-image":
							case "map-notes":
							case "tile":
							case "vector-tile":
							case "scene":
							case null:
								return !1;
							default:
								return !1
						}
					}

					function l(t) {
						return g(t) ?
							!!(t.capabilities && t.capabilities.data && t.capabilities.data.supportsZ) : r(t)
					}

					function r(t) {
						switch (t.type) {
							case "building-scene":
							case "elevation":
							case "integrated-mesh":
							case "point-cloud":
							case "scene":
							case "voxel":
								return !0
						}
						return !1
					}
					var p;
					(function(t) {
						t[t.Ok = 0] = "Ok";
						t[t.Units = 1] = "Units";
						t[t.HeightModel = 2] = "HeightModel";
						t[t.CRS = 3] = "CRS";
						t[t.Unsupported = 4] = "Unsupported"
					})(p || (p = {}));
					const n = new d({
						heightModel: "gravity-related-height"
					});
					a.deriveHeightModelInfoFromLayer = f;
					a.rejectLayerError = function(t, h,
						q) {
						const u = f(t),
							x = v(u, h, q);
						if (u) {
							const y = d.deriveUnitFromSR(u, t.spatialReference)
								.heightUnit;
							if (!q && y !== u.heightUnit) return h = new c("layerview:unmatched-height-unit", `The vertical units of the layer must match the horizontal units (${y})`, {
								horizontalUnit: y
							}), new c("layerview:unsupported-height-model-info", "The vertical coordinate system of the layer is not supported", {
								heightModelInfo: u,
								error: h
							})
						}
						if (!("heightModelInfo" in t && null != t.heightModelInfo || null != t.spatialReference) && l(t) || x === p.Unsupported) return new c("layerview:unsupported-height-model-info",
							"The vertical coordinate system of the layer is not supported", {
								heightModelInfo: u
							});
						switch (x) {
							case p.Units:
								return t = u ? .heightUnit || "unknown", q = h ? .heightUnit || "unknown", t = new c("layerview:incompatible-height-unit", `The vertical units of the layer (${t}) must match the vertical units of the scene (${q})`, {
									layerUnit: t,
									sceneUnit: q
								}), new c("layerview:incompatible-height-model-info", "The vertical coordinate system of the layer is incompatible with the scene", {
									layerHeightModelInfo: u,
									sceneHeightModelInfo: h,
									error: t
								});
							case p.HeightModel:
								return t = u ? .heightModel || "unknown", q = h ? .heightModel || "unknown", t = new c("layerview:incompatible-height-model", `The height model of the layer (${t}) must match the height model of the scene (${q})`, {
									layerHeightModel: t,
									sceneHeightModel: q
								}), new c("layerview:incompatible-height-model-info", "The vertical coordinate system of the layer is incompatible with the scene", {
									layerHeightModelInfo: u,
									sceneHeightModelInfo: h,
									error: t
								});
							case p.CRS:
								return t = u ? .vertCRS || "unknown", q = h ? .vertCRS ||
									"unknown", t = new c("layerview:incompatible-vertical-datum", `The vertical datum of the layer (${t}) must match the vertical datum of the scene (${q})`, {
										layerDatum: t,
										sceneDatum: q
									}), new c("layerview:incompatible-height-model-info", "The vertical coordinate system of the layer is incompatible with the scene", {
										layerHeightModelInfo: u,
										sceneHeightModelInfo: h,
										error: t
									})
						}
						return null
					};
					a.supportsHeightModelInfo = function(t) {
						return null != t.layers || r(t) || g(t) || "heightModelInfo" in t
					};
					a.validateWebSceneError = function(t,
						h) {
						if (!t) return null;
						if (!m(t)) return new c("webscene:unsupported-height-model-info", "The vertical coordinate system of the scene is not supported", {
							heightModelInfo: t
						});
						const q = t.heightUnit;
						t = d.deriveUnitFromSR(t, h)
							.heightUnit;
						return q !== t ? new c("webscene:incompatible-height-unit", `The vertical units of the scene (${q}) must match the horizontal units of the scene (${t})`, {
							verticalUnit: q,
							horizontalUnit: t
						}) : null
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/views/ViewingMode": function() {
			define(["exports"], function(a) {
				a.ViewingMode = void 0;
				(function(b) {
					b[b.Global = 1] = "Global";
					b[b.Local = 2] = "Local"
				})(a.ViewingMode || (a.ViewingMode = {}));
				a.stringFromViewingMode = function(b) {
					return b === a.ViewingMode.Global ? "global" : "local"
				};
				a.viewingModeFromString = function(b) {
					return "global" === b ? a.ViewingMode.Global : a.ViewingMode.Local
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/support/projectionUtils": function() {
			define(["require",
				"exports", "../../chunks/_rollupPluginBabelHelpers", "../../core/promiseUtils", "../../geometry/projection"
			], function(a, b, c, e, d) {
				function k(r) {
					return v.apply(this, arguments)
				}

				function v() {
					v = c._asyncToGenerator(function*(r) {
						g || (g = (new Promise((p, n) => a(["../../portal/support/geometryServiceUtils"], p, n)))
							.then(p => l = p));
						yield g;
						e.throwIfAborted(r)
					});
					return v.apply(this, arguments)
				}

				function m(r, p, n, t) {
					return f.apply(this, arguments)
				}

				function f() {
					f = c._asyncToGenerator(function*(r, p, n, t) {
						if (!r) return null;
						const h =
							r.spatialReference;
						if (d.isLoaded() || d.canProjectWithoutEngine(h, p)) return d.project(r, p);
						if (l) return l.projectGeometry(r, p, n, t);
						yield Promise.race([k(t), d.load(t)]);
						return m(r, p, n, t)
					});
					return f.apply(this, arguments)
				}
				let g = null,
					l;
				b.projectWithEngineOrService = m;
				Object.defineProperties(b, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/views/ViewAnimation": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../core/Error ../core/Promise ../core/promiseUtils ../core/accessorSupport/decorators/property ../core/arrayUtils ../core/accessorSupport/ensureType ../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f) {
					e = function(g) {
						function l(p) {
							p = g.call(this, p) || this;
							p.state = "running";
							p.target = null;
							p._dfd = null;
							return p
						}
						a._inheritsLoose(l, g);
						var r = l.prototype;
						r.initialize = function() {
							this.addResolvingPromise(new Promise((p, n) => this._dfd = {
								resolve: p,
								reject: n
							}))
						};
						r.stop = function() {
							"stopped" !== this.state && "finished" !== this.state && (this._set("state", "stopped"), this._dfd ? .reject(new c("ViewAnimation stopped")))
						};
						r.finish = function() {
							"stopped" !== this.state && "finished" !== this.state && (this._set("state",
								"finished"), this._dfd ? .resolve())
						};
						r.update = function(p, n) {
							n || (n = d.isPromiseLike(p) ? "waiting-for-target" : "running");
							this._set("target", p);
							this._set("state", n)
						};
						a._createClass(l, [{
							key: "done",
							get: function() {
								return "finished" === this.state || "stopped" === this.state
							}
						}]);
						return l
					}(e.EsriPromise);
					b.__decorate([k.property({
						readOnly: !0
					})], e.prototype, "done", null);
					b.__decorate([k.property({
						readOnly: !0,
						type: String
					})], e.prototype, "state", void 0);
					b.__decorate([k.property()], e.prototype, "target", void 0);
					e = b.__decorate([f.subclass("esri.views.ViewAnimation")],
						e);
					(e || (e = {}))
					.State = {
						RUNNING: "running",
						STOPPED: "stopped",
						FINISHED: "finished",
						WAITING_FOR_TARGET: "waiting-for-target"
					};
					return e
				})
		},
		"esri/views/layers/LayerView": function() {
			define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/Accessor ../../core/Evented ../../core/HandleOwner ../../core/Identifiable ../../core/Logger ../../core/maybe ../../core/Promise ../../core/accessorSupport/decorators/property ../../core/arrayUtils ../../core/accessorSupport/ensureType ../../core/accessorSupport/decorators/subclass".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p) {
					c = function(n) {
						function t(q) {
							q = n.call(this, q) || this;
							q.layer = null;
							q.parent = null;
							return q
						}
						a._inheritsLoose(t, n);
						var h = t.prototype;
						h.initialize = function() {
							this.when()
								.catch(q => {
									if ("layerview:create-error" !== q.name) {
										const u = this.layer && this.layer.id || "no id",
											x = this.layer && this.layer.title || "no title";
										v.getLogger(this.declaredClass)
											.error("#resolve()", `Failed to resolve layer view (layer title: '${x}', id: '${u}')`, q)
									}
								})
						};
						h.canResume = function() {
							return this.visible && this.layer ? .loaded &&
								!this.parent ? .suspended && this.view ? .ready || !1
						};
						h.getSuspendInfo = function() {
							const q = this.parent && this.parent.suspended ? this.parent.suspendInfo : {};
							this.view && this.view.ready || (q.viewNotReady = !0);
							this.layer && this.layer.loaded || (q.layerNotLoaded = !0);
							this.visible || (q.layerInvisible = !0);
							return q
						};
						h.isUpdating = function() {
							return !1
						};
						a._createClass(t, [{
								key: "fullOpacity",
								get: function() {
									return m.unwrapOr(this.get("layer.opacity"), 1) * m.unwrapOr(this.get("parent.fullOpacity"), 1)
								}
							}, {
								key: "suspended",
								get: function() {
									return !this.canResume()
								}
							},
							{
								key: "suspendInfo",
								get: function() {
									return this.getSuspendInfo()
								}
							}, {
								key: "legendEnabled",
								get: function() {
									return !this.suspended && !0 === this.layer ? .legendEnabled
								}
							}, {
								key: "updating",
								get: function() {
									return !(!this.updatingHandles ? .updating && !this.isUpdating())
								}
							}, {
								key: "updatingProgress",
								get: function() {
									return this.updating ? 0 : 1
								}
							}, {
								key: "visible",
								get: function() {
									return !0 === this.layer ? .visible
								},
								set: function(q) {
									this._overrideIfSome("visible", q)
								}
							}
						]);
						return t
					}(d.HandleOwnerMixin(k.IdentifiableMixin(f.EsriPromiseMixin(e.EventedMixin(c)))));
					b.__decorate([g.property()], c.prototype, "fullOpacity", null);
					b.__decorate([g.property()], c.prototype, "layer", void 0);
					b.__decorate([g.property()], c.prototype, "parent", void 0);
					b.__decorate([g.property({
						readOnly: !0
					})], c.prototype, "suspended", null);
					b.__decorate([g.property({
						readOnly: !0
					})], c.prototype, "suspendInfo", null);
					b.__decorate([g.property({
						readOnly: !0
					})], c.prototype, "legendEnabled", null);
					b.__decorate([g.property({
						type: Boolean,
						readOnly: !0
					})], c.prototype, "updating", null);
					b.__decorate([g.property({
							readOnly: !0
						})],
						c.prototype, "updatingProgress", null);
					b.__decorate([g.property()], c.prototype, "visible", null);
					b.__decorate([g.property()], c.prototype, "view", void 0);
					return c = b.__decorate([p.subclass("esri.views.layers.LayerView")], c)
				})
		},
		"esri/widgets/Widget": function() {
			define("../chunks/_rollupPluginBabelHelpers ../chunks/tslib.es6 ../intl ../core/domUtils ../core/Evented ../core/events ../core/Handles ../core/has ../core/lang ../core/Logger ../core/maybe ../core/Promise ../core/promiseUtils ../core/reactiveUtils ../core/uuid ../core/accessorSupport/decorators/property ../core/accessorSupport/decorators/cast ../core/accessorSupport/decorators/subclass ../core/accessorSupport/tracking ../core/accessorSupport/tracking/SimpleTrackingTarget ../libs/maquette-advanced-projector/projector ../chunks/componentsUtils ./support/jsxWidgetSupport ./support/tests ./support/vnodeCache ./support/widgetUtils ../intl/locale ../intl/messages".split(" "),
				function(a, b, c, e, d, k, v, m, f, g, l, r, p, n, t, h, q, u, x, y, w, A, B, E, z, C, D, J) {
					function K(L, R) {
						for (const V in R) null != L[V] && ("object" === typeof L[V] && "object" === typeof R[V] ? K(L[V], R ? . [V]) : L[V] = R[V]);
						return L
					}
					let H = 0;
					const G = w.createAdvancedProjector({
						postProcessProjectionOptions(L) {
							const R = L.eventHandlerInterceptor,
								V = /capture$/i;
							L.eventHandlerInterceptor = (U, W, M, T) => {
								const Z = R ? .(U, W, M, T),
									oa = V.test(U);
								U = U.replace(V, "");
								if (!(U.toLowerCase() in M) || oa) {
									const qa = U[2].toLowerCase() + U.slice(3),
										Aa = da => Z ? .call(M, da);
									M.addEventListener(qa,
										Aa, oa);
									const Ka = T.afterRemoved;
									T.afterRemoved = da => {
										Ka ? .(da);
										M.removeEventListener(qa, Aa, oa)
									}
								}
								return Z
							}
						},
						handleInterceptedEvent(L, R, V, U) {
							const {
								eventPhase: W,
								type: M
							} = U, T = W === Event.CAPTURING_PHASE;
							let Z = `on${M}${T?"capture":""}`;
							R = R.properties;
							if (!(R && Z in R || (Z = `on${M[0].toUpperCase()}${M.slice(1)}${T?"Capture":""}`, R && Z in R))) return;
							z.clearVNodeCache();
							L.scheduleRender();
							R[Z].call(R.bind || V, U)
						}
					});
					let F = !1;
					c = function(L) {
						function R(U, W) {
							var M = L.call(this, U, W) || this;
							M._attached = !1;
							M._internalHandles =
								new v;
							M._projector = G;
							M._readyForTrueRender = !1;
							M.iconClass = "esri-icon-checkbox-unchecked";
							M.key = a._assertThisInitialized(M);
							M._loadLocale = p.debounce(a._asyncToGenerator(function*() {
								if (M._messageBundleProps && M._messageBundleProps.length) {
									const qa = yield p.eachAlways(M._messageBundleProps.map(function() {
										var Aa = a._asyncToGenerator(function*({
											bundlePath: Ka,
											propertyName: da
										}) {
											Ka = yield J.fetchMessageBundle(Ka);
											M.uiStrings && Object.keys(M.uiStrings) && (Ka = K(f.clone(Ka), M.uiStrings));
											M[da] = Ka
										});
										return function(Ka) {
											return Aa.apply(this,
												arguments)
										}
									}()));
									for (const Aa of qa) Aa.error && g.getLogger(M.declaredClass)
										.error("widget-intl:locale-error", M.declaredClass, Aa.error)
								}
								yield M.loadLocale()
							}));
							A.commitAssetPath();
							const T = "esri-widget-uid-" + t.generateUUID(),
								Z = M.render.bind(a._assertThisInitialized(M));
							M._trackingTarget = new y.SimpleTrackingTarget(() => M.scheduleRender());
							const oa = () => {
								if (!M._readyForTrueRender || M.destroyed) return null;
								if (!M.visible) return {
									vnodeSelector: "div",
									properties: {
										key: T,
										class: "",
										styles: {
											display: "none"
										}
									},
									domNode: null,
									children: void 0,
									text: void 0
								};
								const qa = Z();
								let {
									properties: Aa
								} = qa;
								Aa || (qa.properties = Aa = {});
								let {
									key: Ka,
									styles: da
								} = Aa;
								Ka || (Aa.key = T);
								da || (Aa.styles = da = {});
								da.display || (da.display = "");
								let ja = 0;
								qa.children ? .forEach(sa => {
									if (!B.isWidgetConstructor(sa.vnodeSelector)) {
										var {
											properties: I
										} = sa;
										I || (sa.properties = I = {});
										I.key || (I.key = `${M.id}--${ja++}`)
									}
								});
								return B.processWidgets(a._assertThisInitialized(M), qa)
							};
							M.render = () => {
								if (F) return oa();
								let qa = z.getVNodeCache(a._assertThisInitialized(M)) ? ? null;
								if (qa) return qa;
								M._trackingTarget.clear();
								F = !0;
								try {
									qa = x.runTracked(M._trackingTarget, oa)
								} catch (Aa) {
									throw console.error(Aa), Aa;
								} finally {
									F = !1
								}
								qa && z.setVNodeCache(a._assertThisInitialized(M), qa);
								return qa
							};
							M.addResolvingPromise(M._resourcesFetch = M.beforeFirstRender()
								.then(() => {
									M._readyForTrueRender = !0;
									M._postInitialize()
								}));
							E.registerLoading(M._resourcesFetch);
							return M
						}
						a._inheritsLoose(R, L);
						var V = R.prototype;
						V.normalizeCtorArgs = function(U, W) {
							U = {
								...U
							};
							W && (U.container = W);
							return U
						};
						V.postInitialize = function() {};
						V.beforeFirstRender =
							function() {
								return Promise.all([this.loadDependencies(), this._loadLocale()])
									.then(() => {})
									.catch(p.throwIfNotAbortError)
							};
						V.loadDependencies = function() {
							var U = a._asyncToGenerator(function*() {});
							return function() {
								return U.apply(this, arguments)
							}
						}();
						V.loadLocale = function() {
							var U = a._asyncToGenerator(function*() {});
							return function() {
								return U.apply(this, arguments)
							}
						}();
						V.destroy = function() {
							this.destroyed || (l.destroyMaybe(this._trackingTarget), l.destroyMaybe(this.viewModel), this._detach(this.container), this._set("container",
								null), this._internalHandles.destroy(), this._emitter.clear(), this.render = () => null, this._projector = null, z.deleteVNodeCache(this))
						};
						V.castContainer = function(U) {
							return e.byId(U)
						};
						V.render = function() {
							throw Error("not implemented");
						};
						V.scheduleRender = function() {
							this.destroyed || (z.deleteVNodeCache(this), this._projector.scheduleRender())
						};
						V.classes = function(...U) {
							return C.classes.apply(this, U)
						};
						V.renderNow = function() {
							z.deleteVNodeCache(this);
							this._projector.renderNow()
						};
						V._postInitialize = function() {
							var U =
								this;
							if (!this.destroyed) {
								this.scheduleRender();
								this._delegatedEventNames ? .length && this._internalHandles.add(n.watch(() => this.viewModel, (M, T) => {
									T && this._internalHandles.remove("delegated-events");
									M && k.isEventTarget(M) && this._internalHandles.add(this._delegatedEventNames.map(Z => k.on(M, Z, oa => {
										this.emit(Z, oa)
									})), "delegated-events")
								}, n.initial));
								this.postInitialize();
								var W = function() {
									var M = a._asyncToGenerator(function*() {
										yield U._loadLocale()
											.catch(p.throwIfNotAbortError);
										U.scheduleRender()
									});
									return function() {
										return M.apply(this,
											arguments)
									}
								}();
								this._internalHandles.add([D.onLocaleChange(W), n.watch(() => this.uiStrings, W), n.when(() => this.container, M => {
									this.destroyed || this._attach(M)
								}, {
									initial: !0,
									once: !0
								})])
							}
						};
						V._attach = function(U) {
							U && (this._projector.merge(U, this.render), this._attached = !0)
						};
						V._detach = function(U) {
							this._attached && (this._projector.detach(this.render), this._attached = !1);
							U ? .parentNode ? .removeChild(U)
						};
						a._createClass(R, [{
							key: "container",
							set: function(U) {
								this._get("container") || this._set("container", U)
							}
						}, {
							key: "domNode",
							get: function() {
								return this.container
							},
							set: function(U) {
								this.container = U
							}
						}, {
							key: "id",
							get: function() {
								return this._get("id") || this.get("container.id") || Date.now()
									.toString(16) + "-widget-" + H++
							},
							set: function(U) {
								U && this._set("id", U)
							}
						}, {
							key: "label",
							get: function() {
								return this.declaredClass.split(".")
									.pop()
							},
							set: function(U) {
								this._overrideIfSome("label", U)
							}
						}, {
							key: "renderable",
							get: function() {
								return this._resourcesFetch
							}
						}, {
							key: "visible",
							get: function() {
								return this._get("visible")
							},
							set: function(U) {
								this._set("visible",
									U)
							}
						}, {
							key: "test",
							get: function() {
								return {
									projector: this._projector
								}
							}
						}]);
						return R
					}(r.EsriPromiseMixin(d.EventedAccessor));
					c[B.WIDGET_SYMBOL] = !0;
					b.__decorate([h.property()], c.prototype, "_readyForTrueRender", void 0);
					b.__decorate([h.property({
						value: null
					})], c.prototype, "container", null);
					b.__decorate([q.cast("container")], c.prototype, "castContainer", null);
					b.__decorate([h.property()], c.prototype, "domNode", null);
					b.__decorate([h.property()], c.prototype, "iconClass", void 0);
					b.__decorate([h.property()], c.prototype,
						"id", null);
					b.__decorate([h.property()], c.prototype, "label", null);
					b.__decorate([h.property()], c.prototype, "renderable", null);
					b.__decorate([h.property()], c.prototype, "uiStrings", void 0);
					b.__decorate([h.property()], c.prototype, "viewModel", void 0);
					b.__decorate([h.property({
						value: !0
					})], c.prototype, "visible", null);
					b.__decorate([h.property()], c.prototype, "key", void 0);
					b.__decorate([h.property()], c.prototype, "children", void 0);
					b.__decorate([h.property()], c.prototype, "afterCreate", void 0);
					b.__decorate([h.property()],
						c.prototype, "afterUpdate", void 0);
					b.__decorate([h.property()], c.prototype, "afterRemoved", void 0);
					return c = b.__decorate([u.subclass("esri.widgets.Widget")], c)
				})
		},
		"esri/core/domUtils": function() {
			define(["exports"], function(a) {
				const b = (() => {
					if ("function" === typeof Element.prototype.closest) return (e, d) => e.closest(d);
					const c = Element.prototype.matches || Element.prototype.msMatchesSelector;
					return (e, d) => {
						do {
							if (c.call(e, d)) return e;
							e = e.parentElement
						} while (null !== e && 1 === e.nodeType);
						return null
					}
				})();
				a.byId = function(c) {
					return "string" ===
						typeof c ? document.getElementById(c) : c ? ? null
				};
				a.closest = b;
				a.empty = function(c) {
					for (; c.hasChildNodes();) c.removeChild(c.firstChild)
				};
				a.insertAfter = function(c, e) {
					const d = e.parentNode;
					d && (d.lastChild === e ? d.appendChild(c) : d.insertBefore(c, e.nextSibling))
				};
				a.insertBefore = function(c, e) {
					const d = e.parentNode;
					d && d.insertBefore(c, e)
				};
				a.remove = function(c) {
					c.parentNode && c.parentNode.removeChild(c)
				};
				a.reparent = function(c, e) {
					for (;;) {
						const d = c.firstChild;
						if (!d) break;
						e.appendChild(d)
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/core/uuid": function() {
			define(["exports"], function(a) {
				const b = "randomUUID" in crypto;
				a.generateUUID = function() {
					if (b) return crypto.randomUUID();
					const c = crypto.getRandomValues(new Uint16Array(8));
					c[3] = c[3] & 4095 | 16384;
					c[4] = c[4] & 16383 | 32768;
					const e = d => c[d].toString(16)
						.padStart(4, "0");
					return e(0) + e(1) + "-" + e(2) + "-" + e(3) + "-" + e(4) + "-" + e(5) + e(6) + e(7)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/libs/maquette-advanced-projector/projector": function() {
			define(["exports",
				"../maquette/dom", "../maquette/projector", "./advanced-projector-options", "./utils"
			], function(a, b, c, e, d) {
				const k = (f, g) => {
						const l = [];
						for (; f && f !== g;) l.push(f), f = f.parentNode;
						return l
					},
					v = (f, g) => f.find(g),
					m = (f, g, l = !1) => {
						let r = f;
						g.forEach((p, n) => {
							const t = r ? .children ? v(r.children, h => h.domNode === p) : void 0;
							if (!l || t || n === g.length - 1) r = t
						});
						return r
					};
				a.createAdvancedProjector = f => {
					let g;
					const l = {
							...e.defaultAdvancedProjectorOptions,
							...f
						},
						r = d.applyDefaultProjectionOptions(l),
						p = r.performanceLogger;
					let n = !0,
						t, h = !1;
					const q = [],
						u = [],
						x = (w, A, B) => {
							let E;
							r.eventHandlerInterceptor = (C, D, J, K) => function(H) {
								p("domEvent", H);
								var G = k(H.currentTarget, E.domNode);
								const F = G.some(R => customElements.get(R ? .tagName ? .toLowerCase()));
								H.eventPhase !== Event.CAPTURING_PHASE && F ? (G = H.composedPath(), G = G.slice(G.indexOf(H.currentTarget), G.indexOf(E.domNode))
									.filter(R => R.getRootNode() === R.ownerDocument)
									.reverse(), G = m(E.getLastRender(), G, !0)) : (G.reverse(), G = m(E.getLastRender(), G));
								let L;
								G && (L = l.handleInterceptedEvent(g, G, this, H));
								p("domEventProcessed",
									H);
								return L
							};
							l.postProcessProjectionOptions ? .(r);
							const z = B();
							E = w(A, z, r);
							q.push(E);
							u.push(B);
							l.afterFirstVNodeRendered && l.afterFirstVNodeRendered(E, z)
						};
					let y = () => {
						t = void 0;
						if (n) {
							n = !1;
							p("renderStart", void 0);
							for (let w = 0; w < q.length; w++) {
								const A = u[w]();
								p("rendered", void 0);
								q[w].update(A);
								p("patched", void 0)
							}
							p("renderDone", void 0);
							n = !0
						}
					};
					l.modifyDoRenderImplementation && (y = l.modifyDoRenderImplementation(y, q, u));
					return g = {
						renderNow: y,
						scheduleRender: () => {
							t || h || (t = requestAnimationFrame(y))
						},
						stop: () => {
							t && (cancelAnimationFrame(t),
								t = void 0);
							h = !0
						},
						resume: () => {
							h = !1;
							n = !0;
							g.scheduleRender()
						},
						append: (w, A) => {
							x(b.dom.append, w, A)
						},
						insertBefore: (w, A) => {
							x(b.dom.insertBefore, w, A)
						},
						merge: (w, A) => {
							x(b.dom.merge, w, A)
						},
						replace: (w, A) => {
							x(b.dom.replace, w, A)
						},
						detach: w => {
							for (let A = 0; A < u.length; A++)
								if (u[A] === w) return u.splice(A, 1), q.splice(A, 1)[0];
							throw Error("renderFunction was not found");
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/libs/maquette/dom": function() {
			define(["exports", "./projection"],
				function(a, b) {
					const c = {
						namespace: void 0,
						performanceLogger: () => {},
						eventHandlerInterceptor: void 0,
						styleApplyer: (e, d, k) => {
							"-" === d.charAt(0) ? e.style.setProperty(d, k) : e.style[d] = k
						}
					};
					a.applyDefaultProjectionOptions = e => b.extend(c, e);
					a.dom = {
						create: (e, d) => {
							d = b.extend(c, d);
							b.createDom(e, document.createElement("div"), void 0, d);
							return b.createProjection(e, d)
						},
						append: (e, d, k) => {
							k = b.extend(c, k);
							b.createDom(d, e, void 0, k);
							return b.createProjection(d, k)
						},
						insertBefore: (e, d, k) => {
							k = b.extend(c, k);
							b.createDom(d, e.parentNode,
								e, k);
							return b.createProjection(d, k)
						},
						merge: (e, d, k) => {
							k = b.extend(c, k);
							d.domNode = e;
							b.initPropertiesAndChildren(e, d, k);
							return b.createProjection(d, k)
						},
						replace: (e, d, k) => {
							k = b.extend(c, k);
							b.createDom(d, e.parentNode, e, k);
							e.parentNode.removeChild(e);
							return b.createProjection(d, k)
						}
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/libs/maquette/projection": function() {
			define(["exports", "../../widgets/support/widgetUtils"], function(a, b) {
				let c = [],
					e = (x, y) => {
						let w = {};
						Object.keys(x)
							.forEach(A => {
								w[A] = x[A]
							});
						y && Object.keys(y)
							.forEach(A => {
								w[A] = y[A]
							});
						return w
					},
					d = (x, y) => x.vnodeSelector !== y.vnodeSelector ? !1 : x.properties && y.properties ? x.properties.key !== y.properties.key ? !1 : x.properties.bind === y.properties.bind : !x.properties && !y.properties,
					k = x => {
						if ("string" !== typeof x) throw Error("Style values must be strings");
					},
					v = (x, y, w, A) => {
						let B = x[y];
						if ("" !== B.vnodeSelector) {
							var E = B.properties;
							if (!(E && (void 0 === E.key ? E.bind : E.key)))
								for (E = 0; E < x.length; E++)
									if (E !== y && d(x[E], B)) throw Error(`${w.vnodeSelector} had a ${B.vnodeSelector} child ${"added"===
A?A:"removed"}, but there is now more than one. You must add unique key properties to make them distinguishable.`);
						}
					},
					m = [],
					f = !1,
					g = x => {
						(x.children || [])
						.forEach(g);
						x.properties && x.properties.afterRemoved && x.properties.afterRemoved.apply(x.properties.bind || x.properties, [x.domNode])
					},
					l = () => {
						f = !1;
						m.forEach(g);
						m.length = 0
					},
					r = x => {
						m.push(x);
						f || (f = !0, "undefined" !== typeof window && "requestIdleCallback" in window ? window.requestIdleCallback(l, {
							timeout: 16
						}) : setTimeout(l, 16))
					},
					p = x => {
						let y = x.domNode;
						if (x.properties) {
							let w =
								x.properties.exitAnimation;
							if (w) {
								y.style.pointerEvents = "none";
								w(y, () => {
									y.parentNode && (y.parentNode.removeChild(y), r(x))
								}, x.properties);
								return
							}
						}
						y.parentNode && (y.parentNode.removeChild(y), r(x))
					},
					n = (x, y, w) => {
						if (y) {
							var A = w.eventHandlerInterceptor,
								B = Object.keys(y),
								E = B.length;
							for (let K = 0; K < E; K++) {
								var z = B[K];
								let H = y[z];
								if ("className" === z) throw Error('Property "className" is not supported, use "class".');
								if ("class" === z) u(x, H, !0);
								else if ("classes" === z) {
									z = Object.keys(H);
									var C = z.length;
									for (var D = 0; D < C; D++) {
										var J =
											z[D];
										H[J] && x.classList.add(J)
									}
								} else if ("styles" === z)
									for (z = Object.keys(H), C = z.length, D = 0; D < C; D++) {
										J = z[D];
										let G = H[J];
										G && (k(G), w.styleApplyer(x, J, G))
									} else "key" !== z && null !== H && void 0 !== H && (C = typeof H, "function" === C ? (0 === z.lastIndexOf("on", 0) && (A && (H = A(z, H, x, y)), "oninput" === z && function() {
										let G = H;
										H = function(F) {
											G.apply(this, [F]);
											F.target["oninput-value"] = F.target.value
										}
									}()), x[z] = H) : "http://www.w3.org/2000/svg" === w.namespace ? "href" === z ? x.setAttributeNS("http://www.w3.org/1999/xlink", z, H) : x.setAttribute(z,
										H) : "string" === C && "value" !== z ? "innerHTML" === z ? x[z] = b.renderingSanitizer.sanitize(H) : x.setAttribute(z, H) : x[z] = H)
							}
						}
					},
					t = (x, y, w) => {
						var A = y.children;
						if (A)
							for (let B of A) h(B, x, void 0, w);
						y.text && (x.textContent = y.text);
						n(x, y.properties, w);
						y.properties && y.properties.afterCreate && y.properties.afterCreate.apply(y.properties.bind || y.properties, [x, w, y.vnodeSelector, y.properties, y.children])
					},
					h = (x, y, w, A) => {
						let B;
						var E = 0;
						let z = x.vnodeSelector,
							C = y.ownerDocument;
						if ("" === z) B = x.domNode = C.createTextNode(x.text), void 0 !==
							w ? y.insertBefore(B, w) : y.appendChild(B);
						else {
							for (let J = 0; J <= z.length; ++J) {
								var D = z.charAt(J);
								if (J === z.length || "." === D || "#" === D) D = z.charAt(E - 1), E = z.slice(E, J), "." === D ? B.classList.add(E) : "#" === D ? B.id = E : ("svg" === E && (A = e(A, {
										namespace: "http://www.w3.org/2000/svg"
									})), void 0 !== A.namespace ? B = x.domNode = C.createElementNS(A.namespace, E) : (B = x.domNode = x.domNode || C.createElement(E), "input" === E && x.properties && void 0 !== x.properties.type && B.setAttribute("type", x.properties.type)), void 0 !== w ? y.insertBefore(B, w) : B.parentNode !==
									y && y.appendChild(B)), E = J + 1
							}
							t(B, x, A)
						}
					},
					q, u = (x, y, w) => {
						y && y.split(" ")
							.forEach(A => {
								A && x.classList.toggle(A, w)
							})
					};
				q = (x, y, w) => {
					let A = x.domNode;
					if (x === y) return !1;
					let B = !1;
					if ("" === y.vnodeSelector) {
						if (y.text !== x.text) return x = A.ownerDocument.createTextNode(y.text), A.parentNode.replaceChild(x, A), y.domNode = x, !0;
						y.domNode = A
					} else {
						0 === y.vnodeSelector.lastIndexOf("svg", 0) && (w = e(w, {
							namespace: "http://www.w3.org/2000/svg"
						}));
						x.text !== y.text && (B = !0, void 0 === y.text ? A.removeChild(A.firstChild) : A.textContent = y.text);
						y.domNode = A;
						var E = x.children;
						var z = y.children,
							C = w;
						if (E === z) E = !1;
						else {
							E = E || c;
							z = z || c;
							for (var D = E.length, J = z.length, K = 0, H = 0, G = !1; H < J;) {
								var F = K < D ? E[K] : void 0,
									L = z[H];
								if (void 0 !== F && d(F, L)) G = q(F, L, C) || G, K++;
								else {
									b: {
										F = E;
										var R = L,
											V = K + 1;
										if ("" !== R.vnodeSelector)
											for (; V < F.length; V++)
												if (d(F[V], R)) {
													F = V;
													break b
												} F = -1
									}
									if (0 <= F) {
										for (; K < F; K++) p(E[K]), v(E, K, y, "removed");
										G = q(E[F], L, C) || G;
										K = F + 1
									} else h(L, A, K < D ? E[K].domNode : void 0, C),
									L.properties && (F = L.properties.enterAnimation) && F(L.domNode, L.properties),
									v(z, H, y, "added")
								}
								H++
							}
							if (D >
								K)
								for (; K < D; K++) p(E[K]), v(E, K, y, "removed");
							E = G
						}
						B = E || B;
						E = x.properties;
						z = y.properties;
						C = w;
						if (z) {
							D = !1;
							J = Object.keys(z);
							H = J.length;
							for (G = 0; G < H; G++)
								if (F = J[G], L = z[F], K = E[F], "class" === F) K !== L && (u(A, K, !1), u(A, L, !0));
								else if ("classes" === F) {
								F = A.classList;
								R = Object.keys(L);
								V = R.length;
								for (var U = 0; U < V; U++) {
									var W = R[U];
									let M = !!L[W];
									M !== !!K[W] && (D = !0, M ? F.add(W) : F.remove(W))
								}
							} else if ("styles" === F)
								for (F = Object.keys(L), R = F.length, V = 0; V < R; V++) U = F[V], W = L[U], W !== K[U] && (D = !0, W ? (k(W), C.styleApplyer(A, U, W)) : C.styleApplyer(A,
									U, ""));
							else L || "string" !== typeof K || (L = ""), "value" === F ? (R = A[F], R !== L && (A["oninput-value"] ? R === A["oninput-value"] : L !== K) && (A[F] = L, A["oninput-value"] = void 0), L !== K && (D = !0)) : L !== K && (K = typeof L, "function" === K && C.eventHandlerInterceptor || ("http://www.w3.org/2000/svg" === C.namespace ? "href" === F ? A.setAttributeNS("http://www.w3.org/1999/xlink", F, L) : A.setAttribute(F, L) : "string" === K ? "innerHTML" === F ? A[F] = b.renderingSanitizer.sanitize(L) : "role" === F && "" === L ? A.removeAttribute(F) : A.setAttribute(F, L) : A[F] !== L && (A[F] =
								L), D = !0));
							E = D
						} else E = void 0;
						B = E || B;
						y.properties && y.properties.afterUpdate && y.properties.afterUpdate.apply(y.properties.bind || y.properties, [A, w, y.vnodeSelector, y.properties, y.children])
					}
					B && y.properties && y.properties.updateAnimation && y.properties.updateAnimation(A, y.properties, x.properties);
					return !1
				};
				a.createDom = h;
				a.createProjection = (x, y) => ({
					getLastRender: () => x,
					update: w => {
						if (x.vnodeSelector !== w.vnodeSelector) throw Error("The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)");
						let A = x;
						x = w;
						q(A, w, y)
					},
					domNode: x.domNode
				});
				a.extend = e;
				a.initPropertiesAndChildren = t;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/widgets/support/widgetUtils": function() {
			define("exports ../../core/ArrayPool ../../core/handleUtils ../../core/has ../../core/Logger ./vnodeCache".split(" "), function(a, b, c, e, d, k) {
				function v() {
					return {
						"align-content": !1,
						"align-items": !1,
						"align-self": !1,
						"alignment-adjust": !1,
						"alignment-baseline": !1,
						all: !1,
						"anchor-point": !1,
						animation: !1,
						"animation-delay": !1,
						"animation-direction": !1,
						"animation-duration": !1,
						"animation-fill-mode": !1,
						"animation-iteration-count": !1,
						"animation-name": !1,
						"animation-play-state": !1,
						"animation-timing-function": !1,
						azimuth: !1,
						"backface-visibility": !1,
						background: !0,
						"background-attachment": !0,
						"background-clip": !0,
						"background-color": !0,
						"background-image": !0,
						"background-origin": !0,
						"background-position": !0,
						"background-repeat": !0,
						"background-size": !0,
						"baseline-shift": !1,
						binding: !1,
						bleed: !1,
						"bookmark-label": !1,
						"bookmark-level": !1,
						"bookmark-state": !1,
						border: !0,
						"border-bottom": !0,
						"border-bottom-color": !0,
						"border-bottom-left-radius": !0,
						"border-bottom-right-radius": !0,
						"border-bottom-style": !0,
						"border-bottom-width": !0,
						"border-collapse": !0,
						"border-color": !0,
						"border-image": !0,
						"border-image-outset": !0,
						"border-image-repeat": !0,
						"border-image-slice": !0,
						"border-image-source": !0,
						"border-image-width": !0,
						"border-left": !0,
						"border-left-color": !0,
						"border-left-style": !0,
						"border-left-width": !0,
						"border-radius": !0,
						"border-right": !0,
						"border-right-color": !0,
						"border-right-style": !0,
						"border-right-width": !0,
						"border-spacing": !0,
						"border-style": !0,
						"border-top": !0,
						"border-top-color": !0,
						"border-top-left-radius": !0,
						"border-top-right-radius": !0,
						"border-top-style": !0,
						"border-top-width": !0,
						"border-width": !0,
						bottom: !1,
						"box-decoration-break": !0,
						"box-shadow": !0,
						"box-sizing": !0,
						"box-snap": !0,
						"box-suppress": !0,
						"break-after": !0,
						"break-before": !0,
						"break-inside": !0,
						"caption-side": !1,
						chains: !1,
						clear: !0,
						clip: !1,
						"clip-path": !1,
						"clip-rule": !1,
						color: !0,
						"color-interpolation-filters": !0,
						"column-count": !1,
						"column-fill": !1,
						"column-gap": !1,
						"column-rule": !1,
						"column-rule-color": !1,
						"column-rule-style": !1,
						"column-rule-width": !1,
						"column-span": !1,
						"column-width": !1,
						columns: !1,
						contain: !1,
						content: !1,
						"counter-increment": !1,
						"counter-reset": !1,
						"counter-set": !1,
						crop: !1,
						cue: !1,
						"cue-after": !1,
						"cue-before": !1,
						cursor: !1,
						direction: !1,
						display: !0,
						"display-inside": !0,
						"display-list": !0,
						"display-outside": !0,
						"dominant-baseline": !1,
						elevation: !1,
						"empty-cells": !1,
						filter: !1,
						flex: !1,
						"flex-basis": !1,
						"flex-direction": !1,
						"flex-flow": !1,
						"flex-grow": !1,
						"flex-shrink": !1,
						"flex-wrap": !1,
						"float": !1,
						"float-offset": !1,
						"flood-color": !1,
						"flood-opacity": !1,
						"flow-from": !1,
						"flow-into": !1,
						font: !0,
						"font-family": !0,
						"font-feature-settings": !0,
						"font-kerning": !0,
						"font-language-override": !0,
						"font-size": !0,
						"font-size-adjust": !0,
						"font-stretch": !0,
						"font-style": !0,
						"font-synthesis": !0,
						"font-variant": !0,
						"font-variant-alternates": !0,
						"font-variant-caps": !0,
						"font-variant-east-asian": !0,
						"font-variant-ligatures": !0,
						"font-variant-numeric": !0,
						"font-variant-position": !0,
						"font-weight": !0,
						grid: !1,
						"grid-area": !1,
						"grid-auto-columns": !1,
						"grid-auto-flow": !1,
						"grid-auto-rows": !1,
						"grid-column": !1,
						"grid-column-end": !1,
						"grid-column-start": !1,
						"grid-row": !1,
						"grid-row-end": !1,
						"grid-row-start": !1,
						"grid-template": !1,
						"grid-template-areas": !1,
						"grid-template-columns": !1,
						"grid-template-rows": !1,
						"hanging-punctuation": !1,
						height: !0,
						hyphens: !1,
						icon: !1,
						"image-orientation": !1,
						"image-resolution": !1,
						"ime-mode": !1,
						"initial-letters": !1,
						"inline-box-align": !1,
						"justify-content": !1,
						"justify-items": !1,
						"justify-self": !1,
						left: !1,
						"letter-spacing": !0,
						"lighting-color": !0,
						"line-box-contain": !1,
						"line-break": !1,
						"line-grid": !1,
						"line-height": !1,
						"line-snap": !1,
						"line-stacking": !1,
						"line-stacking-ruby": !1,
						"line-stacking-shift": !1,
						"line-stacking-strategy": !1,
						"list-style": !0,
						"list-style-image": !0,
						"list-style-position": !0,
						"list-style-type": !0,
						margin: !0,
						"margin-bottom": !0,
						"margin-left": !0,
						"margin-right": !0,
						"margin-top": !0,
						"marker-offset": !1,
						"marker-side": !1,
						marks: !1,
						mask: !1,
						"mask-box": !1,
						"mask-box-outset": !1,
						"mask-box-repeat": !1,
						"mask-box-slice": !1,
						"mask-box-source": !1,
						"mask-box-width": !1,
						"mask-clip": !1,
						"mask-image": !1,
						"mask-origin": !1,
						"mask-position": !1,
						"mask-repeat": !1,
						"mask-size": !1,
						"mask-source-type": !1,
						"mask-type": !1,
						"max-height": !0,
						"max-lines": !1,
						"max-width": !0,
						"min-height": !0,
						"min-width": !0,
						"move-to": !1,
						"nav-down": !1,
						"nav-index": !1,
						"nav-left": !1,
						"nav-right": !1,
						"nav-up": !1,
						"object-fit": !1,
						"object-position": !1,
						opacity: !1,
						order: !1,
						orphans: !1,
						outline: !1,
						"outline-color": !1,
						"outline-offset": !1,
						"outline-style": !1,
						"outline-width": !1,
						overflow: !1,
						"overflow-wrap": !1,
						"overflow-x": !1,
						"overflow-y": !1,
						padding: !0,
						"padding-bottom": !0,
						"padding-left": !0,
						"padding-right": !0,
						"padding-top": !0,
						page: !1,
						"page-break-after": !1,
						"page-break-before": !1,
						"page-break-inside": !1,
						"page-policy": !1,
						pause: !1,
						"pause-after": !1,
						"pause-before": !1,
						perspective: !1,
						"perspective-origin": !1,
						pitch: !1,
						"pitch-range": !1,
						"play-during": !1,
						position: !1,
						"presentation-level": !1,
						quotes: !1,
						"region-fragment": !1,
						resize: !1,
						rest: !1,
						"rest-after": !1,
						"rest-before": !1,
						richness: !1,
						right: !1,
						rotation: !1,
						"rotation-point": !1,
						"ruby-align": !1,
						"ruby-merge": !1,
						"ruby-position": !1,
						"shape-image-threshold": !1,
						"shape-outside": !1,
						"shape-margin": !1,
						size: !1,
						speak: !1,
						"speak-as": !1,
						"speak-header": !1,
						"speak-numeral": !1,
						"speak-punctuation": !1,
						"speech-rate": !1,
						stress: !1,
						"string-set": !1,
						"tab-size": !1,
						"table-layout": !1,
						"text-align": !0,
						"text-align-last": !0,
						"text-combine-upright": !0,
						"text-decoration": !0,
						"text-decoration-color": !0,
						"text-decoration-line": !0,
						"text-decoration-skip": !0,
						"text-decoration-style": !0,
						"text-emphasis": !0,
						"text-emphasis-color": !0,
						"text-emphasis-position": !0,
						"text-emphasis-style": !0,
						"text-height": !0,
						"text-indent": !0,
						"text-justify": !0,
						"text-orientation": !0,
						"text-overflow": !0,
						"text-shadow": !0,
						"text-space-collapse": !0,
						"text-transform": !0,
						"text-underline-position": !0,
						"text-wrap": !0,
						top: !1,
						transform: !1,
						"transform-origin": !1,
						"transform-style": !1,
						transition: !1,
						"transition-delay": !1,
						"transition-duration": !1,
						"transition-property": !1,
						"transition-timing-function": !1,
						"unicode-bidi": !1,
						"vertical-align": !1,
						visibility: !1,
						"voice-balance": !1,
						"voice-duration": !1,
						"voice-family": !1,
						"voice-pitch": !1,
						"voice-range": !1,
						"voice-rate": !1,
						"voice-stress": !1,
						"voice-volume": !1,
						volume: !1,
						"white-space": !1,
						widows: !1,
						width: !0,
						"will-change": !1,
						"word-break": !0,
						"word-spacing": !0,
						"word-wrap": !0,
						"wrap-flow": !1,
						"wrap-through": !1,
						"writing-mode": !1,
						"z-index": !1
					}
				}

				function m(Q) {
					Q = Q || {};
					var aa = {},
						ta;
					for (ta in Q) aa[ta] = Q[ta];
					Q = aa;
					Q.whiteList = Q.whiteList || F.whiteList;
					Q.onAttr = Q.onAttr || F.onAttr;
					Q.onIgnoreAttr = Q.onIgnoreAttr || F.onIgnoreAttr;
					Q.safeAttrValue = Q.safeAttrValue || F.safeAttrValue;
					this.options = Q
				}

				function f() {
					return {
						a: ["target", "href", "title"],
						abbr: ["title"],
						address: [],
						area: ["shape", "coords", "href", "alt"],
						article: [],
						aside: [],
						audio: "autoplay controls crossorigin loop muted preload src".split(" "),
						b: [],
						bdi: ["dir"],
						bdo: ["dir"],
						big: [],
						blockquote: ["cite"],
						br: [],
						caption: [],
						center: [],
						cite: [],
						code: [],
						col: ["align", "valign", "span", "width"],
						colgroup: ["align", "valign", "span", "width"],
						dd: [],
						del: ["datetime"],
						details: ["open"],
						div: [],
						dl: [],
						dt: [],
						em: [],
						figcaption: [],
						figure: [],
						font: ["color", "size", "face"],
						footer: [],
						h1: [],
						h2: [],
						h3: [],
						h4: [],
						h5: [],
						h6: [],
						header: [],
						hr: [],
						i: [],
						img: ["src", "alt", "title", "width", "height"],
						ins: ["datetime"],
						li: [],
						mark: [],
						nav: [],
						ol: [],
						p: [],
						pre: [],
						s: [],
						section: [],
						small: [],
						span: [],
						sub: [],
						summary: [],
						sup: [],
						strong: [],
						strike: [],
						table: ["width", "border", "align", "valign"],
						tbody: ["align", "valign"],
						td: ["width", "rowspan", "colspan", "align", "valign"],
						tfoot: ["align", "valign"],
						th: ["width", "rowspan",
							"colspan", "align", "valign"
						],
						thead: ["align", "valign"],
						tr: ["rowspan", "align", "valign"],
						tt: [],
						u: [],
						ul: [],
						video: "autoplay controls crossorigin loop muted playsinline poster preload src height width".split(" ")
					}
				}

				function g(Q) {
					return Q.replace(M, "\x26lt;")
						.replace(T, "\x26gt;")
				}

				function l(Q) {
					return Q.replace(Z, "\x26quot;")
				}

				function r(Q) {
					return Q.replace(oa, '"')
				}

				function p(Q) {
					return Q.replace(qa, function(aa, ta) {
						return "x" === ta[0] || "X" === ta[0] ? String.fromCharCode(parseInt(ta.substr(1), 16)) : String.fromCharCode(parseInt(ta,
							10))
					})
				}

				function n(Q) {
					return Q.replace(Aa, ":")
						.replace(Ka, " ")
				}

				function t(Q) {
					for (var aa = "", ta = 0, Da = Q.length; ta < Da; ta++) aa += 32 > Q.charCodeAt(ta) ? " " : Q.charAt(ta);
					return U.trim(aa)
				}

				function h(Q) {
					Q = r(Q);
					Q = p(Q);
					Q = n(Q);
					return Q = t(Q)
				}

				function q(Q) {
					Q = l(Q);
					return Q = g(Q)
				}

				function u(Q, aa) {
					for (; aa < Q.length; aa++) {
						var ta = Q[aa];
						if (" " !== ta) return "\x3d" === ta ? aa : -1
					}
				}

				function x(Q, aa) {
					for (; aa < Q.length; aa++) {
						var ta = Q[aa];
						if (" " !== ta) return "'" === ta || '"' === ta ? aa : -1
					}
				}

				function y(Q, aa) {
					for (; 0 < aa; aa--) {
						var ta = Q[aa];
						if (" " !==
							ta) return "\x3d" === ta ? aa : -1
					}
				}

				function w(Q) {
					var aa = '"' === Q[0] && '"' === Q[Q.length - 1] || "'" === Q[0] && "'" === Q[Q.length - 1] ? !0 : !1;
					return aa ? Q.substr(1, Q.length - 2) : Q
				}

				function A(Q) {
					var aa = ba.spaceIndex(Q);
					if (-1 === aa) return {
						html: "",
						closing: "/" === Q[Q.length - 2]
					};
					Q = ba.trim(Q.slice(aa + 1, -1));
					(aa = "/" === Q[Q.length - 1]) && (Q = ba.trim(Q.slice(0, -1)));
					return {
						html: Q,
						closing: aa
					}
				}

				function B(Q) {
					var aa = {},
						ta;
					for (ta in Q) Array.isArray(Q[ta]) ? aa[ta.toLowerCase()] = Q[ta].map(function(Da) {
							return Da.toLowerCase()
						}) : aa[ta.toLowerCase()] =
						Q[ta];
					return aa
				}

				function E(Q) {
					Q = Q || {};
					var aa = {},
						ta;
					for (ta in Q) aa[ta] = Q[ta];
					Q = aa;
					Q.stripIgnoreTag && (Q.onIgnoreTag && console.error('Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'), Q.onIgnoreTag = pa.onIgnoreTagStripAll);
					Q.whiteList = Q.whiteList || Q.allowList ? B(Q.whiteList || Q.allowList) : pa.whiteList;
					Q.onTag = Q.onTag || pa.onTag;
					Q.onTagAttr = Q.onTagAttr || pa.onTagAttr;
					Q.onIgnoreTag = Q.onIgnoreTag || pa.onIgnoreTag;
					Q.onIgnoreTagAttr = Q.onIgnoreTagAttr || pa.onIgnoreTagAttr;
					Q.safeAttrValue =
						Q.safeAttrValue || pa.safeAttrValue;
					Q.escapeHtml = Q.escapeHtml || pa.escapeHtml;
					this.options = Q;
					!1 === Q.css ? this.cssFilter = !1 : (Q.css = Q.css || {}, this.cssFilter = new ea(Q.css))
				}

				function z(Q) {
					Q = Q ? .closest("[dir]");
					return null !== Q && Q instanceof HTMLElement && "rtl" === Q.dir || "rtl" === document.dir
				}
				var C = function(Q) {
						if ("object" !== typeof Q || null === Q || "[object Object]" !== Object.prototype.toString.call(Q)) return !1;
						var aa = Object.getPrototypeOf(Q);
						if (null === aa) return !0;
						for (; null !== Object.getPrototypeOf(aa);) aa = Object.getPrototypeOf(aa);
						return Object.getPrototypeOf(Q) === aa
					},
					D = {
						exports: {}
					},
					J = {};
				e = {
					exports: {}
				};
				var K = {},
					H = /javascript\s*:/gim;
				K.whiteList = v();
				K.getDefaultWhiteList = v;
				K.onAttr = function(Q, aa, ta) {};
				K.onIgnoreAttr = function(Q, aa, ta) {};
				K.safeAttrValue = function(Q, aa) {
					return H.test(aa) ? "" : aa
				};
				var G = {
						indexOf: function(Q, aa) {
							var ta;
							if (Array.prototype.indexOf) return Q.indexOf(aa);
							var Da = 0;
							for (ta = Q.length; Da < ta; Da++)
								if (Q[Da] === aa) return Da;
							return -1
						},
						forEach: function(Q, aa, ta) {
							var Da;
							if (Array.prototype.forEach) return Q.forEach(aa, ta);
							var Ga = 0;
							for (Da = Q.length; Ga < Da; Ga++) aa.call(ta, Q[Ga], Ga, Q)
						},
						trim: function(Q) {
							return String.prototype.trim ? Q.trim() : Q.replace(/(^\s*)|(\s*$)/g, "")
						},
						trimRight: function(Q) {
							return String.prototype.trimRight ? Q.trimRight() : Q.replace(/(\s*$)/g, "")
						}
					},
					F = K,
					L = function(Q, aa) {
						function ta() {
							if (!Ga) {
								var Wa = G.trim(Q.slice(Na, Ma)),
									Xa = Wa.indexOf(":");
								if (-1 !== Xa) {
									var bb = G.trim(Wa.slice(0, Xa));
									Xa = G.trim(Wa.slice(Xa + 1));
									bb && (Wa = aa(Na, Ta.length, bb, Xa, Wa)) && (Ta += Wa + "; ")
								}
							}
							Na = Ma + 1
						}
						Q = G.trimRight(Q);
						";" !== Q[Q.length - 1] && (Q +=
							";");
						for (var Da = Q.length, Ga = !1, Na = 0, Ma = 0, Ta = ""; Ma < Da; Ma++) {
							var Ra = Q[Ma];
							if ("/" === Ra && "*" === Q[Ma + 1]) {
								Ra = Q.indexOf("*/", Ma + 2);
								if (-1 === Ra) break;
								Ma = Ra + 1;
								Na = Ma + 1;
								Ga = !1
							} else "(" === Ra ? Ga = !0 : ")" === Ra ? Ga = !1 : ";" === Ra ? Ga || ta() : "\n" === Ra && ta()
						}
						return G.trim(Ta)
					};
				m.prototype.process = function(Q) {
					Q = (Q || "")
						.toString();
					if (!Q) return "";
					var aa = this.options,
						ta = aa.whiteList,
						Da = aa.onAttr,
						Ga = aa.onIgnoreAttr,
						Na = aa.safeAttrValue;
					return L(Q, function(Ma, Ta, Ra, Wa, Xa) {
						var bb = ta[Ra],
							$a = !1;
						!0 === bb ? $a = bb : "function" === typeof bb ? $a =
							bb(Wa) : bb instanceof RegExp && ($a = bb.test(Wa));
						!0 !== $a && ($a = !1);
						if (Wa = Na(Ra, Wa)) {
							Ma = {
								position: Ta,
								sourcePosition: Ma,
								source: Xa,
								isWhite: $a
							};
							if ($a) return $a = Da(Ra, Wa, Ma), void 0 === $a || null === $a ? Ra + ":" + Wa : $a;
							$a = Ga(Ra, Wa, Ma);
							if (void 0 !== $a && null !== $a) return $a
						}
					})
				};
				(function(Q, aa) {
					aa = Q.exports = function(Da, Ga) {
						return (new m(Ga))
							.process(Da)
					};
					aa.FilterCSS = m;
					for (var ta in K) aa[ta] = K[ta]
				})(e, e.exports);
				var R = {
						indexOf: function(Q, aa) {
							var ta;
							if (Array.prototype.indexOf) return Q.indexOf(aa);
							var Da = 0;
							for (ta = Q.length; Da <
								ta; Da++)
								if (Q[Da] === aa) return Da;
							return -1
						},
						forEach: function(Q, aa, ta) {
							var Da;
							if (Array.prototype.forEach) return Q.forEach(aa, ta);
							var Ga = 0;
							for (Da = Q.length; Ga < Da; Ga++) aa.call(ta, Q[Ga], Ga, Q)
						},
						trim: function(Q) {
							return String.prototype.trim ? Q.trim() : Q.replace(/(^\s*)|(\s*$)/g, "")
						},
						spaceIndex: function(Q) {
							return (Q = /\s|\n|\t/.exec(Q)) ? Q.index : -1
						}
					},
					V = e.exports.getDefaultWhiteList,
					U = R,
					W = new e.exports.FilterCSS,
					M = /</g,
					T = />/g,
					Z = /"/g,
					oa = /&quot;/g,
					qa = /&#([a-zA-Z0-9]*);?/gim,
					Aa = /&colon;?/gim,
					Ka = /&newline;?/gim,
					da = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi,
					ja = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi,
					sa = /u\s*r\s*l\s*\(.*/gi;
				J.whiteList = f();
				J.getDefaultWhiteList = f;
				J.onTag = function(Q, aa, ta) {};
				J.onIgnoreTag = function(Q, aa, ta) {};
				J.onTagAttr = function(Q, aa, ta) {};
				J.onIgnoreTagAttr = function(Q, aa, ta) {};
				J.safeAttrValue = function(Q, aa, ta, Da) {
					ta = h(ta);
					if ("href" === aa || "src" === aa) {
						ta = U.trim(ta);
						if ("#" === ta) return "#";
						if ("http://" !== ta.substr(0, 7) && "https://" !== ta.substr(0, 8) && "mailto:" !== ta.substr(0, 7) && "tel:" !== ta.substr(0, 4) && "data:image/" !== ta.substr(0, 11) &&
							"ftp://" !== ta.substr(0, 6) && "./" !== ta.substr(0, 2) && "../" !== ta.substr(0, 3) && "#" !== ta[0] && "/" !== ta[0]) return ""
					} else if ("background" === aa) {
						if (da.lastIndex = 0, da.test(ta)) return ""
					} else if ("style" === aa) {
						ja.lastIndex = 0;
						if (ja.test(ta)) return "";
						sa.lastIndex = 0;
						if (sa.test(ta) && (da.lastIndex = 0, da.test(ta))) return "";
						!1 !== Da && (Da = Da || W, ta = Da.process(ta))
					}
					return ta = q(ta)
				};
				J.escapeHtml = g;
				J.escapeQuote = l;
				J.unescapeQuote = r;
				J.escapeHtmlEntities = p;
				J.escapeDangerHtml5Entities = n;
				J.clearNonPrintableCharacter = t;
				J.friendlyAttrValue =
					h;
				J.escapeAttrValue = q;
				J.onIgnoreTagStripAll = function() {
					return ""
				};
				J.StripTagBody = function(Q, aa) {
					"function" !== typeof aa && (aa = function() {});
					var ta = !Array.isArray(Q),
						Da = [],
						Ga = !1;
					return {
						onIgnoreTag: function(Na, Ma, Ta) {
							var Ra = ta ? !0 : -1 !== U.indexOf(Q, Na);
							if (Ra) {
								if (Ta.isClosing) return Da.push([!1 !== Ga ? Ga : Ta.position, Ta.position + 10]), Ga = !1, "[/removed]";
								Ga || (Ga = Ta.position);
								return "[removed]"
							}
							return aa(Na, Ma, Ta)
						},
						remove: function(Na) {
							var Ma = "",
								Ta = 0;
							U.forEach(Da, function(Ra) {
								Ma += Na.slice(Ta, Ra[0]);
								Ta = Ra[1]
							});
							return Ma +=
								Na.slice(Ta)
						}
					}
				};
				J.stripCommentTag = function(Q) {
					for (var aa = "", ta = 0; ta < Q.length;) {
						var Da = Q.indexOf("\x3c!--", ta);
						if (-1 === Da) {
							aa += Q.slice(ta);
							break
						}
						aa += Q.slice(ta, Da);
						ta = Q.indexOf("--\x3e", Da);
						if (-1 === ta) break;
						ta += 3
					}
					return aa
				};
				J.stripBlankChar = function(Q) {
					Q = Q.split("");
					Q = Q.filter(function(aa) {
						aa = aa.charCodeAt(0);
						return 127 === aa ? !1 : 31 >= aa ? 10 === aa || 13 === aa ? !0 : !1 : !0
					});
					return Q.join("")
				};
				J.cssFilter = W;
				J.getDefaultCSSWhiteList = V;
				var I = {},
					N = /[^a-zA-Z0-9\\_:.-]/gim;
				I.parseTag = function(Q, aa, ta) {
					var Da = "",
						Ga =
						0,
						Na = !1,
						Ma = !1,
						Ta = 0,
						Ra = Q.length,
						Wa = "",
						Xa = "";
					Ta = 0;
					a: for (; Ta < Ra; Ta++)
						if (Xa = Q.charAt(Ta), !1 === Na) "\x3c" === Xa && (Na = Ta);
						else if (!1 === Ma)
						if ("\x3c" === Xa) Da += ta(Q.slice(Ga, Ta)), Ga = Na = Ta;
						else if ("\x3e" === Xa) Da += ta(Q.slice(Ga, Na)), Xa = Q.slice(Na, Ta + 1), Ga = void 0, Ga = Xa, Wa = R.spaceIndex(Ga), Ga = -1 === Wa ? Ga.slice(1, -1) : Ga.slice(1, Wa + 1), Ga = R.trim(Ga)
						.toLowerCase(), "/" === Ga.slice(0, 1) && (Ga = Ga.slice(1)), "/" === Ga.slice(-1) && (Ga = Ga.slice(0, -1)), Wa = Ga, Da += aa(Na, Da.length, Wa, Xa, "\x3c/" === Xa.slice(0, 2)), Ga = Ta + 1, Na = !1;
					else {
						if ('"' ===
							Xa || "'" === Xa) {
							Wa = 1;
							for (var bb = Q.charAt(Ta - Wa);
								"" === bb.trim() || "\x3d" === bb;) {
								if ("\x3d" === bb) {
									Ma = Xa;
									continue a
								}
								bb = Q.charAt(Ta - ++Wa)
							}
						}
					} else Xa === Ma && (Ma = !1);
					Ga < Q.length && (Da += ta(Q.substr(Ga)));
					return Da
				};
				I.parseAttr = function(Q, aa) {
					function ta(Xa, bb) {
						Xa = R.trim(Xa);
						Xa = Xa.replace(N, "")
							.toLowerCase();
						1 > Xa.length || (Xa = aa(Xa, bb || "")) && Na.push(Xa)
					}
					for (var Da = 0, Ga = 0, Na = [], Ma = !1, Ta = Q.length, Ra = 0; Ra < Ta; Ra++) {
						var Wa = Q.charAt(Ra);
						if (!1 === Ma && "\x3d" === Wa) Ma = Q.slice(Da, Ra), Da = Ra + 1, Ga = '"' === Q.charAt(Da) || "'" === Q.charAt(Da) ?
							Da : x(Q, Ra + 1);
						else {
							if (!1 !== Ma && Ra === Ga)
								if (Wa = Q.indexOf(Wa, Ra + 1), -1 === Wa) break;
								else {
									Da = R.trim(Q.slice(Ga + 1, Wa));
									ta(Ma, Da);
									Ma = !1;
									Ra = Wa;
									Da = Ra + 1;
									continue
								}
							/\s|\n|\t/.test(Wa) && (Q = Q.replace(/\s|\n|\t/g, " "), !1 === Ma ? (Wa = u(Q, Ra), -1 === Wa ? (Da = R.trim(Q.slice(Da, Ra)), ta(Da), Ma = !1, Da = Ra + 1) : Ra = Wa - 1) : (Wa = y(Q, Ra - 1), -1 === Wa && (Da = R.trim(Q.slice(Da, Ra)), Da = w(Da), ta(Ma, Da), Ma = !1, Da = Ra + 1)))
						}
					}
					Da < Q.length && (!1 === Ma ? ta(Q.slice(Da)) : ta(Ma, w(R.trim(Q.slice(Da)))));
					return R.trim(Na.join(" "))
				};
				var ea = e.exports.FilterCSS,
					pa =
					J,
					xa = I.parseTag,
					S = I.parseAttr,
					ba = R;
				E.prototype.process = function(Q) {
					Q = (Q || "")
						.toString();
					if (!Q) return "";
					var aa = this.options,
						ta = aa.whiteList,
						Da = aa.onTag,
						Ga = aa.onIgnoreTag,
						Na = aa.onTagAttr,
						Ma = aa.onIgnoreTagAttr,
						Ta = aa.safeAttrValue,
						Ra = aa.escapeHtml,
						Wa = this.cssFilter;
					aa.stripBlankChar && (Q = pa.stripBlankChar(Q));
					aa.allowCommentTag || (Q = pa.stripCommentTag(Q));
					var Xa = !1;
					aa.stripIgnoreTagBody && (Xa = pa.StripTagBody(aa.stripIgnoreTagBody, Ga), Ga = Xa.onIgnoreTag);
					Q = xa(Q, function(bb, $a, Ya, ab, Qa) {
						bb = {
							sourcePosition: bb,
							position: $a,
							isClosing: Qa,
							isWhite: Object.prototype.hasOwnProperty.call(ta, Ya)
						};
						$a = Da(Ya, ab, bb);
						if (void 0 !== $a && null !== $a) return $a;
						if (bb.isWhite) {
							if (bb.isClosing) return "\x3c/" + Ya + "\x3e";
							bb = A(ab);
							var Ba = ta[Ya];
							$a = S(bb.html, function(O, Y) {
								var ya = -1 !== ba.indexOf(Ba, O),
									za = Na(Ya, O, Y, ya);
								if (void 0 !== za && null !== za) return za;
								if (ya) return (Y = Ta(Ya, O, Y, Wa)) ? O + '\x3d"' + Y + '"' : O;
								za = Ma(Ya, O, Y, ya);
								if (void 0 !== za && null !== za) return za
							});
							ab = "\x3c" + Ya;
							$a && (ab += " " + $a);
							bb.closing && (ab += " /");
							return ab + "\x3e"
						}
						$a = Ga(Ya, ab,
							bb);
						return void 0 !== $a && null !== $a ? $a : Ra(ab)
					}, Ra);
					Xa && (Q = Xa.remove(Q));
					return Q
				};
				(function(Q, aa) {
					function ta(Ga, Na) {
						return (new Da(Na))
							.process(Ga)
					}
					var Da = E;
					aa = Q.exports = ta;
					aa.filterXSS = ta;
					aa.FilterXSS = Da;
					(function() {
						for (var Ga in J) aa[Ga] = J[Ga];
						for (var Na in I) aa[Na] = I[Na]
					})();
					"undefined" !== typeof self && "undefined" !== typeof DedicatedWorkerGlobalScope && self instanceof DedicatedWorkerGlobalScope && (self.filterXSS = Q.exports)
				})(D, D.exports);
				e = function() {
					function Q(aa, ta) {
						var Da = this;
						this.arcgisWhiteList = {
							a: ["href", "style", "target"],
							abbr: ["title"],
							audio: ["autoplay", "controls", "loop", "muted", "preload"],
							b: [],
							br: [],
							dd: ["style"],
							div: ["align", "style"],
							dl: ["style"],
							dt: ["style"],
							em: [],
							figcaption: ["style"],
							figure: ["style"],
							font: ["color", "face", "size", "style"],
							h1: ["style"],
							h2: ["style"],
							h3: ["style"],
							h4: ["style"],
							h5: ["style"],
							h6: ["style"],
							hr: [],
							i: [],
							img: "alt border height src style width".split(" "),
							li: [],
							ol: [],
							p: ["style"],
							source: ["media", "src", "type"],
							span: ["style"],
							strong: [],
							sub: ["style"],
							sup: ["style"],
							table: "border cellpadding cellspacing height style width".split(" "),
							tbody: [],
							tr: ["align", "height", "style", "valign"],
							td: "align colspan height nowrap rowspan style valign width".split(" "),
							th: "align colspan height nowrap rowspan style valign width".split(" "),
							u: [],
							ul: [],
							video: "autoplay controls height loop muted poster preload width".split(" ")
						};
						this.allowedProtocols = "http https mailto iform tel flow lfmobile arcgis-navigator arcgis-appstudio-player arcgis-survey123 arcgis-collector arcgis-workforce arcgis-explorer arcgis-trek2there arcgis-quickcapture mspbi comgooglemaps pdfefile pdfehttp pdfehttps boxapp boxemm awb awbs gropen radarscope".split(" ");
						this.arcgisFilterOptions = {
							allowCommentTag: !0,
							safeAttrValue: function(Na, Ma, Ta, Ra) {
								return "a" === Na && "href" === Ma || ("img" === Na || "source" === Na) && "src" === Ma ? Da.sanitizeUrl(Ta) : D.exports.safeAttrValue(Na, Ma, Ta, Ra)
							}
						};
						this._entityMap = {
							"\x26": "\x26#x38;",
							"\x3c": "\x26#x3C;",
							"\x3e": "\x26#x3E;",
							'"': "\x26#x22;",
							"'": "\x26#x27;",
							"/": "\x26#x2F;"
						};
						if (aa && !ta) var Ga = aa;
						else aa && ta ? (Ga = Object.create(this.arcgisFilterOptions), Object.keys(aa)
							.forEach(function(Na) {
								"whiteList" === Na ? Ga.whiteList = Da._extendObjectOfArrays([Da.arcgisWhiteList,
									aa.whiteList || {}
								]) : Ga[Na] = aa[Na]
							})) : (Ga = Object.create(this.arcgisFilterOptions), Ga.whiteList = this.arcgisWhiteList);
						this.xssFilterOptions = Ga;
						this._xssFilter = new D.exports.FilterXSS(Ga)
					}
					Q.prototype.sanitize = function(aa, ta) {
						void 0 === ta && (ta = {});
						switch (typeof aa) {
							case "number":
								return isNaN(aa) || !isFinite(aa) ? null : aa;
							case "boolean":
								return aa;
							case "string":
								return this._xssFilter.process(aa);
							case "object":
								return this._iterateOverObject(aa, ta);
							default:
								if (!ta.allowUndefined || "undefined" !== typeof aa) return null
						}
					};
					Q.prototype.sanitizeUrl = function(aa, ta) {
						ta = (null !== ta && void 0 !== ta ? ta : {})
							.isProtocolRequired;
						ta = void 0 === ta ? !0 : ta;
						var Da = this._trim(aa.substring(0, aa.indexOf(":"))),
							Ga = "/" === aa,
							Na = /^#/.test(aa),
							Ma = Da && -1 < this.allowedProtocols.indexOf(Da.toLowerCase());
						return Ga || Na || Ma ? D.exports.escapeAttrValue(aa) : Da || ta ? "" : D.exports.escapeAttrValue("https://".concat(aa))
					};
					Q.prototype.sanitizeHTMLAttribute = function(aa, ta, Da, Ga) {
						return "function" === typeof this.xssFilterOptions.safeAttrValue ? this.xssFilterOptions.safeAttrValue(aa,
							ta, Da, Ga) : D.exports.safeAttrValue(aa, ta, Da, Ga)
					};
					Q.prototype.validate = function(aa, ta) {
						void 0 === ta && (ta = {});
						ta = this.sanitize(aa, ta);
						return {
							isValid: aa === ta,
							sanitized: ta
						}
					};
					Q.prototype.encodeHTML = function(aa) {
						var ta = this;
						return String(aa)
							.replace(/[&<>"'\/]/g, function(Da) {
								return ta._entityMap[Da]
							})
					};
					Q.prototype.encodeAttrValue = function(aa) {
						var ta = /^[a-zA-Z0-9]$/;
						return String(aa)
							.replace(/[\x00-\xFF]/g, function(Da, Ga) {
								return ta.test(Da) ? Da : "\x26#x".concat(Number(aa.charCodeAt(Ga))
									.toString(16), ";")
							})
					};
					Q.prototype._extendObjectOfArrays = function(aa) {
						var ta = {};
						aa.forEach(function(Da) {
							Object.keys(Da)
								.forEach(function(Ga) {
									Array.isArray(Da[Ga]) && Array.isArray(ta[Ga]) ? ta[Ga] = ta[Ga].concat(Da[Ga]) : ta[Ga] = Da[Ga]
								})
						});
						return ta
					};
					Q.prototype._iterateOverObject = function(aa, ta) {
						var Da = this;
						void 0 === ta && (ta = {});
						try {
							var Ga = !1,
								Na = void 0;
							if (Array.isArray(aa)) Na = aa.reduce(function(Ma, Ta) {
								var Ra = Da.validate(Ta, ta);
								if (Ra.isValid) return Ma.concat([Ta]);
								Ga = !0;
								return Ma.concat([Ra.sanitized])
							}, []);
							else if (C(aa)) Na = Object.keys(aa)
								.reduce(function(Ma,
									Ta) {
									var Ra = aa[Ta],
										Wa = Da.validate(Ra, ta);
									Wa.isValid ? Ma[Ta] = Ra : (Ga = !0, Ma[Ta] = Wa.sanitized);
									return Ma
								}, {});
							else return ta.allowUndefined && "undefined" === typeof aa ? void 0 : null;
							return Ga ? Na : aa
						} catch (Ma) {
							return null
						}
					};
					Q.prototype._trim = function(aa) {
						return String.prototype.trim ? aa.trim() : aa.replace(/(^\s*)|(\s*$)/g, "")
					};
					return Q
				}();
				var la, ha, P = function(Q) {
						if ("WebkitTransition" in Q.style) la = "webkitTransitionEnd", ha = "webkitAnimationEnd";
						else if ("transition" in Q.style) la = "transitionend", ha = "animationend";
						else throw Error("Your browser is not supported!");
					},
					ca = function(Q, aa) {
						void 0 === aa && (aa = Q + "-active");
						return function(ta) {
							la || P(ta);
							var Da = !1,
								Ga = function(Na) {
									Da || (Da = !0, ta.removeEventListener(la, Ga), ta.removeEventListener(ha, Ga), ta.classList.remove(Q), ta.classList.remove(aa))
								};
							ta.classList.add(Q);
							ta.addEventListener(la, Ga);
							ta.addEventListener(ha, Ga);
							requestAnimationFrame(function() {
								ta.classList.add(aa)
							})
						}
					},
					ka = function(Q, aa) {
						void 0 === aa && (aa = Q + "-active");
						return function(ta, Da) {
							la || P(ta);
							var Ga = !1,
								Na = function(Ma) {
									Ga || (Ga = !0, ta.removeEventListener(la,
										Na), ta.removeEventListener(ha, Na), Da())
								};
							ta.classList.add(Q);
							ta.addEventListener(la, Na);
							ta.addEventListener(ha, Na);
							requestAnimationFrame(function() {
								ta.classList.add(aa)
							})
						}
					};
				const va = d.getLogger("esri.widgets.support.widgetUtils");
				d = (() => {
					const Q = new Map,
						aa = new ResizeObserver(ta => {
							k.clearVNodeCache();
							for (const Da of ta) Q.get(Da.target) ? .(Da)
						});
					return (ta, Da, Ga) => {
						Q.has(ta) && va.error("Already observing element", ta);
						Q.set(ta, Da);
						aa.observe(ta, Ga);
						return c.makeHandle(() => {
							aa.unobserve(ta);
							Q.delete(ta)
						})
					}
				})();
				V = "dd dl dt h1 h2 h3 h4 h5 h6 sub sup animate animatetransform circle clippath defs ellipse g image line lineargradient marker mask path pattern polygon polyline radialgradient rect stop svg switch symbol text textpath tspan use".split(" ");
				const Ca = V.reduce((Q, aa) => {
						Q[aa] = [];
						return Q
					}, {}),
					ma = "align alink alt bgcolor border cellpadding cellspacing class color cols colspan coords d dir face height hspace ismap lang marginheight marginwidth multiple nohref noresize noshade nowrap ref rel rev rows rowspan scrolling shape span summary tabindex title usemap valign value vlink vspace width".split(" ");
				e = new e({
					whiteList: Ca,
					onTagAttr: (Q, aa, ta) => {
						Q = `${aa}="${ta}"`;
						if (ma.includes(aa)) return Q
					},
					stripIgnoreTag: !0,
					stripIgnoreTagBody: ["script", "style"]
				}, !0);
				a.additionalAllowedTags = V;
				a.classes = function(Q) {
					const aa = b.acquire();
					for (var ta = 0; ta < arguments.length; ta++) {
						const Da = arguments[ta],
							Ga = typeof Da;
						if ("string" === Ga) aa.push(Da);
						else if (Array.isArray(Da)) aa.push.apply(aa, Da);
						else if ("object" === Ga)
							for (const Na in Da) Da[Na] && aa.push(Na)
					}
					ta = aa.join(" ");
					b.release(aa);
					return ta
				};
				a.cssTransition = function(Q,
					aa) {
					return ("enter" === Q ? ca : ka)(aa)
				};
				a.discardNode = function(Q) {
					this[Q.getAttribute("data-node-ref")] = null
				};
				a.getDir = function(Q) {
					return z(Q) ? "rtl" : "ltr"
				};
				a.isActivationKey = function(Q) {
					return "Enter" === Q || " " === Q
				};
				a.isRTL = z;
				a.keepMenuItemWithinView = function(Q, aa) {
					const ta = Q.getBoundingClientRect();
					aa = aa.getBoundingClientRect();
					const Da = ta.top,
						Ga = aa.top;
					(ta.top + ta.height > aa.top + aa.height || Da < Ga) && Q.scrollIntoView({
						block: "end"
					})
				};
				a.onResize = d;
				a.renderingSanitizer = e;
				a.safeAttrs = ma;
				a.storeNode = function(Q) {
					this[Q.getAttribute("data-node-ref")] =
						Q
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/widgets/support/vnodeCache": function() {
			define(["exports"], function(a) {
				const b = new Map;
				a.clearVNodeCache = function() {
					b.clear()
				};
				a.deleteVNodeCache = function(c) {
					b.delete(c)
				};
				a.getVNodeCache = function(c) {
					return b.get(c)
				};
				a.setVNodeCache = function(c, e) {
					b.set(c, e)
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/libs/maquette/projector": function() {
			define(["exports",
				"./dom"
			], function(a, b) {
				let c;
				c = Array.prototype.find ? (k, v) => k.find(v) : (k, v) => k.filter(v)[0];
				let e = (k, v) => {
						let m = k;
						v.forEach(f => {
							m = m && m.children ? c(m.children, g => g.domNode === f) : void 0
						});
						return m
					},
					d = (k, v, m) => {
						let f = function(g) {
							m("domEvent", g);
							var l = v(),
								r = g.currentTarget,
								p = l.domNode;
							let n = [];
							for (; r && r !== p;) n.push(r), r = r.parentNode;
							n.reverse();
							l = e(l.getLastRender(), n);
							k.scheduleRender();
							let t;
							l && (t = l.properties[`on${g.type}`].apply(l.properties.bind || this, arguments));
							m("domEventProcessed", g);
							return t
						};
						return (g, l, r, p) => f
					};
				a.createProjector = k => {
					let v, m = b.applyDefaultProjectionOptions(k),
						f = m.performanceLogger,
						g = !0,
						l, r = !1,
						p = [],
						n = [],
						t = (q, u, x) => {
							let y;
							m.eventHandlerInterceptor = d(v, () => y, f);
							y = q(u, x(), m);
							p.push(y);
							n.push(x)
						},
						h = () => {
							l = void 0;
							if (g) {
								g = !1;
								f("renderStart", void 0);
								for (let q = 0; q < p.length; q++) {
									let u = n[q]();
									f("rendered", void 0);
									p[q].update(u);
									f("patched", void 0)
								}
								f("renderDone", void 0);
								g = !0
							}
						};
					return v = {
						renderNow: h,
						scheduleRender: () => {
							l || r || (l = requestAnimationFrame(h))
						},
						stop: () => {
							l && (cancelAnimationFrame(l),
								l = void 0);
							r = !0
						},
						resume: () => {
							r = !1;
							g = !0;
							v.scheduleRender()
						},
						append: (q, u) => {
							t(b.dom.append, q, u)
						},
						insertBefore: (q, u) => {
							t(b.dom.insertBefore, q, u)
						},
						merge: (q, u) => {
							t(b.dom.merge, q, u)
						},
						replace: (q, u) => {
							t(b.dom.replace, q, u)
						},
						detach: q => {
							for (let u = 0; u < n.length; u++)
								if (n[u] === q) return n.splice(u, 1), p.splice(u, 1)[0];
							throw Error("renderFunction was not found");
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/libs/maquette-advanced-projector/advanced-projector-options": function() {
			define(["exports"],
				function(a) {
					a.defaultAdvancedProjectorOptions = {
						handleInterceptedEvent: (b, c, e, d) => {
							b.scheduleRender();
							return c.properties[`on${d.type}`].apply(c.properties.bind || e, [d])
						}
					};
					Object.defineProperties(a, {
						__esModule: {
							value: !0
						},
						[Symbol.toStringTag]: {
							value: "Module"
						}
					})
				})
		},
		"esri/libs/maquette-advanced-projector/utils": function() {
			define(["exports"], function(a) {
				const b = {
					namespace: void 0,
					performanceLogger: () => {},
					eventHandlerInterceptor: void 0,
					styleApplyer: (c, e, d) => {
						c.style[e] = d
					}
				};
				a.applyDefaultProjectionOptions =
					c => ({
						...b,
						...c
					});
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/chunks/componentsUtils": function() {
			define(["exports", "../assets", "../core/has", "../core/urlUtils"], function(a, b, c, e) {
				function d(O) {
					return O.map(Y => {
							let ya = "";
							for (let za = 0; za < Y; za++) ya += (65536 * (1 + Math.random()) | 0)
								.toString(16)
								.substring(1);
							return ya
						})
						.join("-")
				}

				function k(O, Y) {
					function ya(za) {
						if (za) {
							var fa;
							(fa = za.closest(Y)) || (za = za.getRootNode()
								.host || null, fa = ya(za));
							za = fa
						} else za = null;
						return za
					}
					return ya(O)
				}

				function v(O, Y) {
					return m(O, Y)
				}

				function m(O, Y) {
					if (O) {
						var ya = Y(O);
						if (void 0 !== ya) return ya;
						({
							parentNode: O
						} = O);
						return m(O instanceof ShadowRoot ? O.host : O, Y)
					}
				}

				function f(O) {
					return "function" === typeof(null === O || void 0 === O ? void 0 : O.setFocus)
				}

				function g(O, Y) {
					return O ? Array.from(O.children || [])
						.filter(ya => null === ya || void 0 === ya ? void 0 : ya.matches(Y)) : []
				}

				function l(O, Y, ya) {
					Y = ":not([slot])" === Y ? g(O, ":not([slot])") : Array.from(O.querySelectorAll(Y));
					Y = ya && !1 === ya.direct ? Y : Y.filter(fa => fa.parentElement ===
						O);
					Y = (null === ya || void 0 === ya ? 0 : ya.matches) ? Y.filter(fa => null === fa || void 0 === fa ? void 0 : fa.matches(ya.matches)) : Y;
					const za = null === ya || void 0 === ya ? void 0 : ya.selector;
					return za ? Y.map(fa => Array.from(fa.querySelectorAll(za)))
						.reduce((fa, Pa) => [...fa, ...Pa], [])
						.filter(fa => !!fa) : Y
				}

				function r(O, Y, ya) {
					Y = ":not([slot])" === Y ? g(O, ":not([slot])")[0] || null : O.querySelector(Y);
					Y = ya && !1 === ya.direct ? Y : (null === Y || void 0 === Y ? void 0 : Y.parentElement) === O ? Y : null;
					Y = (null === ya || void 0 === ya ? 0 : ya.matches) ? (null === Y || void 0 ===
						Y ? 0 : Y.matches(ya.matches)) ? Y : null : Y;
					return (O = null === ya || void 0 === ya ? void 0 : ya.selector) ? null === Y || void 0 === Y ? void 0 : Y.querySelector(O) : Y
				}

				function p() {
					const {
						classList: O
					} = document.body, Y = window.matchMedia("(prefers-color-scheme: dark)")
						.matches, ya = fa => document.body.dispatchEvent(new CustomEvent("calciteThemeChange", {
							bubbles: !0,
							detail: {
								theme: fa
							}
						}));
					let za = O.contains("calcite-theme-dark") || O.contains("calcite-theme-auto") && Y ? "dark" : "light";
					ya(za);
					window.matchMedia("(prefers-color-scheme: dark)")
						.addEventListener("change",
							fa => {
								fa = fa.matches ? "dark" : "light";
								za !== fa && ya(fa);
								za = fa
							});
					(new MutationObserver(() => {
						var fa = O.contains("calcite-theme-dark") || O.contains("calcite-theme-auto") && Y ? "dark" : "light";
						za !== fa && ya(fa);
						za = fa
					}))
					.observe(document.body, {
						attributes: !0,
						attributeFilter: ["class"]
					})
				}
				let n, t, h, q = !1,
					u = !1,
					x = !1,
					y = !1,
					w = !1;
				const A = (O, Y) => () => {},
					B = {},
					E = O => {
						O = typeof O;
						return "object" === O || "function" === O
					},
					z = (O, Y, ...ya) => {
						let za = null,
							fa = null,
							Pa = null,
							Sa = !1,
							Ua = !1;
						const Za = [],
							db = fb => {
								for (let ib = 0; ib < fb.length; ib++)
									if (za = fb[ib],
										Array.isArray(za)) db(za);
									else if (null != za && "boolean" !== typeof za) {
									if (Sa = "function" !== typeof O && !E(za)) za = String(za);
									Sa && Ua ? Za[Za.length - 1].$text$ += za : Za.push(Sa ? C(null, za) : za);
									Ua = Sa
								}
							};
						db(ya);
						if (Y) {
							Y.key && (fa = Y.key);
							Y.name && (Pa = Y.name);
							const fb = Y.className || Y.class;
							fb && (Y.class = "object" !== typeof fb ? fb : Object.keys(fb)
								.filter(ib => fb[ib])
								.join(" "))
						}
						if ("function" === typeof O) return O(null === Y ? {} : Y, Za, J);
						ya = C(O, null);
						ya.$attrs$ = Y;
						0 < Za.length && (ya.$children$ = Za);
						ya.$key$ = fa;
						ya.$name$ = Pa;
						return ya
					},
					C = (O,
						Y) => ({
						$flags$: 0,
						$tag$: O,
						$text$: Y,
						$elm$: null,
						$children$: null,
						$attrs$: null,
						$key$: null,
						$name$: null
					}),
					D = {},
					J = {
						forEach: (O, Y) => O.map(K)
							.forEach(Y),
						map: (O, Y) => O.map(K)
							.map(Y)
							.map(H)
					},
					K = O => ({
						vattrs: O.$attrs$,
						vchildren: O.$children$,
						vkey: O.$key$,
						vname: O.$name$,
						vtag: O.$tag$,
						vtext: O.$text$
					}),
					H = O => {
						if ("function" === typeof O.vtag) {
							var Y = Object.assign({}, O.vattrs);
							O.vkey && (Y.key = O.vkey);
							O.vname && (Y.name = O.vname);
							return z(O.vtag, Y, ...(O.vchildren || []))
						}
						Y = C(O.vtag, O.vtext);
						Y.$attrs$ = O.vattrs;
						Y.$children$ = O.vchildren;
						Y.$key$ = O.vkey;
						Y.$name$ = O.vname;
						return Y
					},
					G = O => Da.map(Y => Y(O))
					.find(Y => !!Y),
					F = (O, Y) => {
						if (null != O && !E(O)) {
							if (Y & 4) return "false" === O ? !1 : "" === O || !!O;
							if (Y & 2) return parseFloat(O);
							if (Y & 1) return String(O)
						}
						return O
					},
					L = new WeakMap,
					R = (O, Y, ya) => {
						let za = ta.get(O);
						Wa && ya ? (za = za || new CSSStyleSheet, "string" === typeof za ? za = Y : za.replaceSync(Y)) : za = Y;
						ta.set(O, za)
					},
					V = (O, Y) => "sc-" + (Y && O.$flags$ & 32 ? O.$tagName$ + "-" + Y : O.$tagName$),
					U = (O, Y, ya, za, fa, Pa) => {
						if (ya !== za) {
							let Za = Y in O,
								db = Y.toLowerCase();
							if ("class" === Y) {
								O = O.classList;
								const fb = ya ? ya.split(W) : [],
									ib = za ? za.split(W) : [];
								O.remove(...fb.filter(gb => gb && !ib.includes(gb)));
								O.add(...ib.filter(gb => gb && !fb.includes(gb)))
							} else if ("style" === Y) {
								for (var Sa in ya) za && null != za[Sa] || (Sa.includes("-") ? O.style.removeProperty(Sa) : O.style[Sa] = "");
								for (var Ua in za) ya && za[Ua] === ya[Ua] || (Ua.includes("-") ? O.style.setProperty(Ua, za[Ua]) : O.style[Ua] = za[Ua])
							} else if ("key" !== Y)
								if ("ref" === Y) za && za(O);
								else if (O.__lookupSetter__(Y) || "o" !== Y[0] || "n" !== Y[1]) {
								Sa = E(za);
								if ((Za || Sa && null !== za) && !fa) try {
									if (O.tagName.includes("-")) O[Y] =
										za;
									else if (Ua = null == za ? "" : za, "list" === Y) Za = !1;
									else if (null == ya || O[Y] != Ua) O[Y] = Ua
								} catch (fb) {}
								ya = !1;
								db !== (db = db.replace(/^xlink:?/, "")) && (Y = db, ya = !0);
								if (null == za || !1 === za) {
									if (!1 !== za || "" === O.getAttribute(Y)) ya ? O.removeAttributeNS("http://www.w3.org/1999/xlink", Y) : O.removeAttribute(Y)
								} else(!Za || Pa & 4 || fa) && !Sa && (za = !0 === za ? "" : za, ya ? O.setAttributeNS("http://www.w3.org/1999/xlink", Y, za) : O.setAttribute(Y, za))
							} else Y = "-" === Y[2] ? Y.slice(3) : db in Ga ? db.slice(2) : db[2] + Y.slice(3), ya && Ma.rel(O, Y, ya, !1), za && Ma.ael(O,
								Y, za, !1)
						}
					},
					W = /\s/,
					M = (O, Y, ya, za) => {
						const fa = 11 === Y.$elm$.nodeType && Y.$elm$.host ? Y.$elm$.host : Y.$elm$;
						O = O && O.$attrs$ || B;
						const Pa = Y.$attrs$ || B;
						for (za in O) za in Pa || U(fa, za, O[za], void 0, ya, Y.$flags$);
						for (za in Pa) U(fa, za, O[za], Pa[za], ya, Y.$flags$)
					},
					T = (O, Y, ya, za) => {
						Y = Y.$children$[ya];
						let fa = 0,
							Pa;
						q || (x = !0, "slot" === Y.$tag$ && (n && za.classList.add(n + "-s"), Y.$flags$ |= Y.$children$ ? 2 : 1));
						if (null !== Y.$text$) za = Y.$elm$ = Na.createTextNode(Y.$text$);
						else if (Y.$flags$ & 1) za = Y.$elm$ = Na.createTextNode("");
						else {
							y || (y =
								"svg" === Y.$tag$);
							za = Y.$elm$ = Na.createElementNS(y ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", Y.$flags$ & 2 ? "slot-fb" : Y.$tag$);
							y && "foreignObject" === Y.$tag$ && (y = !1);
							M(null, Y, y);
							null != n && za["s-si"] !== n && za.classList.add(za["s-si"] = n);
							if (Y.$children$)
								for (fa = 0; fa < Y.$children$.length; ++fa)(Pa = T(O, Y, fa, za)) && za.appendChild(Pa);
							"svg" === Y.$tag$ ? y = !1 : "foreignObject" === za.tagName && (y = !0)
						}
						za["s-hn"] = h;
						Y.$flags$ & 3 && (za["s-sr"] = !0, za["s-cr"] = t, za["s-sn"] = Y.$name$ || "", (ya = O && O.$children$ && O.$children$[ya]) &&
							ya.$tag$ === Y.$tag$ && O.$elm$ && Z(O.$elm$, !1));
						return za
					},
					Z = (O, Y) => {
						Ma.$flags$ |= 1;
						O = O.childNodes;
						for (let ya = O.length - 1; 0 <= ya; ya--) {
							const za = O[ya];
							za["s-hn"] !== h && za["s-ol"] && ((za["s-ol"] ? za["s-ol"] : za)
								.parentNode.insertBefore(za, za && za["s-ol"] || za), za["s-ol"].remove(), za["s-ol"] = void 0, x = !0);
							Y && Z(za, Y)
						}
						Ma.$flags$ &= -2
					},
					oa = (O, Y, ya, za, fa, Pa) => {
						let Sa = O["s-cr"] && O["s-cr"].parentNode || O,
							Ua;
						Sa.shadowRoot && Sa.tagName === h && (Sa = Sa.shadowRoot);
						for (; fa <= Pa; ++fa) za[fa] && (Ua = T(null, ya, fa, O)) && (za[fa].$elm$ = Ua, Sa.insertBefore(Ua,
							Y && Y["s-ol"] || Y))
					},
					qa = (O, Y, ya, za, fa) => {
						for (; Y <= ya; ++Y)
							if (za = O[Y]) fa = za.$elm$, N(za), u = !0, fa["s-ol"] ? fa["s-ol"].remove() : Z(fa, !0), fa.remove()
					},
					Aa = (O, Y) => O.$tag$ === Y.$tag$ ? "slot" === O.$tag$ ? O.$name$ === Y.$name$ : O.$key$ === Y.$key$ : !1,
					Ka = (O, Y) => {
						const ya = Y.$elm$ = O.$elm$,
							za = O.$children$,
							fa = Y.$children$,
							Pa = Y.$tag$;
						var Sa = Y.$text$;
						if (null === Sa) {
							y = "svg" === Pa ? !0 : "foreignObject" === Pa ? !1 : y;
							"slot" !== Pa && M(O, Y, y);
							if (null !== za && null !== fa) {
								var Ua = Sa = O = 0,
									Za = 0;
								let fb = za.length - 1,
									ib = za[0],
									gb = za[fb],
									kb = fa.length - 1,
									cb = fa[0],
									jb = fa[kb];
								for (; O <= fb && Sa <= kb;)
									if (null == ib) ib = za[++O];
									else if (null == gb) gb = za[--fb];
								else if (null == cb) cb = fa[++Sa];
								else if (null == jb) jb = fa[--kb];
								else if (Aa(ib, cb)) Ka(ib, cb), ib = za[++O], cb = fa[++Sa];
								else if (Aa(gb, jb)) Ka(gb, jb), gb = za[--fb], jb = fa[--kb];
								else if (Aa(ib, jb)) "slot" !== ib.$tag$ && "slot" !== jb.$tag$ || Z(ib.$elm$.parentNode, !1), Ka(ib, jb), ya.insertBefore(ib.$elm$, gb.$elm$.nextSibling), ib = za[++O], jb = fa[--kb];
								else if (Aa(gb, cb)) "slot" !== ib.$tag$ && "slot" !== jb.$tag$ || Z(gb.$elm$.parentNode, !1), Ka(gb, cb), ya.insertBefore(gb.$elm$,
									ib.$elm$), gb = za[--fb], cb = fa[++Sa];
								else {
									Ua = -1;
									for (Za = O; Za <= fb; ++Za)
										if (za[Za] && null !== za[Za].$key$ && za[Za].$key$ === cb.$key$) {
											Ua = Za;
											break
										} 0 <= Ua ? (Za = za[Ua], Za.$tag$ !== cb.$tag$ ? Ua = T(za && za[Sa], Y, Ua, ya) : (Ka(Za, cb), za[Ua] = void 0, Ua = Za.$elm$)) : Ua = T(za && za[Sa], Y, Sa, ya);
									cb = fa[++Sa];
									if (Ua) {
										Za = ib.$elm$;
										Za = (Za["s-ol"] ? Za["s-ol"] : Za)
											.parentNode;
										var db = ib.$elm$;
										Za.insertBefore.call(Za, Ua, db && db["s-ol"] || db)
									}
								}
								O > fb ? oa(ya, null == fa[kb + 1] ? null : fa[kb + 1].$elm$, Y, fa, Sa, kb) : Sa > kb && qa(za, O, fb)
							} else null !== fa ? (null !== O.$text$ &&
								(ya.textContent = ""), oa(ya, null, Y, fa, 0, fa.length - 1)) : null !== za && qa(za, 0, za.length - 1);
							y && "svg" === Pa && (y = !1)
						} else(Y = ya["s-cr"]) ? Y.parentNode.textContent = Sa : O.$text$ !== Sa && (ya.data = Sa)
					},
					da = O => {
						O = O.childNodes;
						let Y, ya, za, fa, Pa, Sa;
						ya = 0;
						for (za = O.length; ya < za; ya++)
							if (Y = O[ya], 1 === Y.nodeType) {
								if (Y["s-sr"])
									for (Pa = Y["s-sn"], Y.hidden = !1, fa = 0; fa < za; fa++)
										if (Sa = O[fa].nodeType, O[fa]["s-hn"] !== Y["s-hn"] || "" !== Pa) {
											if (1 === Sa && Pa === O[fa].getAttribute("slot")) {
												Y.hidden = !0;
												break
											}
										} else if (1 === Sa || 3 === Sa && "" !== O[fa].textContent.trim()) {
									Y.hidden = !0;
									break
								}
								da(Y)
							}
					},
					ja = [],
					sa = O => {
						let Y, ya, za, fa, Pa, Sa = 0;
						const Ua = O.childNodes,
							Za = Ua.length;
						for (; Sa < Za; Sa++) {
							O = Ua[Sa];
							if (O["s-sr"] && (Y = O["s-cr"]) && Y.parentNode)
								for (ya = Y.parentNode.childNodes, za = O["s-sn"], Pa = ya.length - 1; 0 <= Pa; Pa--) Y = ya[Pa], Y["s-cn"] || Y["s-nr"] || Y["s-hn"] === O["s-hn"] || (I(Y, za) ? (fa = ja.find(db => db.$nodeToRelocate$ === Y), u = !0, Y["s-sn"] = Y["s-sn"] || za, fa ? fa.$slotRefNode$ = O : ja.push({
									$slotRefNode$: O,
									$nodeToRelocate$: Y
								}), Y["s-sr"] && ja.map(db => {
									I(db.$nodeToRelocate$, Y["s-sn"]) && (fa = ja.find(fb => fb.$nodeToRelocate$ ===
										Y)) && !db.$slotRefNode$ && (db.$slotRefNode$ = fa.$slotRefNode$)
								})) : ja.some(db => db.$nodeToRelocate$ === Y) || ja.push({
									$nodeToRelocate$: Y
								}));
							1 === O.nodeType && sa(O)
						}
					},
					I = (O, Y) => 1 === O.nodeType ? null === O.getAttribute("slot") && "" === Y || O.getAttribute("slot") === Y ? !0 : !1 : O["s-sn"] === Y ? !0 : "" === Y,
					N = O => {
						O.$attrs$ && O.$attrs$.ref && O.$attrs$.ref(null);
						O.$children$ && O.$children$.map(N)
					},
					ea = (O, Y) => {
						const ya = O.$hostElement$;
						var za = O.$cmpMeta$,
							fa = O.$vnode$ || C(null, null);
						const Pa = Y && Y.$tag$ === D ? Y : z(null, null, Y);
						h = ya.tagName;
						za.$attrsToReflect$ &&
							(Pa.$attrs$ = Pa.$attrs$ || {}, za.$attrsToReflect$.map(([Sa, Ua]) => Pa.$attrs$[Ua] = ya[Sa]));
						Pa.$tag$ = null;
						Pa.$flags$ |= 4;
						O.$vnode$ = Pa;
						Pa.$elm$ = fa.$elm$ = ya.shadowRoot || ya;
						n = ya["s-sc"];
						t = ya["s-cr"];
						q = 0 !== (za.$flags$ & 1);
						u = !1;
						Ka(fa, Pa);
						Ma.$flags$ |= 1;
						if (x) {
							sa(Pa.$elm$);
							let Sa, Ua;
							for (za = 0; za < ja.length; za++) fa = ja[za], O = fa.$nodeToRelocate$, O["s-ol"] || (fa = Na.createTextNode(""), fa["s-nr"] = O, O.parentNode.insertBefore(O["s-ol"] = fa, O));
							for (za = 0; za < ja.length; za++)
								if (fa = ja[za], O = fa.$nodeToRelocate$, fa.$slotRefNode$) {
									Y =
										fa.$slotRefNode$.parentNode;
									Sa = fa.$slotRefNode$.nextSibling;
									for (fa = O["s-ol"]; fa = fa.previousSibling;)
										if ((Ua = fa["s-nr"]) && Ua["s-sn"] === O["s-sn"] && Y === Ua.parentNode && (Ua = Ua.nextSibling, !Ua || !Ua["s-nr"])) {
											Sa = Ua;
											break
										}(Sa || Y === O.parentNode) && O.nextSibling === Sa || O === Sa || (!O["s-hn"] && O["s-ol"] && (O["s-hn"] = O["s-ol"].parentNode.nodeName), Y.insertBefore(O, Sa))
								} else 1 === O.nodeType && (O.hidden = !0)
						}
						u && da(Pa.$elm$);
						Ma.$flags$ &= -2;
						ja.length = 0
					},
					pa = (O, Y) => {
						O.$flags$ |= 16;
						return ab(() => xa(O, Y))
					},
					xa = (O, Y) => {
						const ya =
							O.$hostElement$,
							za = A("scheduleUpdate", O.$cmpMeta$.$tagName$);
						let fa;
						fa = Y ? ba(ya, "componentWillLoad") : ba(ya, "componentWillUpdate");
						fa = la(fa, () => ba(ya, "componentWillRender"));
						za();
						return la(fa, () => S(O, ya, Y))
					},
					S = async (O, Y, ya) => {
						var za = O.$hostElement$,
							fa = A("update", O.$cmpMeta$.$tagName$);
						za["s-rc"];
						if (ya) {
							var Pa = O.$cmpMeta$;
							ya = O.$hostElement$;
							za = Pa.$flags$;
							const Ua = A("attachStyles", Pa.$tagName$);
							var Sa = ya.shadowRoot ? ya.shadowRoot : ya.getRootNode();
							Pa = V(Pa, O.$modeName$);
							const Za = ta.get(Pa);
							Sa = 11 === Sa.nodeType ?
								Sa : Na;
							if (Za)
								if ("string" === typeof Za) {
									Sa = Sa.head || Sa;
									let db = L.get(Sa),
										fb;
									db || L.set(Sa, db = new Set);
									db.has(Pa) || (fb = Na.createElement("style"), fb.innerHTML = Za, Sa.insertBefore(fb, Sa.querySelector("link")), db && db.add(Pa))
								} else Sa.adoptedStyleSheets.includes(Za) || (Sa.adoptedStyleSheets = [...Sa.adoptedStyleSheets, Za]);
							Sa = Pa;
							za & 10 && (ya["s-sc"] = Sa, ya.classList.add(Sa + "-h"), za & 2 && ya.classList.add(Sa + "-s"));
							Ua()
						}
						ya = A("render", O.$cmpMeta$.$tagName$);
						try {
							Y = Y.render && Y.render(), O.$flags$ &= -17, O.$flags$ |= 2, ea(O, Y)
						} catch (Ua) {
							(0, console.error)(Ua,
								O.$hostElement$)
						}
						ya();
						fa();
						fa = O.$hostElement$;
						Y = A("postUpdate", O.$cmpMeta$.$tagName$);
						O.$ancestorComponent$;
						ba(fa, "componentDidRender");
						O.$flags$ & 64 ? ba(fa, "componentDidUpdate") : (O.$flags$ |= 64, ba(fa, "componentDidLoad"));
						Y()
					}, ba = (O, Y, ya) => {
						if (O && O[Y]) try {
							return O[Y](ya)
						} catch (za) {
							(0, console.error)(za, void 0)
						}
					}, la = (O, Y) => O && O.then ? O.then(Y) : Y(), ha = (O, Y, ya, za) => {
						const fa = aa.get(O),
							Pa = fa.$instanceValues$.get(Y),
							Sa = fa.$flags$;
						ya = F(ya, za.$members$[Y][0]);
						const Ua = Number.isNaN(Pa) && Number.isNaN(ya);
						ya ===
							Pa || Ua || (fa.$instanceValues$.set(Y, ya), za.$watchers$ && Sa & 128 && (za = za.$watchers$[Y]) && za.map(Za => {
								try {
									O[Za](ya, Pa, Y)
								} catch (db) {
									(0, console.error)(db, O)
								}
							}), 2 !== (Sa & 18) || O.componentShouldUpdate && !1 === O.componentShouldUpdate(ya, Pa, Y) || pa(fa, !1))
					}, P = (O, Y, ya) => {
						if (Y.$members$) {
							O.watchers && (Y.$watchers$ = O.watchers);
							ya = Object.entries(Y.$members$);
							const za = O.prototype;
							ya.map(([Pa, [Sa]]) => {
								(Sa & 31 || Sa & 32) && Object.defineProperty(za, Pa, {
									get() {
										return aa.get(this)
											.$instanceValues$.get(Pa)
									},
									set(Ua) {
										ha(this, Pa, Ua,
											Y)
									},
									configurable: !0,
									enumerable: !0
								})
							});
							const fa = new Map;
							za.attributeChangedCallback = function(Pa, Sa, Ua) {
								Ma.jmp(() => {
									const Za = fa.get(Pa);
									if (this.hasOwnProperty(Za)) Ua = this[Za], delete this[Za];
									else if (za.hasOwnProperty(Za) && "number" === typeof this[Za] && this[Za] == Ua) return;
									this[Za] = null === Ua && "boolean" === typeof this[Za] ? !1 : Ua
								})
							};
							O.observedAttributes = ya.filter(([, Pa]) => Pa[0] & 15)
								.map(([Pa, Sa]) => {
									const Ua = Sa[1] || Pa;
									fa.set(Ua, Pa);
									Sa[0] & 512 && Y.$attrsToReflect$.push([Pa, Ua]);
									return Ua
								})
						}
						return O
					}, ca = async (O,
						Y, ya, za, fa) => {
						0 === (Y.$flags$ & 32) && (fa = O.constructor, Y.$flags$ |= 32, customElements.whenDefined(ya.$tagName$)
							.then(() => Y.$flags$ |= 128), fa.style && (za = fa.style, "string" !== typeof za && (za = za[Y.$modeName$ = G(O)]), O = V(ya, Y.$modeName$), ta.has(O) || (fa = A("registerStyles", ya.$tagName$), R(O, za, !!(ya.$flags$ & 1)), fa())));
						Y.$ancestorComponent$;
						pa(Y, !0)
					}, ka = O => {
						if (0 === (Ma.$flags$ & 1)) {
							const Y = aa.get(O),
								ya = Y.$cmpMeta$,
								za = A("connectedCallback", ya.$tagName$);
							Y.$flags$ & 1 ? ma(O, Y, ya.$listeners$) : (Y.$flags$ |= 1, ya.$flags$ & 12 &&
								va(O), ya.$members$ && Object.entries(ya.$members$)
								.map(([fa, [Pa]]) => {
									Pa & 31 && O.hasOwnProperty(fa) && (Pa = O[fa], delete O[fa], O[fa] = Pa)
								}), ca(O, Y, ya));
							za()
						}
					}, va = O => {
						const Y = O["s-cr"] = Na.createComment("");
						Y["s-cn"] = !0;
						O.insertBefore(Y, O.firstChild)
					}, Ca = O => {
						0 === (Ma.$flags$ & 1) && (O = aa.get(O), O.$rmListeners$ && (O.$rmListeners$.map(Y => Y()), O.$rmListeners$ = void 0))
					}, ma = (O, Y, ya, za) => {
						ya && ya.map(([fa, Pa, Sa]) => {
							const Ua = fa & 4 ? Na : fa & 8 ? Ga : fa & 16 ? Na.body : O,
								Za = Q(Y, Sa),
								db = Ta ? {
									passive: 0 !== (fa & 1),
									capture: 0 !== (fa & 2)
								} : 0 !== (fa &
									2);
							Ma.ael(Ua, Pa, Za, db);
							(Y.$rmListeners$ = Y.$rmListeners$ || [])
							.push(() => Ma.rel(Ua, Pa, Za, db))
						})
					}, Q = (O, Y) => ya => {
						try {
							O.$hostElement$[Y](ya)
						} catch (za) {
							(0, console.error)(za, void 0)
						}
					}, aa = new WeakMap, ta = new Map, Da = [], Ga = "undefined" !== typeof window ? window : {};
				null;
				const Na = Ga.document || {
					head: {}
				};
				c = Ga.HTMLElement || class {};
				const Ma = {
						$flags$: 0,
						$resourcesUrl$: "",
						jmp: O => O(),
						raf: O => requestAnimationFrame(O),
						ael: (O, Y, ya, za) => O.addEventListener(Y, ya, za),
						rel: (O, Y, ya, za) => O.removeEventListener(Y, ya, za),
						ce: (O, Y) => new CustomEvent(O,
							Y)
					},
					Ta = (() => {
						let O = !1;
						try {
							Na.addEventListener("e", null, Object.defineProperty({}, "passive", {
								get() {
									O = !0
								}
							}))
						} catch (Y) {}
						return O
					})();
				a: {
					try {
						new CSSStyleSheet;
						var Ra = "function" === typeof(new CSSStyleSheet)
							.replaceSync;
						break a
					} catch (O) {}
					Ra = !1
				}
				const Wa = Ra,
					Xa = [],
					bb = [],
					$a = O => {
						for (let Y = 0; Y < O.length; Y++) try {
							O[Y](performance.now())
						} catch (ya) {
							(0, console.error)(ya, void 0)
						}
						O.length = 0
					},
					Ya = () => {
						$a(Xa);
						$a(bb);
						(w = 0 < Xa.length) && Ma.raf(Ya)
					},
					ab = ((O, Y) => ya => {
						O.push(ya);
						w || (w = !0, Y && Ma.$flags$ & 4 ? (ya = Ya, Promise.resolve(void 0)
								.then(ya)) :
							Ma.raf(Ya))
					})(bb, !0),
					Qa = () => d([2, 1, 1, 1, 3]),
					Ba = {
						autoTheme: "calcite-theme-auto",
						darkTheme: "calcite-theme-dark",
						lightTheme: "calcite-theme-light",
						rtl: "calcite--rtl"
					};
				(function() {
					"undefined" !== typeof window && "undefined" !== typeof location && "undefined" !== typeof document && window.location === location && window.document === document && ("interactive" === document.readyState ? p() : document.addEventListener("DOMContentLoaded", () => p(), {
						once: !0
					}))
				})();
				a.Build = {
					isDev: !1,
					isBrowser: !0,
					isServer: !1,
					isTesting: !1
				};
				a.CSS_UTILITY =
					Ba;
				a.Fragment = (O, Y) => Y;
				a.H = c;
				a.Host = D;
				a.TEXT = {
					loading: "Loading"
				};
				a.closestElementCrossShadowBoundary = k;
				a.commitAssetPath = function() {
					Ma.$resourcesUrl$ = e.makeAbsolute(b.getAssetUrl("esri/widgets/support/components/assets"))
				};
				a.containsCrossShadowBoundary = function(O, Y) {
					return !!v(Y, ya => ya === O ? !0 : void 0)
				};
				a.createEvent = (O, Y, ya) => ({
					emit: za => {
						za = Ma.ce(Y, {
							bubbles: !!(ya & 4),
							composed: !!(ya & 2),
							cancelable: !!(ya & 1),
							detail: za
						});
						O.dispatchEvent(za);
						return za
					}
				});
				a.ensureId = function(O) {
					return O ? O.id = O.id || `${O.tagName.toLowerCase()}-${Qa()}` :
						""
				};
				a.filterDirectChildren = function(O, Y) {
					return Array.from(O.children)
						.filter(ya => ya.matches(Y))
				};
				a.focusElement = async function(O) {
					if (O) return f(O) ? O.setFocus() : O.focus()
				};
				a.forceUpdate = O => {
					O = aa.get(O);
					const Y = O.$hostElement$.isConnected;
					Y && 2 === (O.$flags$ & 18) && pa(O, !1);
					return Y
				};
				a.getAssetPath = O => {
					O = new URL(O, Ma.$resourcesUrl$);
					return O.origin !== Ga.location.origin ? O.href : O.pathname
				};
				a.getElementDir = function(O) {
					return (O = k(O, "[dir]")) ? O.getAttribute("dir") : "ltr"
				};
				a.getElementProp = function(O, Y, ya) {
					return (O =
						O.closest(`[${Y}]`)) ? O.getAttribute(Y) : ya
				};
				a.getSlotted = function(O, Y, ya) {
					Y && !Array.isArray(Y) && "string" !== typeof Y && (ya = Y, Y = null);
					Y = Y ? Array.isArray(Y) ? Y.map(za => `[slot="${za}"]`)
						.join(",") : `[slot="${Y}"]` : ":not([slot])";
					return (null === ya || void 0 === ya ? 0 : ya.all) ? l(O, Y, ya) : r(O, Y, ya)
				};
				a.getThemeName = function(O) {
					O = k(O, `.${Ba.darkTheme}, .${Ba.lightTheme}`);
					return (null === O || void 0 === O ? 0 : O.classList.contains("calcite-theme-dark")) ? "dark" : "light"
				};
				a.guid = Qa;
				a.h = z;
				a.intersects = function(O, Y) {
					return !(Y.left >
						O.right || Y.right < O.left || Y.top > O.bottom || Y.bottom < O.top)
				};
				a.isCalciteFocusable = f;
				a.isPrimaryPointerButton = function(O) {
					return !(!O.isPrimary || 0 !== O.button)
				};
				a.nodeListToArray = function(O) {
					return Array.isArray(O) ? O : Array.from(O)
				};
				a.proxyCustomElement = (O, Y) => {
					const ya = {
						$flags$: Y[0],
						$tagName$: Y[1]
					};
					ya.$members$ = Y[2];
					ya.$listeners$ = Y[3];
					ya.$watchers$ = O.$watchers$;
					ya.$attrsToReflect$ = [];
					const za = O.prototype.connectedCallback,
						fa = O.prototype.disconnectedCallback;
					Object.assign(O.prototype, {
						__registerHost() {
							const Pa = {
								$flags$: 0,
								$hostElement$: this,
								$cmpMeta$: ya,
								$instanceValues$: new Map
							};
							ma(this, Pa, ya.$listeners$);
							aa.set(this, Pa)
						},
						connectedCallback() {
							ka(this);
							za && za.call(this)
						},
						disconnectedCallback() {
							Ca(this);
							fa && fa.call(this)
						},
						__attachShadow() {
							this.attachShadow({
								mode: "open",
								delegatesFocus: !!(ya.$flags$ & 16)
							})
						}
					});
					O.is = ya.$tagName$;
					return P(O, ya)
				};
				a.queryElementRoots = function(O, {
					selector: Y,
					id: ya
				}) {
					function za(fa) {
						if (!fa) return null;
						fa.assignedSlot && (fa = fa.assignedSlot);
						var Pa = fa.getRootNode();
						fa = ya ? "getElementById" in
							Pa ? Pa.getElementById(ya) : null : Y ? Pa.querySelector(Y) : null;
						Pa = Pa.host || null;
						return fa ? fa : Pa ? za(Pa) : null
					}
					return za(O)
				};
				a.setRequestedIcon = function(O, Y, ya) {
					if ("string" === typeof Y && "" !== Y) return Y;
					if ("" === Y) return O[ya]
				};
				a.toAriaBoolean = function(O) {
					return (!!O)
						.toString()
				}
			})
		},
		"esri/widgets/support/jsxWidgetSupport": function() {
			define(["exports", "../../core/handleUtils"], function(a, b) {
				function c(r, p) {
					let n = p.children;
					if (n && n.length)
						for (var t = 0; t < n.length; ++t) n[t] = c(r, n[t]);
					else n = f;
					t = p.vnodeSelector;
					if (v(t)) {
						p =
							p.properties || g;
						const h = p.key || t;
						return {
							vnodeSelector: "div",
							properties: {
								key: h,
								afterCreate: e,
								afterUpdate: d,
								afterRemoved: k,
								parentWidget: r,
								widgetConstructor: t,
								widgetProperties: {
									...p,
									key: h,
									children: n
								}
							},
							children: void 0,
							text: void 0,
							domNode: null
						}
					}
					return p
				}

				function e(r, p, n, {
					parentWidget: t,
					widgetConstructor: h,
					widgetProperties: q
				}) {
					p = new h(q);
					p.container = r;
					l.set(r, p);
					p.afterCreate ? .(p, r);
					t._internalHandles.add(b.makeHandle(() => k(r)))
				}

				function d(r, p, n, {
					widgetProperties: t
				}) {
					if (p = l.get(r)) p.set(t), p.afterUpdate ? .(p,
						r)
				}

				function k(r) {
					const p = l.get(r);
					p && (p.destroy(), l.delete(r))
				}

				function v(r) {
					return "function" === typeof r && r[m]
				}
				const m = Symbol("widget"),
					f = [],
					g = {},
					l = new WeakMap;
				a.WIDGET_SYMBOL = m;
				a.isWidgetConstructor = v;
				a.processWidgets = c;
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/widgets/support/tests": function() {
			define(["exports"], function(a) {
				const b = new Set;
				a.hasPendingLoading = function() {
					return 0 < b.size
				};
				a.registerLoading = function(c) {
					b.add(c);
					c.finally(() =>
						b.delete(c))
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/widgets/support/widget": function() {
			define("exports ./decorators/accessibleHandler ./decorators/messageBundle ./decorators/vmEvent ./jsxFactory ./widgetUtils ../../support/themeUtils".split(" "), function(a, b, c, e, d, k, v) {
				a.accessibleHandler = b.accessibleHandler;
				a.messageBundle = c.messageBundle;
				a.vmEvent = e.vmEvent;
				a.tsx = d.tsx;
				a.tsxFragment = d.tsxFragment;
				a.additionalAllowedTags = k.additionalAllowedTags;
				a.classes = k.classes;
				a.cssTransition = k.cssTransition;
				a.discardNode = k.discardNode;
				a.getDir = k.getDir;
				a.isActivationKey = k.isActivationKey;
				a.isRTL = k.isRTL;
				a.keepMenuItemWithinView = k.keepMenuItemWithinView;
				a.onResize = k.onResize;
				a.renderingSanitizer = k.renderingSanitizer;
				a.safeAttrs = k.safeAttrs;
				a.storeNode = k.storeNode;
				a.getCalciteThemeClass = v.getCalciteThemeClass;
				a.isDarkTheme = v.isDarkTheme;
				a.setCalciteThemeClass = v.setCalciteThemeClass;
				a.hasDomNode = function(m) {
					return m && "function" === typeof m.postMixInProperties &&
						"function" === typeof m.buildRendering && "function" === typeof m.postCreate && "function" === typeof m.startup
				};
				a.isWidget = function(m) {
					return m && "function" === typeof m.render
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/widgets/support/decorators/accessibleHandler": function() {
			define(["exports", "../widgetUtils"], function(a, b) {
				function c(e) {
					return function(d, ...k) {
						const {
							type: v
						} = d;
						d instanceof KeyboardEvent || "keyup" === v || "keydown" === v || "keypress" === v ? b.isActivationKey(d.key) &&
							(d.preventDefault(), d.stopPropagation(), d.target.click()) : e.call(this, d, ...k)
					}
				}
				a.accessibleHandler = function() {
					return function(e, d) {
						if (!e[d]) throw new TypeError(`Cannot auto bind undefined function '${d}'`);
						return {
							value: c(e[d])
						}
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/widgets/support/decorators/messageBundle": function() {
			define(["exports"], function(a) {
				a.messageBundle = function(b) {
					return (c, e) => {
						c.hasOwnProperty("_messageBundleProps") || (c._messageBundleProps =
							c._messageBundleProps ? c._messageBundleProps.slice() : []);
						c._messageBundleProps.push({
							bundlePath: b,
							propertyName: e
						})
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/widgets/support/decorators/vmEvent": function() {
			define(["exports"], function(a) {
				function b(c) {
					return c.split(",")
						.map(e => e.trim())
				}
				a.vmEvent = function(c) {
					return e => {
						e.hasOwnProperty("_delegatedEventNames") || (e._delegatedEventNames = e._delegatedEventNames ? e._delegatedEventNames.slice() : []);
						e =
							e._delegatedEventNames;
						const d = Array.isArray(c) ? c : b(c);
						e.push(...d)
					}
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/widgets/support/jsxFactory": function() {
			define(["exports", "./jsxWidgetSupport"], function(a, b) {
				var c = function(d, k) {
						for (var v = 0, m = d.length; v < m; v++) {
							var f = d[v];
							Array.isArray(f) ? c(f, k) : null !== f && void 0 !== f && !1 !== f && (f.hasOwnProperty("vnodeSelector") || (f = {
									vnodeSelector: "",
									properties: void 0,
									children: void 0,
									text: f.toString(),
									domNode: null
								}),
								k.push(f))
						}
					},
					e = function(d, k) {
						for (var v = [], m = 2; m < arguments.length; m++) v[m - 2] = arguments[m];
						if (1 === v.length && "string" === typeof v[0]) return {
							vnodeSelector: d,
							properties: k || void 0,
							children: void 0,
							text: v[0],
							domNode: null
						};
						m = [];
						c(v, m);
						return {
							vnodeSelector: d,
							properties: k || void 0,
							children: m,
							text: void 0,
							domNode: null
						}
					};
				a.tsx = function(d, k, ...v) {
					return "function" !== typeof d || b.isWidgetConstructor(d) ? e(d, k, ...v) : d(k, ...v)
				};
				a.tsxFragment = function(...d) {
					return d
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"esri/support/themeUtils": function() {
			define(["exports"], function(a) {
				function b() {
					return getComputedStyle(document.body)
						.getPropertyValue("--esri-calcite-theme-name")
						.replace(/\s|'|"/g, "")
						.startsWith("dark")
				}

				function c() {
					return `${"calcite-theme-"}${b()?"dark":"light"}`
				}

				function e(d) {
					Array.from(d.classList)
						.forEach(k => {
							k.startsWith("calcite-theme-") && d.classList.remove(k)
						})
				}
				a.getCalciteThemeClass = c;
				a.isDarkTheme = b;
				a.setCalciteThemeClass = function(d) {
					e(d);
					d.classList.add(c())
				};
				Object.defineProperties(a, {
					__esModule: {
						value: !0
					},
					[Symbol.toStringTag]: {
						value: "Module"
					}
				})
			})
		},
		"*noref": 1
	}
});
require.boot && require.apply(null, require.boot);